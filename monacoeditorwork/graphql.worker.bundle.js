"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      let { name, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name,
        message,
        stack
      };
    }
    return error;
  }
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var ErrorHandler, errorHandler, canceledName, CancellationError;
  var init_errors = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js"() {
      ErrorHandler = class {
        constructor() {
          this.listeners = [];
          this.unexpectedErrorHandler = function(e) {
            setTimeout(() => {
              if (e.stack) {
                throw new Error(e.message + "\n\n" + e.stack);
              }
              throw e;
            }, 0);
          };
        }
        emit(e) {
          this.listeners.forEach((listener) => {
            listener(e);
          });
        }
        onUnexpectedError(e) {
          this.unexpectedErrorHandler(e);
          this.emit(e);
        }
        onUnexpectedExternalError(e) {
          this.unexpectedErrorHandler(e);
        }
      };
      errorHandler = new ErrorHandler();
      canceledName = "Canceled";
      CancellationError = class extends Error {
        constructor() {
          super(canceledName);
          this.name = this.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js
  function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      result = fn.apply(_this, arguments);
      return result;
    };
  }
  var init_functional = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  var init_iterator = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js"() {
      (function(Iterable2) {
        function is(thing) {
          return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
        }
        Iterable2.is = is;
        const _empty2 = Object.freeze([]);
        function empty() {
          return _empty2;
        }
        Iterable2.empty = empty;
        function* single(element) {
          yield element;
        }
        Iterable2.single = single;
        function from(iterable) {
          return iterable || _empty2;
        }
        Iterable2.from = from;
        function isEmpty(iterable) {
          return !iterable || iterable[Symbol.iterator]().next().done === true;
        }
        Iterable2.isEmpty = isEmpty;
        function first(iterable) {
          return iterable[Symbol.iterator]().next().value;
        }
        Iterable2.first = first;
        function some(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return true;
            }
          }
          return false;
        }
        Iterable2.some = some;
        function find(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return element;
            }
          }
          return void 0;
        }
        Iterable2.find = find;
        function* filter(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              yield element;
            }
          }
        }
        Iterable2.filter = filter;
        function* map(iterable, fn) {
          let index = 0;
          for (const element of iterable) {
            yield fn(element, index++);
          }
        }
        Iterable2.map = map;
        function* concat(...iterables) {
          for (const iterable of iterables) {
            for (const element of iterable) {
              yield element;
            }
          }
        }
        Iterable2.concat = concat;
        function* concatNested(iterables) {
          for (const iterable of iterables) {
            for (const element of iterable) {
              yield element;
            }
          }
        }
        Iterable2.concatNested = concatNested;
        function reduce(iterable, reducer, initialValue) {
          let value = initialValue;
          for (const element of iterable) {
            value = reducer(value, element);
          }
          return value;
        }
        Iterable2.reduce = reduce;
        function* slice(arr, from2, to = arr.length) {
          if (from2 < 0) {
            from2 += arr.length;
          }
          if (to < 0) {
            to += arr.length;
          } else if (to > arr.length) {
            to = arr.length;
          }
          for (; from2 < to; from2++) {
            yield arr[from2];
          }
        }
        Iterable2.slice = slice;
        function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
          const consumed = [];
          if (atMost === 0) {
            return [consumed, iterable];
          }
          const iterator = iterable[Symbol.iterator]();
          for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
              return [consumed, Iterable2.empty()];
            }
            consumed.push(next.value);
          }
          return [consumed, { [Symbol.iterator]() {
            return iterator;
          } }];
        }
        Iterable2.consume = consume;
        function equals2(a, b, comparator = (at, bt) => at === bt) {
          const ai = a[Symbol.iterator]();
          const bi = b[Symbol.iterator]();
          while (true) {
            const an = ai.next();
            const bn = bi.next();
            if (an.done !== bn.done) {
              return false;
            } else if (an.done) {
              return true;
            } else if (!comparator(an.value, bn.value)) {
              return false;
            }
          }
        }
        Iterable2.equals = equals2;
      })(Iterable || (Iterable = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      let errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new MultiDisposeError(errors);
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: once(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var TRACK_DISPOSABLES, disposableTracker, MultiDisposeError, DisposableStore, Disposable, SafeDisposable;
  var init_lifecycle = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"() {
      init_functional();
      init_iterator();
      TRACK_DISPOSABLES = false;
      disposableTracker = null;
      if (TRACK_DISPOSABLES) {
        const __is_disposable_tracked__ = "__is_disposable_tracked__";
        setDisposableTracker(new class {
          trackDisposable(x) {
            const stack = new Error("Potentially leaked disposable").stack;
            setTimeout(() => {
              if (!x[__is_disposable_tracked__]) {
                console.log(stack);
              }
            }, 3e3);
          }
          setParent(child, parent) {
            if (child && child !== Disposable.None) {
              try {
                child[__is_disposable_tracked__] = true;
              } catch (_a3) {
              }
            }
          }
          markAsDisposed(disposable) {
            if (disposable && disposable !== Disposable.None) {
              try {
                disposable[__is_disposable_tracked__] = true;
              } catch (_a3) {
              }
            }
          }
          markAsSingleton(disposable) {
          }
        }());
      }
      MultiDisposeError = class extends Error {
        constructor(errors) {
          super(`Encountered errors while disposing of store. Errors: [${errors.join(", ")}]`);
          this.errors = errors;
        }
      };
      DisposableStore = class {
        constructor() {
          this._toDispose = /* @__PURE__ */ new Set();
          this._isDisposed = false;
          trackDisposable(this);
        }
        dispose() {
          if (this._isDisposed) {
            return;
          }
          markAsDisposed(this);
          this._isDisposed = true;
          this.clear();
        }
        get isDisposed() {
          return this._isDisposed;
        }
        clear() {
          try {
            dispose(this._toDispose.values());
          } finally {
            this._toDispose.clear();
          }
        }
        add(o) {
          if (!o) {
            return o;
          }
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          setParentOfDisposable(o, this);
          if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
              console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
            }
          } else {
            this._toDispose.add(o);
          }
          return o;
        }
      };
      DisposableStore.DISABLE_DISPOSED_WARNING = false;
      Disposable = class {
        constructor() {
          this._store = new DisposableStore();
          trackDisposable(this);
          setParentOfDisposable(this._store, this);
        }
        dispose() {
          markAsDisposed(this);
          this._store.dispose();
        }
        _register(o) {
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          return this._store.add(o);
        }
      };
      Disposable.None = Object.freeze({ dispose() {
      } });
      SafeDisposable = class {
        constructor() {
          this.dispose = () => {
          };
          this.unset = () => {
          };
          this.isset = () => false;
          trackDisposable(this);
        }
        set(fn) {
          let callback = fn;
          this.unset = () => callback = void 0;
          this.isset = () => callback !== void 0;
          this.dispose = () => {
            if (callback) {
              callback();
              callback = void 0;
              markAsDisposed(this);
            }
          };
          return this;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node, LinkedList;
  var init_linkedList = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js"() {
      Node = class {
        constructor(element) {
          this.element = element;
          this.next = Node.Undefined;
          this.prev = Node.Undefined;
        }
      };
      Node.Undefined = new Node(void 0);
      LinkedList = class {
        constructor() {
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        get size() {
          return this._size;
        }
        isEmpty() {
          return this._first === Node.Undefined;
        }
        clear() {
          let node = this._first;
          while (node !== Node.Undefined) {
            const next = node.next;
            node.prev = Node.Undefined;
            node.next = Node.Undefined;
            node = next;
          }
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        unshift(element) {
          return this._insert(element, false);
        }
        push(element) {
          return this._insert(element, true);
        }
        _insert(element, atTheEnd) {
          const newNode = new Node(element);
          if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
          } else if (atTheEnd) {
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
          } else {
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
          }
          this._size += 1;
          let didRemove = false;
          return () => {
            if (!didRemove) {
              didRemove = true;
              this._remove(newNode);
            }
          };
        }
        shift() {
          if (this._first === Node.Undefined) {
            return void 0;
          } else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
          }
        }
        pop() {
          if (this._last === Node.Undefined) {
            return void 0;
          } else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
          }
        }
        _remove(node) {
          if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
          } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            this._first = Node.Undefined;
            this._last = Node.Undefined;
          } else if (node.next === Node.Undefined) {
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
          } else if (node.prev === Node.Undefined) {
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
          }
          this._size -= 1;
        }
        *[Symbol.iterator]() {
          let node = this._first;
          while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a, LANGUAGE_DEFAULT, _isWindows, _isMacintosh, _isLinux, _isLinuxSnap, _isNative, _isWeb, _isElectron, _isIOS, _isCI, _locale, _language, _translationsConfigFile, _userAgent, globals, nodeProcess, isElectronProcess, isElectronRenderer, _platform, isWindows, isMacintosh, isWebWorker, userAgent, setTimeout0, isChrome, isFirefox, isSafari, isEdge, isAndroid;
  var init_platform = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js"() {
      LANGUAGE_DEFAULT = "en";
      _isWindows = false;
      _isMacintosh = false;
      _isLinux = false;
      _isLinuxSnap = false;
      _isNative = false;
      _isWeb = false;
      _isElectron = false;
      _isIOS = false;
      _isCI = false;
      _locale = void 0;
      _language = LANGUAGE_DEFAULT;
      _translationsConfigFile = void 0;
      _userAgent = void 0;
      globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
      nodeProcess = void 0;
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        nodeProcess = globals.vscode.process;
      } else if (typeof process !== "undefined") {
        nodeProcess = process;
      }
      isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
      isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
      if (typeof navigator === "object" && !isElectronRenderer) {
        _userAgent = navigator.userAgent;
        _isWindows = _userAgent.indexOf("Windows") >= 0;
        _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
        _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
        _isLinux = _userAgent.indexOf("Linux") >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
      } else if (typeof nodeProcess === "object") {
        _isWindows = nodeProcess.platform === "win32";
        _isMacintosh = nodeProcess.platform === "darwin";
        _isLinux = nodeProcess.platform === "linux";
        _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
        _isElectron = isElectronProcess;
        _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
        _locale = LANGUAGE_DEFAULT;
        _language = LANGUAGE_DEFAULT;
        const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
        if (rawNlsConfig) {
          try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages["*"];
            _locale = nlsConfig.locale;
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
          } catch (e) {
          }
        }
        _isNative = true;
      } else {
        console.error("Unable to resolve platform.");
      }
      _platform = 0;
      if (_isMacintosh) {
        _platform = 1;
      } else if (_isWindows) {
        _platform = 3;
      } else if (_isLinux) {
        _platform = 2;
      }
      isWindows = _isWindows;
      isMacintosh = _isMacintosh;
      isWebWorker = _isWeb && typeof globals.importScripts === "function";
      userAgent = _userAgent;
      setTimeout0 = (() => {
        if (typeof globals.postMessage === "function" && !globals.importScripts) {
          let pending = [];
          globals.addEventListener("message", (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
              for (let i = 0, len = pending.length; i < len; i++) {
                const candidate = pending[i];
                if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                  pending.splice(i, 1);
                  candidate.callback();
                  return;
                }
              }
            }
          });
          let lastId = 0;
          return (callback) => {
            const myId = ++lastId;
            pending.push({
              id: myId,
              callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
          };
        }
        return (callback) => setTimeout(callback);
      })();
      isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
      isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
      isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
      isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
      isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow, StopWatch;
  var init_stopwatch = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js"() {
      init_platform();
      hasPerformanceNow = globals.performance && typeof globals.performance.now === "function";
      StopWatch = class {
        constructor(highResolution) {
          this._highResolution = hasPerformanceNow && highResolution;
          this._startTime = this._now();
          this._stopTime = -1;
        }
        static create(highResolution = true) {
          return new StopWatch(highResolution);
        }
        stop() {
          this._stopTime = this._now();
        }
        elapsed() {
          if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
          }
          return this._now() - this._startTime;
        }
        _now() {
          return this._highResolution ? globals.performance.now() : Date.now();
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableDisposeWithListenerWarning, _enableSnapshotPotentialLeakWarning, Event, EventProfiling, _globalLeakWarningThreshold, LeakageMonitor, Stacktrace, Listener, Emitter;
  var init_event = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js"() {
      init_errors();
      init_lifecycle();
      init_linkedList();
      init_stopwatch();
      _enableDisposeWithListenerWarning = false;
      _enableSnapshotPotentialLeakWarning = false;
      (function(Event2) {
        Event2.None = () => Disposable.None;
        function _addLeakageTraceLogic(options) {
          if (_enableSnapshotPotentialLeakWarning) {
            const { onListenerDidAdd: origListenerDidAdd } = options;
            const stack = Stacktrace.create();
            let count = 0;
            options.onListenerDidAdd = () => {
              if (++count === 2) {
                console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
                stack.print();
              }
              origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
            };
          }
        }
        function once3(event) {
          return (listener, thisArgs = null, disposables) => {
            let didFire = false;
            let result;
            result = event((e) => {
              if (didFire) {
                return;
              } else if (result) {
                result.dispose();
              } else {
                didFire = true;
              }
              return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
              result.dispose();
            }
            return result;
          };
        }
        Event2.once = once3;
        function map(event, map2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
        }
        Event2.map = map;
        function forEach(event, each, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => {
            each(i);
            listener.call(thisArgs, i);
          }, null, disposables), disposable);
        }
        Event2.forEach = forEach;
        function filter(event, filter2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
        }
        Event2.filter = filter;
        function signal(event) {
          return event;
        }
        Event2.signal = signal;
        function any(...events) {
          return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
        }
        Event2.any = any;
        function reduce(event, merge, initial, disposable) {
          let output = initial;
          return map(event, (e) => {
            output = merge(output, e);
            return output;
          }, disposable);
        }
        Event2.reduce = reduce;
        function snapshot(event, disposable) {
          let listener;
          const options = {
            onFirstListenerAdd() {
              listener = event(emitter.fire, emitter);
            },
            onLastListenerRemove() {
              listener.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          if (disposable) {
            disposable.add(emitter);
          }
          return emitter.event;
        }
        function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {
          let subscription;
          let output = void 0;
          let handle = void 0;
          let numDebouncedCalls = 0;
          const options = {
            leakWarningThreshold,
            onFirstListenerAdd() {
              subscription = event((cur) => {
                numDebouncedCalls++;
                output = merge(output, cur);
                if (leading && !handle) {
                  emitter.fire(output);
                  output = void 0;
                }
                clearTimeout(handle);
                handle = setTimeout(() => {
                  const _output = output;
                  output = void 0;
                  handle = void 0;
                  if (!leading || numDebouncedCalls > 1) {
                    emitter.fire(_output);
                  }
                  numDebouncedCalls = 0;
                }, delay);
              });
            },
            onLastListenerRemove() {
              subscription.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          if (disposable) {
            disposable.add(emitter);
          }
          return emitter.event;
        }
        Event2.debounce = debounce;
        function latch(event, equals2 = (a, b) => a === b, disposable) {
          let firstCall = true;
          let cache;
          return filter(event, (value) => {
            const shouldEmit = firstCall || !equals2(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit;
          }, disposable);
        }
        Event2.latch = latch;
        function split(event, isT, disposable) {
          return [
            Event2.filter(event, isT, disposable),
            Event2.filter(event, (e) => !isT(e), disposable)
          ];
        }
        Event2.split = split;
        function buffer(event, flushAfterTimeout = false, _buffer = []) {
          let buffer2 = _buffer.slice();
          let listener = event((e) => {
            if (buffer2) {
              buffer2.push(e);
            } else {
              emitter.fire(e);
            }
          });
          const flush = () => {
            if (buffer2) {
              buffer2.forEach((e) => emitter.fire(e));
            }
            buffer2 = null;
          };
          const emitter = new Emitter({
            onFirstListenerAdd() {
              if (!listener) {
                listener = event((e) => emitter.fire(e));
              }
            },
            onFirstListenerDidAdd() {
              if (buffer2) {
                if (flushAfterTimeout) {
                  setTimeout(flush);
                } else {
                  flush();
                }
              }
            },
            onLastListenerRemove() {
              if (listener) {
                listener.dispose();
              }
              listener = null;
            }
          });
          return emitter.event;
        }
        Event2.buffer = buffer;
        class ChainableEvent {
          constructor(event) {
            this.event = event;
          }
          map(fn) {
            return new ChainableEvent(map(this.event, fn));
          }
          forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn));
          }
          filter(fn) {
            return new ChainableEvent(filter(this.event, fn));
          }
          reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial));
          }
          latch() {
            return new ChainableEvent(latch(this.event));
          }
          debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
          }
          on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
          }
          once(listener, thisArgs, disposables) {
            return once3(this.event)(listener, thisArgs, disposables);
          }
        }
        function chain(event) {
          return new ChainableEvent(event);
        }
        Event2.chain = chain;
        function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.on(eventName, fn);
          const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
          const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
          return result.event;
        }
        Event2.fromNodeEventEmitter = fromNodeEventEmitter;
        function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
          const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
          const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
          return result.event;
        }
        Event2.fromDOMEventEmitter = fromDOMEventEmitter;
        function toPromise(event) {
          return new Promise((resolve2) => once3(event)(resolve2));
        }
        Event2.toPromise = toPromise;
        function runAndSubscribe(event, handler) {
          handler(void 0);
          return event((e) => handler(e));
        }
        Event2.runAndSubscribe = runAndSubscribe;
        function runAndSubscribeWithStore(event, handler) {
          let store = null;
          function run(e) {
            store === null || store === void 0 ? void 0 : store.dispose();
            store = new DisposableStore();
            handler(e, store);
          }
          run(void 0);
          const disposable = event((e) => run(e));
          return toDisposable(() => {
            disposable.dispose();
            store === null || store === void 0 ? void 0 : store.dispose();
          });
        }
        Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
      })(Event || (Event = {}));
      EventProfiling = class {
        constructor(name) {
          this._listenerCount = 0;
          this._invocationCount = 0;
          this._elapsedOverall = 0;
          this._name = `${name}_${EventProfiling._idPool++}`;
        }
        start(listenerCount) {
          this._stopWatch = new StopWatch(true);
          this._listenerCount = listenerCount;
        }
        stop() {
          if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this._elapsedOverall += elapsed;
            this._invocationCount += 1;
            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);
            this._stopWatch = void 0;
          }
        }
      };
      EventProfiling._idPool = 0;
      _globalLeakWarningThreshold = -1;
      LeakageMonitor = class {
        constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
          this.customThreshold = customThreshold;
          this.name = name;
          this._warnCountdown = 0;
        }
        dispose() {
          if (this._stacks) {
            this._stacks.clear();
          }
        }
        check(stack, listenerCount) {
          let threshold = _globalLeakWarningThreshold;
          if (typeof this.customThreshold === "number") {
            threshold = this.customThreshold;
          }
          if (threshold <= 0 || listenerCount < threshold) {
            return void 0;
          }
          if (!this._stacks) {
            this._stacks = /* @__PURE__ */ new Map();
          }
          const count = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count + 1);
          this._warnCountdown -= 1;
          if (this._warnCountdown <= 0) {
            this._warnCountdown = threshold * 0.5;
            let topStack;
            let topCount = 0;
            for (const [stack2, count2] of this._stacks) {
              if (!topStack || topCount < count2) {
                topStack = stack2;
                topCount = count2;
              }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
          }
          return () => {
            const count2 = this._stacks.get(stack.value) || 0;
            this._stacks.set(stack.value, count2 - 1);
          };
        }
      };
      Stacktrace = class {
        constructor(value) {
          this.value = value;
        }
        static create() {
          var _a3;
          return new Stacktrace((_a3 = new Error().stack) !== null && _a3 !== void 0 ? _a3 : "");
        }
        print() {
          console.warn(this.value.split("\n").slice(2).join("\n"));
        }
      };
      Listener = class {
        constructor(callback, callbackThis, stack) {
          this.callback = callback;
          this.callbackThis = callbackThis;
          this.stack = stack;
          this.subscription = new SafeDisposable();
        }
        invoke(e) {
          this.callback.call(this.callbackThis, e);
        }
      };
      Emitter = class {
        constructor(options) {
          var _a3;
          this._disposed = false;
          this._options = options;
          this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : void 0;
          this._perfMon = ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3._profName) ? new EventProfiling(this._options._profName) : void 0;
        }
        dispose() {
          var _a3, _b, _c, _d;
          if (!this._disposed) {
            this._disposed = true;
            if (this._listeners) {
              if (_enableDisposeWithListenerWarning) {
                const listeners = Array.from(this._listeners);
                queueMicrotask(() => {
                  var _a4;
                  for (const listener of listeners) {
                    if (listener.subscription.isset()) {
                      listener.subscription.unset();
                      (_a4 = listener.stack) === null || _a4 === void 0 ? void 0 : _a4.print();
                    }
                  }
                });
              }
              this._listeners.clear();
            }
            (_a3 = this._deliveryQueue) === null || _a3 === void 0 ? void 0 : _a3.clear();
            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);
            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
          }
        }
        get event() {
          if (!this._event) {
            this._event = (callback, thisArgs, disposables) => {
              var _a3, _b, _c;
              if (!this._listeners) {
                this._listeners = new LinkedList();
              }
              const firstListener = this._listeners.isEmpty();
              if (firstListener && ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.onFirstListenerAdd)) {
                this._options.onFirstListenerAdd(this);
              }
              let removeMonitor;
              let stack;
              if (this._leakageMon && this._listeners.size >= 30) {
                stack = Stacktrace.create();
                removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
              }
              if (_enableDisposeWithListenerWarning) {
                stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
              }
              const listener = new Listener(callback, thisArgs, stack);
              const removeListener = this._listeners.push(listener);
              if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {
                this._options.onFirstListenerDidAdd(this);
              }
              if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {
                this._options.onListenerDidAdd(this, callback, thisArgs);
              }
              const result = listener.subscription.set(() => {
                if (removeMonitor) {
                  removeMonitor();
                }
                if (!this._disposed) {
                  removeListener();
                  if (this._options && this._options.onLastListenerRemove) {
                    const hasListeners = this._listeners && !this._listeners.isEmpty();
                    if (!hasListeners) {
                      this._options.onLastListenerRemove(this);
                    }
                  }
                }
              });
              if (disposables instanceof DisposableStore) {
                disposables.add(result);
              } else if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        fire(event) {
          var _a3, _b;
          if (this._listeners) {
            if (!this._deliveryQueue) {
              this._deliveryQueue = new LinkedList();
            }
            for (let listener of this._listeners) {
              this._deliveryQueue.push([listener, event]);
            }
            (_a3 = this._perfMon) === null || _a3 === void 0 ? void 0 : _a3.start(this._deliveryQueue.size);
            while (this._deliveryQueue.size > 0) {
              const [listener, event2] = this._deliveryQueue.shift();
              try {
                listener.invoke(event2);
              } catch (e) {
                onUnexpectedError(e);
              }
            }
            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js
  function getAllPropertyNames(obj) {
    let res = [];
    let proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
      res = res.concat(Object.getOwnPropertyNames(proto));
      proto = Object.getPrototypeOf(proto);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    let result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  function assertNever(value, message = "Unreachable") {
    throw new Error(message);
  }
  var init_types = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js
  var LRUCachedComputed;
  var init_cache = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js"() {
      LRUCachedComputed = class {
        constructor(computeFn) {
          this.computeFn = computeFn;
          this.lastCache = void 0;
          this.lastArgKey = void 0;
        }
        get(arg) {
          const key = JSON.stringify(arg);
          if (this.lastArgKey !== key) {
            this.lastArgKey = key;
            this.lastCache = this.computeFn(arg);
          }
          return this.lastCache;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy;
  var init_lazy = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js"() {
      Lazy = class {
        constructor(executor) {
          this.executor = executor;
          this._didRun = false;
        }
        getValue() {
          if (!this._didRun) {
            try {
              this._value = this.executor();
            } catch (err) {
              this._error = err;
            } finally {
              this._didRun = true;
            }
          }
          if (this._error) {
            throw this._error;
          }
          return this._value;
        }
        get rawValue() {
          return this._value;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var _a2, IS_BASIC_ASCII, UTF8_BOM_CHARACTER, GraphemeBreakTree, AmbiguousCharacters, InvisibleCharacters;
  var init_strings = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js"() {
      init_cache();
      init_lazy();
      IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
      UTF8_BOM_CHARACTER = String.fromCharCode(65279);
      GraphemeBreakTree = class {
        constructor() {
          this._data = getGraphemeBreakRawData();
        }
        static getInstance() {
          if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
          }
          return GraphemeBreakTree._INSTANCE;
        }
        getGraphemeBreakType(codePoint) {
          if (codePoint < 32) {
            if (codePoint === 10) {
              return 3;
            }
            if (codePoint === 13) {
              return 2;
            }
            return 4;
          }
          if (codePoint < 127) {
            return 0;
          }
          const data = this._data;
          const nodeCount = data.length / 3;
          let nodeIndex = 1;
          while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
              nodeIndex = 2 * nodeIndex;
            } else if (codePoint > data[3 * nodeIndex + 1]) {
              nodeIndex = 2 * nodeIndex + 1;
            } else {
              return data[3 * nodeIndex + 2];
            }
          }
          return 0;
        }
      };
      GraphemeBreakTree._INSTANCE = null;
      AmbiguousCharacters = class {
        constructor(confusableDictionary) {
          this.confusableDictionary = confusableDictionary;
        }
        static getInstance(locales) {
          return AmbiguousCharacters.cache.get(Array.from(locales));
        }
        static getLocales() {
          return AmbiguousCharacters._locales.getValue();
        }
        isAmbiguous(codePoint) {
          return this.confusableDictionary.has(codePoint);
        }
        getPrimaryConfusable(codePoint) {
          return this.confusableDictionary.get(codePoint);
        }
        getConfusableCodePoints() {
          return new Set(this.confusableDictionary.keys());
        }
      };
      _a2 = AmbiguousCharacters;
      AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
        return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
      });
      AmbiguousCharacters.cache = new LRUCachedComputed((locales) => {
        function arrayToMap(arr) {
          const result = /* @__PURE__ */ new Map();
          for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
          }
          return result;
        }
        function mergeMaps(map1, map2) {
          const result = new Map(map1);
          for (const [key, value] of map2) {
            result.set(key, value);
          }
          return result;
        }
        function intersectMaps(map1, map2) {
          if (!map1) {
            return map2;
          }
          const result = /* @__PURE__ */ new Map();
          for (const [key, value] of map1) {
            if (map2.has(key)) {
              result.set(key, value);
            }
          }
          return result;
        }
        const data = _a2.ambiguousCharacterData.getValue();
        let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
        if (filteredLocales.length === 0) {
          filteredLocales = ["_default"];
        }
        let languageSpecificMap = void 0;
        for (const locale of filteredLocales) {
          const map2 = arrayToMap(data[locale]);
          languageSpecificMap = intersectMaps(languageSpecificMap, map2);
        }
        const commonMap = arrayToMap(data["_common"]);
        const map = mergeMaps(commonMap, languageSpecificMap);
        return new AmbiguousCharacters(map);
      });
      AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter((k) => !k.startsWith("_")));
      InvisibleCharacters = class {
        static getRawData() {
          return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
        }
        static getData() {
          if (!this._data) {
            this._data = new Set(InvisibleCharacters.getRawData());
          }
          return this._data;
        }
        static isInvisibleCharacter(codePoint) {
          return InvisibleCharacters.getData().has(codePoint);
        }
        static get codePoints() {
          return InvisibleCharacters.getData();
        }
      };
      InvisibleCharacters._data = void 0;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    let result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var INITIALIZE, RequestMessage, ReplyMessage, SubscribeEventMessage, EventMessage, UnsubscribeEventMessage, SimpleWorkerProtocol, SimpleWorkerServer;
  var init_simpleWorker = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js"() {
      init_errors();
      init_event();
      init_lifecycle();
      init_platform();
      init_types();
      init_strings();
      INITIALIZE = "$initialize";
      RequestMessage = class {
        constructor(vsWorker, req, method, args) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.method = method;
          this.args = args;
          this.type = 0;
        }
      };
      ReplyMessage = class {
        constructor(vsWorker, seq, res, err) {
          this.vsWorker = vsWorker;
          this.seq = seq;
          this.res = res;
          this.err = err;
          this.type = 1;
        }
      };
      SubscribeEventMessage = class {
        constructor(vsWorker, req, eventName, arg) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.eventName = eventName;
          this.arg = arg;
          this.type = 2;
        }
      };
      EventMessage = class {
        constructor(vsWorker, req, event) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.event = event;
          this.type = 3;
        }
      };
      UnsubscribeEventMessage = class {
        constructor(vsWorker, req) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.type = 4;
        }
      };
      SimpleWorkerProtocol = class {
        constructor(handler) {
          this._workerId = -1;
          this._handler = handler;
          this._lastSentReq = 0;
          this._pendingReplies = /* @__PURE__ */ Object.create(null);
          this._pendingEmitters = /* @__PURE__ */ new Map();
          this._pendingEvents = /* @__PURE__ */ new Map();
        }
        setWorkerId(workerId) {
          this._workerId = workerId;
        }
        sendMessage(method, args) {
          const req = String(++this._lastSentReq);
          return new Promise((resolve2, reject) => {
            this._pendingReplies[req] = {
              resolve: resolve2,
              reject
            };
            this._send(new RequestMessage(this._workerId, req, method, args));
          });
        }
        listen(eventName, arg) {
          let req = null;
          const emitter = new Emitter({
            onFirstListenerAdd: () => {
              req = String(++this._lastSentReq);
              this._pendingEmitters.set(req, emitter);
              this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
            },
            onLastListenerRemove: () => {
              this._pendingEmitters.delete(req);
              this._send(new UnsubscribeEventMessage(this._workerId, req));
              req = null;
            }
          });
          return emitter.event;
        }
        handleMessage(message) {
          if (!message || !message.vsWorker) {
            return;
          }
          if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
          }
          this._handleMessage(message);
        }
        _handleMessage(msg) {
          switch (msg.type) {
            case 1:
              return this._handleReplyMessage(msg);
            case 0:
              return this._handleRequestMessage(msg);
            case 2:
              return this._handleSubscribeEventMessage(msg);
            case 3:
              return this._handleEventMessage(msg);
            case 4:
              return this._handleUnsubscribeEventMessage(msg);
          }
        }
        _handleReplyMessage(replyMessage) {
          if (!this._pendingReplies[replyMessage.seq]) {
            console.warn("Got reply to unknown seq");
            return;
          }
          let reply = this._pendingReplies[replyMessage.seq];
          delete this._pendingReplies[replyMessage.seq];
          if (replyMessage.err) {
            let err = replyMessage.err;
            if (replyMessage.err.$isError) {
              err = new Error();
              err.name = replyMessage.err.name;
              err.message = replyMessage.err.message;
              err.stack = replyMessage.err.stack;
            }
            reply.reject(err);
            return;
          }
          reply.resolve(replyMessage.res);
        }
        _handleRequestMessage(requestMessage) {
          let req = requestMessage.req;
          let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
          result.then((r) => {
            this._send(new ReplyMessage(this._workerId, req, r, void 0));
          }, (e) => {
            if (e.detail instanceof Error) {
              e.detail = transformErrorForSerialization(e.detail);
            }
            this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
          });
        }
        _handleSubscribeEventMessage(msg) {
          const req = msg.req;
          const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
            this._send(new EventMessage(this._workerId, req, event));
          });
          this._pendingEvents.set(req, disposable);
        }
        _handleEventMessage(msg) {
          if (!this._pendingEmitters.has(msg.req)) {
            console.warn("Got event for unknown req");
            return;
          }
          this._pendingEmitters.get(msg.req).fire(msg.event);
        }
        _handleUnsubscribeEventMessage(msg) {
          if (!this._pendingEvents.has(msg.req)) {
            console.warn("Got unsubscribe for unknown req");
            return;
          }
          this._pendingEvents.get(msg.req).dispose();
          this._pendingEvents.delete(msg.req);
        }
        _send(msg) {
          let transfer = [];
          if (msg.type === 0) {
            for (let i = 0; i < msg.args.length; i++) {
              if (msg.args[i] instanceof ArrayBuffer) {
                transfer.push(msg.args[i]);
              }
            }
          } else if (msg.type === 1) {
            if (msg.res instanceof ArrayBuffer) {
              transfer.push(msg.res);
            }
          }
          this._handler.sendMessage(msg, transfer);
        }
      };
      SimpleWorkerServer = class {
        constructor(postMessage, requestHandlerFactory) {
          this._requestHandlerFactory = requestHandlerFactory;
          this._requestHandler = null;
          this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
              postMessage(msg, transfer);
            },
            handleMessage: (method, args) => this._handleMessage(method, args),
            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
          });
        }
        onmessage(msg) {
          this._protocol.handleMessage(msg);
        }
        _handleMessage(method, args) {
          if (method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2], args[3]);
          }
          if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
            return Promise.reject(new Error("Missing requestHandler or method: " + method));
          }
          try {
            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
          } catch (e) {
            return Promise.reject(e);
          }
        }
        _handleEvent(eventName, arg) {
          if (!this._requestHandler) {
            throw new Error(`Missing requestHandler`);
          }
          if (propertyIsDynamicEvent(eventName)) {
            const event = this._requestHandler[eventName].call(this._requestHandler, arg);
            if (typeof event !== "function") {
              throw new Error(`Missing dynamic event ${eventName} on request handler.`);
            }
            return event;
          }
          if (propertyIsEvent(eventName)) {
            const event = this._requestHandler[eventName];
            if (typeof event !== "function") {
              throw new Error(`Missing event ${eventName} on request handler.`);
            }
            return event;
          }
          throw new Error(`Malformed event name ${eventName}`);
        }
        initialize(workerId, loaderConfig, moduleId, hostMethods) {
          this._protocol.setWorkerId(workerId);
          const proxyMethodRequest = (method, args) => {
            return this._protocol.sendMessage(method, args);
          };
          const proxyListen = (eventName, arg) => {
            return this._protocol.listen(eventName, arg);
          };
          const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
          if (this._requestHandlerFactory) {
            this._requestHandler = this._requestHandlerFactory(hostProxy);
            return Promise.resolve(getAllMethodNames(this._requestHandler));
          }
          if (loaderConfig) {
            if (typeof loaderConfig.baseUrl !== "undefined") {
              delete loaderConfig["baseUrl"];
            }
            if (typeof loaderConfig.paths !== "undefined") {
              if (typeof loaderConfig.paths.vs !== "undefined") {
                delete loaderConfig.paths["vs"];
              }
            }
            if (typeof loaderConfig.trustedTypesPolicy !== void 0) {
              delete loaderConfig["trustedTypesPolicy"];
            }
            loaderConfig.catchError = true;
            globals.require.config(loaderConfig);
          }
          return new Promise((resolve2, reject) => {
            const req = globals.require;
            req([moduleId], (module) => {
              this._requestHandler = module.create(hostProxy);
              if (!this._requestHandler) {
                reject(new Error(`No RequestHandler!`));
                return;
              }
              resolve2(getAllMethodNames(this._requestHandler));
            }, reject);
          });
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange;
  var init_diffChange = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js"() {
      DiffChange = class {
        constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
          this.originalStart = originalStart;
          this.originalLength = originalLength;
          this.modifiedStart = modifiedStart;
          this.modifiedLength = modifiedLength;
        }
        getOriginalEnd() {
          return this.originalStart + this.originalLength;
        }
        getModifiedEnd() {
          return this.modifiedStart + this.modifiedLength;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1;
  var init_hash = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js"() {
      init_strings();
      StringSHA1 = class {
        constructor() {
          this._h0 = 1732584193;
          this._h1 = 4023233417;
          this._h2 = 2562383102;
          this._h3 = 271733878;
          this._h4 = 3285377520;
          this._buff = new Uint8Array(64 + 3);
          this._buffDV = new DataView(this._buff.buffer);
          this._buffLen = 0;
          this._totalLen = 0;
          this._leftoverHighSurrogate = 0;
          this._finished = false;
        }
        update(str) {
          const strLen = str.length;
          if (strLen === 0) {
            return;
          }
          const buff = this._buff;
          let buffLen = this._buffLen;
          let leftoverHighSurrogate = this._leftoverHighSurrogate;
          let charCode;
          let offset;
          if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
          } else {
            charCode = str.charCodeAt(0);
            offset = 0;
          }
          while (true) {
            let codePoint = charCode;
            if (isHighSurrogate(charCode)) {
              if (offset + 1 < strLen) {
                const nextCharCode = str.charCodeAt(offset + 1);
                if (isLowSurrogate(nextCharCode)) {
                  offset++;
                  codePoint = computeCodePoint(charCode, nextCharCode);
                } else {
                  codePoint = 65533;
                }
              } else {
                leftoverHighSurrogate = charCode;
                break;
              }
            } else if (isLowSurrogate(charCode)) {
              codePoint = 65533;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
              charCode = str.charCodeAt(offset);
            } else {
              break;
            }
          }
          this._buffLen = buffLen;
          this._leftoverHighSurrogate = leftoverHighSurrogate;
        }
        _push(buff, buffLen, codePoint) {
          if (codePoint < 128) {
            buff[buffLen++] = codePoint;
          } else if (codePoint < 2048) {
            buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else if (codePoint < 65536) {
            buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else {
            buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
            buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          }
          if (buffLen >= 64) {
            this._step();
            buffLen -= 64;
            this._totalLen += 64;
            buff[0] = buff[64 + 0];
            buff[1] = buff[64 + 1];
            buff[2] = buff[64 + 2];
          }
          return buffLen;
        }
        digest() {
          if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
              this._leftoverHighSurrogate = 0;
              this._buffLen = this._push(this._buff, this._buffLen, 65533);
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
          }
          return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
        }
        _wrapUp() {
          this._buff[this._buffLen++] = 128;
          fill(this._buff, this._buffLen);
          if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
          }
          const ml = 8 * this._totalLen;
          this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
          this._buffDV.setUint32(60, ml % 4294967296, false);
          this._step();
        }
        _step() {
          const bigBlock32 = StringSHA1._bigBlock32;
          const data = this._buffDV;
          for (let j = 0; j < 64; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
          }
          for (let j = 64; j < 320; j += 4) {
            bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
          }
          let a = this._h0;
          let b = this._h1;
          let c = this._h2;
          let d = this._h3;
          let e = this._h4;
          let f, k;
          let temp;
          for (let j = 0; j < 80; j++) {
            if (j < 20) {
              f = b & c | ~b & d;
              k = 1518500249;
            } else if (j < 40) {
              f = b ^ c ^ d;
              k = 1859775393;
            } else if (j < 60) {
              f = b & c | b & d | c & d;
              k = 2400959708;
            } else {
              f = b ^ c ^ d;
              k = 3395469782;
            }
            temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
          }
          this._h0 = this._h0 + a & 4294967295;
          this._h1 = this._h1 + b & 4294967295;
          this._h2 = this._h2 + c & 4294967295;
          this._h3 = this._h3 + d & 4294967295;
          this._h4 = this._h4 + e & 4294967295;
        }
      };
      StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var StringDiffSequence, Debug, MyArray, DiffChangeHelper, LcsDiff;
  var init_diff = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"() {
      init_diffChange();
      init_hash();
      StringDiffSequence = class {
        constructor(source) {
          this.source = source;
        }
        getElements() {
          const source = this.source;
          const characters = new Int32Array(source.length);
          for (let i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
          }
          return characters;
        }
      };
      Debug = class {
        static Assert(condition, message) {
          if (!condition) {
            throw new Error(message);
          }
        }
      };
      MyArray = class {
        static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
          for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
          }
        }
        static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
          for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
          }
        }
      };
      DiffChangeHelper = class {
        constructor() {
          this.m_changes = [];
          this.m_originalStart = 1073741824;
          this.m_modifiedStart = 1073741824;
          this.m_originalCount = 0;
          this.m_modifiedCount = 0;
        }
        MarkNextChange() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
          }
          this.m_originalCount = 0;
          this.m_modifiedCount = 0;
          this.m_originalStart = 1073741824;
          this.m_modifiedStart = 1073741824;
        }
        AddOriginalElement(originalIndex, modifiedIndex) {
          this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
          this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
          this.m_originalCount++;
        }
        AddModifiedElement(originalIndex, modifiedIndex) {
          this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
          this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
          this.m_modifiedCount++;
        }
        getChanges() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.MarkNextChange();
          }
          return this.m_changes;
        }
        getReverseChanges() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.MarkNextChange();
          }
          this.m_changes.reverse();
          return this.m_changes;
        }
      };
      LcsDiff = class {
        constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
          this.ContinueProcessingPredicate = continueProcessingPredicate;
          this._originalSequence = originalSequence;
          this._modifiedSequence = modifiedSequence;
          const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
          const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
          this._hasStrings = originalHasStrings && modifiedHasStrings;
          this._originalStringElements = originalStringElements;
          this._originalElementsOrHash = originalElementsOrHash;
          this._modifiedStringElements = modifiedStringElements;
          this._modifiedElementsOrHash = modifiedElementsOrHash;
          this.m_forwardHistory = [];
          this.m_reverseHistory = [];
        }
        static _isStringArray(arr) {
          return arr.length > 0 && typeof arr[0] === "string";
        }
        static _getElements(sequence) {
          const elements = sequence.getElements();
          if (LcsDiff._isStringArray(elements)) {
            const hashes = new Int32Array(elements.length);
            for (let i = 0, len = elements.length; i < len; i++) {
              hashes[i] = stringHash(elements[i], 0);
            }
            return [elements, hashes, true];
          }
          if (elements instanceof Int32Array) {
            return [[], elements, false];
          }
          return [[], new Int32Array(elements), false];
        }
        ElementsAreEqual(originalIndex, newIndex) {
          if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
          }
          return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
        }
        ElementsAreStrictEqual(originalIndex, newIndex) {
          if (!this.ElementsAreEqual(originalIndex, newIndex)) {
            return false;
          }
          const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
          const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
          return originalElement === modifiedElement;
        }
        static _getStrictElement(sequence, index) {
          if (typeof sequence.getStrictElement === "function") {
            return sequence.getStrictElement(index);
          }
          return null;
        }
        OriginalElementsAreEqual(index1, index2) {
          if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
          }
          return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
        }
        ModifiedElementsAreEqual(index1, index2) {
          if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
          }
          return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
        }
        ComputeDiff(pretty) {
          return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
        }
        _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
          const quitEarlyArr = [false];
          let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
          if (pretty) {
            changes = this.PrettifyChanges(changes);
          }
          return {
            quitEarly: quitEarlyArr[0],
            changes
          };
        }
        ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
          quitEarlyArr[0] = false;
          while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
          }
          while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
          }
          if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            let changes;
            if (modifiedStart <= modifiedEnd) {
              Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
              changes = [
                new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
              ];
            } else if (originalStart <= originalEnd) {
              Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
              changes = [
                new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
              ];
            } else {
              Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
              Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
              changes = [];
            }
            return changes;
          }
          const midOriginalArr = [0];
          const midModifiedArr = [0];
          const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
          const midOriginal = midOriginalArr[0];
          const midModified = midModifiedArr[0];
          if (result !== null) {
            return result;
          } else if (!quitEarlyArr[0]) {
            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            let rightChanges = [];
            if (!quitEarlyArr[0]) {
              rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            } else {
              rightChanges = [
                new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
              ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
          }
          return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        }
        WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
          let forwardChanges = null;
          let reverseChanges = null;
          let changeHelper = new DiffChangeHelper();
          let diagonalMin = diagonalForwardStart;
          let diagonalMax = diagonalForwardEnd;
          let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
          let lastOriginalIndex = -1073741824;
          let historyIndex = this.m_forwardHistory.length - 1;
          do {
            const diagonal = diagonalRelative + diagonalForwardBase;
            if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
              originalIndex = forwardPoints[diagonal + 1];
              modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
              if (originalIndex < lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex;
              changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
              diagonalRelative = diagonal + 1 - diagonalForwardBase;
            } else {
              originalIndex = forwardPoints[diagonal - 1] + 1;
              modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
              if (originalIndex < lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex - 1;
              changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
              diagonalRelative = diagonal - 1 - diagonalForwardBase;
            }
            if (historyIndex >= 0) {
              forwardPoints = this.m_forwardHistory[historyIndex];
              diagonalForwardBase = forwardPoints[0];
              diagonalMin = 1;
              diagonalMax = forwardPoints.length - 1;
            }
          } while (--historyIndex >= -1);
          forwardChanges = changeHelper.getReverseChanges();
          if (quitEarlyArr[0]) {
            let originalStartPoint = midOriginalArr[0] + 1;
            let modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
              const lastForwardChange = forwardChanges[forwardChanges.length - 1];
              originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
              modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
              new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
          } else {
            changeHelper = new DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
            lastOriginalIndex = 1073741824;
            historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
              const diagonal = diagonalRelative + diagonalReverseBase;
              if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
                originalIndex = reversePoints[diagonal + 1] - 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                if (originalIndex > lastOriginalIndex) {
                  changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex + 1;
                changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                diagonalRelative = diagonal + 1 - diagonalReverseBase;
              } else {
                originalIndex = reversePoints[diagonal - 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                if (originalIndex > lastOriginalIndex) {
                  changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                diagonalRelative = diagonal - 1 - diagonalReverseBase;
              }
              if (historyIndex >= 0) {
                reversePoints = this.m_reverseHistory[historyIndex];
                diagonalReverseBase = reversePoints[0];
                diagonalMin = 1;
                diagonalMax = reversePoints.length - 1;
              }
            } while (--historyIndex >= -1);
            reverseChanges = changeHelper.getChanges();
          }
          return this.ConcatenateChanges(forwardChanges, reverseChanges);
        }
        ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
          let originalIndex = 0, modifiedIndex = 0;
          let diagonalForwardStart = 0, diagonalForwardEnd = 0;
          let diagonalReverseStart = 0, diagonalReverseEnd = 0;
          originalStart--;
          modifiedStart--;
          midOriginalArr[0] = 0;
          midModifiedArr[0] = 0;
          this.m_forwardHistory = [];
          this.m_reverseHistory = [];
          const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
          const numDiagonals = maxDifferences + 1;
          const forwardPoints = new Int32Array(numDiagonals);
          const reversePoints = new Int32Array(numDiagonals);
          const diagonalForwardBase = modifiedEnd - modifiedStart;
          const diagonalReverseBase = originalEnd - originalStart;
          const diagonalForwardOffset = originalStart - modifiedStart;
          const diagonalReverseOffset = originalEnd - modifiedEnd;
          const delta = diagonalReverseBase - diagonalForwardBase;
          const deltaIsEven = delta % 2 === 0;
          forwardPoints[diagonalForwardBase] = originalStart;
          reversePoints[diagonalReverseBase] = originalEnd;
          quitEarlyArr[0] = false;
          for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
            let furthestOriginalIndex = 0;
            let furthestModifiedIndex = 0;
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
              if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
                originalIndex = forwardPoints[diagonal + 1];
              } else {
                originalIndex = forwardPoints[diagonal - 1] + 1;
              }
              modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
              const tempOriginalIndex = originalIndex;
              while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                originalIndex++;
                modifiedIndex++;
              }
              forwardPoints[diagonal] = originalIndex;
              if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                furthestOriginalIndex = originalIndex;
                furthestModifiedIndex = modifiedIndex;
              }
              if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
                if (originalIndex >= reversePoints[diagonal]) {
                  midOriginalArr[0] = originalIndex;
                  midModifiedArr[0] = modifiedIndex;
                  if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                  } else {
                    return null;
                  }
                }
              }
            }
            const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
              quitEarlyArr[0] = true;
              midOriginalArr[0] = furthestOriginalIndex;
              midModifiedArr[0] = furthestModifiedIndex;
              if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                originalStart++;
                modifiedStart++;
                return [
                  new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
              }
            }
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
              if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
                originalIndex = reversePoints[diagonal + 1] - 1;
              } else {
                originalIndex = reversePoints[diagonal - 1];
              }
              modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
              const tempOriginalIndex = originalIndex;
              while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                originalIndex--;
                modifiedIndex--;
              }
              reversePoints[diagonal] = originalIndex;
              if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                if (originalIndex <= forwardPoints[diagonal]) {
                  midOriginalArr[0] = originalIndex;
                  midModifiedArr[0] = modifiedIndex;
                  if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                  } else {
                    return null;
                  }
                }
              }
            }
            if (numDifferences <= 1447) {
              let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
              temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
              MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
              this.m_forwardHistory.push(temp);
              temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
              temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
              MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
              this.m_reverseHistory.push(temp);
            }
          }
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        }
        PrettifyChanges(changes) {
          for (let i = 0; i < changes.length; i++) {
            const change = changes[i];
            const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
              const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
              const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
              if (endStrictEqual && !startStrictEqual) {
                break;
              }
              change.originalStart++;
              change.modifiedStart++;
            }
            let mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
              changes[i] = mergedChangeArr[0];
              changes.splice(i + 1, 1);
              i--;
              continue;
            }
          }
          for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            let originalStop = 0;
            let modifiedStop = 0;
            if (i > 0) {
              const prevChange = changes[i - 1];
              originalStop = prevChange.originalStart + prevChange.originalLength;
              modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
            }
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            let bestDelta = 0;
            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (let delta = 1; ; delta++) {
              const originalStart = change.originalStart - delta;
              const modifiedStart = change.modifiedStart - delta;
              if (originalStart < originalStop || modifiedStart < modifiedStop) {
                break;
              }
              if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                break;
              }
              if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                break;
              }
              const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
              const score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
              if (score > bestScore) {
                bestScore = score;
                bestDelta = delta;
              }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
            const mergedChangeArr = [null];
            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
              changes[i - 1] = mergedChangeArr[0];
              changes.splice(i, 1);
              i++;
              continue;
            }
          }
          if (this._hasStrings) {
            for (let i = 1, len = changes.length; i < len; i++) {
              const aChange = changes[i - 1];
              const bChange = changes[i];
              const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
              const aOriginalStart = aChange.originalStart;
              const bOriginalEnd = bChange.originalStart + bChange.originalLength;
              const abOriginalLength = bOriginalEnd - aOriginalStart;
              const aModifiedStart = aChange.modifiedStart;
              const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
              const abModifiedLength = bModifiedEnd - aModifiedStart;
              if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
                const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
                if (t) {
                  const [originalMatchStart, modifiedMatchStart] = t;
                  if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                    aChange.originalLength = originalMatchStart - aChange.originalStart;
                    aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                    bChange.originalStart = originalMatchStart + matchedLength;
                    bChange.modifiedStart = modifiedMatchStart + matchedLength;
                    bChange.originalLength = bOriginalEnd - bChange.originalStart;
                    bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                  }
                }
              }
            }
          }
          return changes;
        }
        _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
          if (originalLength < desiredLength || modifiedLength < desiredLength) {
            return null;
          }
          const originalMax = originalStart + originalLength - desiredLength + 1;
          const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
          let bestScore = 0;
          let bestOriginalStart = 0;
          let bestModifiedStart = 0;
          for (let i = originalStart; i < originalMax; i++) {
            for (let j = modifiedStart; j < modifiedMax; j++) {
              const score = this._contiguousSequenceScore(i, j, desiredLength);
              if (score > 0 && score > bestScore) {
                bestScore = score;
                bestOriginalStart = i;
                bestModifiedStart = j;
              }
            }
          }
          if (bestScore > 0) {
            return [bestOriginalStart, bestModifiedStart];
          }
          return null;
        }
        _contiguousSequenceScore(originalStart, modifiedStart, length) {
          let score = 0;
          for (let l = 0; l < length; l++) {
            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
              return 0;
            }
            score += this._originalStringElements[originalStart + l].length;
          }
          return score;
        }
        _OriginalIsBoundary(index) {
          if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
          }
          return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
        }
        _OriginalRegionIsBoundary(originalStart, originalLength) {
          if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
          }
          if (originalLength > 0) {
            const originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
              return true;
            }
          }
          return false;
        }
        _ModifiedIsBoundary(index) {
          if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
          }
          return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
        }
        _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
          if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
          }
          if (modifiedLength > 0) {
            const modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
              return true;
            }
          }
          return false;
        }
        _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
          const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
          const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
          return originalScore + modifiedScore;
        }
        ConcatenateChanges(left, right) {
          let mergedChangeArr = [];
          if (left.length === 0 || right.length === 0) {
            return right.length > 0 ? right : left;
          } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            const result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
          } else {
            const result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
          }
        }
        ChangesOverlap(left, right, mergedChangeArr) {
          Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
          Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
          if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            const originalStart = left.originalStart;
            let originalLength = left.originalLength;
            const modifiedStart = left.modifiedStart;
            let modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
              originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
              modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
          } else {
            mergedChangeArr[0] = null;
            return false;
          }
        }
        ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
          if (diagonal >= 0 && diagonal < numDiagonals) {
            return diagonal;
          }
          const diagonalsBelow = diagonalBaseIndex;
          const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
          const diffEven = numDifferences % 2 === 0;
          if (diagonal < 0) {
            const lowerBoundEven = diagonalsBelow % 2 === 0;
            return diffEven === lowerBoundEven ? 0 : 1;
          } else {
            const upperBoundEven = diagonalsAbove % 2 === 0;
            return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess, cwd, env, platform;
  var init_process = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js"() {
      init_platform();
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        const sandboxProcess = globals.vscode.process;
        safeProcess = {
          get platform() {
            return sandboxProcess.platform;
          },
          get arch() {
            return sandboxProcess.arch;
          },
          get env() {
            return sandboxProcess.env;
          },
          cwd() {
            return sandboxProcess.cwd();
          }
        };
      } else if (typeof process !== "undefined") {
        safeProcess = {
          get platform() {
            return process.platform;
          },
          get arch() {
            return process.arch;
          },
          get env() {
            return process.env;
          },
          cwd() {
            return process.env["VSCODE_CWD"] || process.cwd();
          }
        };
      } else {
        safeProcess = {
          get platform() {
            return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
          },
          get arch() {
            return void 0;
          },
          get env() {
            return {};
          },
          cwd() {
            return "/";
          }
        };
      }
      cwd = safeProcess.cwd;
      env = safeProcess.env;
      platform = safeProcess.platform;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js
  function validateString(value, name) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name, "string", value);
    }
  }
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType("pathObject", "Object", pathObject);
    }
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_COLON, CHAR_QUESTION_MARK, ErrorInvalidArgType, win32, posix, normalize, resolve, relative, dirname, basename, extname, sep;
  var init_path = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js"() {
      init_process();
      CHAR_UPPERCASE_A = 65;
      CHAR_LOWERCASE_A = 97;
      CHAR_UPPERCASE_Z = 90;
      CHAR_LOWERCASE_Z = 122;
      CHAR_DOT = 46;
      CHAR_FORWARD_SLASH = 47;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_COLON = 58;
      CHAR_QUESTION_MARK = 63;
      ErrorInvalidArgType = class extends Error {
        constructor(name, expected, actual) {
          let determiner;
          if (typeof expected === "string" && expected.indexOf("not ") === 0) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          const type = name.indexOf(".") !== -1 ? "property" : "argument";
          let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
          msg += `. Received type ${typeof actual}`;
          super(msg);
          this.code = "ERR_INVALID_ARG_TYPE";
        }
      };
      win32 = {
        resolve(...pathSegments) {
          let resolvedDevice = "";
          let resolvedTail = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
              path = pathSegments[i];
              validateString(path, "path");
              if (path.length === 0) {
                continue;
              }
            } else if (resolvedDevice.length === 0) {
              path = cwd();
            } else {
              path = env[`=${resolvedDevice}`] || cwd();
              if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
                path = `${resolvedDevice}\\`;
              }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len === 1) {
              if (isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
              }
            } else if (isPathSeparator(code)) {
              isAbsolute = true;
              if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  const firstPart = path.slice(last, j);
                  last = j;
                  while (j < len && isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j < len && j !== last) {
                    last = j;
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                      j++;
                    }
                    if (j === len || j !== last) {
                      device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                      rootEnd = j;
                    }
                  }
                }
              } else {
                rootEnd = 1;
              }
            } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
              device = path.slice(0, 2);
              rootEnd = 2;
              if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                isAbsolute = true;
                rootEnd = 3;
              }
            }
            if (device.length > 0) {
              if (resolvedDevice.length > 0) {
                if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                  continue;
                }
              } else {
                resolvedDevice = device;
              }
            }
            if (resolvedAbsolute) {
              if (resolvedDevice.length > 0) {
                break;
              }
            } else {
              resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
              resolvedAbsolute = isAbsolute;
              if (isAbsolute && resolvedDevice.length > 0) {
                break;
              }
            }
          }
          resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
          return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
        },
        normalize(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = 0;
          let device;
          let isAbsolute = false;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPosixPathSeparator(code) ? "\\" : path;
          }
          if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                const firstPart = path.slice(last, j);
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return `\\\\${firstPart}\\${path.slice(last)}\\`;
                  }
                  if (j !== last) {
                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                    rootEnd = j;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
              isAbsolute = true;
              rootEnd = 3;
            }
          }
          let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
          if (tail.length === 0 && !isAbsolute) {
            tail = ".";
          }
          if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
          }
          if (device === void 0) {
            return isAbsolute ? `\\${tail}` : tail;
          }
          return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
        },
        isAbsolute(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return false;
          }
          const code = path.charCodeAt(0);
          return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          let firstPart;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = firstPart = arg;
              } else {
                joined += `\\${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          let needsReplace = true;
          let slashCount = 0;
          if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
              ++slashCount;
              if (firstLen > 2) {
                if (isPathSeparator(firstPart.charCodeAt(2))) {
                  ++slashCount;
                } else {
                  needsReplace = false;
                }
              }
            }
          }
          if (needsReplace) {
            while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
              slashCount++;
            }
            if (slashCount >= 2) {
              joined = `\\${joined.slice(slashCount)}`;
            }
          }
          return win32.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          const fromOrig = win32.resolve(from);
          const toOrig = win32.resolve(to);
          if (fromOrig === toOrig) {
            return "";
          }
          from = fromOrig.toLowerCase();
          to = toOrig.toLowerCase();
          if (from === to) {
            return "";
          }
          let fromStart = 0;
          while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
          }
          let fromEnd = from.length;
          while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
          }
          const fromLen = fromEnd - fromStart;
          let toStart = 0;
          while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
          }
          let toEnd = to.length;
          while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
          }
          const toLen = toEnd - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_BACKWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i !== length) {
            if (lastCommonSep === -1) {
              return toOrig;
            }
          } else {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                return toOrig.slice(toStart + i + 1);
              }
              if (i === 2) {
                return toOrig.slice(toStart + i);
              }
            }
            if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 2) {
                lastCommonSep = 3;
              }
            }
            if (lastCommonSep === -1) {
              lastCommonSep = 0;
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
              out += out.length === 0 ? ".." : "\\..";
            }
          }
          toStart += lastCommonSep;
          if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
          }
          if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
          }
          return toOrig.slice(toStart, toEnd);
        },
        toNamespacedPath(path) {
          if (typeof path !== "string") {
            return path;
          }
          if (path.length === 0) {
            return "";
          }
          const resolvedPath = win32.resolve(path);
          if (resolvedPath.length <= 2) {
            return path;
          }
          if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
              const code = resolvedPath.charCodeAt(2);
              if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
              }
            }
          } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            return `\\\\?\\${resolvedPath}`;
          }
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = -1;
          let offset = 0;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPathSeparator(code) ? path : ".";
          }
          if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return path;
                  }
                  if (j !== last) {
                    rootEnd = offset = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
          }
          let end = -1;
          let matchedSlash = true;
          for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            if (rootEnd === -1) {
              return ".";
            }
            end = rootEnd;
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
          }
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
              const code = path.charCodeAt(i);
              if (isPathSeparator(code)) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let start = 0;
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
          }
          for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format.bind(null, "\\"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const len = path.length;
          let rootEnd = 0;
          let code = path.charCodeAt(0);
          if (len === 1) {
            if (isPathSeparator(code)) {
              ret.root = ret.dir = path;
              return ret;
            }
            ret.base = ret.name = path;
            return ret;
          }
          if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    rootEnd = j;
                  } else if (j !== last) {
                    rootEnd = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            if (len <= 2) {
              ret.root = ret.dir = path;
              return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
              if (len === 3) {
                ret.root = ret.dir = path;
                return ret;
              }
              rootEnd = 3;
            }
          }
          if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
          }
          let startDot = -1;
          let startPart = rootEnd;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(startPart, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
          } else {
            ret.dir = ret.root;
          }
          return ret;
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null
      };
      posix = {
        resolve(...pathSegments) {
          let resolvedPath = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : cwd();
            validateString(path, "path");
            if (path.length === 0) {
              continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          }
          resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
          if (resolvedAbsolute) {
            return `/${resolvedPath}`;
          }
          return resolvedPath.length > 0 ? resolvedPath : ".";
        },
        normalize(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
          path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
          if (path.length === 0) {
            if (isAbsolute) {
              return "/";
            }
            return trailingSeparator ? "./" : ".";
          }
          if (trailingSeparator) {
            path += "/";
          }
          return isAbsolute ? `/${path}` : path;
        },
        isAbsolute(path) {
          validateString(path, "path");
          return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = arg;
              } else {
                joined += `/${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return posix.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to) {
            return "";
          }
          const fromStart = 1;
          const fromEnd = from.length;
          const fromLen = fromEnd - fromStart;
          const toStart = 1;
          const toLen = to.length - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_FORWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                return to.slice(toStart + i + 1);
              }
              if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              out += out.length === 0 ? ".." : "/..";
            }
          }
          return `${out}${to.slice(toStart + lastCommonSep)}`;
        },
        toNamespacedPath(path) {
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let end = -1;
          let matchedSlash = true;
          for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            return hasRoot ? "/" : ".";
          }
          if (hasRoot && end === 1) {
            return "//";
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              const code = path.charCodeAt(i);
              if (code === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format.bind(null, "/"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
            if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(start2, end);
            } else {
              ret.name = path.slice(start2, startDot);
              ret.base = path.slice(start2, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
          } else if (isAbsolute) {
            ret.dir = "/";
          }
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.win32 = win32.win32 = win32;
      posix.posix = win32.posix = posix;
      normalize = platform === "win32" ? win32.normalize : posix.normalize;
      resolve = platform === "win32" ? win32.resolve : posix.resolve;
      relative = platform === "win32" ? win32.relative : posix.relative;
      dirname = platform === "win32" ? win32.dirname : posix.dirname;
      basename = platform === "win32" ? win32.basename : posix.basename;
      extname = platform === "win32" ? win32.extname : posix.extname;
      sep = platform === "win32" ? win32.sep : posix.sep;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  function encodeURIComponentFast(uriComponent, allowSlash) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.indexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.indexOf(":");
      if (idx === -1) {
        res += encoder(authority, false);
      } else {
        res += encoder(authority.substr(0, idx), false);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true);
    }
    if (query) {
      res += "?";
      res += encoder(query, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a3) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }
  var _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, Uri, encodeTable, _rEncodedAsHex;
  var init_uri = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js"() {
      init_path();
      init_platform();
      _schemePattern = /^\w[\w\d+.-]*$/;
      _singleSlashStart = /^\//;
      _doubleSlashStart = /^\/\//;
      _empty = "";
      _slash = "/";
      _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      URI = class {
        constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
          if (typeof schemeOrData === "object") {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
          } else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
          }
        }
        static isUri(thing) {
          if (thing instanceof URI) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
        }
        get fsPath() {
          return uriToFsPath(this, false);
        }
        with(change) {
          if (!change) {
            return this;
          }
          let { scheme, authority, path, query, fragment } = change;
          if (scheme === void 0) {
            scheme = this.scheme;
          } else if (scheme === null) {
            scheme = _empty;
          }
          if (authority === void 0) {
            authority = this.authority;
          } else if (authority === null) {
            authority = _empty;
          }
          if (path === void 0) {
            path = this.path;
          } else if (path === null) {
            path = _empty;
          }
          if (query === void 0) {
            query = this.query;
          } else if (query === null) {
            query = _empty;
          }
          if (fragment === void 0) {
            fragment = this.fragment;
          } else if (fragment === null) {
            fragment = _empty;
          }
          if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
            return this;
          }
          return new Uri(scheme, authority, path, query, fragment);
        }
        static parse(value, _strict = false) {
          const match = _regexp.exec(value);
          if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
          }
          return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
        }
        static file(path) {
          let authority = _empty;
          if (isWindows) {
            path = path.replace(/\\/g, _slash);
          }
          if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
              authority = path.substring(2);
              path = _slash;
            } else {
              authority = path.substring(2, idx);
              path = path.substring(idx) || _slash;
            }
          }
          return new Uri("file", authority, path, _empty, _empty);
        }
        static from(components) {
          const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
          _validateUri(result, true);
          return result;
        }
        static joinPath(uri, ...pathFragment) {
          if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPath on URI without path`);
          }
          let newPath;
          if (isWindows && uri.scheme === "file") {
            newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
          } else {
            newPath = posix.join(uri.path, ...pathFragment);
          }
          return uri.with({ path: newPath });
        }
        toString(skipEncoding = false) {
          return _asFormatted(this, skipEncoding);
        }
        toJSON() {
          return this;
        }
        static revive(data) {
          if (!data) {
            return data;
          } else if (data instanceof URI) {
            return data;
          } else {
            const result = new Uri(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
          }
        }
      };
      _pathSepMarker = isWindows ? 1 : void 0;
      Uri = class extends URI {
        constructor() {
          super(...arguments);
          this._formatted = null;
          this._fsPath = null;
        }
        get fsPath() {
          if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
          }
          return this._fsPath;
        }
        toString(skipEncoding = false) {
          if (!skipEncoding) {
            if (!this._formatted) {
              this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
          } else {
            return _asFormatted(this, true);
          }
        }
        toJSON() {
          const res = {
            $mid: 1
          };
          if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
          }
          if (this._formatted) {
            res.external = this._formatted;
          }
          if (this.path) {
            res.path = this.path;
          }
          if (this.scheme) {
            res.scheme = this.scheme;
          }
          if (this.authority) {
            res.authority = this.authority;
          }
          if (this.query) {
            res.query = this.query;
          }
          if (this.fragment) {
            res.fragment = this.fragment;
          }
          return res;
        }
      };
      encodeTable = {
        [58]: "%3A",
        [47]: "%2F",
        [63]: "%3F",
        [35]: "%23",
        [91]: "%5B",
        [93]: "%5D",
        [64]: "%40",
        [33]: "%21",
        [36]: "%24",
        [38]: "%26",
        [39]: "%27",
        [40]: "%28",
        [41]: "%29",
        [42]: "%2A",
        [43]: "%2B",
        [44]: "%2C",
        [59]: "%3B",
        [61]: "%3D",
        [32]: "%20"
      };
      _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position;
  var init_position = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js"() {
      Position = class {
        constructor(lineNumber, column) {
          this.lineNumber = lineNumber;
          this.column = column;
        }
        with(newLineNumber = this.lineNumber, newColumn = this.column) {
          if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
          } else {
            return new Position(newLineNumber, newColumn);
          }
        }
        delta(deltaLineNumber = 0, deltaColumn = 0) {
          return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
        }
        equals(other) {
          return Position.equals(this, other);
        }
        static equals(a, b) {
          if (!a && !b) {
            return true;
          }
          return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
        }
        isBefore(other) {
          return Position.isBefore(this, other);
        }
        static isBefore(a, b) {
          if (a.lineNumber < b.lineNumber) {
            return true;
          }
          if (b.lineNumber < a.lineNumber) {
            return false;
          }
          return a.column < b.column;
        }
        isBeforeOrEqual(other) {
          return Position.isBeforeOrEqual(this, other);
        }
        static isBeforeOrEqual(a, b) {
          if (a.lineNumber < b.lineNumber) {
            return true;
          }
          if (b.lineNumber < a.lineNumber) {
            return false;
          }
          return a.column <= b.column;
        }
        static compare(a, b) {
          const aLineNumber = a.lineNumber | 0;
          const bLineNumber = b.lineNumber | 0;
          if (aLineNumber === bLineNumber) {
            const aColumn = a.column | 0;
            const bColumn = b.column | 0;
            return aColumn - bColumn;
          }
          return aLineNumber - bLineNumber;
        }
        clone() {
          return new Position(this.lineNumber, this.column);
        }
        toString() {
          return "(" + this.lineNumber + "," + this.column + ")";
        }
        static lift(pos) {
          return new Position(pos.lineNumber, pos.column);
        }
        static isIPosition(obj) {
          return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range;
  var init_range = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"() {
      init_position();
      Range = class {
        constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
          if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
          } else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
          }
        }
        isEmpty() {
          return Range.isEmpty(this);
        }
        static isEmpty(range) {
          return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
        }
        containsPosition(position) {
          return Range.containsPosition(this, position);
        }
        static containsPosition(range, position) {
          if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
          }
          if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
          }
          if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
          }
          return true;
        }
        static strictContainsPosition(range, position) {
          if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
          }
          if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
            return false;
          }
          if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
            return false;
          }
          return true;
        }
        containsRange(range) {
          return Range.containsRange(this, range);
        }
        static containsRange(range, otherRange) {
          if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
          }
          if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
          }
          return true;
        }
        strictContainsRange(range) {
          return Range.strictContainsRange(this, range);
        }
        static strictContainsRange(range, otherRange) {
          if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
          }
          if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
          }
          return true;
        }
        plusRange(range) {
          return Range.plusRange(this, range);
        }
        static plusRange(a, b) {
          let startLineNumber;
          let startColumn;
          let endLineNumber;
          let endColumn;
          if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
          } else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
          } else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
          }
          if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
          } else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
          } else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
          }
          return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        intersectRanges(range) {
          return Range.intersectRanges(this, range);
        }
        static intersectRanges(a, b) {
          let resultStartLineNumber = a.startLineNumber;
          let resultStartColumn = a.startColumn;
          let resultEndLineNumber = a.endLineNumber;
          let resultEndColumn = a.endColumn;
          let otherStartLineNumber = b.startLineNumber;
          let otherStartColumn = b.startColumn;
          let otherEndLineNumber = b.endLineNumber;
          let otherEndColumn = b.endColumn;
          if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
          } else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
          }
          if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
          } else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
          }
          if (resultStartLineNumber > resultEndLineNumber) {
            return null;
          }
          if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
          }
          return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        }
        equalsRange(other) {
          return Range.equalsRange(this, other);
        }
        static equalsRange(a, b) {
          return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
        }
        getEndPosition() {
          return Range.getEndPosition(this);
        }
        static getEndPosition(range) {
          return new Position(range.endLineNumber, range.endColumn);
        }
        getStartPosition() {
          return Range.getStartPosition(this);
        }
        static getStartPosition(range) {
          return new Position(range.startLineNumber, range.startColumn);
        }
        toString() {
          return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
        }
        setEndPosition(endLineNumber, endColumn) {
          return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        setStartPosition(startLineNumber, startColumn) {
          return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        collapseToStart() {
          return Range.collapseToStart(this);
        }
        static collapseToStart(range) {
          return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        }
        static fromPositions(start, end = start) {
          return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        static lift(range) {
          if (!range) {
            return null;
          }
          return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        }
        static isIRange(obj) {
          return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
        }
        static areIntersectingOrTouching(a, b) {
          if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
            return false;
          }
          if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
            return false;
          }
          return true;
        }
        static areIntersecting(a, b) {
          if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
            return false;
          }
          if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
            return false;
          }
          return true;
        }
        static compareRangesUsingStarts(a, b) {
          if (a && b) {
            const aStartLineNumber = a.startLineNumber | 0;
            const bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
              const aStartColumn = a.startColumn | 0;
              const bStartColumn = b.startColumn | 0;
              if (aStartColumn === bStartColumn) {
                const aEndLineNumber = a.endLineNumber | 0;
                const bEndLineNumber = b.endLineNumber | 0;
                if (aEndLineNumber === bEndLineNumber) {
                  const aEndColumn = a.endColumn | 0;
                  const bEndColumn = b.endColumn | 0;
                  return aEndColumn - bEndColumn;
                }
                return aEndLineNumber - bEndLineNumber;
              }
              return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
          }
          const aExists = a ? 1 : 0;
          const bExists = b ? 1 : 0;
          return aExists - bExists;
        }
        static compareRangesUsingEnds(a, b) {
          if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
              if (a.startLineNumber === b.startLineNumber) {
                return a.startColumn - b.startColumn;
              }
              return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
          }
          return a.endLineNumber - b.endLineNumber;
        }
        static spansMultipleLines(range) {
          return range.endLineNumber > range.startLineNumber;
        }
        toJSON() {
          return this;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }
  var MINIMUM_MATCHING_CHARACTER_LENGTH, LineSequence, CharSequence, CharChange, LineChange, DiffComputer;
  var init_diffComputer = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js"() {
      init_diff();
      init_strings();
      MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
      LineSequence = class {
        constructor(lines) {
          const startColumns = [];
          const endColumns = [];
          for (let i = 0, length = lines.length; i < length; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
          }
          this.lines = lines;
          this._startColumns = startColumns;
          this._endColumns = endColumns;
        }
        getElements() {
          const elements = [];
          for (let i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
          }
          return elements;
        }
        getStrictElement(index) {
          return this.lines[index];
        }
        getStartLineNumber(i) {
          return i + 1;
        }
        getEndLineNumber(i) {
          return i + 1;
        }
        createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
          const charCodes = [];
          const lineNumbers = [];
          const columns = [];
          let len = 0;
          for (let index = startIndex; index <= endIndex; index++) {
            const lineContent = this.lines[index];
            const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
            const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
            for (let col = startColumn; col < endColumn; col++) {
              charCodes[len] = lineContent.charCodeAt(col - 1);
              lineNumbers[len] = index + 1;
              columns[len] = col;
              len++;
            }
          }
          return new CharSequence(charCodes, lineNumbers, columns);
        }
      };
      CharSequence = class {
        constructor(charCodes, lineNumbers, columns) {
          this._charCodes = charCodes;
          this._lineNumbers = lineNumbers;
          this._columns = columns;
        }
        getElements() {
          return this._charCodes;
        }
        getStartLineNumber(i) {
          return this._lineNumbers[i];
        }
        getStartColumn(i) {
          return this._columns[i];
        }
        getEndLineNumber(i) {
          return this._lineNumbers[i];
        }
        getEndColumn(i) {
          return this._columns[i] + 1;
        }
      };
      CharChange = class {
        constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
          this.originalStartLineNumber = originalStartLineNumber;
          this.originalStartColumn = originalStartColumn;
          this.originalEndLineNumber = originalEndLineNumber;
          this.originalEndColumn = originalEndColumn;
          this.modifiedStartLineNumber = modifiedStartLineNumber;
          this.modifiedStartColumn = modifiedStartColumn;
          this.modifiedEndLineNumber = modifiedEndLineNumber;
          this.modifiedEndColumn = modifiedEndColumn;
        }
        static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
          let originalStartLineNumber;
          let originalStartColumn;
          let originalEndLineNumber;
          let originalEndColumn;
          let modifiedStartLineNumber;
          let modifiedStartColumn;
          let modifiedEndLineNumber;
          let modifiedEndColumn;
          if (diffChange.originalLength === 0) {
            originalStartLineNumber = 0;
            originalStartColumn = 0;
            originalEndLineNumber = 0;
            originalEndColumn = 0;
          } else {
            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
          }
          if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = 0;
            modifiedStartColumn = 0;
            modifiedEndLineNumber = 0;
            modifiedEndColumn = 0;
          } else {
            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          }
          return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
        }
      };
      LineChange = class {
        constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
          this.originalStartLineNumber = originalStartLineNumber;
          this.originalEndLineNumber = originalEndLineNumber;
          this.modifiedStartLineNumber = modifiedStartLineNumber;
          this.modifiedEndLineNumber = modifiedEndLineNumber;
          this.charChanges = charChanges;
        }
        static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
          let originalStartLineNumber;
          let originalEndLineNumber;
          let modifiedStartLineNumber;
          let modifiedEndLineNumber;
          let charChanges = void 0;
          if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
          } else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
          }
          if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
          } else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          }
          if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
              rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
              charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
            }
          }
          return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
        }
      };
      DiffComputer = class {
        constructor(originalLines, modifiedLines, opts) {
          this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
          this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
          this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
          this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
          this.originalLines = originalLines;
          this.modifiedLines = modifiedLines;
          this.original = new LineSequence(originalLines);
          this.modified = new LineSequence(modifiedLines);
          this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
          this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
        }
        computeDiff() {
          if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
              return {
                quitEarly: false,
                changes: []
              };
            }
            return {
              quitEarly: false,
              changes: [{
                originalStartLineNumber: 1,
                originalEndLineNumber: 1,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: this.modified.lines.length,
                charChanges: [{
                  modifiedEndColumn: 0,
                  modifiedEndLineNumber: 0,
                  modifiedStartColumn: 0,
                  modifiedStartLineNumber: 0,
                  originalEndColumn: 0,
                  originalEndLineNumber: 0,
                  originalStartColumn: 0,
                  originalStartLineNumber: 0
                }]
              }]
            };
          }
          if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            return {
              quitEarly: false,
              changes: [{
                originalStartLineNumber: 1,
                originalEndLineNumber: this.original.lines.length,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: 1,
                charChanges: [{
                  modifiedEndColumn: 0,
                  modifiedEndLineNumber: 0,
                  modifiedStartColumn: 0,
                  modifiedStartLineNumber: 0,
                  originalEndColumn: 0,
                  originalEndLineNumber: 0,
                  originalStartColumn: 0,
                  originalStartLineNumber: 0
                }]
              }]
            };
          }
          const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
          const rawChanges = diffResult.changes;
          const quitEarly = diffResult.quitEarly;
          if (this.shouldIgnoreTrimWhitespace) {
            const lineChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
              lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
              quitEarly,
              changes: lineChanges
            };
          }
          const result = [];
          let originalLineIndex = 0;
          let modifiedLineIndex = 0;
          for (let i = -1, len = rawChanges.length; i < len; i++) {
            const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
            const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
            const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
              const originalLine = this.originalLines[originalLineIndex];
              const modifiedLine = this.modifiedLines[modifiedLineIndex];
              if (originalLine !== modifiedLine) {
                {
                  let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                  let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                  while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                    const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                    const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                    if (originalChar !== modifiedChar) {
                      break;
                    }
                    originalStartColumn--;
                    modifiedStartColumn--;
                  }
                  if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                    this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                  }
                }
                {
                  let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                  let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                  const originalMaxColumn = originalLine.length + 1;
                  const modifiedMaxColumn = modifiedLine.length + 1;
                  while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                    const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                    const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                    if (originalChar !== modifiedChar) {
                      break;
                    }
                    originalEndColumn++;
                    modifiedEndColumn++;
                  }
                  if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                    this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                  }
                }
              }
              originalLineIndex++;
              modifiedLineIndex++;
            }
            if (nextChange) {
              result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
              originalLineIndex += nextChange.originalLength;
              modifiedLineIndex += nextChange.modifiedLength;
            }
          }
          return {
            quitEarly,
            changes: result
          };
        }
        _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
          if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            return;
          }
          let charChanges = void 0;
          if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
          }
          result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
        }
        _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
          const len = result.length;
          if (len === 0) {
            return false;
          }
          const prevChange = result[len - 1];
          if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            return false;
          }
          if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
              prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
          }
          return false;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js
  var init_arrays = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 255) {
      return 255;
    }
    return v | 0;
  }
  function toUint32(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 4294967295) {
      return 4294967295;
    }
    return v | 0;
  }
  var init_uint = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer, PrefixSumIndexOfResult;
  var init_prefixSumComputer = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js"() {
      init_arrays();
      init_uint();
      PrefixSumComputer = class {
        constructor(values) {
          this.values = values;
          this.prefixSum = new Uint32Array(values.length);
          this.prefixSumValidIndex = new Int32Array(1);
          this.prefixSumValidIndex[0] = -1;
        }
        insertValues(insertIndex, insertValues) {
          insertIndex = toUint32(insertIndex);
          const oldValues = this.values;
          const oldPrefixSum = this.prefixSum;
          const insertValuesLen = insertValues.length;
          if (insertValuesLen === 0) {
            return false;
          }
          this.values = new Uint32Array(oldValues.length + insertValuesLen);
          this.values.set(oldValues.subarray(0, insertIndex), 0);
          this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
          this.values.set(insertValues, insertIndex);
          if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
          }
          this.prefixSum = new Uint32Array(this.values.length);
          if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
          }
          return true;
        }
        setValue(index, value) {
          index = toUint32(index);
          value = toUint32(value);
          if (this.values[index] === value) {
            return false;
          }
          this.values[index] = value;
          if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
          }
          return true;
        }
        removeValues(startIndex, count) {
          startIndex = toUint32(startIndex);
          count = toUint32(count);
          const oldValues = this.values;
          const oldPrefixSum = this.prefixSum;
          if (startIndex >= oldValues.length) {
            return false;
          }
          const maxCount = oldValues.length - startIndex;
          if (count >= maxCount) {
            count = maxCount;
          }
          if (count === 0) {
            return false;
          }
          this.values = new Uint32Array(oldValues.length - count);
          this.values.set(oldValues.subarray(0, startIndex), 0);
          this.values.set(oldValues.subarray(startIndex + count), startIndex);
          this.prefixSum = new Uint32Array(this.values.length);
          if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
          }
          if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
          }
          return true;
        }
        getTotalSum() {
          if (this.values.length === 0) {
            return 0;
          }
          return this._getPrefixSum(this.values.length - 1);
        }
        getPrefixSum(index) {
          if (index < 0) {
            return 0;
          }
          index = toUint32(index);
          return this._getPrefixSum(index);
        }
        _getPrefixSum(index) {
          if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
          }
          let startIndex = this.prefixSumValidIndex[0] + 1;
          if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
          }
          if (index >= this.values.length) {
            index = this.values.length - 1;
          }
          for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
          }
          this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
          return this.prefixSum[index];
        }
        getIndexOf(sum) {
          sum = Math.floor(sum);
          this.getTotalSum();
          let low = 0;
          let high = this.values.length - 1;
          let mid = 0;
          let midStop = 0;
          let midStart = 0;
          while (low <= high) {
            mid = low + (high - low) / 2 | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (sum < midStart) {
              high = mid - 1;
            } else if (sum >= midStop) {
              low = mid + 1;
            } else {
              break;
            }
          }
          return new PrefixSumIndexOfResult(mid, sum - midStart);
        }
      };
      PrefixSumIndexOfResult = class {
        constructor(index, remainder) {
          this.index = index;
          this.remainder = remainder;
          this._prefixSumIndexOfResultBrand = void 0;
          this.index = index;
          this.remainder = remainder;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel;
  var init_mirrorTextModel = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js"() {
      init_strings();
      init_position();
      init_prefixSumComputer();
      MirrorTextModel = class {
        constructor(uri, lines, eol, versionId) {
          this._uri = uri;
          this._lines = lines;
          this._eol = eol;
          this._versionId = versionId;
          this._lineStarts = null;
          this._cachedTextValue = null;
        }
        dispose() {
          this._lines.length = 0;
        }
        get version() {
          return this._versionId;
        }
        getText() {
          if (this._cachedTextValue === null) {
            this._cachedTextValue = this._lines.join(this._eol);
          }
          return this._cachedTextValue;
        }
        onEvents(e) {
          if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
          }
          const changes = e.changes;
          for (const change of changes) {
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
          }
          this._versionId = e.versionId;
          this._cachedTextValue = null;
        }
        _ensureLineStarts() {
          if (!this._lineStarts) {
            const eolLength = this._eol.length;
            const linesLength = this._lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
              lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new PrefixSumComputer(lineStartValues);
          }
        }
        _setLineText(lineIndex, newValue) {
          this._lines[lineIndex] = newValue;
          if (this._lineStarts) {
            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
          }
        }
        _acceptDeleteRange(range) {
          if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
              return;
            }
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
          }
          this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
          this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
          if (this._lineStarts) {
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
          }
        }
        _acceptInsertText(position, insertText) {
          if (insertText.length === 0) {
            return;
          }
          const insertLines = splitLines(insertText);
          if (insertLines.length === 1) {
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
          }
          insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
          this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
          const newLengths = new Uint32Array(insertLines.length - 1);
          for (let i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
          }
          if (this._lineStarts) {
            this._lineStarts.insertValues(position.lineNumber, newLengths);
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {
    if (text.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text = text.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }
  var USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, _defaultConfig;
  var init_wordHelper = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"() {
      USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
      DEFAULT_WORD_REGEXP = createWordRegExp();
      _defaultConfig = {
        maxLen: 1e3,
        windowSize: 15,
        timeBudget: 150
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier;
  var init_characterClassifier = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js"() {
      init_uint();
      CharacterClassifier = class {
        constructor(_defaultValue) {
          const defaultValue = toUint8(_defaultValue);
          this._defaultValue = defaultValue;
          this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
          this._map = /* @__PURE__ */ new Map();
        }
        static _createAsciiMap(defaultValue) {
          const asciiMap = new Uint8Array(256);
          for (let i = 0; i < 256; i++) {
            asciiMap[i] = defaultValue;
          }
          return asciiMap;
        }
        set(charCode, _value) {
          const value = toUint8(_value);
          if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
          } else {
            this._map.set(charCode, value);
          }
        }
        get(charCode) {
          if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
          } else {
            return this._map.get(charCode) || this._defaultValue;
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [1, 104, 2],
        [1, 72, 2],
        [1, 102, 6],
        [1, 70, 6],
        [2, 116, 3],
        [2, 84, 3],
        [3, 116, 4],
        [3, 84, 4],
        [4, 112, 5],
        [4, 80, 5],
        [5, 115, 9],
        [5, 83, 9],
        [5, 58, 10],
        [6, 105, 7],
        [6, 73, 7],
        [7, 108, 8],
        [7, 76, 8],
        [8, 101, 9],
        [8, 69, 9],
        [9, 58, 10],
        [10, 47, 11],
        [11, 47, 12]
      ]);
    }
    return _stateMachine;
  }
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(0);
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1);
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2);
      }
    }
    return _classifier;
  }
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }
  var Uint8Matrix, StateMachine, _stateMachine, _classifier, LinkComputer;
  var init_linkComputer = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js"() {
      init_characterClassifier();
      Uint8Matrix = class {
        constructor(rows, cols, defaultValue) {
          const data = new Uint8Array(rows * cols);
          for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
          }
          this._data = data;
          this.rows = rows;
          this.cols = cols;
        }
        get(row, col) {
          return this._data[row * this.cols + col];
        }
        set(row, col, value) {
          this._data[row * this.cols + col] = value;
        }
      };
      StateMachine = class {
        constructor(edges) {
          let maxCharCode = 0;
          let maxState = 0;
          for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
              maxCharCode = chCode;
            }
            if (from > maxState) {
              maxState = from;
            }
            if (to > maxState) {
              maxState = to;
            }
          }
          maxCharCode++;
          maxState++;
          const states = new Uint8Matrix(maxState, maxCharCode, 0);
          for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
          }
          this._states = states;
          this._maxCharCode = maxCharCode;
        }
        nextState(currentState, chCode) {
          if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0;
          }
          return this._states.get(currentState, chCode);
        }
      };
      _stateMachine = null;
      _classifier = null;
      LinkComputer = class {
        static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
          let lastIncludedCharIndex = linkEndIndex - 1;
          do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2) {
              break;
            }
            lastIncludedCharIndex--;
          } while (lastIncludedCharIndex > linkBeginIndex);
          if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
              lastIncludedCharIndex--;
            }
          }
          return {
            range: {
              startLineNumber: lineNumber,
              startColumn: linkBeginIndex + 1,
              endLineNumber: lineNumber,
              endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
          };
        }
        static computeLinks(model, stateMachine = getStateMachine()) {
          const classifier = getClassifier();
          const result = [];
          for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
              let resetStateMachine = false;
              const chCode = line.charCodeAt(j);
              if (state === 13) {
                let chClass;
                switch (chCode) {
                  case 40:
                    hasOpenParens = true;
                    chClass = 0;
                    break;
                  case 41:
                    chClass = hasOpenParens ? 0 : 1;
                    break;
                  case 91:
                    inSquareBrackets = true;
                    hasOpenSquareBracket = true;
                    chClass = 0;
                    break;
                  case 93:
                    inSquareBrackets = false;
                    chClass = hasOpenSquareBracket ? 0 : 1;
                    break;
                  case 123:
                    hasOpenCurlyBracket = true;
                    chClass = 0;
                    break;
                  case 125:
                    chClass = hasOpenCurlyBracket ? 0 : 1;
                    break;
                  case 39:
                    chClass = linkBeginChCode === 34 || linkBeginChCode === 96 ? 0 : 1;
                    break;
                  case 34:
                    chClass = linkBeginChCode === 39 || linkBeginChCode === 96 ? 0 : 1;
                    break;
                  case 96:
                    chClass = linkBeginChCode === 39 || linkBeginChCode === 34 ? 0 : 1;
                    break;
                  case 42:
                    chClass = linkBeginChCode === 42 ? 1 : 0;
                    break;
                  case 124:
                    chClass = linkBeginChCode === 124 ? 1 : 0;
                    break;
                  case 32:
                    chClass = inSquareBrackets ? 0 : 1;
                    break;
                  default:
                    chClass = classifier.get(chCode);
                }
                if (chClass === 1) {
                  result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                  resetStateMachine = true;
                }
              } else if (state === 12) {
                let chClass;
                if (chCode === 91) {
                  hasOpenSquareBracket = true;
                  chClass = 0;
                } else {
                  chClass = classifier.get(chCode);
                }
                if (chClass === 1) {
                  resetStateMachine = true;
                } else {
                  state = 13;
                }
              } else {
                state = stateMachine.nextState(state, chCode);
                if (state === 0) {
                  resetStateMachine = true;
                }
              }
              if (resetStateMachine) {
                state = 1;
                hasOpenParens = false;
                hasOpenSquareBracket = false;
                hasOpenCurlyBracket = false;
                linkBeginIndex = j + 1;
                linkBeginChCode = chCode;
              }
              j++;
            }
            if (state === 13) {
              result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
          }
          return result;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace;
  var init_inplaceReplaceSupport = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js"() {
      BasicInplaceReplace = class {
        constructor() {
          this._defaultValueSet = [
            ["true", "false"],
            ["True", "False"],
            ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
            ["public", "protected", "private"]
          ];
        }
        navigateValueSet(range1, text1, range2, text2, up) {
          if (range1 && text1) {
            const result = this.doNavigateValueSet(text1, up);
            if (result) {
              return {
                range: range1,
                value: result
              };
            }
          }
          if (range2 && text2) {
            const result = this.doNavigateValueSet(text2, up);
            if (result) {
              return {
                range: range2,
                value: result
              };
            }
          }
          return null;
        }
        doNavigateValueSet(text, up) {
          const numberResult = this.numberReplace(text, up);
          if (numberResult !== null) {
            return numberResult;
          }
          return this.textReplace(text, up);
        }
        numberReplace(value, up) {
          const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
          let n1 = Number(value);
          let n2 = parseFloat(value);
          if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
              return null;
            } else {
              n1 = Math.floor(n1 * precision);
              n1 += up ? precision : -precision;
              return String(n1 / precision);
            }
          }
          return null;
        }
        textReplace(value, up) {
          return this.valueSetsReplace(this._defaultValueSet, value, up);
        }
        valueSetsReplace(valueSets, value, up) {
          let result = null;
          for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
          }
          return result;
        }
        valueSetReplace(valueSet, value, up) {
          let idx = valueSet.indexOf(value);
          if (idx >= 0) {
            idx += up ? 1 : -1;
            if (idx < 0) {
              idx = valueSet.length - 1;
            } else {
              idx %= valueSet.length;
            }
            return valueSet[idx];
          }
          return null;
        }
      };
      BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent, CancellationToken, MutableToken, CancellationTokenSource;
  var init_cancellation = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js"() {
      init_event();
      shortcutEvent = Object.freeze(function(callback, context) {
        const handle = setTimeout(callback.bind(context), 0);
        return { dispose() {
          clearTimeout(handle);
        } };
      });
      (function(CancellationToken2) {
        function isCancellationToken(thing) {
          if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
            return true;
          }
          if (thing instanceof MutableToken) {
            return true;
          }
          if (!thing || typeof thing !== "object") {
            return false;
          }
          return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
        }
        CancellationToken2.isCancellationToken = isCancellationToken;
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: shortcutEvent
        });
      })(CancellationToken || (CancellationToken = {}));
      MutableToken = class {
        constructor() {
          this._isCancelled = false;
          this._emitter = null;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
          }
        }
      };
      CancellationTokenSource = class {
        constructor(parent) {
          this._token = void 0;
          this._parentListener = void 0;
          this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
        }
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else if (this._token instanceof MutableToken) {
            this._token.cancel();
          }
        }
        dispose(cancel = false) {
          if (cancel) {
            this.cancel();
          }
          if (this._parentListener) {
            this._parentListener.dispose();
          }
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }
  var KeyCodeStrMap, uiMap, userSettingsUSMap, userSettingsGeneralMap, EVENT_KEY_CODE_MAP, NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE, scanCodeIntToStr, scanCodeStrToInt, scanCodeLowerCaseStrToInt, IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, KeyCodeUtils;
  var init_keyCodes = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js"() {
      KeyCodeStrMap = class {
        constructor() {
          this._keyCodeToStr = [];
          this._strToKeyCode = /* @__PURE__ */ Object.create(null);
        }
        define(keyCode, str) {
          this._keyCodeToStr[keyCode] = str;
          this._strToKeyCode[str.toLowerCase()] = keyCode;
        }
        keyCodeToStr(keyCode) {
          return this._keyCodeToStr[keyCode];
        }
        strToKeyCode(str) {
          return this._strToKeyCode[str.toLowerCase()] || 0;
        }
      };
      uiMap = new KeyCodeStrMap();
      userSettingsUSMap = new KeyCodeStrMap();
      userSettingsGeneralMap = new KeyCodeStrMap();
      EVENT_KEY_CODE_MAP = new Array(230);
      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
      scanCodeIntToStr = [];
      scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
      scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
      IMMUTABLE_CODE_TO_KEY_CODE = [];
      IMMUTABLE_KEY_CODE_TO_CODE = [];
      for (let i = 0; i <= 193; i++) {
        IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
      }
      for (let i = 0; i <= 127; i++) {
        IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
      }
      (function() {
        const empty = "";
        const mappings = [
          [0, 1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
          [0, 1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
          [0, 1, 2, "Super", 0, empty, 0, empty, empty, empty],
          [0, 1, 3, "Fn", 0, empty, 0, empty, empty, empty],
          [0, 1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
          [0, 1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
          [0, 1, 6, "Resume", 0, empty, 0, empty, empty, empty],
          [0, 1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
          [0, 1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
          [0, 1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
          [31, 0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
          [32, 0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
          [33, 0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
          [34, 0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
          [35, 0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
          [36, 0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
          [37, 0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
          [38, 0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
          [39, 0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
          [40, 0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
          [41, 0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
          [42, 0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
          [43, 0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
          [44, 0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
          [45, 0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
          [46, 0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
          [47, 0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
          [48, 0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
          [49, 0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
          [50, 0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
          [51, 0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
          [52, 0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
          [53, 0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
          [54, 0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
          [55, 0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
          [56, 0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
          [22, 0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
          [23, 0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
          [24, 0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
          [25, 0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
          [26, 0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
          [27, 0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
          [28, 0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
          [29, 0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
          [30, 0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
          [21, 0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
          [3, 1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
          [9, 1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
          [1, 1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
          [2, 1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
          [10, 1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
          [83, 0, 51, "Minus", 83, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
          [81, 0, 52, "Equal", 81, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
          [87, 0, 53, "BracketLeft", 87, "[", 219, "VK_OEM_4", "[", "OEM_4"],
          [89, 0, 54, "BracketRight", 89, "]", 221, "VK_OEM_6", "]", "OEM_6"],
          [88, 0, 55, "Backslash", 88, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
          [0, 0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
          [80, 0, 57, "Semicolon", 80, ";", 186, "VK_OEM_1", ";", "OEM_1"],
          [90, 0, 58, "Quote", 90, "'", 222, "VK_OEM_7", "'", "OEM_7"],
          [86, 0, 59, "Backquote", 86, "`", 192, "VK_OEM_3", "`", "OEM_3"],
          [82, 0, 60, "Comma", 82, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
          [84, 0, 61, "Period", 84, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
          [85, 0, 62, "Slash", 85, "/", 191, "VK_OEM_2", "/", "OEM_2"],
          [8, 1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
          [59, 1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
          [60, 1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
          [61, 1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
          [62, 1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
          [63, 1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
          [64, 1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
          [65, 1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
          [66, 1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
          [67, 1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
          [68, 1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
          [69, 1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
          [70, 1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
          [0, 1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
          [79, 1, 77, "ScrollLock", 79, "ScrollLock", 145, "VK_SCROLL", empty, empty],
          [7, 1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
          [19, 1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
          [14, 1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
          [11, 1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
          [20, 1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
          [13, 1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
          [12, 1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
          [17, 1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
          [15, 1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
          [18, 1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
          [16, 1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
          [78, 1, 89, "NumLock", 78, "NumLock", 144, "VK_NUMLOCK", empty, empty],
          [108, 1, 90, "NumpadDivide", 108, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
          [103, 1, 91, "NumpadMultiply", 103, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
          [106, 1, 92, "NumpadSubtract", 106, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
          [104, 1, 93, "NumpadAdd", 104, "NumPad_Add", 107, "VK_ADD", empty, empty],
          [3, 1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
          [94, 1, 95, "Numpad1", 94, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
          [95, 1, 96, "Numpad2", 95, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
          [96, 1, 97, "Numpad3", 96, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
          [97, 1, 98, "Numpad4", 97, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
          [98, 1, 99, "Numpad5", 98, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
          [99, 1, 100, "Numpad6", 99, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
          [100, 1, 101, "Numpad7", 100, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
          [101, 1, 102, "Numpad8", 101, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
          [102, 1, 103, "Numpad9", 102, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
          [93, 1, 104, "Numpad0", 93, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
          [107, 1, 105, "NumpadDecimal", 107, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
          [92, 0, 106, "IntlBackslash", 92, "OEM_102", 226, "VK_OEM_102", empty, empty],
          [58, 1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
          [0, 1, 108, "Power", 0, empty, 0, empty, empty, empty],
          [0, 1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
          [71, 1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
          [72, 1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
          [73, 1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
          [74, 1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
          [75, 1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
          [76, 1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
          [77, 1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
          [0, 1, 117, "F20", 0, empty, 0, "VK_F20", empty, empty],
          [0, 1, 118, "F21", 0, empty, 0, "VK_F21", empty, empty],
          [0, 1, 119, "F22", 0, empty, 0, "VK_F22", empty, empty],
          [0, 1, 120, "F23", 0, empty, 0, "VK_F23", empty, empty],
          [0, 1, 121, "F24", 0, empty, 0, "VK_F24", empty, empty],
          [0, 1, 122, "Open", 0, empty, 0, empty, empty, empty],
          [0, 1, 123, "Help", 0, empty, 0, empty, empty, empty],
          [0, 1, 124, "Select", 0, empty, 0, empty, empty, empty],
          [0, 1, 125, "Again", 0, empty, 0, empty, empty, empty],
          [0, 1, 126, "Undo", 0, empty, 0, empty, empty, empty],
          [0, 1, 127, "Cut", 0, empty, 0, empty, empty, empty],
          [0, 1, 128, "Copy", 0, empty, 0, empty, empty, empty],
          [0, 1, 129, "Paste", 0, empty, 0, empty, empty, empty],
          [0, 1, 130, "Find", 0, empty, 0, empty, empty, empty],
          [0, 1, 131, "AudioVolumeMute", 112, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
          [0, 1, 132, "AudioVolumeUp", 113, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
          [0, 1, 133, "AudioVolumeDown", 114, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
          [105, 1, 134, "NumpadComma", 105, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
          [110, 0, 135, "IntlRo", 110, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
          [0, 1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
          [0, 0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
          [0, 1, 138, "Convert", 0, empty, 0, empty, empty, empty],
          [0, 1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
          [0, 1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
          [0, 1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
          [0, 1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
          [0, 1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
          [0, 1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
          [0, 1, 145, "Abort", 0, empty, 0, empty, empty, empty],
          [0, 1, 146, "Props", 0, empty, 0, empty, empty, empty],
          [0, 1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
          [0, 1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
          [0, 1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
          [0, 1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
          [0, 1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
          [0, 1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
          [0, 1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
          [0, 1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
          [0, 1, 155, "NumpadClear", 126, "Clear", 12, "VK_CLEAR", empty, empty],
          [0, 1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
          [5, 1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
          [4, 1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
          [6, 1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
          [57, 1, 0, empty, 57, "Meta", 0, "VK_COMMAND", empty, empty],
          [5, 1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
          [4, 1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
          [6, 1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
          [57, 1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
          [5, 1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
          [4, 1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
          [6, 1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
          [57, 1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
          [0, 1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
          [0, 1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
          [0, 1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
          [0, 1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
          [0, 1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
          [0, 1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
          [114, 1, 171, "MediaTrackNext", 119, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
          [115, 1, 172, "MediaTrackPrevious", 120, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
          [116, 1, 173, "MediaStop", 121, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
          [0, 1, 174, "Eject", 0, empty, 0, empty, empty, empty],
          [117, 1, 175, "MediaPlayPause", 122, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
          [0, 1, 176, "MediaSelect", 123, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
          [0, 1, 177, "LaunchMail", 124, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
          [0, 1, 178, "LaunchApp2", 125, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
          [0, 1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
          [0, 1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
          [0, 1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
          [0, 1, 182, "BrowserSearch", 115, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
          [0, 1, 183, "BrowserHome", 116, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
          [112, 1, 184, "BrowserBack", 117, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
          [113, 1, 185, "BrowserForward", 118, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
          [0, 1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
          [0, 1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
          [0, 1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
          [0, 1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
          [0, 1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
          [0, 1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
          [0, 1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
          [109, 1, 0, empty, 109, "KeyInComposition", 229, empty, empty, empty],
          [111, 1, 0, empty, 111, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
          [91, 1, 0, empty, 91, "OEM_8", 223, "VK_OEM_8", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
        ];
        let seenKeyCode = [];
        let seenScanCode = [];
        for (const mapping of mappings) {
          const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
          if (!seenScanCode[scanCode]) {
            seenScanCode[scanCode] = true;
            scanCodeIntToStr[scanCode] = scanCodeStr;
            scanCodeStrToInt[scanCodeStr] = scanCode;
            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
            if (immutable) {
              IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
              if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
                IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
              }
            }
          }
          if (!seenKeyCode[keyCode]) {
            seenKeyCode[keyCode] = true;
            if (!keyCodeStr) {
              throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
            }
            uiMap.define(keyCode, keyCodeStr);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
          }
          if (eventKeyCode) {
            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
          }
          if (vkey) {
            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
          }
        }
        IMMUTABLE_KEY_CODE_TO_CODE[3] = 46;
      })();
      (function(KeyCodeUtils2) {
        function toString(keyCode) {
          return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toString = toString;
        function fromString(key) {
          return uiMap.strToKeyCode(key);
        }
        KeyCodeUtils2.fromString = fromString;
        function toUserSettingsUS(keyCode) {
          return userSettingsUSMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
        function toUserSettingsGeneral(keyCode) {
          return userSettingsGeneralMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
        function fromUserSettings(key) {
          return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
        }
        KeyCodeUtils2.fromUserSettings = fromUserSettings;
        function toElectronAccelerator(keyCode) {
          if (keyCode >= 93 && keyCode <= 108) {
            return null;
          }
          switch (keyCode) {
            case 16:
              return "Up";
            case 18:
              return "Down";
            case 15:
              return "Left";
            case 17:
              return "Right";
          }
          return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
      })(KeyCodeUtils || (KeyCodeUtils = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection;
  var init_selection = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js"() {
      init_position();
      init_range();
      Selection = class extends Range {
        constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
          super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
          this.selectionStartLineNumber = selectionStartLineNumber;
          this.selectionStartColumn = selectionStartColumn;
          this.positionLineNumber = positionLineNumber;
          this.positionColumn = positionColumn;
        }
        toString() {
          return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
        }
        equalsSelection(other) {
          return Selection.selectionsEqual(this, other);
        }
        static selectionsEqual(a, b) {
          return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
        }
        getDirection() {
          if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0;
          }
          return 1;
        }
        setEndPosition(endLineNumber, endColumn) {
          if (this.getDirection() === 0) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
          }
          return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        }
        getPosition() {
          return new Position(this.positionLineNumber, this.positionColumn);
        }
        getSelectionStart() {
          return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
        }
        setStartPosition(startLineNumber, startColumn) {
          if (this.getDirection() === 0) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
          }
          return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        }
        static fromPositions(start, end = start) {
          return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        static fromRange(range, direction) {
          if (direction === 0) {
            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
          } else {
            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
          }
        }
        static liftSelection(sel) {
          return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        }
        static selectionsArrEqual(a, b) {
          if (a && !b || !a && b) {
            return false;
          }
          if (!a && !b) {
            return true;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
        static isISelection(obj) {
          return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
        }
        static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
          if (direction === 0) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
          }
          return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var __awaiter, TokenizationRegistry, TokenizationSupportFactoryData;
  var init_tokenizationRegistry = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js"() {
      init_event();
      init_lifecycle();
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      TokenizationRegistry = class {
        constructor() {
          this._map = /* @__PURE__ */ new Map();
          this._factories = /* @__PURE__ */ new Map();
          this._onDidChange = new Emitter();
          this.onDidChange = this._onDidChange.event;
          this._colorMap = null;
        }
        fire(languages) {
          this._onDidChange.fire({
            changedLanguages: languages,
            changedColorMap: false
          });
        }
        register(language, support) {
          this._map.set(language, support);
          this.fire([language]);
          return toDisposable(() => {
            if (this._map.get(language) !== support) {
              return;
            }
            this._map.delete(language);
            this.fire([language]);
          });
        }
        registerFactory(languageId, factory) {
          var _a3;
          (_a3 = this._factories.get(languageId)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
          const myData = new TokenizationSupportFactoryData(this, languageId, factory);
          this._factories.set(languageId, myData);
          return toDisposable(() => {
            const v = this._factories.get(languageId);
            if (!v || v !== myData) {
              return;
            }
            this._factories.delete(languageId);
            v.dispose();
          });
        }
        getOrCreate(languageId) {
          return __awaiter(this, void 0, void 0, function* () {
            const tokenizationSupport = this.get(languageId);
            if (tokenizationSupport) {
              return tokenizationSupport;
            }
            const factory = this._factories.get(languageId);
            if (!factory || factory.isResolved) {
              return null;
            }
            yield factory.resolve();
            return this.get(languageId);
          });
        }
        get(language) {
          return this._map.get(language) || null;
        }
        isResolved(languageId) {
          const tokenizationSupport = this.get(languageId);
          if (tokenizationSupport) {
            return true;
          }
          const factory = this._factories.get(languageId);
          if (!factory || factory.isResolved) {
            return true;
          }
          return false;
        }
        setColorMap(colorMap) {
          this._colorMap = colorMap;
          this._onDidChange.fire({
            changedLanguages: Array.from(this._map.keys()),
            changedColorMap: true
          });
        }
        getColorMap() {
          return this._colorMap;
        }
        getDefaultBackground() {
          if (this._colorMap && this._colorMap.length > 2) {
            return this._colorMap[2];
          }
          return null;
        }
      };
      TokenizationSupportFactoryData = class extends Disposable {
        constructor(_registry, _languageId, _factory) {
          super();
          this._registry = _registry;
          this._languageId = _languageId;
          this._factory = _factory;
          this._isDisposed = false;
          this._resolvePromise = null;
          this._isResolved = false;
        }
        get isResolved() {
          return this._isResolved;
        }
        dispose() {
          this._isDisposed = true;
          super.dispose();
        }
        resolve() {
          return __awaiter(this, void 0, void 0, function* () {
            if (!this._resolvePromise) {
              this._resolvePromise = this._create();
            }
            return this._resolvePromise;
          });
        }
        _create() {
          return __awaiter(this, void 0, void 0, function* () {
            const value = yield Promise.resolve(this._factory.createTokenizationSupport());
            this._isResolved = true;
            if (value && !this._isDisposed) {
              this._register(this._registry.register(this._languageId, value));
            }
          });
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js
  var Codicon, CSSIcon;
  var init_codicons = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js"() {
      Codicon = class {
        constructor(id, definition, description) {
          this.id = id;
          this.definition = definition;
          this.description = description;
          Codicon._allCodicons.push(this);
        }
        get classNames() {
          return "codicon codicon-" + this.id;
        }
        get classNamesArray() {
          return ["codicon", "codicon-" + this.id];
        }
        get cssSelector() {
          return ".codicon.codicon-" + this.id;
        }
        static getAll() {
          return Codicon._allCodicons;
        }
      };
      Codicon._allCodicons = [];
      Codicon.add = new Codicon("add", { fontCharacter: "\\ea60" });
      Codicon.plus = new Codicon("plus", Codicon.add.definition);
      Codicon.gistNew = new Codicon("gist-new", Codicon.add.definition);
      Codicon.repoCreate = new Codicon("repo-create", Codicon.add.definition);
      Codicon.lightbulb = new Codicon("lightbulb", { fontCharacter: "\\ea61" });
      Codicon.lightBulb = new Codicon("light-bulb", { fontCharacter: "\\ea61" });
      Codicon.repo = new Codicon("repo", { fontCharacter: "\\ea62" });
      Codicon.repoDelete = new Codicon("repo-delete", { fontCharacter: "\\ea62" });
      Codicon.gistFork = new Codicon("gist-fork", { fontCharacter: "\\ea63" });
      Codicon.repoForked = new Codicon("repo-forked", { fontCharacter: "\\ea63" });
      Codicon.gitPullRequest = new Codicon("git-pull-request", { fontCharacter: "\\ea64" });
      Codicon.gitPullRequestAbandoned = new Codicon("git-pull-request-abandoned", { fontCharacter: "\\ea64" });
      Codicon.recordKeys = new Codicon("record-keys", { fontCharacter: "\\ea65" });
      Codicon.keyboard = new Codicon("keyboard", { fontCharacter: "\\ea65" });
      Codicon.tag = new Codicon("tag", { fontCharacter: "\\ea66" });
      Codicon.tagAdd = new Codicon("tag-add", { fontCharacter: "\\ea66" });
      Codicon.tagRemove = new Codicon("tag-remove", { fontCharacter: "\\ea66" });
      Codicon.person = new Codicon("person", { fontCharacter: "\\ea67" });
      Codicon.personFollow = new Codicon("person-follow", { fontCharacter: "\\ea67" });
      Codicon.personOutline = new Codicon("person-outline", { fontCharacter: "\\ea67" });
      Codicon.personFilled = new Codicon("person-filled", { fontCharacter: "\\ea67" });
      Codicon.gitBranch = new Codicon("git-branch", { fontCharacter: "\\ea68" });
      Codicon.gitBranchCreate = new Codicon("git-branch-create", { fontCharacter: "\\ea68" });
      Codicon.gitBranchDelete = new Codicon("git-branch-delete", { fontCharacter: "\\ea68" });
      Codicon.sourceControl = new Codicon("source-control", { fontCharacter: "\\ea68" });
      Codicon.mirror = new Codicon("mirror", { fontCharacter: "\\ea69" });
      Codicon.mirrorPublic = new Codicon("mirror-public", { fontCharacter: "\\ea69" });
      Codicon.star = new Codicon("star", { fontCharacter: "\\ea6a" });
      Codicon.starAdd = new Codicon("star-add", { fontCharacter: "\\ea6a" });
      Codicon.starDelete = new Codicon("star-delete", { fontCharacter: "\\ea6a" });
      Codicon.starEmpty = new Codicon("star-empty", { fontCharacter: "\\ea6a" });
      Codicon.comment = new Codicon("comment", { fontCharacter: "\\ea6b" });
      Codicon.commentAdd = new Codicon("comment-add", { fontCharacter: "\\ea6b" });
      Codicon.alert = new Codicon("alert", { fontCharacter: "\\ea6c" });
      Codicon.warning = new Codicon("warning", { fontCharacter: "\\ea6c" });
      Codicon.search = new Codicon("search", { fontCharacter: "\\ea6d" });
      Codicon.searchSave = new Codicon("search-save", { fontCharacter: "\\ea6d" });
      Codicon.logOut = new Codicon("log-out", { fontCharacter: "\\ea6e" });
      Codicon.signOut = new Codicon("sign-out", { fontCharacter: "\\ea6e" });
      Codicon.logIn = new Codicon("log-in", { fontCharacter: "\\ea6f" });
      Codicon.signIn = new Codicon("sign-in", { fontCharacter: "\\ea6f" });
      Codicon.eye = new Codicon("eye", { fontCharacter: "\\ea70" });
      Codicon.eyeUnwatch = new Codicon("eye-unwatch", { fontCharacter: "\\ea70" });
      Codicon.eyeWatch = new Codicon("eye-watch", { fontCharacter: "\\ea70" });
      Codicon.circleFilled = new Codicon("circle-filled", { fontCharacter: "\\ea71" });
      Codicon.primitiveDot = new Codicon("primitive-dot", { fontCharacter: "\\ea71" });
      Codicon.closeDirty = new Codicon("close-dirty", { fontCharacter: "\\ea71" });
      Codicon.debugBreakpoint = new Codicon("debug-breakpoint", { fontCharacter: "\\ea71" });
      Codicon.debugBreakpointDisabled = new Codicon("debug-breakpoint-disabled", { fontCharacter: "\\ea71" });
      Codicon.debugHint = new Codicon("debug-hint", { fontCharacter: "\\ea71" });
      Codicon.primitiveSquare = new Codicon("primitive-square", { fontCharacter: "\\ea72" });
      Codicon.edit = new Codicon("edit", { fontCharacter: "\\ea73" });
      Codicon.pencil = new Codicon("pencil", { fontCharacter: "\\ea73" });
      Codicon.info = new Codicon("info", { fontCharacter: "\\ea74" });
      Codicon.issueOpened = new Codicon("issue-opened", { fontCharacter: "\\ea74" });
      Codicon.gistPrivate = new Codicon("gist-private", { fontCharacter: "\\ea75" });
      Codicon.gitForkPrivate = new Codicon("git-fork-private", { fontCharacter: "\\ea75" });
      Codicon.lock = new Codicon("lock", { fontCharacter: "\\ea75" });
      Codicon.mirrorPrivate = new Codicon("mirror-private", { fontCharacter: "\\ea75" });
      Codicon.close = new Codicon("close", { fontCharacter: "\\ea76" });
      Codicon.removeClose = new Codicon("remove-close", { fontCharacter: "\\ea76" });
      Codicon.x = new Codicon("x", { fontCharacter: "\\ea76" });
      Codicon.repoSync = new Codicon("repo-sync", { fontCharacter: "\\ea77" });
      Codicon.sync = new Codicon("sync", { fontCharacter: "\\ea77" });
      Codicon.clone = new Codicon("clone", { fontCharacter: "\\ea78" });
      Codicon.desktopDownload = new Codicon("desktop-download", { fontCharacter: "\\ea78" });
      Codicon.beaker = new Codicon("beaker", { fontCharacter: "\\ea79" });
      Codicon.microscope = new Codicon("microscope", { fontCharacter: "\\ea79" });
      Codicon.vm = new Codicon("vm", { fontCharacter: "\\ea7a" });
      Codicon.deviceDesktop = new Codicon("device-desktop", { fontCharacter: "\\ea7a" });
      Codicon.file = new Codicon("file", { fontCharacter: "\\ea7b" });
      Codicon.fileText = new Codicon("file-text", { fontCharacter: "\\ea7b" });
      Codicon.more = new Codicon("more", { fontCharacter: "\\ea7c" });
      Codicon.ellipsis = new Codicon("ellipsis", { fontCharacter: "\\ea7c" });
      Codicon.kebabHorizontal = new Codicon("kebab-horizontal", { fontCharacter: "\\ea7c" });
      Codicon.mailReply = new Codicon("mail-reply", { fontCharacter: "\\ea7d" });
      Codicon.reply = new Codicon("reply", { fontCharacter: "\\ea7d" });
      Codicon.organization = new Codicon("organization", { fontCharacter: "\\ea7e" });
      Codicon.organizationFilled = new Codicon("organization-filled", { fontCharacter: "\\ea7e" });
      Codicon.organizationOutline = new Codicon("organization-outline", { fontCharacter: "\\ea7e" });
      Codicon.newFile = new Codicon("new-file", { fontCharacter: "\\ea7f" });
      Codicon.fileAdd = new Codicon("file-add", { fontCharacter: "\\ea7f" });
      Codicon.newFolder = new Codicon("new-folder", { fontCharacter: "\\ea80" });
      Codicon.fileDirectoryCreate = new Codicon("file-directory-create", { fontCharacter: "\\ea80" });
      Codicon.trash = new Codicon("trash", { fontCharacter: "\\ea81" });
      Codicon.trashcan = new Codicon("trashcan", { fontCharacter: "\\ea81" });
      Codicon.history = new Codicon("history", { fontCharacter: "\\ea82" });
      Codicon.clock = new Codicon("clock", { fontCharacter: "\\ea82" });
      Codicon.folder = new Codicon("folder", { fontCharacter: "\\ea83" });
      Codicon.fileDirectory = new Codicon("file-directory", { fontCharacter: "\\ea83" });
      Codicon.symbolFolder = new Codicon("symbol-folder", { fontCharacter: "\\ea83" });
      Codicon.logoGithub = new Codicon("logo-github", { fontCharacter: "\\ea84" });
      Codicon.markGithub = new Codicon("mark-github", { fontCharacter: "\\ea84" });
      Codicon.github = new Codicon("github", { fontCharacter: "\\ea84" });
      Codicon.terminal = new Codicon("terminal", { fontCharacter: "\\ea85" });
      Codicon.console = new Codicon("console", { fontCharacter: "\\ea85" });
      Codicon.repl = new Codicon("repl", { fontCharacter: "\\ea85" });
      Codicon.zap = new Codicon("zap", { fontCharacter: "\\ea86" });
      Codicon.symbolEvent = new Codicon("symbol-event", { fontCharacter: "\\ea86" });
      Codicon.error = new Codicon("error", { fontCharacter: "\\ea87" });
      Codicon.stop = new Codicon("stop", { fontCharacter: "\\ea87" });
      Codicon.variable = new Codicon("variable", { fontCharacter: "\\ea88" });
      Codicon.symbolVariable = new Codicon("symbol-variable", { fontCharacter: "\\ea88" });
      Codicon.array = new Codicon("array", { fontCharacter: "\\ea8a" });
      Codicon.symbolArray = new Codicon("symbol-array", { fontCharacter: "\\ea8a" });
      Codicon.symbolModule = new Codicon("symbol-module", { fontCharacter: "\\ea8b" });
      Codicon.symbolPackage = new Codicon("symbol-package", { fontCharacter: "\\ea8b" });
      Codicon.symbolNamespace = new Codicon("symbol-namespace", { fontCharacter: "\\ea8b" });
      Codicon.symbolObject = new Codicon("symbol-object", { fontCharacter: "\\ea8b" });
      Codicon.symbolMethod = new Codicon("symbol-method", { fontCharacter: "\\ea8c" });
      Codicon.symbolFunction = new Codicon("symbol-function", { fontCharacter: "\\ea8c" });
      Codicon.symbolConstructor = new Codicon("symbol-constructor", { fontCharacter: "\\ea8c" });
      Codicon.symbolBoolean = new Codicon("symbol-boolean", { fontCharacter: "\\ea8f" });
      Codicon.symbolNull = new Codicon("symbol-null", { fontCharacter: "\\ea8f" });
      Codicon.symbolNumeric = new Codicon("symbol-numeric", { fontCharacter: "\\ea90" });
      Codicon.symbolNumber = new Codicon("symbol-number", { fontCharacter: "\\ea90" });
      Codicon.symbolStructure = new Codicon("symbol-structure", { fontCharacter: "\\ea91" });
      Codicon.symbolStruct = new Codicon("symbol-struct", { fontCharacter: "\\ea91" });
      Codicon.symbolParameter = new Codicon("symbol-parameter", { fontCharacter: "\\ea92" });
      Codicon.symbolTypeParameter = new Codicon("symbol-type-parameter", { fontCharacter: "\\ea92" });
      Codicon.symbolKey = new Codicon("symbol-key", { fontCharacter: "\\ea93" });
      Codicon.symbolText = new Codicon("symbol-text", { fontCharacter: "\\ea93" });
      Codicon.symbolReference = new Codicon("symbol-reference", { fontCharacter: "\\ea94" });
      Codicon.goToFile = new Codicon("go-to-file", { fontCharacter: "\\ea94" });
      Codicon.symbolEnum = new Codicon("symbol-enum", { fontCharacter: "\\ea95" });
      Codicon.symbolValue = new Codicon("symbol-value", { fontCharacter: "\\ea95" });
      Codicon.symbolRuler = new Codicon("symbol-ruler", { fontCharacter: "\\ea96" });
      Codicon.symbolUnit = new Codicon("symbol-unit", { fontCharacter: "\\ea96" });
      Codicon.activateBreakpoints = new Codicon("activate-breakpoints", { fontCharacter: "\\ea97" });
      Codicon.archive = new Codicon("archive", { fontCharacter: "\\ea98" });
      Codicon.arrowBoth = new Codicon("arrow-both", { fontCharacter: "\\ea99" });
      Codicon.arrowDown = new Codicon("arrow-down", { fontCharacter: "\\ea9a" });
      Codicon.arrowLeft = new Codicon("arrow-left", { fontCharacter: "\\ea9b" });
      Codicon.arrowRight = new Codicon("arrow-right", { fontCharacter: "\\ea9c" });
      Codicon.arrowSmallDown = new Codicon("arrow-small-down", { fontCharacter: "\\ea9d" });
      Codicon.arrowSmallLeft = new Codicon("arrow-small-left", { fontCharacter: "\\ea9e" });
      Codicon.arrowSmallRight = new Codicon("arrow-small-right", { fontCharacter: "\\ea9f" });
      Codicon.arrowSmallUp = new Codicon("arrow-small-up", { fontCharacter: "\\eaa0" });
      Codicon.arrowUp = new Codicon("arrow-up", { fontCharacter: "\\eaa1" });
      Codicon.bell = new Codicon("bell", { fontCharacter: "\\eaa2" });
      Codicon.bold = new Codicon("bold", { fontCharacter: "\\eaa3" });
      Codicon.book = new Codicon("book", { fontCharacter: "\\eaa4" });
      Codicon.bookmark = new Codicon("bookmark", { fontCharacter: "\\eaa5" });
      Codicon.debugBreakpointConditionalUnverified = new Codicon("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" });
      Codicon.debugBreakpointConditional = new Codicon("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" });
      Codicon.debugBreakpointConditionalDisabled = new Codicon("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" });
      Codicon.debugBreakpointDataUnverified = new Codicon("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" });
      Codicon.debugBreakpointData = new Codicon("debug-breakpoint-data", { fontCharacter: "\\eaa9" });
      Codicon.debugBreakpointDataDisabled = new Codicon("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" });
      Codicon.debugBreakpointLogUnverified = new Codicon("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" });
      Codicon.debugBreakpointLog = new Codicon("debug-breakpoint-log", { fontCharacter: "\\eaab" });
      Codicon.debugBreakpointLogDisabled = new Codicon("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" });
      Codicon.briefcase = new Codicon("briefcase", { fontCharacter: "\\eaac" });
      Codicon.broadcast = new Codicon("broadcast", { fontCharacter: "\\eaad" });
      Codicon.browser = new Codicon("browser", { fontCharacter: "\\eaae" });
      Codicon.bug = new Codicon("bug", { fontCharacter: "\\eaaf" });
      Codicon.calendar = new Codicon("calendar", { fontCharacter: "\\eab0" });
      Codicon.caseSensitive = new Codicon("case-sensitive", { fontCharacter: "\\eab1" });
      Codicon.check = new Codicon("check", { fontCharacter: "\\eab2" });
      Codicon.checklist = new Codicon("checklist", { fontCharacter: "\\eab3" });
      Codicon.chevronDown = new Codicon("chevron-down", { fontCharacter: "\\eab4" });
      Codicon.dropDownButton = new Codicon("drop-down-button", Codicon.chevronDown.definition);
      Codicon.chevronLeft = new Codicon("chevron-left", { fontCharacter: "\\eab5" });
      Codicon.chevronRight = new Codicon("chevron-right", { fontCharacter: "\\eab6" });
      Codicon.chevronUp = new Codicon("chevron-up", { fontCharacter: "\\eab7" });
      Codicon.chromeClose = new Codicon("chrome-close", { fontCharacter: "\\eab8" });
      Codicon.chromeMaximize = new Codicon("chrome-maximize", { fontCharacter: "\\eab9" });
      Codicon.chromeMinimize = new Codicon("chrome-minimize", { fontCharacter: "\\eaba" });
      Codicon.chromeRestore = new Codicon("chrome-restore", { fontCharacter: "\\eabb" });
      Codicon.circleOutline = new Codicon("circle-outline", { fontCharacter: "\\eabc" });
      Codicon.debugBreakpointUnverified = new Codicon("debug-breakpoint-unverified", { fontCharacter: "\\eabc" });
      Codicon.circleSlash = new Codicon("circle-slash", { fontCharacter: "\\eabd" });
      Codicon.circuitBoard = new Codicon("circuit-board", { fontCharacter: "\\eabe" });
      Codicon.clearAll = new Codicon("clear-all", { fontCharacter: "\\eabf" });
      Codicon.clippy = new Codicon("clippy", { fontCharacter: "\\eac0" });
      Codicon.closeAll = new Codicon("close-all", { fontCharacter: "\\eac1" });
      Codicon.cloudDownload = new Codicon("cloud-download", { fontCharacter: "\\eac2" });
      Codicon.cloudUpload = new Codicon("cloud-upload", { fontCharacter: "\\eac3" });
      Codicon.code = new Codicon("code", { fontCharacter: "\\eac4" });
      Codicon.collapseAll = new Codicon("collapse-all", { fontCharacter: "\\eac5" });
      Codicon.colorMode = new Codicon("color-mode", { fontCharacter: "\\eac6" });
      Codicon.commentDiscussion = new Codicon("comment-discussion", { fontCharacter: "\\eac7" });
      Codicon.compareChanges = new Codicon("compare-changes", { fontCharacter: "\\eafd" });
      Codicon.creditCard = new Codicon("credit-card", { fontCharacter: "\\eac9" });
      Codicon.dash = new Codicon("dash", { fontCharacter: "\\eacc" });
      Codicon.dashboard = new Codicon("dashboard", { fontCharacter: "\\eacd" });
      Codicon.database = new Codicon("database", { fontCharacter: "\\eace" });
      Codicon.debugContinue = new Codicon("debug-continue", { fontCharacter: "\\eacf" });
      Codicon.debugDisconnect = new Codicon("debug-disconnect", { fontCharacter: "\\ead0" });
      Codicon.debugPause = new Codicon("debug-pause", { fontCharacter: "\\ead1" });
      Codicon.debugRestart = new Codicon("debug-restart", { fontCharacter: "\\ead2" });
      Codicon.debugStart = new Codicon("debug-start", { fontCharacter: "\\ead3" });
      Codicon.debugStepInto = new Codicon("debug-step-into", { fontCharacter: "\\ead4" });
      Codicon.debugStepOut = new Codicon("debug-step-out", { fontCharacter: "\\ead5" });
      Codicon.debugStepOver = new Codicon("debug-step-over", { fontCharacter: "\\ead6" });
      Codicon.debugStop = new Codicon("debug-stop", { fontCharacter: "\\ead7" });
      Codicon.debug = new Codicon("debug", { fontCharacter: "\\ead8" });
      Codicon.deviceCameraVideo = new Codicon("device-camera-video", { fontCharacter: "\\ead9" });
      Codicon.deviceCamera = new Codicon("device-camera", { fontCharacter: "\\eada" });
      Codicon.deviceMobile = new Codicon("device-mobile", { fontCharacter: "\\eadb" });
      Codicon.diffAdded = new Codicon("diff-added", { fontCharacter: "\\eadc" });
      Codicon.diffIgnored = new Codicon("diff-ignored", { fontCharacter: "\\eadd" });
      Codicon.diffModified = new Codicon("diff-modified", { fontCharacter: "\\eade" });
      Codicon.diffRemoved = new Codicon("diff-removed", { fontCharacter: "\\eadf" });
      Codicon.diffRenamed = new Codicon("diff-renamed", { fontCharacter: "\\eae0" });
      Codicon.diff = new Codicon("diff", { fontCharacter: "\\eae1" });
      Codicon.discard = new Codicon("discard", { fontCharacter: "\\eae2" });
      Codicon.editorLayout = new Codicon("editor-layout", { fontCharacter: "\\eae3" });
      Codicon.emptyWindow = new Codicon("empty-window", { fontCharacter: "\\eae4" });
      Codicon.exclude = new Codicon("exclude", { fontCharacter: "\\eae5" });
      Codicon.extensions = new Codicon("extensions", { fontCharacter: "\\eae6" });
      Codicon.eyeClosed = new Codicon("eye-closed", { fontCharacter: "\\eae7" });
      Codicon.fileBinary = new Codicon("file-binary", { fontCharacter: "\\eae8" });
      Codicon.fileCode = new Codicon("file-code", { fontCharacter: "\\eae9" });
      Codicon.fileMedia = new Codicon("file-media", { fontCharacter: "\\eaea" });
      Codicon.filePdf = new Codicon("file-pdf", { fontCharacter: "\\eaeb" });
      Codicon.fileSubmodule = new Codicon("file-submodule", { fontCharacter: "\\eaec" });
      Codicon.fileSymlinkDirectory = new Codicon("file-symlink-directory", { fontCharacter: "\\eaed" });
      Codicon.fileSymlinkFile = new Codicon("file-symlink-file", { fontCharacter: "\\eaee" });
      Codicon.fileZip = new Codicon("file-zip", { fontCharacter: "\\eaef" });
      Codicon.files = new Codicon("files", { fontCharacter: "\\eaf0" });
      Codicon.filter = new Codicon("filter", { fontCharacter: "\\eaf1" });
      Codicon.flame = new Codicon("flame", { fontCharacter: "\\eaf2" });
      Codicon.foldDown = new Codicon("fold-down", { fontCharacter: "\\eaf3" });
      Codicon.foldUp = new Codicon("fold-up", { fontCharacter: "\\eaf4" });
      Codicon.fold = new Codicon("fold", { fontCharacter: "\\eaf5" });
      Codicon.folderActive = new Codicon("folder-active", { fontCharacter: "\\eaf6" });
      Codicon.folderOpened = new Codicon("folder-opened", { fontCharacter: "\\eaf7" });
      Codicon.gear = new Codicon("gear", { fontCharacter: "\\eaf8" });
      Codicon.gift = new Codicon("gift", { fontCharacter: "\\eaf9" });
      Codicon.gistSecret = new Codicon("gist-secret", { fontCharacter: "\\eafa" });
      Codicon.gist = new Codicon("gist", { fontCharacter: "\\eafb" });
      Codicon.gitCommit = new Codicon("git-commit", { fontCharacter: "\\eafc" });
      Codicon.gitCompare = new Codicon("git-compare", { fontCharacter: "\\eafd" });
      Codicon.gitMerge = new Codicon("git-merge", { fontCharacter: "\\eafe" });
      Codicon.githubAction = new Codicon("github-action", { fontCharacter: "\\eaff" });
      Codicon.githubAlt = new Codicon("github-alt", { fontCharacter: "\\eb00" });
      Codicon.globe = new Codicon("globe", { fontCharacter: "\\eb01" });
      Codicon.grabber = new Codicon("grabber", { fontCharacter: "\\eb02" });
      Codicon.graph = new Codicon("graph", { fontCharacter: "\\eb03" });
      Codicon.gripper = new Codicon("gripper", { fontCharacter: "\\eb04" });
      Codicon.heart = new Codicon("heart", { fontCharacter: "\\eb05" });
      Codicon.home = new Codicon("home", { fontCharacter: "\\eb06" });
      Codicon.horizontalRule = new Codicon("horizontal-rule", { fontCharacter: "\\eb07" });
      Codicon.hubot = new Codicon("hubot", { fontCharacter: "\\eb08" });
      Codicon.inbox = new Codicon("inbox", { fontCharacter: "\\eb09" });
      Codicon.issueClosed = new Codicon("issue-closed", { fontCharacter: "\\eba4" });
      Codicon.issueReopened = new Codicon("issue-reopened", { fontCharacter: "\\eb0b" });
      Codicon.issues = new Codicon("issues", { fontCharacter: "\\eb0c" });
      Codicon.italic = new Codicon("italic", { fontCharacter: "\\eb0d" });
      Codicon.jersey = new Codicon("jersey", { fontCharacter: "\\eb0e" });
      Codicon.json = new Codicon("json", { fontCharacter: "\\eb0f" });
      Codicon.kebabVertical = new Codicon("kebab-vertical", { fontCharacter: "\\eb10" });
      Codicon.key = new Codicon("key", { fontCharacter: "\\eb11" });
      Codicon.law = new Codicon("law", { fontCharacter: "\\eb12" });
      Codicon.lightbulbAutofix = new Codicon("lightbulb-autofix", { fontCharacter: "\\eb13" });
      Codicon.linkExternal = new Codicon("link-external", { fontCharacter: "\\eb14" });
      Codicon.link = new Codicon("link", { fontCharacter: "\\eb15" });
      Codicon.listOrdered = new Codicon("list-ordered", { fontCharacter: "\\eb16" });
      Codicon.listUnordered = new Codicon("list-unordered", { fontCharacter: "\\eb17" });
      Codicon.liveShare = new Codicon("live-share", { fontCharacter: "\\eb18" });
      Codicon.loading = new Codicon("loading", { fontCharacter: "\\eb19" });
      Codicon.location = new Codicon("location", { fontCharacter: "\\eb1a" });
      Codicon.mailRead = new Codicon("mail-read", { fontCharacter: "\\eb1b" });
      Codicon.mail = new Codicon("mail", { fontCharacter: "\\eb1c" });
      Codicon.markdown = new Codicon("markdown", { fontCharacter: "\\eb1d" });
      Codicon.megaphone = new Codicon("megaphone", { fontCharacter: "\\eb1e" });
      Codicon.mention = new Codicon("mention", { fontCharacter: "\\eb1f" });
      Codicon.milestone = new Codicon("milestone", { fontCharacter: "\\eb20" });
      Codicon.mortarBoard = new Codicon("mortar-board", { fontCharacter: "\\eb21" });
      Codicon.move = new Codicon("move", { fontCharacter: "\\eb22" });
      Codicon.multipleWindows = new Codicon("multiple-windows", { fontCharacter: "\\eb23" });
      Codicon.mute = new Codicon("mute", { fontCharacter: "\\eb24" });
      Codicon.noNewline = new Codicon("no-newline", { fontCharacter: "\\eb25" });
      Codicon.note = new Codicon("note", { fontCharacter: "\\eb26" });
      Codicon.octoface = new Codicon("octoface", { fontCharacter: "\\eb27" });
      Codicon.openPreview = new Codicon("open-preview", { fontCharacter: "\\eb28" });
      Codicon.package_ = new Codicon("package", { fontCharacter: "\\eb29" });
      Codicon.paintcan = new Codicon("paintcan", { fontCharacter: "\\eb2a" });
      Codicon.pin = new Codicon("pin", { fontCharacter: "\\eb2b" });
      Codicon.play = new Codicon("play", { fontCharacter: "\\eb2c" });
      Codicon.run = new Codicon("run", { fontCharacter: "\\eb2c" });
      Codicon.plug = new Codicon("plug", { fontCharacter: "\\eb2d" });
      Codicon.preserveCase = new Codicon("preserve-case", { fontCharacter: "\\eb2e" });
      Codicon.preview = new Codicon("preview", { fontCharacter: "\\eb2f" });
      Codicon.project = new Codicon("project", { fontCharacter: "\\eb30" });
      Codicon.pulse = new Codicon("pulse", { fontCharacter: "\\eb31" });
      Codicon.question = new Codicon("question", { fontCharacter: "\\eb32" });
      Codicon.quote = new Codicon("quote", { fontCharacter: "\\eb33" });
      Codicon.radioTower = new Codicon("radio-tower", { fontCharacter: "\\eb34" });
      Codicon.reactions = new Codicon("reactions", { fontCharacter: "\\eb35" });
      Codicon.references = new Codicon("references", { fontCharacter: "\\eb36" });
      Codicon.refresh = new Codicon("refresh", { fontCharacter: "\\eb37" });
      Codicon.regex = new Codicon("regex", { fontCharacter: "\\eb38" });
      Codicon.remoteExplorer = new Codicon("remote-explorer", { fontCharacter: "\\eb39" });
      Codicon.remote = new Codicon("remote", { fontCharacter: "\\eb3a" });
      Codicon.remove = new Codicon("remove", { fontCharacter: "\\eb3b" });
      Codicon.replaceAll = new Codicon("replace-all", { fontCharacter: "\\eb3c" });
      Codicon.replace = new Codicon("replace", { fontCharacter: "\\eb3d" });
      Codicon.repoClone = new Codicon("repo-clone", { fontCharacter: "\\eb3e" });
      Codicon.repoForcePush = new Codicon("repo-force-push", { fontCharacter: "\\eb3f" });
      Codicon.repoPull = new Codicon("repo-pull", { fontCharacter: "\\eb40" });
      Codicon.repoPush = new Codicon("repo-push", { fontCharacter: "\\eb41" });
      Codicon.report = new Codicon("report", { fontCharacter: "\\eb42" });
      Codicon.requestChanges = new Codicon("request-changes", { fontCharacter: "\\eb43" });
      Codicon.rocket = new Codicon("rocket", { fontCharacter: "\\eb44" });
      Codicon.rootFolderOpened = new Codicon("root-folder-opened", { fontCharacter: "\\eb45" });
      Codicon.rootFolder = new Codicon("root-folder", { fontCharacter: "\\eb46" });
      Codicon.rss = new Codicon("rss", { fontCharacter: "\\eb47" });
      Codicon.ruby = new Codicon("ruby", { fontCharacter: "\\eb48" });
      Codicon.saveAll = new Codicon("save-all", { fontCharacter: "\\eb49" });
      Codicon.saveAs = new Codicon("save-as", { fontCharacter: "\\eb4a" });
      Codicon.save = new Codicon("save", { fontCharacter: "\\eb4b" });
      Codicon.screenFull = new Codicon("screen-full", { fontCharacter: "\\eb4c" });
      Codicon.screenNormal = new Codicon("screen-normal", { fontCharacter: "\\eb4d" });
      Codicon.searchStop = new Codicon("search-stop", { fontCharacter: "\\eb4e" });
      Codicon.server = new Codicon("server", { fontCharacter: "\\eb50" });
      Codicon.settingsGear = new Codicon("settings-gear", { fontCharacter: "\\eb51" });
      Codicon.settings = new Codicon("settings", { fontCharacter: "\\eb52" });
      Codicon.shield = new Codicon("shield", { fontCharacter: "\\eb53" });
      Codicon.smiley = new Codicon("smiley", { fontCharacter: "\\eb54" });
      Codicon.sortPrecedence = new Codicon("sort-precedence", { fontCharacter: "\\eb55" });
      Codicon.splitHorizontal = new Codicon("split-horizontal", { fontCharacter: "\\eb56" });
      Codicon.splitVertical = new Codicon("split-vertical", { fontCharacter: "\\eb57" });
      Codicon.squirrel = new Codicon("squirrel", { fontCharacter: "\\eb58" });
      Codicon.starFull = new Codicon("star-full", { fontCharacter: "\\eb59" });
      Codicon.starHalf = new Codicon("star-half", { fontCharacter: "\\eb5a" });
      Codicon.symbolClass = new Codicon("symbol-class", { fontCharacter: "\\eb5b" });
      Codicon.symbolColor = new Codicon("symbol-color", { fontCharacter: "\\eb5c" });
      Codicon.symbolCustomColor = new Codicon("symbol-customcolor", { fontCharacter: "\\eb5c" });
      Codicon.symbolConstant = new Codicon("symbol-constant", { fontCharacter: "\\eb5d" });
      Codicon.symbolEnumMember = new Codicon("symbol-enum-member", { fontCharacter: "\\eb5e" });
      Codicon.symbolField = new Codicon("symbol-field", { fontCharacter: "\\eb5f" });
      Codicon.symbolFile = new Codicon("symbol-file", { fontCharacter: "\\eb60" });
      Codicon.symbolInterface = new Codicon("symbol-interface", { fontCharacter: "\\eb61" });
      Codicon.symbolKeyword = new Codicon("symbol-keyword", { fontCharacter: "\\eb62" });
      Codicon.symbolMisc = new Codicon("symbol-misc", { fontCharacter: "\\eb63" });
      Codicon.symbolOperator = new Codicon("symbol-operator", { fontCharacter: "\\eb64" });
      Codicon.symbolProperty = new Codicon("symbol-property", { fontCharacter: "\\eb65" });
      Codicon.wrench = new Codicon("wrench", { fontCharacter: "\\eb65" });
      Codicon.wrenchSubaction = new Codicon("wrench-subaction", { fontCharacter: "\\eb65" });
      Codicon.symbolSnippet = new Codicon("symbol-snippet", { fontCharacter: "\\eb66" });
      Codicon.tasklist = new Codicon("tasklist", { fontCharacter: "\\eb67" });
      Codicon.telescope = new Codicon("telescope", { fontCharacter: "\\eb68" });
      Codicon.textSize = new Codicon("text-size", { fontCharacter: "\\eb69" });
      Codicon.threeBars = new Codicon("three-bars", { fontCharacter: "\\eb6a" });
      Codicon.thumbsdown = new Codicon("thumbsdown", { fontCharacter: "\\eb6b" });
      Codicon.thumbsup = new Codicon("thumbsup", { fontCharacter: "\\eb6c" });
      Codicon.tools = new Codicon("tools", { fontCharacter: "\\eb6d" });
      Codicon.triangleDown = new Codicon("triangle-down", { fontCharacter: "\\eb6e" });
      Codicon.triangleLeft = new Codicon("triangle-left", { fontCharacter: "\\eb6f" });
      Codicon.triangleRight = new Codicon("triangle-right", { fontCharacter: "\\eb70" });
      Codicon.triangleUp = new Codicon("triangle-up", { fontCharacter: "\\eb71" });
      Codicon.twitter = new Codicon("twitter", { fontCharacter: "\\eb72" });
      Codicon.unfold = new Codicon("unfold", { fontCharacter: "\\eb73" });
      Codicon.unlock = new Codicon("unlock", { fontCharacter: "\\eb74" });
      Codicon.unmute = new Codicon("unmute", { fontCharacter: "\\eb75" });
      Codicon.unverified = new Codicon("unverified", { fontCharacter: "\\eb76" });
      Codicon.verified = new Codicon("verified", { fontCharacter: "\\eb77" });
      Codicon.versions = new Codicon("versions", { fontCharacter: "\\eb78" });
      Codicon.vmActive = new Codicon("vm-active", { fontCharacter: "\\eb79" });
      Codicon.vmOutline = new Codicon("vm-outline", { fontCharacter: "\\eb7a" });
      Codicon.vmRunning = new Codicon("vm-running", { fontCharacter: "\\eb7b" });
      Codicon.watch = new Codicon("watch", { fontCharacter: "\\eb7c" });
      Codicon.whitespace = new Codicon("whitespace", { fontCharacter: "\\eb7d" });
      Codicon.wholeWord = new Codicon("whole-word", { fontCharacter: "\\eb7e" });
      Codicon.window = new Codicon("window", { fontCharacter: "\\eb7f" });
      Codicon.wordWrap = new Codicon("word-wrap", { fontCharacter: "\\eb80" });
      Codicon.zoomIn = new Codicon("zoom-in", { fontCharacter: "\\eb81" });
      Codicon.zoomOut = new Codicon("zoom-out", { fontCharacter: "\\eb82" });
      Codicon.listFilter = new Codicon("list-filter", { fontCharacter: "\\eb83" });
      Codicon.listFlat = new Codicon("list-flat", { fontCharacter: "\\eb84" });
      Codicon.listSelection = new Codicon("list-selection", { fontCharacter: "\\eb85" });
      Codicon.selection = new Codicon("selection", { fontCharacter: "\\eb85" });
      Codicon.listTree = new Codicon("list-tree", { fontCharacter: "\\eb86" });
      Codicon.debugBreakpointFunctionUnverified = new Codicon("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" });
      Codicon.debugBreakpointFunction = new Codicon("debug-breakpoint-function", { fontCharacter: "\\eb88" });
      Codicon.debugBreakpointFunctionDisabled = new Codicon("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" });
      Codicon.debugStackframeActive = new Codicon("debug-stackframe-active", { fontCharacter: "\\eb89" });
      Codicon.debugStackframeDot = new Codicon("debug-stackframe-dot", { fontCharacter: "\\eb8a" });
      Codicon.debugStackframe = new Codicon("debug-stackframe", { fontCharacter: "\\eb8b" });
      Codicon.debugStackframeFocused = new Codicon("debug-stackframe-focused", { fontCharacter: "\\eb8b" });
      Codicon.debugBreakpointUnsupported = new Codicon("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" });
      Codicon.symbolString = new Codicon("symbol-string", { fontCharacter: "\\eb8d" });
      Codicon.debugReverseContinue = new Codicon("debug-reverse-continue", { fontCharacter: "\\eb8e" });
      Codicon.debugStepBack = new Codicon("debug-step-back", { fontCharacter: "\\eb8f" });
      Codicon.debugRestartFrame = new Codicon("debug-restart-frame", { fontCharacter: "\\eb90" });
      Codicon.callIncoming = new Codicon("call-incoming", { fontCharacter: "\\eb92" });
      Codicon.callOutgoing = new Codicon("call-outgoing", { fontCharacter: "\\eb93" });
      Codicon.menu = new Codicon("menu", { fontCharacter: "\\eb94" });
      Codicon.expandAll = new Codicon("expand-all", { fontCharacter: "\\eb95" });
      Codicon.feedback = new Codicon("feedback", { fontCharacter: "\\eb96" });
      Codicon.groupByRefType = new Codicon("group-by-ref-type", { fontCharacter: "\\eb97" });
      Codicon.ungroupByRefType = new Codicon("ungroup-by-ref-type", { fontCharacter: "\\eb98" });
      Codicon.account = new Codicon("account", { fontCharacter: "\\eb99" });
      Codicon.bellDot = new Codicon("bell-dot", { fontCharacter: "\\eb9a" });
      Codicon.debugConsole = new Codicon("debug-console", { fontCharacter: "\\eb9b" });
      Codicon.library = new Codicon("library", { fontCharacter: "\\eb9c" });
      Codicon.output = new Codicon("output", { fontCharacter: "\\eb9d" });
      Codicon.runAll = new Codicon("run-all", { fontCharacter: "\\eb9e" });
      Codicon.syncIgnored = new Codicon("sync-ignored", { fontCharacter: "\\eb9f" });
      Codicon.pinned = new Codicon("pinned", { fontCharacter: "\\eba0" });
      Codicon.githubInverted = new Codicon("github-inverted", { fontCharacter: "\\eba1" });
      Codicon.debugAlt = new Codicon("debug-alt", { fontCharacter: "\\eb91" });
      Codicon.serverProcess = new Codicon("server-process", { fontCharacter: "\\eba2" });
      Codicon.serverEnvironment = new Codicon("server-environment", { fontCharacter: "\\eba3" });
      Codicon.pass = new Codicon("pass", { fontCharacter: "\\eba4" });
      Codicon.stopCircle = new Codicon("stop-circle", { fontCharacter: "\\eba5" });
      Codicon.playCircle = new Codicon("play-circle", { fontCharacter: "\\eba6" });
      Codicon.record = new Codicon("record", { fontCharacter: "\\eba7" });
      Codicon.debugAltSmall = new Codicon("debug-alt-small", { fontCharacter: "\\eba8" });
      Codicon.vmConnect = new Codicon("vm-connect", { fontCharacter: "\\eba9" });
      Codicon.cloud = new Codicon("cloud", { fontCharacter: "\\ebaa" });
      Codicon.merge = new Codicon("merge", { fontCharacter: "\\ebab" });
      Codicon.exportIcon = new Codicon("export", { fontCharacter: "\\ebac" });
      Codicon.graphLeft = new Codicon("graph-left", { fontCharacter: "\\ebad" });
      Codicon.magnet = new Codicon("magnet", { fontCharacter: "\\ebae" });
      Codicon.notebook = new Codicon("notebook", { fontCharacter: "\\ebaf" });
      Codicon.redo = new Codicon("redo", { fontCharacter: "\\ebb0" });
      Codicon.checkAll = new Codicon("check-all", { fontCharacter: "\\ebb1" });
      Codicon.pinnedDirty = new Codicon("pinned-dirty", { fontCharacter: "\\ebb2" });
      Codicon.passFilled = new Codicon("pass-filled", { fontCharacter: "\\ebb3" });
      Codicon.circleLargeFilled = new Codicon("circle-large-filled", { fontCharacter: "\\ebb4" });
      Codicon.circleLargeOutline = new Codicon("circle-large-outline", { fontCharacter: "\\ebb5" });
      Codicon.combine = new Codicon("combine", { fontCharacter: "\\ebb6" });
      Codicon.gather = new Codicon("gather", { fontCharacter: "\\ebb6" });
      Codicon.table = new Codicon("table", { fontCharacter: "\\ebb7" });
      Codicon.variableGroup = new Codicon("variable-group", { fontCharacter: "\\ebb8" });
      Codicon.typeHierarchy = new Codicon("type-hierarchy", { fontCharacter: "\\ebb9" });
      Codicon.typeHierarchySub = new Codicon("type-hierarchy-sub", { fontCharacter: "\\ebba" });
      Codicon.typeHierarchySuper = new Codicon("type-hierarchy-super", { fontCharacter: "\\ebbb" });
      Codicon.gitPullRequestCreate = new Codicon("git-pull-request-create", { fontCharacter: "\\ebbc" });
      Codicon.runAbove = new Codicon("run-above", { fontCharacter: "\\ebbd" });
      Codicon.runBelow = new Codicon("run-below", { fontCharacter: "\\ebbe" });
      Codicon.notebookTemplate = new Codicon("notebook-template", { fontCharacter: "\\ebbf" });
      Codicon.debugRerun = new Codicon("debug-rerun", { fontCharacter: "\\ebc0" });
      Codicon.workspaceTrusted = new Codicon("workspace-trusted", { fontCharacter: "\\ebc1" });
      Codicon.workspaceUntrusted = new Codicon("workspace-untrusted", { fontCharacter: "\\ebc2" });
      Codicon.workspaceUnspecified = new Codicon("workspace-unspecified", { fontCharacter: "\\ebc3" });
      Codicon.terminalCmd = new Codicon("terminal-cmd", { fontCharacter: "\\ebc4" });
      Codicon.terminalDebian = new Codicon("terminal-debian", { fontCharacter: "\\ebc5" });
      Codicon.terminalLinux = new Codicon("terminal-linux", { fontCharacter: "\\ebc6" });
      Codicon.terminalPowershell = new Codicon("terminal-powershell", { fontCharacter: "\\ebc7" });
      Codicon.terminalTmux = new Codicon("terminal-tmux", { fontCharacter: "\\ebc8" });
      Codicon.terminalUbuntu = new Codicon("terminal-ubuntu", { fontCharacter: "\\ebc9" });
      Codicon.terminalBash = new Codicon("terminal-bash", { fontCharacter: "\\ebca" });
      Codicon.arrowSwap = new Codicon("arrow-swap", { fontCharacter: "\\ebcb" });
      Codicon.copy = new Codicon("copy", { fontCharacter: "\\ebcc" });
      Codicon.personAdd = new Codicon("person-add", { fontCharacter: "\\ebcd" });
      Codicon.filterFilled = new Codicon("filter-filled", { fontCharacter: "\\ebce" });
      Codicon.wand = new Codicon("wand", { fontCharacter: "\\ebcf" });
      Codicon.debugLineByLine = new Codicon("debug-line-by-line", { fontCharacter: "\\ebd0" });
      Codicon.inspect = new Codicon("inspect", { fontCharacter: "\\ebd1" });
      Codicon.layers = new Codicon("layers", { fontCharacter: "\\ebd2" });
      Codicon.layersDot = new Codicon("layers-dot", { fontCharacter: "\\ebd3" });
      Codicon.layersActive = new Codicon("layers-active", { fontCharacter: "\\ebd4" });
      Codicon.compass = new Codicon("compass", { fontCharacter: "\\ebd5" });
      Codicon.compassDot = new Codicon("compass-dot", { fontCharacter: "\\ebd6" });
      Codicon.compassActive = new Codicon("compass-active", { fontCharacter: "\\ebd7" });
      Codicon.azure = new Codicon("azure", { fontCharacter: "\\ebd8" });
      Codicon.issueDraft = new Codicon("issue-draft", { fontCharacter: "\\ebd9" });
      Codicon.gitPullRequestClosed = new Codicon("git-pull-request-closed", { fontCharacter: "\\ebda" });
      Codicon.gitPullRequestDraft = new Codicon("git-pull-request-draft", { fontCharacter: "\\ebdb" });
      Codicon.debugAll = new Codicon("debug-all", { fontCharacter: "\\ebdc" });
      Codicon.debugCoverage = new Codicon("debug-coverage", { fontCharacter: "\\ebdd" });
      Codicon.runErrors = new Codicon("run-errors", { fontCharacter: "\\ebde" });
      Codicon.folderLibrary = new Codicon("folder-library", { fontCharacter: "\\ebdf" });
      Codicon.debugContinueSmall = new Codicon("debug-continue-small", { fontCharacter: "\\ebe0" });
      Codicon.beakerStop = new Codicon("beaker-stop", { fontCharacter: "\\ebe1" });
      Codicon.graphLine = new Codicon("graph-line", { fontCharacter: "\\ebe2" });
      Codicon.graphScatter = new Codicon("graph-scatter", { fontCharacter: "\\ebe3" });
      Codicon.pieChart = new Codicon("pie-chart", { fontCharacter: "\\ebe4" });
      Codicon.bracket = new Codicon("bracket", Codicon.json.definition);
      Codicon.bracketDot = new Codicon("bracket-dot", { fontCharacter: "\\ebe5" });
      Codicon.bracketError = new Codicon("bracket-error", { fontCharacter: "\\ebe6" });
      Codicon.lockSmall = new Codicon("lock-small", { fontCharacter: "\\ebe7" });
      Codicon.azureDevops = new Codicon("azure-devops", { fontCharacter: "\\ebe8" });
      Codicon.verifiedFilled = new Codicon("verified-filled", { fontCharacter: "\\ebe9" });
      Codicon.newLine = new Codicon("newline", { fontCharacter: "\\ebea" });
      Codicon.layout = new Codicon("layout", { fontCharacter: "\\ebeb" });
      Codicon.layoutActivitybarLeft = new Codicon("layout-activitybar-left", { fontCharacter: "\\ebec" });
      Codicon.layoutActivitybarRight = new Codicon("layout-activitybar-right", { fontCharacter: "\\ebed" });
      Codicon.layoutPanelLeft = new Codicon("layout-panel-left", { fontCharacter: "\\ebee" });
      Codicon.layoutPanelCenter = new Codicon("layout-panel-center", { fontCharacter: "\\ebef" });
      Codicon.layoutPanelJustify = new Codicon("layout-panel-justify", { fontCharacter: "\\ebf0" });
      Codicon.layoutPanelRight = new Codicon("layout-panel-right", { fontCharacter: "\\ebf1" });
      Codicon.layoutPanel = new Codicon("layout-panel", { fontCharacter: "\\ebf2" });
      Codicon.layoutSidebarLeft = new Codicon("layout-sidebar-left", { fontCharacter: "\\ebf3" });
      Codicon.layoutSidebarRight = new Codicon("layout-sidebar-right", { fontCharacter: "\\ebf4" });
      Codicon.layoutStatusbar = new Codicon("layout-statusbar", { fontCharacter: "\\ebf5" });
      Codicon.layoutMenubar = new Codicon("layout-menubar", { fontCharacter: "\\ebf6" });
      Codicon.layoutCentered = new Codicon("layout-centered", { fontCharacter: "\\ebf7" });
      Codicon.target = new Codicon("target", { fontCharacter: "\\ebf8" });
      Codicon.indent = new Codicon("indent", { fontCharacter: "\\ebf9" });
      Codicon.recordSmall = new Codicon("record-small", { fontCharacter: "\\ebfa" });
      Codicon.errorSmall = new Codicon("error-small", { fontCharacter: "\\ebfb" });
      Codicon.arrowCircleDown = new Codicon("arrow-circle-down", { fontCharacter: "\\ebfc" });
      Codicon.arrowCircleLeft = new Codicon("arrow-circle-left", { fontCharacter: "\\ebfd" });
      Codicon.arrowCircleRight = new Codicon("arrow-circle-right", { fontCharacter: "\\ebfe" });
      Codicon.arrowCircleUp = new Codicon("arrow-circle-up", { fontCharacter: "\\ebff" });
      Codicon.dialogError = new Codicon("dialog-error", Codicon.error.definition);
      Codicon.dialogWarning = new Codicon("dialog-warning", Codicon.warning.definition);
      Codicon.dialogInfo = new Codicon("dialog-info", Codicon.info.definition);
      Codicon.dialogClose = new Codicon("dialog-close", Codicon.close.definition);
      Codicon.treeItemExpanded = new Codicon("tree-item-expanded", Codicon.chevronDown.definition);
      Codicon.treeFilterOnTypeOn = new Codicon("tree-filter-on-type-on", Codicon.listFilter.definition);
      Codicon.treeFilterOnTypeOff = new Codicon("tree-filter-on-type-off", Codicon.listSelection.definition);
      Codicon.treeFilterClear = new Codicon("tree-filter-clear", Codicon.close.definition);
      Codicon.treeItemLoading = new Codicon("tree-item-loading", Codicon.loading.definition);
      Codicon.menuSelection = new Codicon("menu-selection", Codicon.check.definition);
      Codicon.menuSubmenu = new Codicon("menu-submenu", Codicon.chevronRight.definition);
      Codicon.menuBarMore = new Codicon("menubar-more", Codicon.more.definition);
      Codicon.scrollbarButtonLeft = new Codicon("scrollbar-button-left", Codicon.triangleLeft.definition);
      Codicon.scrollbarButtonRight = new Codicon("scrollbar-button-right", Codicon.triangleRight.definition);
      Codicon.scrollbarButtonUp = new Codicon("scrollbar-button-up", Codicon.triangleUp.definition);
      Codicon.scrollbarButtonDown = new Codicon("scrollbar-button-down", Codicon.triangleDown.definition);
      Codicon.toolBarMore = new Codicon("toolbar-more", Codicon.more.definition);
      Codicon.quickInputBack = new Codicon("quick-input-back", Codicon.arrowLeft.definition);
      (function(CSSIcon2) {
        CSSIcon2.iconNameSegment = "[A-Za-z0-9]+";
        CSSIcon2.iconNameExpression = "[A-Za-z0-9-]+";
        CSSIcon2.iconModifierExpression = "~[A-Za-z]+";
        CSSIcon2.iconNameCharacter = "[A-Za-z0-9~-]";
        const cssIconIdRegex = new RegExp(`^(${CSSIcon2.iconNameExpression})(${CSSIcon2.iconModifierExpression})?$`);
        function asClassNameArray(icon) {
          if (icon instanceof Codicon) {
            return ["codicon", "codicon-" + icon.id];
          }
          const match = cssIconIdRegex.exec(icon.id);
          if (!match) {
            return asClassNameArray(Codicon.error);
          }
          let [, id, modifier] = match;
          const classNames = ["codicon", "codicon-" + id];
          if (modifier) {
            classNames.push("codicon-modifier-" + modifier.substr(1));
          }
          return classNames;
        }
        CSSIcon2.asClassNameArray = asClassNameArray;
        function asClassName(icon) {
          return asClassNameArray(icon).join(" ");
        }
        CSSIcon2.asClassName = asClassName;
        function asCSSSelector(icon) {
          return "." + asClassNameArray(icon).join(".");
        }
        CSSIcon2.asCSSSelector = asCSSSelector;
      })(CSSIcon || (CSSIcon = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token, CompletionItemKinds, InlineCompletionTriggerKind, SignatureHelpTriggerKind, DocumentHighlightKind, SymbolKinds, FoldingRangeKind, Command, InlayHintKind, TokenizationRegistry2;
  var init_languages = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js"() {
      init_uri();
      init_range();
      init_tokenizationRegistry();
      init_codicons();
      Token = class {
        constructor(offset, type, language) {
          this._tokenBrand = void 0;
          this.offset = offset;
          this.type = type;
          this.language = language;
        }
        toString() {
          return "(" + this.offset + ", " + this.type + ")";
        }
      };
      (function(CompletionItemKinds2) {
        const byKind = /* @__PURE__ */ new Map();
        byKind.set(0, Codicon.symbolMethod);
        byKind.set(1, Codicon.symbolFunction);
        byKind.set(2, Codicon.symbolConstructor);
        byKind.set(3, Codicon.symbolField);
        byKind.set(4, Codicon.symbolVariable);
        byKind.set(5, Codicon.symbolClass);
        byKind.set(6, Codicon.symbolStruct);
        byKind.set(7, Codicon.symbolInterface);
        byKind.set(8, Codicon.symbolModule);
        byKind.set(9, Codicon.symbolProperty);
        byKind.set(10, Codicon.symbolEvent);
        byKind.set(11, Codicon.symbolOperator);
        byKind.set(12, Codicon.symbolUnit);
        byKind.set(13, Codicon.symbolValue);
        byKind.set(15, Codicon.symbolEnum);
        byKind.set(14, Codicon.symbolConstant);
        byKind.set(15, Codicon.symbolEnum);
        byKind.set(16, Codicon.symbolEnumMember);
        byKind.set(17, Codicon.symbolKeyword);
        byKind.set(27, Codicon.symbolSnippet);
        byKind.set(18, Codicon.symbolText);
        byKind.set(19, Codicon.symbolColor);
        byKind.set(20, Codicon.symbolFile);
        byKind.set(21, Codicon.symbolReference);
        byKind.set(22, Codicon.symbolCustomColor);
        byKind.set(23, Codicon.symbolFolder);
        byKind.set(24, Codicon.symbolTypeParameter);
        byKind.set(25, Codicon.account);
        byKind.set(26, Codicon.issues);
        function toIcon(kind) {
          let codicon = byKind.get(kind);
          if (!codicon) {
            console.info("No codicon found for CompletionItemKind " + kind);
            codicon = Codicon.symbolProperty;
          }
          return codicon;
        }
        CompletionItemKinds2.toIcon = toIcon;
        const data = /* @__PURE__ */ new Map();
        data.set("method", 0);
        data.set("function", 1);
        data.set("constructor", 2);
        data.set("field", 3);
        data.set("variable", 4);
        data.set("class", 5);
        data.set("struct", 6);
        data.set("interface", 7);
        data.set("module", 8);
        data.set("property", 9);
        data.set("event", 10);
        data.set("operator", 11);
        data.set("unit", 12);
        data.set("value", 13);
        data.set("constant", 14);
        data.set("enum", 15);
        data.set("enum-member", 16);
        data.set("enumMember", 16);
        data.set("keyword", 17);
        data.set("snippet", 27);
        data.set("text", 18);
        data.set("color", 19);
        data.set("file", 20);
        data.set("reference", 21);
        data.set("customcolor", 22);
        data.set("folder", 23);
        data.set("type-parameter", 24);
        data.set("typeParameter", 24);
        data.set("account", 25);
        data.set("issue", 26);
        function fromString(value, strict) {
          let res = data.get(value);
          if (typeof res === "undefined" && !strict) {
            res = 9;
          }
          return res;
        }
        CompletionItemKinds2.fromString = fromString;
      })(CompletionItemKinds || (CompletionItemKinds = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
      })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind || (DocumentHighlightKind = {}));
      (function(SymbolKinds2) {
        const byKind = /* @__PURE__ */ new Map();
        byKind.set(0, Codicon.symbolFile);
        byKind.set(1, Codicon.symbolModule);
        byKind.set(2, Codicon.symbolNamespace);
        byKind.set(3, Codicon.symbolPackage);
        byKind.set(4, Codicon.symbolClass);
        byKind.set(5, Codicon.symbolMethod);
        byKind.set(6, Codicon.symbolProperty);
        byKind.set(7, Codicon.symbolField);
        byKind.set(8, Codicon.symbolConstructor);
        byKind.set(9, Codicon.symbolEnum);
        byKind.set(10, Codicon.symbolInterface);
        byKind.set(11, Codicon.symbolFunction);
        byKind.set(12, Codicon.symbolVariable);
        byKind.set(13, Codicon.symbolConstant);
        byKind.set(14, Codicon.symbolString);
        byKind.set(15, Codicon.symbolNumber);
        byKind.set(16, Codicon.symbolBoolean);
        byKind.set(17, Codicon.symbolArray);
        byKind.set(18, Codicon.symbolObject);
        byKind.set(19, Codicon.symbolKey);
        byKind.set(20, Codicon.symbolNull);
        byKind.set(21, Codicon.symbolEnumMember);
        byKind.set(22, Codicon.symbolStruct);
        byKind.set(23, Codicon.symbolEvent);
        byKind.set(24, Codicon.symbolOperator);
        byKind.set(25, Codicon.symbolTypeParameter);
        function toIcon(kind) {
          let icon = byKind.get(kind);
          if (!icon) {
            console.info("No codicon found for SymbolKind " + kind);
            icon = Codicon.symbolProperty;
          }
          return icon;
        }
        SymbolKinds2.toIcon = toIcon;
      })(SymbolKinds || (SymbolKinds = {}));
      FoldingRangeKind = class {
        constructor(value) {
          this.value = value;
        }
      };
      FoldingRangeKind.Comment = new FoldingRangeKind("comment");
      FoldingRangeKind.Imports = new FoldingRangeKind("imports");
      FoldingRangeKind.Region = new FoldingRangeKind("region");
      (function(Command2) {
        function is(obj) {
          if (!obj || typeof obj !== "object") {
            return false;
          }
          return typeof obj.id === "string" && typeof obj.title === "string";
        }
        Command2.is = is;
      })(Command || (Command = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind || (InlayHintKind = {}));
      TokenizationRegistry2 = new TokenizationRegistry();
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport, CompletionItemInsertTextRule, CompletionItemKind, CompletionItemTag, CompletionTriggerKind, ContentWidgetPositionPreference, CursorChangeReason, DefaultEndOfLine, DocumentHighlightKind2, EditorAutoIndentStrategy, EditorOption, EndOfLinePreference, EndOfLineSequence, IndentAction, InjectedTextCursorStops, InlayHintKind2, InlineCompletionTriggerKind2, KeyCode, MarkerSeverity, MarkerTag, MinimapPosition, MouseTargetType, OverlayWidgetPositionPreference, OverviewRulerLane, PositionAffinity, RenderLineNumbersType, RenderMinimap, ScrollType, ScrollbarVisibility, SelectionDirection, SignatureHelpTriggerKind2, SymbolKind, SymbolTag, TextEditorCursorBlinkingStyle, TextEditorCursorStyle, TrackedRangeStickiness, WrappingIndent;
  var init_standaloneEnums = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js"() {
      (function(AccessibilitySupport2) {
        AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
        AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
        AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
      })(AccessibilitySupport || (AccessibilitySupport = {}));
      (function(CompletionItemInsertTextRule2) {
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
      })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
      (function(CompletionItemKind2) {
        CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
        CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
        CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
        CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
        CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
        CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
        CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
        CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
        CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
        CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
        CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
        CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
        CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
        CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
        CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
        CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
        CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
        CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
        CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
        CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
        CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
        CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
        CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
        CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
        CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
        CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
        CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
        CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
      })(CompletionItemKind || (CompletionItemKind = {}));
      (function(CompletionItemTag2) {
        CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
      })(CompletionItemTag || (CompletionItemTag = {}));
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
      })(CompletionTriggerKind || (CompletionTriggerKind = {}));
      (function(ContentWidgetPositionPreference2) {
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
      })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
      (function(CursorChangeReason2) {
        CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
        CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
        CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
        CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
        CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
        CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
        CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
      })(CursorChangeReason || (CursorChangeReason = {}));
      (function(DefaultEndOfLine2) {
        DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
        DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
      })(DefaultEndOfLine || (DefaultEndOfLine = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
      (function(EditorAutoIndentStrategy2) {
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
      })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
      (function(EditorOption2) {
        EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
        EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
        EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
        EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
        EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
        EditorOption2[EditorOption2["autoClosingBrackets"] = 5] = "autoClosingBrackets";
        EditorOption2[EditorOption2["autoClosingDelete"] = 6] = "autoClosingDelete";
        EditorOption2[EditorOption2["autoClosingOvertype"] = 7] = "autoClosingOvertype";
        EditorOption2[EditorOption2["autoClosingQuotes"] = 8] = "autoClosingQuotes";
        EditorOption2[EditorOption2["autoIndent"] = 9] = "autoIndent";
        EditorOption2[EditorOption2["automaticLayout"] = 10] = "automaticLayout";
        EditorOption2[EditorOption2["autoSurround"] = 11] = "autoSurround";
        EditorOption2[EditorOption2["bracketPairColorization"] = 12] = "bracketPairColorization";
        EditorOption2[EditorOption2["guides"] = 13] = "guides";
        EditorOption2[EditorOption2["codeLens"] = 14] = "codeLens";
        EditorOption2[EditorOption2["codeLensFontFamily"] = 15] = "codeLensFontFamily";
        EditorOption2[EditorOption2["codeLensFontSize"] = 16] = "codeLensFontSize";
        EditorOption2[EditorOption2["colorDecorators"] = 17] = "colorDecorators";
        EditorOption2[EditorOption2["columnSelection"] = 18] = "columnSelection";
        EditorOption2[EditorOption2["comments"] = 19] = "comments";
        EditorOption2[EditorOption2["contextmenu"] = 20] = "contextmenu";
        EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 21] = "copyWithSyntaxHighlighting";
        EditorOption2[EditorOption2["cursorBlinking"] = 22] = "cursorBlinking";
        EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 23] = "cursorSmoothCaretAnimation";
        EditorOption2[EditorOption2["cursorStyle"] = 24] = "cursorStyle";
        EditorOption2[EditorOption2["cursorSurroundingLines"] = 25] = "cursorSurroundingLines";
        EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 26] = "cursorSurroundingLinesStyle";
        EditorOption2[EditorOption2["cursorWidth"] = 27] = "cursorWidth";
        EditorOption2[EditorOption2["disableLayerHinting"] = 28] = "disableLayerHinting";
        EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 29] = "disableMonospaceOptimizations";
        EditorOption2[EditorOption2["domReadOnly"] = 30] = "domReadOnly";
        EditorOption2[EditorOption2["dragAndDrop"] = 31] = "dragAndDrop";
        EditorOption2[EditorOption2["emptySelectionClipboard"] = 32] = "emptySelectionClipboard";
        EditorOption2[EditorOption2["extraEditorClassName"] = 33] = "extraEditorClassName";
        EditorOption2[EditorOption2["fastScrollSensitivity"] = 34] = "fastScrollSensitivity";
        EditorOption2[EditorOption2["find"] = 35] = "find";
        EditorOption2[EditorOption2["fixedOverflowWidgets"] = 36] = "fixedOverflowWidgets";
        EditorOption2[EditorOption2["folding"] = 37] = "folding";
        EditorOption2[EditorOption2["foldingStrategy"] = 38] = "foldingStrategy";
        EditorOption2[EditorOption2["foldingHighlight"] = 39] = "foldingHighlight";
        EditorOption2[EditorOption2["foldingImportsByDefault"] = 40] = "foldingImportsByDefault";
        EditorOption2[EditorOption2["foldingMaximumRegions"] = 41] = "foldingMaximumRegions";
        EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 42] = "unfoldOnClickAfterEndOfLine";
        EditorOption2[EditorOption2["fontFamily"] = 43] = "fontFamily";
        EditorOption2[EditorOption2["fontInfo"] = 44] = "fontInfo";
        EditorOption2[EditorOption2["fontLigatures"] = 45] = "fontLigatures";
        EditorOption2[EditorOption2["fontSize"] = 46] = "fontSize";
        EditorOption2[EditorOption2["fontWeight"] = 47] = "fontWeight";
        EditorOption2[EditorOption2["formatOnPaste"] = 48] = "formatOnPaste";
        EditorOption2[EditorOption2["formatOnType"] = 49] = "formatOnType";
        EditorOption2[EditorOption2["glyphMargin"] = 50] = "glyphMargin";
        EditorOption2[EditorOption2["gotoLocation"] = 51] = "gotoLocation";
        EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 52] = "hideCursorInOverviewRuler";
        EditorOption2[EditorOption2["hover"] = 53] = "hover";
        EditorOption2[EditorOption2["inDiffEditor"] = 54] = "inDiffEditor";
        EditorOption2[EditorOption2["inlineSuggest"] = 55] = "inlineSuggest";
        EditorOption2[EditorOption2["letterSpacing"] = 56] = "letterSpacing";
        EditorOption2[EditorOption2["lightbulb"] = 57] = "lightbulb";
        EditorOption2[EditorOption2["lineDecorationsWidth"] = 58] = "lineDecorationsWidth";
        EditorOption2[EditorOption2["lineHeight"] = 59] = "lineHeight";
        EditorOption2[EditorOption2["lineNumbers"] = 60] = "lineNumbers";
        EditorOption2[EditorOption2["lineNumbersMinChars"] = 61] = "lineNumbersMinChars";
        EditorOption2[EditorOption2["linkedEditing"] = 62] = "linkedEditing";
        EditorOption2[EditorOption2["links"] = 63] = "links";
        EditorOption2[EditorOption2["matchBrackets"] = 64] = "matchBrackets";
        EditorOption2[EditorOption2["minimap"] = 65] = "minimap";
        EditorOption2[EditorOption2["mouseStyle"] = 66] = "mouseStyle";
        EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 67] = "mouseWheelScrollSensitivity";
        EditorOption2[EditorOption2["mouseWheelZoom"] = 68] = "mouseWheelZoom";
        EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 69] = "multiCursorMergeOverlapping";
        EditorOption2[EditorOption2["multiCursorModifier"] = 70] = "multiCursorModifier";
        EditorOption2[EditorOption2["multiCursorPaste"] = 71] = "multiCursorPaste";
        EditorOption2[EditorOption2["occurrencesHighlight"] = 72] = "occurrencesHighlight";
        EditorOption2[EditorOption2["overviewRulerBorder"] = 73] = "overviewRulerBorder";
        EditorOption2[EditorOption2["overviewRulerLanes"] = 74] = "overviewRulerLanes";
        EditorOption2[EditorOption2["padding"] = 75] = "padding";
        EditorOption2[EditorOption2["parameterHints"] = 76] = "parameterHints";
        EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 77] = "peekWidgetDefaultFocus";
        EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 78] = "definitionLinkOpensInPeek";
        EditorOption2[EditorOption2["quickSuggestions"] = 79] = "quickSuggestions";
        EditorOption2[EditorOption2["quickSuggestionsDelay"] = 80] = "quickSuggestionsDelay";
        EditorOption2[EditorOption2["readOnly"] = 81] = "readOnly";
        EditorOption2[EditorOption2["renameOnType"] = 82] = "renameOnType";
        EditorOption2[EditorOption2["renderControlCharacters"] = 83] = "renderControlCharacters";
        EditorOption2[EditorOption2["renderFinalNewline"] = 84] = "renderFinalNewline";
        EditorOption2[EditorOption2["renderLineHighlight"] = 85] = "renderLineHighlight";
        EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 86] = "renderLineHighlightOnlyWhenFocus";
        EditorOption2[EditorOption2["renderValidationDecorations"] = 87] = "renderValidationDecorations";
        EditorOption2[EditorOption2["renderWhitespace"] = 88] = "renderWhitespace";
        EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 89] = "revealHorizontalRightPadding";
        EditorOption2[EditorOption2["roundedSelection"] = 90] = "roundedSelection";
        EditorOption2[EditorOption2["rulers"] = 91] = "rulers";
        EditorOption2[EditorOption2["scrollbar"] = 92] = "scrollbar";
        EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 93] = "scrollBeyondLastColumn";
        EditorOption2[EditorOption2["scrollBeyondLastLine"] = 94] = "scrollBeyondLastLine";
        EditorOption2[EditorOption2["scrollPredominantAxis"] = 95] = "scrollPredominantAxis";
        EditorOption2[EditorOption2["selectionClipboard"] = 96] = "selectionClipboard";
        EditorOption2[EditorOption2["selectionHighlight"] = 97] = "selectionHighlight";
        EditorOption2[EditorOption2["selectOnLineNumbers"] = 98] = "selectOnLineNumbers";
        EditorOption2[EditorOption2["showFoldingControls"] = 99] = "showFoldingControls";
        EditorOption2[EditorOption2["showUnused"] = 100] = "showUnused";
        EditorOption2[EditorOption2["snippetSuggestions"] = 101] = "snippetSuggestions";
        EditorOption2[EditorOption2["smartSelect"] = 102] = "smartSelect";
        EditorOption2[EditorOption2["smoothScrolling"] = 103] = "smoothScrolling";
        EditorOption2[EditorOption2["stickyTabStops"] = 104] = "stickyTabStops";
        EditorOption2[EditorOption2["stopRenderingLineAfter"] = 105] = "stopRenderingLineAfter";
        EditorOption2[EditorOption2["suggest"] = 106] = "suggest";
        EditorOption2[EditorOption2["suggestFontSize"] = 107] = "suggestFontSize";
        EditorOption2[EditorOption2["suggestLineHeight"] = 108] = "suggestLineHeight";
        EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 109] = "suggestOnTriggerCharacters";
        EditorOption2[EditorOption2["suggestSelection"] = 110] = "suggestSelection";
        EditorOption2[EditorOption2["tabCompletion"] = 111] = "tabCompletion";
        EditorOption2[EditorOption2["tabIndex"] = 112] = "tabIndex";
        EditorOption2[EditorOption2["unicodeHighlighting"] = 113] = "unicodeHighlighting";
        EditorOption2[EditorOption2["unusualLineTerminators"] = 114] = "unusualLineTerminators";
        EditorOption2[EditorOption2["useShadowDOM"] = 115] = "useShadowDOM";
        EditorOption2[EditorOption2["useTabStops"] = 116] = "useTabStops";
        EditorOption2[EditorOption2["wordSeparators"] = 117] = "wordSeparators";
        EditorOption2[EditorOption2["wordWrap"] = 118] = "wordWrap";
        EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 119] = "wordWrapBreakAfterCharacters";
        EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 120] = "wordWrapBreakBeforeCharacters";
        EditorOption2[EditorOption2["wordWrapColumn"] = 121] = "wordWrapColumn";
        EditorOption2[EditorOption2["wordWrapOverride1"] = 122] = "wordWrapOverride1";
        EditorOption2[EditorOption2["wordWrapOverride2"] = 123] = "wordWrapOverride2";
        EditorOption2[EditorOption2["wrappingIndent"] = 124] = "wrappingIndent";
        EditorOption2[EditorOption2["wrappingStrategy"] = 125] = "wrappingStrategy";
        EditorOption2[EditorOption2["showDeprecated"] = 126] = "showDeprecated";
        EditorOption2[EditorOption2["inlayHints"] = 127] = "inlayHints";
        EditorOption2[EditorOption2["editorClassName"] = 128] = "editorClassName";
        EditorOption2[EditorOption2["pixelRatio"] = 129] = "pixelRatio";
        EditorOption2[EditorOption2["tabFocusMode"] = 130] = "tabFocusMode";
        EditorOption2[EditorOption2["layoutInfo"] = 131] = "layoutInfo";
        EditorOption2[EditorOption2["wrappingInfo"] = 132] = "wrappingInfo";
      })(EditorOption || (EditorOption = {}));
      (function(EndOfLinePreference2) {
        EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
        EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
        EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
      })(EndOfLinePreference || (EndOfLinePreference = {}));
      (function(EndOfLineSequence2) {
        EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
        EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
      })(EndOfLineSequence || (EndOfLineSequence = {}));
      (function(IndentAction2) {
        IndentAction2[IndentAction2["None"] = 0] = "None";
        IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
        IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
        IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
      })(IndentAction || (IndentAction = {}));
      (function(InjectedTextCursorStops3) {
        InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
        InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
      })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind2 || (InlayHintKind2 = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
      })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
      (function(KeyCode2) {
        KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
        KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
        KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
        KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
        KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
        KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
        KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
        KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
        KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
        KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
        KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
        KeyCode2[KeyCode2["Space"] = 10] = "Space";
        KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
        KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
        KeyCode2[KeyCode2["End"] = 13] = "End";
        KeyCode2[KeyCode2["Home"] = 14] = "Home";
        KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
        KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
        KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
        KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
        KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
        KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
        KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
        KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
        KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
        KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
        KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
        KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
        KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
        KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
        KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
        KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
        KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
        KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
        KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
        KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
        KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
        KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
        KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
        KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
        KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
        KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
        KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
        KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
        KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
        KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
        KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
        KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
        KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
        KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
        KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
        KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
        KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
        KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
        KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
        KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
        KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
        KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
        KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
        KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
        KeyCode2[KeyCode2["F1"] = 59] = "F1";
        KeyCode2[KeyCode2["F2"] = 60] = "F2";
        KeyCode2[KeyCode2["F3"] = 61] = "F3";
        KeyCode2[KeyCode2["F4"] = 62] = "F4";
        KeyCode2[KeyCode2["F5"] = 63] = "F5";
        KeyCode2[KeyCode2["F6"] = 64] = "F6";
        KeyCode2[KeyCode2["F7"] = 65] = "F7";
        KeyCode2[KeyCode2["F8"] = 66] = "F8";
        KeyCode2[KeyCode2["F9"] = 67] = "F9";
        KeyCode2[KeyCode2["F10"] = 68] = "F10";
        KeyCode2[KeyCode2["F11"] = 69] = "F11";
        KeyCode2[KeyCode2["F12"] = 70] = "F12";
        KeyCode2[KeyCode2["F13"] = 71] = "F13";
        KeyCode2[KeyCode2["F14"] = 72] = "F14";
        KeyCode2[KeyCode2["F15"] = 73] = "F15";
        KeyCode2[KeyCode2["F16"] = 74] = "F16";
        KeyCode2[KeyCode2["F17"] = 75] = "F17";
        KeyCode2[KeyCode2["F18"] = 76] = "F18";
        KeyCode2[KeyCode2["F19"] = 77] = "F19";
        KeyCode2[KeyCode2["NumLock"] = 78] = "NumLock";
        KeyCode2[KeyCode2["ScrollLock"] = 79] = "ScrollLock";
        KeyCode2[KeyCode2["Semicolon"] = 80] = "Semicolon";
        KeyCode2[KeyCode2["Equal"] = 81] = "Equal";
        KeyCode2[KeyCode2["Comma"] = 82] = "Comma";
        KeyCode2[KeyCode2["Minus"] = 83] = "Minus";
        KeyCode2[KeyCode2["Period"] = 84] = "Period";
        KeyCode2[KeyCode2["Slash"] = 85] = "Slash";
        KeyCode2[KeyCode2["Backquote"] = 86] = "Backquote";
        KeyCode2[KeyCode2["BracketLeft"] = 87] = "BracketLeft";
        KeyCode2[KeyCode2["Backslash"] = 88] = "Backslash";
        KeyCode2[KeyCode2["BracketRight"] = 89] = "BracketRight";
        KeyCode2[KeyCode2["Quote"] = 90] = "Quote";
        KeyCode2[KeyCode2["OEM_8"] = 91] = "OEM_8";
        KeyCode2[KeyCode2["IntlBackslash"] = 92] = "IntlBackslash";
        KeyCode2[KeyCode2["Numpad0"] = 93] = "Numpad0";
        KeyCode2[KeyCode2["Numpad1"] = 94] = "Numpad1";
        KeyCode2[KeyCode2["Numpad2"] = 95] = "Numpad2";
        KeyCode2[KeyCode2["Numpad3"] = 96] = "Numpad3";
        KeyCode2[KeyCode2["Numpad4"] = 97] = "Numpad4";
        KeyCode2[KeyCode2["Numpad5"] = 98] = "Numpad5";
        KeyCode2[KeyCode2["Numpad6"] = 99] = "Numpad6";
        KeyCode2[KeyCode2["Numpad7"] = 100] = "Numpad7";
        KeyCode2[KeyCode2["Numpad8"] = 101] = "Numpad8";
        KeyCode2[KeyCode2["Numpad9"] = 102] = "Numpad9";
        KeyCode2[KeyCode2["NumpadMultiply"] = 103] = "NumpadMultiply";
        KeyCode2[KeyCode2["NumpadAdd"] = 104] = "NumpadAdd";
        KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode2[KeyCode2["NumpadSubtract"] = 106] = "NumpadSubtract";
        KeyCode2[KeyCode2["NumpadDecimal"] = 107] = "NumpadDecimal";
        KeyCode2[KeyCode2["NumpadDivide"] = 108] = "NumpadDivide";
        KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
        KeyCode2[KeyCode2["ABNT_C1"] = 110] = "ABNT_C1";
        KeyCode2[KeyCode2["ABNT_C2"] = 111] = "ABNT_C2";
        KeyCode2[KeyCode2["AudioVolumeMute"] = 112] = "AudioVolumeMute";
        KeyCode2[KeyCode2["AudioVolumeUp"] = 113] = "AudioVolumeUp";
        KeyCode2[KeyCode2["AudioVolumeDown"] = 114] = "AudioVolumeDown";
        KeyCode2[KeyCode2["BrowserSearch"] = 115] = "BrowserSearch";
        KeyCode2[KeyCode2["BrowserHome"] = 116] = "BrowserHome";
        KeyCode2[KeyCode2["BrowserBack"] = 117] = "BrowserBack";
        KeyCode2[KeyCode2["BrowserForward"] = 118] = "BrowserForward";
        KeyCode2[KeyCode2["MediaTrackNext"] = 119] = "MediaTrackNext";
        KeyCode2[KeyCode2["MediaTrackPrevious"] = 120] = "MediaTrackPrevious";
        KeyCode2[KeyCode2["MediaStop"] = 121] = "MediaStop";
        KeyCode2[KeyCode2["MediaPlayPause"] = 122] = "MediaPlayPause";
        KeyCode2[KeyCode2["LaunchMediaPlayer"] = 123] = "LaunchMediaPlayer";
        KeyCode2[KeyCode2["LaunchMail"] = 124] = "LaunchMail";
        KeyCode2[KeyCode2["LaunchApp2"] = 125] = "LaunchApp2";
        KeyCode2[KeyCode2["Clear"] = 126] = "Clear";
        KeyCode2[KeyCode2["MAX_VALUE"] = 127] = "MAX_VALUE";
      })(KeyCode || (KeyCode = {}));
      (function(MarkerSeverity2) {
        MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
        MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
        MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
        MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
      })(MarkerSeverity || (MarkerSeverity = {}));
      (function(MarkerTag2) {
        MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
        MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
      })(MarkerTag || (MarkerTag = {}));
      (function(MinimapPosition3) {
        MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
        MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
      })(MinimapPosition || (MinimapPosition = {}));
      (function(MouseTargetType2) {
        MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
        MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
        MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
        MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
        MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
        MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
        MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
        MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
        MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
        MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
        MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
        MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
        MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
        MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
      })(MouseTargetType || (MouseTargetType = {}));
      (function(OverlayWidgetPositionPreference2) {
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
      })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane || (OverviewRulerLane = {}));
      (function(PositionAffinity2) {
        PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
        PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
        PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
      })(PositionAffinity || (PositionAffinity = {}));
      (function(RenderLineNumbersType2) {
        RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
        RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
        RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
        RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
        RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
      })(RenderLineNumbersType || (RenderLineNumbersType = {}));
      (function(RenderMinimap2) {
        RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
        RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
        RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
      })(RenderMinimap || (RenderMinimap = {}));
      (function(ScrollType2) {
        ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
        ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
      })(ScrollType || (ScrollType = {}));
      (function(ScrollbarVisibility2) {
        ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
        ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
      })(ScrollbarVisibility || (ScrollbarVisibility = {}));
      (function(SelectionDirection2) {
        SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
        SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
      })(SelectionDirection || (SelectionDirection = {}));
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
      (function(SymbolKind2) {
        SymbolKind2[SymbolKind2["File"] = 0] = "File";
        SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
        SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
        SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
        SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
        SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
        SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
        SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
        SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
        SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
        SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
        SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
        SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
        SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
        SymbolKind2[SymbolKind2["String"] = 14] = "String";
        SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
        SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
        SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
        SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
        SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
        SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
        SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
        SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
        SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
        SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
        SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
      })(SymbolKind || (SymbolKind = {}));
      (function(SymbolTag2) {
        SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
      })(SymbolTag || (SymbolTag = {}));
      (function(TextEditorCursorBlinkingStyle2) {
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
      })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
      (function(TextEditorCursorStyle2) {
        TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
        TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
        TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
        TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
        TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
        TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
      })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
      (function(TrackedRangeStickiness2) {
        TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
      })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
      (function(WrappingIndent2) {
        WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
        WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
        WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
        WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
      })(WrappingIndent || (WrappingIndent = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      languages: void 0,
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }
  var KeyMod;
  var init_editorBaseApi = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"() {
      init_cancellation();
      init_event();
      init_keyCodes();
      init_uri();
      init_position();
      init_range();
      init_selection();
      init_languages();
      init_standaloneEnums();
      KeyMod = class {
        static chord(firstPart, secondPart) {
          return KeyChord(firstPart, secondPart);
        }
      };
      KeyMod.CtrlCmd = 2048;
      KeyMod.Shift = 1024;
      KeyMod.Alt = 512;
      KeyMod.WinCtrl = 256;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  function once2(computeFn) {
    const cache = {};
    return (input) => {
      if (!cache.hasOwnProperty(input)) {
        cache[input] = computeFn(input);
      }
      return cache[input];
    };
  }
  var WordCharacterClassifier, getMapForWordSeparators;
  var init_wordCharacterClassifier = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"() {
      init_characterClassifier();
      WordCharacterClassifier = class extends CharacterClassifier {
        constructor(wordSeparators) {
          super(0);
          for (let i = 0, len = wordSeparators.length; i < len; i++) {
            this.set(wordSeparators.charCodeAt(i), 2);
          }
          this.set(32, 1);
          this.set(9, 1);
        }
      };
      getMapForWordSeparators = once2((input) => new WordCharacterClassifier(input));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js
  var init_objects = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js"() {
      init_types();
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2, MinimapPosition2, InjectedTextCursorStops2;
  var init_model = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js"() {
      init_objects();
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
      (function(MinimapPosition3) {
        MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
        MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
      })(MinimapPosition2 || (MinimapPosition2 = {}));
      (function(InjectedTextCursorStops3) {
        InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
        InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
      })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
  }
  var Searcher;
  var init_textModelSearch = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"() {
      init_strings();
      init_wordCharacterClassifier();
      init_position();
      init_range();
      init_model();
      Searcher = class {
        constructor(wordSeparators, searchRegex) {
          this._wordSeparators = wordSeparators;
          this._searchRegex = searchRegex;
          this._prevMatchStartIndex = -1;
          this._prevMatchLength = 0;
        }
        reset(lastIndex) {
          this._searchRegex.lastIndex = lastIndex;
          this._prevMatchStartIndex = -1;
          this._prevMatchLength = 0;
        }
        next(text) {
          const textLength = text.length;
          let m;
          do {
            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
              return null;
            }
            m = this._searchRegex.exec(text);
            if (!m) {
              return null;
            }
            const matchStartIndex = m.index;
            const matchLength = m[0].length;
            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
              if (matchLength === 0) {
                if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
                  this._searchRegex.lastIndex += 2;
                } else {
                  this._searchRegex.lastIndex += 1;
                }
                continue;
              }
              return null;
            }
            this._prevMatchStartIndex = matchStartIndex;
            this._prevMatchLength = matchLength;
            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
              return m;
            }
          } while (m);
          return null;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }
  var UnicodeTextModelHighlighter, CodePointHighlighter;
  var init_unicodeTextModelHighlighter = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"() {
      init_range();
      init_textModelSearch();
      init_strings();
      init_types();
      init_wordHelper();
      UnicodeTextModelHighlighter = class {
        static computeUnicodeHighlights(model, options, range) {
          const startLine = range ? range.startLineNumber : 1;
          const endLine = range ? range.endLineNumber : model.getLineCount();
          const codePointHighlighter = new CodePointHighlighter(options);
          const candidates = codePointHighlighter.getCandidateCodePoints();
          let regex;
          if (candidates === "allNonBasicAscii") {
            regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
          } else {
            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
          }
          const searcher = new Searcher(null, regex);
          const ranges = [];
          let hasMore = false;
          let m;
          let ambiguousCharacterCount = 0;
          let invisibleCharacterCount = 0;
          let nonBasicAsciiCharacterCount = 0;
          forLoop:
            for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
              const lineContent = model.getLineContent(lineNumber);
              const lineLength = lineContent.length;
              searcher.reset(0);
              do {
                m = searcher.next(lineContent);
                if (m) {
                  let startIndex = m.index;
                  let endIndex = m.index + m[0].length;
                  if (startIndex > 0) {
                    const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                    if (isHighSurrogate(charCodeBefore)) {
                      startIndex--;
                    }
                  }
                  if (endIndex + 1 < lineLength) {
                    const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                    if (isHighSurrogate(charCodeBefore)) {
                      endIndex++;
                    }
                  }
                  const str = lineContent.substring(startIndex, endIndex);
                  const word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
                  const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
                  if (highlightReason !== 0) {
                    if (highlightReason === 3) {
                      ambiguousCharacterCount++;
                    } else if (highlightReason === 2) {
                      invisibleCharacterCount++;
                    } else if (highlightReason === 1) {
                      nonBasicAsciiCharacterCount++;
                    } else {
                      assertNever(highlightReason);
                    }
                    const MAX_RESULT_LENGTH = 1e3;
                    if (ranges.length >= MAX_RESULT_LENGTH) {
                      hasMore = true;
                      break forLoop;
                    }
                    ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
                  }
                }
              } while (m);
            }
          return {
            ranges,
            hasMore,
            ambiguousCharacterCount,
            invisibleCharacterCount,
            nonBasicAsciiCharacterCount
          };
        }
        static computeUnicodeHighlightReason(char, options) {
          const codePointHighlighter = new CodePointHighlighter(options);
          const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
          switch (reason) {
            case 0:
              return null;
            case 2:
              return { kind: 1 };
            case 3: {
              const codePoint = char.codePointAt(0);
              const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
              const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
              return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
            }
            case 1:
              return { kind: 2 };
          }
        }
      };
      CodePointHighlighter = class {
        constructor(options) {
          this.options = options;
          this.allowedCodePoints = new Set(options.allowedCodePoints);
          this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
        }
        getCandidateCodePoints() {
          if (this.options.nonBasicASCII) {
            return "allNonBasicAscii";
          }
          const set = /* @__PURE__ */ new Set();
          if (this.options.invisibleCharacters) {
            for (const cp of InvisibleCharacters.codePoints) {
              if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
                set.add(cp);
              }
            }
          }
          if (this.options.ambiguousCharacters) {
            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
              set.add(cp);
            }
          }
          for (const cp of this.allowedCodePoints) {
            set.delete(cp);
          }
          return set;
        }
        shouldHighlightNonBasicASCII(character, wordContext) {
          const codePoint = character.codePointAt(0);
          if (this.allowedCodePoints.has(codePoint)) {
            return 0;
          }
          if (this.options.nonBasicASCII) {
            return 1;
          }
          let hasBasicASCIICharacters = false;
          let hasNonConfusableNonBasicAsciiCharacter = false;
          if (wordContext) {
            for (let char of wordContext) {
              const codePoint2 = char.codePointAt(0);
              const isBasicASCII2 = isBasicASCII(char);
              hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
              if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
                hasNonConfusableNonBasicAsciiCharacter = true;
              }
            }
          }
          if (!hasBasicASCIICharacters && hasNonConfusableNonBasicAsciiCharacter) {
            return 0;
          }
          if (this.options.invisibleCharacters) {
            if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
              return 2;
            }
          }
          if (this.options.ambiguousCharacters) {
            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
              return 3;
            }
          }
          return 0;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var __awaiter2, MirrorModel, EditorSimpleWorker;
  var init_editorSimpleWorker = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"() {
      init_diff();
      init_platform();
      init_uri();
      init_position();
      init_range();
      init_diffComputer();
      init_mirrorTextModel();
      init_wordHelper();
      init_linkComputer();
      init_inplaceReplaceSupport();
      init_editorBaseApi();
      init_types();
      init_stopwatch();
      init_unicodeTextModelHighlighter();
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      MirrorModel = class extends MirrorTextModel {
        get uri() {
          return this._uri;
        }
        get eol() {
          return this._eol;
        }
        getValue() {
          return this.getText();
        }
        getLinesContent() {
          return this._lines.slice(0);
        }
        getLineCount() {
          return this._lines.length;
        }
        getLineContent(lineNumber) {
          return this._lines[lineNumber - 1];
        }
        getWordAtPosition(position, wordDefinition) {
          const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
          if (wordAtText) {
            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
          }
          return null;
        }
        words(wordDefinition) {
          const lines = this._lines;
          const wordenize = this._wordenize.bind(this);
          let lineNumber = 0;
          let lineText = "";
          let wordRangesIdx = 0;
          let wordRanges = [];
          return {
            *[Symbol.iterator]() {
              while (true) {
                if (wordRangesIdx < wordRanges.length) {
                  const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                  wordRangesIdx += 1;
                  yield value;
                } else {
                  if (lineNumber < lines.length) {
                    lineText = lines[lineNumber];
                    wordRanges = wordenize(lineText, wordDefinition);
                    wordRangesIdx = 0;
                    lineNumber += 1;
                  } else {
                    break;
                  }
                }
              }
            }
          };
        }
        getLineWords(lineNumber, wordDefinition) {
          const content = this._lines[lineNumber - 1];
          const ranges = this._wordenize(content, wordDefinition);
          const words = [];
          for (const range of ranges) {
            words.push({
              word: content.substring(range.start, range.end),
              startColumn: range.start + 1,
              endColumn: range.end + 1
            });
          }
          return words;
        }
        _wordenize(content, wordDefinition) {
          const result = [];
          let match;
          wordDefinition.lastIndex = 0;
          while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
              break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
          }
          return result;
        }
        getValueInRange(range) {
          range = this._validateRange(range);
          if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
          }
          const lineEnding = this._eol;
          const startLineIndex = range.startLineNumber - 1;
          const endLineIndex = range.endLineNumber - 1;
          const resultLines = [];
          resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
          for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
          }
          resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
          return resultLines.join(lineEnding);
        }
        offsetAt(position) {
          position = this._validatePosition(position);
          this._ensureLineStarts();
          return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
        }
        positionAt(offset) {
          offset = Math.floor(offset);
          offset = Math.max(0, offset);
          this._ensureLineStarts();
          const out = this._lineStarts.getIndexOf(offset);
          const lineLength = this._lines[out.index].length;
          return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
          };
        }
        _validateRange(range) {
          const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
          const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
          if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
            return {
              startLineNumber: start.lineNumber,
              startColumn: start.column,
              endLineNumber: end.lineNumber,
              endColumn: end.column
            };
          }
          return range;
        }
        _validatePosition(position) {
          if (!Position.isIPosition(position)) {
            throw new Error("bad position");
          }
          let { lineNumber, column } = position;
          let hasChanged = false;
          if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
          } else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
          } else {
            const maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
              column = 1;
              hasChanged = true;
            } else if (column > maxCharacter) {
              column = maxCharacter;
              hasChanged = true;
            }
          }
          if (!hasChanged) {
            return position;
          } else {
            return { lineNumber, column };
          }
        }
      };
      EditorSimpleWorker = class {
        constructor(host, foreignModuleFactory) {
          this._host = host;
          this._models = /* @__PURE__ */ Object.create(null);
          this._foreignModuleFactory = foreignModuleFactory;
          this._foreignModule = null;
        }
        dispose() {
          this._models = /* @__PURE__ */ Object.create(null);
        }
        _getModel(uri) {
          return this._models[uri];
        }
        _getModels() {
          const all = [];
          Object.keys(this._models).forEach((key) => all.push(this._models[key]));
          return all;
        }
        acceptNewModel(data) {
          this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
        }
        acceptModelChanged(strURL, e) {
          if (!this._models[strURL]) {
            return;
          }
          const model = this._models[strURL];
          model.onEvents(e);
        }
        acceptRemovedModel(strURL) {
          if (!this._models[strURL]) {
            return;
          }
          delete this._models[strURL];
        }
        computeUnicodeHighlights(url, options, range) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(url);
            if (!model) {
              return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
            }
            return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
          });
        }
        computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
          return __awaiter2(this, void 0, void 0, function* () {
            const original = this._getModel(originalUrl);
            const modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
              return null;
            }
            const originalLines = original.getLinesContent();
            const modifiedLines = modified.getLinesContent();
            const diffComputer = new DiffComputer(originalLines, modifiedLines, {
              shouldComputeCharChanges: true,
              shouldPostProcessCharChanges: true,
              shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
              shouldMakePrettyDiff: true,
              maxComputationTime
            });
            const diffResult = diffComputer.computeDiff();
            const identical = diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified);
            return {
              quitEarly: diffResult.quitEarly,
              identical,
              changes: diffResult.changes
            };
          });
        }
        _modelsAreIdentical(original, modified) {
          const originalLineCount = original.getLineCount();
          const modifiedLineCount = modified.getLineCount();
          if (originalLineCount !== modifiedLineCount) {
            return false;
          }
          for (let line = 1; line <= originalLineCount; line++) {
            const originalLine = original.getLineContent(line);
            const modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
              return false;
            }
          }
          return true;
        }
        computeMoreMinimalEdits(modelUrl, edits) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return edits;
            }
            const result = [];
            let lastEol = void 0;
            edits = edits.slice(0).sort((a, b) => {
              if (a.range && b.range) {
                return Range.compareRangesUsingStarts(a.range, b.range);
              }
              const aRng = a.range ? 0 : 1;
              const bRng = b.range ? 0 : 1;
              return aRng - bRng;
            });
            for (let { range, text, eol } of edits) {
              if (typeof eol === "number") {
                lastEol = eol;
              }
              if (Range.isEmpty(range) && !text) {
                continue;
              }
              const original = model.getValueInRange(range);
              text = text.replace(/\r\n|\n|\r/g, model.eol);
              if (original === text) {
                continue;
              }
              if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                result.push({ range, text });
                continue;
              }
              const changes = stringDiff(original, text, false);
              const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
              for (const change of changes) {
                const start = model.positionAt(editOffset + change.originalStart);
                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                const newEdit = {
                  text: text.substr(change.modifiedStart, change.modifiedLength),
                  range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                };
                if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                  result.push(newEdit);
                }
              }
            }
            if (typeof lastEol === "number") {
              result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
            }
            return result;
          });
        }
        computeLinks(modelUrl) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return null;
            }
            return computeLinks(model);
          });
        }
        textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const sw = new StopWatch(true);
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const seen = /* @__PURE__ */ new Set();
            outer:
              for (let url of modelUrls) {
                const model = this._getModel(url);
                if (!model) {
                  continue;
                }
                for (let word of model.words(wordDefRegExp)) {
                  if (word === leadingWord || !isNaN(Number(word))) {
                    continue;
                  }
                  seen.add(word);
                  if (seen.size > EditorSimpleWorker._suggestionsLimit) {
                    break outer;
                  }
                }
              }
            return { words: Array.from(seen), duration: sw.elapsed() };
          });
        }
        computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return /* @__PURE__ */ Object.create(null);
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const result = /* @__PURE__ */ Object.create(null);
            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
              const words = model.getLineWords(line, wordDefRegExp);
              for (const word of words) {
                if (!isNaN(Number(word.word))) {
                  continue;
                }
                let array = result[word.word];
                if (!array) {
                  array = [];
                  result[word.word] = array;
                }
                array.push({
                  startLineNumber: line,
                  startColumn: word.startColumn,
                  endLineNumber: line,
                  endColumn: word.endColumn
                });
              }
            }
            return result;
          });
        }
        navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return null;
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
              range = {
                startLineNumber: range.startLineNumber,
                startColumn: range.startColumn,
                endLineNumber: range.endLineNumber,
                endColumn: range.endColumn + 1
              };
            }
            const selectionText = model.getValueInRange(range);
            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            if (!wordRange) {
              return null;
            }
            const word = model.getValueInRange(wordRange);
            const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return result;
          });
        }
        loadForeignModule(moduleId, createData, foreignHostMethods) {
          const proxyMethodRequest = (method, args) => {
            return this._host.fhr(method, args);
          };
          const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
          const ctx = {
            host: foreignHost,
            getMirrorModels: () => {
              return this._getModels();
            }
          };
          if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            return Promise.resolve(getAllMethodNames(this._foreignModule));
          }
          return Promise.reject(new Error(`Unexpected usage`));
        }
        fmr(method, args) {
          if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
            return Promise.reject(new Error("Missing requestHandler or method: " + method));
          }
          try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
      EditorSimpleWorker._diffLimit = 1e5;
      EditorSimpleWorker._suggestionsLimit = 1e4;
      if (typeof importScripts === "function") {
        globals.monaco = createMonacoBaseAPI();
      }
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var editor_worker_exports = {};
  __export(editor_worker_exports, {
    initialize: () => initialize
  });
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      self.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    self.onmessage = (e) => {
      simpleWorker.onmessage(e.data);
    };
  }
  var initialized;
  var init_editor_worker = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js"() {
      init_simpleWorker();
      init_editorSimpleWorker();
      initialized = false;
      self.onmessage = (e) => {
        if (!initialized) {
          initialize(null);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/version.js
  var require_version = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.versionInfo = exports.version = void 0;
      var version = "16.5.0";
      exports.version = version;
      var versionInfo = Object.freeze({
        major: 16,
        minor: 5,
        patch: 0,
        preReleaseTag: null
      });
      exports.versionInfo = versionInfo;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/devAssert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.devAssert = devAssert;
      function devAssert(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isPromise.js
  var require_isPromise = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isPromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPromise = isPromise;
      function isPromise(value) {
        return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isObjectLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isObjectLike = isObjectLike;
      function isObjectLike(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/invariant.js
  var require_invariant = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/invariant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invariant = invariant;
      function invariant(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message != null ? message : "Unexpected invariant triggered.");
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/location.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getLocation = getLocation;
      var _invariant = require_invariant();
      var LineRegExp = /\r\n|[\n\r]/g;
      function getLocation(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match of source.body.matchAll(LineRegExp)) {
          typeof match.index === "number" || (0, _invariant.invariant)(false);
          if (match.index >= position) {
            break;
          }
          lastLineStart = match.index + match[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/printLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printLocation = printLocation;
      exports.printSourceLocation = printSourceLocation;
      var _location = require_location();
      function printLocation(location) {
        return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
      }
      function printSourceLocation(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i = 0; i < locationLine.length; i += 80) {
            subLines.push(locationLine.slice(i, i + 80));
          }
          return locationStr + printPrefixedLines([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines([
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/GraphQLError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLError = void 0;
      exports.formatError = formatError;
      exports.printError = printError;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError = class extends Error {
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path !== null && path !== void 0 ? path : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
          const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => (0, _location.getLocation)(loc.source, loc.start));
          const originalExtensions = (0, _isObjectLike.isObjectLike)(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, GraphQLError);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports.GraphQLError = GraphQLError;
      function undefinedIfEmpty(array) {
        return array === void 0 || array.length === 0 ? void 0 : array;
      }
      function printError(error) {
        return error.toString();
      }
      function formatError(error) {
        return error.toJSON();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/syntaxError.js
  var require_syntaxError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/syntaxError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.syntaxError = syntaxError;
      var _GraphQLError = require_GraphQLError();
      function syntaxError(source, position, description) {
        return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
          source,
          positions: [position]
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/ast.js
  var require_ast = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/ast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
      exports.isNode = isNode;
      var Location = class {
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports.Location = Location;
      var Token2 = class {
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports.Token = Token2;
      var QueryDocumentKeys = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports.QueryDocumentKeys = QueryDocumentKeys;
      var kindValues = new Set(Object.keys(QueryDocumentKeys));
      function isNode(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues.has(maybeKind);
      }
      var OperationTypeNode;
      exports.OperationTypeNode = OperationTypeNode;
      (function(OperationTypeNode2) {
        OperationTypeNode2["QUERY"] = "query";
        OperationTypeNode2["MUTATION"] = "mutation";
        OperationTypeNode2["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/directiveLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DirectiveLocation = void 0;
      var DirectiveLocation;
      exports.DirectiveLocation = DirectiveLocation;
      (function(DirectiveLocation2) {
        DirectiveLocation2["QUERY"] = "QUERY";
        DirectiveLocation2["MUTATION"] = "MUTATION";
        DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation2["FIELD"] = "FIELD";
        DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation2["SCHEMA"] = "SCHEMA";
        DirectiveLocation2["SCALAR"] = "SCALAR";
        DirectiveLocation2["OBJECT"] = "OBJECT";
        DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation2["INTERFACE"] = "INTERFACE";
        DirectiveLocation2["UNION"] = "UNION";
        DirectiveLocation2["ENUM"] = "ENUM";
        DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/kinds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Kind = void 0;
      var Kind;
      exports.Kind = Kind;
      (function(Kind2) {
        Kind2["NAME"] = "Name";
        Kind2["DOCUMENT"] = "Document";
        Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind2["SELECTION_SET"] = "SelectionSet";
        Kind2["FIELD"] = "Field";
        Kind2["ARGUMENT"] = "Argument";
        Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind2["INLINE_FRAGMENT"] = "InlineFragment";
        Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind2["VARIABLE"] = "Variable";
        Kind2["INT"] = "IntValue";
        Kind2["FLOAT"] = "FloatValue";
        Kind2["STRING"] = "StringValue";
        Kind2["BOOLEAN"] = "BooleanValue";
        Kind2["NULL"] = "NullValue";
        Kind2["ENUM"] = "EnumValue";
        Kind2["LIST"] = "ListValue";
        Kind2["OBJECT"] = "ObjectValue";
        Kind2["OBJECT_FIELD"] = "ObjectField";
        Kind2["DIRECTIVE"] = "Directive";
        Kind2["NAMED_TYPE"] = "NamedType";
        Kind2["LIST_TYPE"] = "ListType";
        Kind2["NON_NULL_TYPE"] = "NonNullType";
        Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind2["FIELD_DEFINITION"] = "FieldDefinition";
        Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind || (exports.Kind = Kind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/characterClasses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDigit = isDigit;
      exports.isLetter = isLetter;
      exports.isNameContinue = isNameContinue;
      exports.isNameStart = isNameStart;
      exports.isWhiteSpace = isWhiteSpace;
      function isWhiteSpace(code) {
        return code === 9 || code === 32;
      }
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter(code) {
        return code >= 97 && code <= 122 || code >= 65 && code <= 90;
      }
      function isNameStart(code) {
        return isLetter(code) || code === 95;
      }
      function isNameContinue(code) {
        return isLetter(code) || isDigit(code) || code === 95;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/blockString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dedentBlockStringLines = dedentBlockStringLines;
      exports.isPrintableAsBlockString = isPrintableAsBlockString;
      exports.printBlockString = printBlockString;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i = 0; i < lines.length; ++i) {
          var _firstNonEmptyLine;
          const line = lines[i];
          const indent = leadingWhitespace(line);
          if (indent === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
          lastNonEmptyLine = i;
          if (i !== 0 && indent < commonIndent) {
            commonIndent = indent;
          }
        }
        return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
      }
      function leadingWhitespace(str) {
        let i = 0;
        while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
          ++i;
        }
        return i;
      }
      function isPrintableAsBlockString(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i = 0; i < value.length; ++i) {
          switch (value.codePointAt(i)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            case 13:
              return false;
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0)));
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/tokenKind.js
  var require_tokenKind = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/tokenKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TokenKind = void 0;
      var TokenKind;
      exports.TokenKind = TokenKind;
      (function(TokenKind2) {
        TokenKind2["SOF"] = "<SOF>";
        TokenKind2["EOF"] = "<EOF>";
        TokenKind2["BANG"] = "!";
        TokenKind2["DOLLAR"] = "$";
        TokenKind2["AMP"] = "&";
        TokenKind2["PAREN_L"] = "(";
        TokenKind2["PAREN_R"] = ")";
        TokenKind2["SPREAD"] = "...";
        TokenKind2["COLON"] = ":";
        TokenKind2["EQUALS"] = "=";
        TokenKind2["AT"] = "@";
        TokenKind2["BRACKET_L"] = "[";
        TokenKind2["BRACKET_R"] = "]";
        TokenKind2["BRACE_L"] = "{";
        TokenKind2["PIPE"] = "|";
        TokenKind2["BRACE_R"] = "}";
        TokenKind2["NAME"] = "Name";
        TokenKind2["INT"] = "Int";
        TokenKind2["FLOAT"] = "Float";
        TokenKind2["STRING"] = "String";
        TokenKind2["BLOCK_STRING"] = "BlockString";
        TokenKind2["COMMENT"] = "Comment";
      })(TokenKind || (exports.TokenKind = TokenKind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/lexer.js
  var require_lexer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/lexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Lexer = void 0;
      exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _blockString = require_blockString();
      var _characterClasses = require_characterClasses();
      var _tokenKind = require_tokenKind();
      var Lexer = class {
        constructor(source) {
          const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        advance() {
          this.lastToken = this.token;
          const token = this.token = this.lookahead();
          return token;
        }
        lookahead() {
          let token = this.token;
          if (token.kind !== _tokenKind.TokenKind.EOF) {
            do {
              if (token.next) {
                token = token.next;
              } else {
                const nextToken = readNextToken(this, token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
              }
            } while (token.kind === _tokenKind.TokenKind.COMMENT);
          }
          return token;
        }
      };
      exports.Lexer = Lexer;
      function isPunctuatorTokenKind(kind) {
        return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
      }
      function isUnicodeScalarValue(code) {
        return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
      }
      function isSupplementaryCodePoint(body, location) {
        return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
      }
      function isLeadingSurrogate(code) {
        return code >= 55296 && code <= 56319;
      }
      function isTrailingSurrogate(code) {
        return code >= 56320 && code <= 57343;
      }
      function printCodePointAt(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === void 0) {
          return _tokenKind.TokenKind.EOF;
        } else if (code >= 32 && code <= 126) {
          const char = String.fromCodePoint(code);
          return char === '"' ? `'"'` : `"${char}"`;
        }
        return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
      }
      function createToken(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new _ast.Token(kind, start, end, line, col, value);
      }
      function readNextToken(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          switch (code) {
            case 65279:
            case 9:
            case 32:
            case 44:
              ++position;
              continue;
            case 10:
              ++position;
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 13:
              if (body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 35:
              return readComment(lexer, position);
            case 33:
              return createToken(lexer, _tokenKind.TokenKind.BANG, position, position + 1);
            case 36:
              return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position, position + 1);
            case 38:
              return createToken(lexer, _tokenKind.TokenKind.AMP, position, position + 1);
            case 40:
              return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position, position + 1);
            case 41:
              return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position, position + 1);
            case 46:
              if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                return createToken(lexer, _tokenKind.TokenKind.SPREAD, position, position + 3);
              }
              break;
            case 58:
              return createToken(lexer, _tokenKind.TokenKind.COLON, position, position + 1);
            case 61:
              return createToken(lexer, _tokenKind.TokenKind.EQUALS, position, position + 1);
            case 64:
              return createToken(lexer, _tokenKind.TokenKind.AT, position, position + 1);
            case 91:
              return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position, position + 1);
            case 93:
              return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position, position + 1);
            case 123:
              return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position, position + 1);
            case 124:
              return createToken(lexer, _tokenKind.TokenKind.PIPE, position, position + 1);
            case 125:
              return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position, position + 1);
            case 34:
              if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                return readBlockString(lexer, position);
              }
              return readString(lexer, position);
          }
          if ((0, _characterClasses.isDigit)(code) || code === 45) {
            return readNumber(lexer, position, code);
          }
          if ((0, _characterClasses.isNameStart)(code)) {
            return readName(lexer, position);
          }
          throw (0, _syntaxError.syntaxError)(lexer.source, position, code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
        }
        return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
      }
      function readComment(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            break;
          }
        }
        return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position, body.slice(start + 1, position));
      }
      function readNumber(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 45) {
          code = body.charCodeAt(++position);
        }
        if (code === 48) {
          code = body.charCodeAt(++position);
          if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
          }
        } else {
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46) {
          isFloat = true;
          code = body.charCodeAt(++position);
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 69 || code === 101) {
          isFloat = true;
          code = body.charCodeAt(++position);
          if (code === 43 || code === 45) {
            code = body.charCodeAt(++position);
          }
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
          throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
        }
        return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, body.slice(start, position));
      }
      function readDigits(lexer, start, firstCode) {
        if (!(0, _characterClasses.isDigit)(firstCode)) {
          throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
        }
        const body = lexer.source.body;
        let position = start + 1;
        while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
          ++position;
        }
        return position;
      }
      function readString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = "";
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34) {
            value += body.slice(chunkStart, position);
            return createToken(lexer, _tokenKind.TokenKind.STRING, start, position + 1, value);
          }
          if (code === 92) {
            value += body.slice(chunkStart, position);
            const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
            value += escape.value;
            position += escape.size;
            chunkStart = position;
            continue;
          }
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
      }
      function readEscapedUnicodeVariableWidth(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while (size < 12) {
          const code = body.charCodeAt(position + size++);
          if (code === 125) {
            if (size < 5 || !isUnicodeScalarValue(point)) {
              break;
            }
            return {
              value: String.fromCodePoint(point),
              size
            };
          }
          point = point << 4 | readHexDigit(code);
          if (point < 0) {
            break;
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
      }
      function readEscapedUnicodeFixedWidth(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode(body, position + 2);
        if (isUnicodeScalarValue(code)) {
          return {
            value: String.fromCodePoint(code),
            size: 6
          };
        }
        if (isLeadingSurrogate(code)) {
          if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
            const trailingCode = read16BitHexCode(body, position + 8);
            if (isTrailingSurrogate(trailingCode)) {
              return {
                value: String.fromCodePoint(code, trailingCode),
                size: 12
              };
            }
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
      }
      function read16BitHexCode(body, position) {
        return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
      }
      function readHexDigit(code) {
        return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
      }
      function readEscapedCharacter(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch (code) {
          case 34:
            return {
              value: '"',
              size: 2
            };
          case 92:
            return {
              value: "\\",
              size: 2
            };
          case 47:
            return {
              value: "/",
              size: 2
            };
          case 98:
            return {
              value: "\b",
              size: 2
            };
          case 102:
            return {
              value: "\f",
              size: 2
            };
          case 110:
            return {
              value: "\n",
              size: 2
            };
          case 114:
            return {
              value: "\r",
              size: 2
            };
          case 116:
            return {
              value: "	",
              size: 2
            };
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
      }
      function readBlockString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = "";
        const blockLines = [];
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position + 3, (0, _blockString.dedentBlockStringLines)(blockLines).join("\n"));
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token;
          }
          if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1;
            position += 4;
            continue;
          }
          if (code === 10 || code === 13) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 13 && body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
      }
      function readName(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
          } else {
            break;
          }
        }
        return createToken(lexer, _tokenKind.TokenKind.NAME, start, position, body.slice(start, position));
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/inspect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inspect = inspect;
      var MAX_ARRAY_LENGTH = 10;
      var MAX_RECURSIVE_DEPTH = 2;
      function inspect(value) {
        return formatValue(value, []);
      }
      function formatValue(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray(value, seenValues);
        }
        return formatObject(value, seenValues);
      }
      function isJSONable(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[" + getObjectTag(object) + "]";
        }
        const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray(array, seenValues) {
        if (array.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH, array.length);
        const remaining = array.length - len;
        const items = [];
        for (let i = 0; i < len; ++i) {
          items.push(formatValue(array[i], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object.constructor === "function") {
          const name = object.constructor.name;
          if (typeof name === "string" && name !== "") {
            return name;
          }
        }
        return tag;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/instanceOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.instanceOf = void 0;
      var _inspect = require_inspect();
      var instanceOf = false ? function instanceOf2(value, constructor) {
        return value instanceof constructor;
      } : function instanceOf2(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
          if (className === valueClassName) {
            const stringifiedValue = (0, _inspect.inspect)(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      };
      exports.instanceOf = instanceOf;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/source.js
  var require_source = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Source = void 0;
      exports.isSource = isSource;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var Source = class {
        constructor(body, name = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || (0, _devAssert.devAssert)(false, `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`);
          this.body = body;
          this.name = name;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || (0, _devAssert.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
          this.locationOffset.column > 0 || (0, _devAssert.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
      exports.Source = Source;
      function isSource(source) {
        return (0, _instanceOf.instanceOf)(source, Source);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/parser.js
  var require_parser = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Parser = void 0;
      exports.parse = parse;
      exports.parseConstValue = parseConstValue;
      exports.parseType = parseType;
      exports.parseValue = parseValue;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function parse(source, options) {
        const parser = new Parser(source, options);
        return parser.parseDocument();
      }
      function parseValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseConstValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseType(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const type = parser.parseTypeReference();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return type;
      }
      var Parser = class {
        constructor(source, options) {
          const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
          this._lexer = new _lexer.Lexer(sourceObj);
          this._options = options;
        }
        parseName() {
          const token = this.expectToken(_tokenKind.TokenKind.NAME);
          return this.node(token, {
            kind: _kinds.Kind.NAME,
            value: token.value
          });
        }
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)
          });
        }
        parseDefinition() {
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: _kinds.Kind.OPERATION_DEFINITION,
              operation: _ast.OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name;
          if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
          }
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseOperationType() {
          const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return _ast.OperationTypeNode.QUERY;
            case "mutation":
              return _ast.OperationTypeNode.MUTATION;
            case "subscription":
              return _ast.OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        parseVariableDefinitions() {
          return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
        }
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.DOLLAR);
          return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
          });
        }
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)
          });
        }
        parseSelection() {
          return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name;
          if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
          } else {
            name = nameOrAlias;
          }
          return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
        }
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseFragmentDefinition() {
          var _this$_options;
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        parseValueLiteral(isConst) {
          const token = this._lexer.token;
          switch (token.kind) {
            case _tokenKind.TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
              this._lexer.advance();
              return this.node(token, {
                kind: _kinds.Kind.INT,
                value: token.value
              });
            case _tokenKind.TokenKind.FLOAT:
              this._lexer.advance();
              return this.node(token, {
                kind: _kinds.Kind.FLOAT,
                value: token.value
              });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
              this._lexer.advance();
              switch (token.value) {
                case "true":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token, {
                    kind: _kinds.Kind.NULL
                  });
                default:
                  return this.node(token, {
                    kind: _kinds.Kind.ENUM,
                    value: token.value
                  });
              }
            case _tokenKind.TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(_tokenKind.TokenKind.DOLLAR);
                if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
                } else {
                  throw this.unexpected(token);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token = this._lexer.token;
          this._lexer.advance();
          return this.node(token, {
            kind: _kinds.Kind.STRING,
            value: token.value,
            block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
          });
        }
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)
          });
        }
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)
          });
        }
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(_tokenKind.TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.AT);
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        parseTypeReference() {
          const start = this._lexer.token;
          let type;
          if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type = this.node(start, {
              kind: _kinds.Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type = this.parseNamedType();
          }
          if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
              kind: _kinds.Kind.NON_NULL_TYPE,
              type
            });
          }
          return type;
        }
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        peekDescription() {
          return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
        }
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseNamedType();
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type
          });
        }
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
          });
        }
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
        }
        parseFieldsDefinition() {
          return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
        }
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type,
            directives
          });
        }
        parseArgumentDefs() {
          return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
        }
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type,
            defaultValue,
            directives
          });
        }
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types
          });
        }
        parseUnionMemberTypes() {
          return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
        }
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
          });
        }
        parseEnumValuesDefinition() {
          return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
        }
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
          });
        }
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
          }
          return this.parseName();
        }
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
          });
        }
        parseInputFieldsDefinition() {
          return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
        }
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
          });
        }
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          if (directives.length === 0 && types.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types
          });
        }
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
          });
        }
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
          });
        }
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(_tokenKind.TokenKind.AT);
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
          });
        }
        parseDirectiveLocations() {
          return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
        }
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name = this.parseName();
          if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {
            return name;
          }
          throw this.unexpected(start);
        }
        node(startToken, node) {
          var _this$_options2;
          if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {
            node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
          }
          return node;
        }
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        expectToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this._lexer.advance();
            return token;
          }
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
        }
        expectOptionalToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this._lexer.advance();
            return true;
          }
          return false;
        }
        expectKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this._lexer.advance();
          } else {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
          }
        }
        expectOptionalKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this._lexer.advance();
            return true;
          }
          return false;
        }
        unexpected(atToken) {
          const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
        }
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
      };
      exports.Parser = Parser;
      function getTokenDesc(token) {
        const value = token.value;
        return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
      }
      function getTokenKindDesc(kind) {
        return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/didYouMean.js
  var require_didYouMean = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/didYouMean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.didYouMean = didYouMean;
      var MAX_SUGGESTIONS = 5;
      function didYouMean(firstArg, secondArg) {
        const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
        let message = " Did you mean ";
        if (subMessage) {
          message += subMessage + " ";
        }
        const suggestions = suggestionsArg.map((x) => `"${x}"`);
        switch (suggestions.length) {
          case 0:
            return "";
          case 1:
            return message + suggestions[0] + "?";
          case 2:
            return message + suggestions[0] + " or " + suggestions[1] + "?";
        }
        const selected = suggestions.slice(0, MAX_SUGGESTIONS);
        const lastItem = selected.pop();
        return message + selected.join(", ") + ", or " + lastItem + "?";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/identityFunc.js
  var require_identityFunc = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/identityFunc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.identityFunc = identityFunc;
      function identityFunc(x) {
        return x;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/keyMap.js
  var require_keyMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/keyMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyMap = keyMap;
      function keyMap(list, keyFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = item;
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/keyValMap.js
  var require_keyValMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/keyValMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyValMap = keyValMap;
      function keyValMap(list, keyFn, valFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = valFn(item);
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/mapValue.js
  var require_mapValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/mapValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapValue = mapValue;
      function mapValue(map, fn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map)) {
          result[key] = fn(map[key], key);
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/naturalCompare.js
  var require_naturalCompare = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/naturalCompare.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.naturalCompare = naturalCompare;
      function naturalCompare(aStr, bStr) {
        let aIndex = 0;
        let bIndex = 0;
        while (aIndex < aStr.length && bIndex < bStr.length) {
          let aChar = aStr.charCodeAt(aIndex);
          let bChar = bStr.charCodeAt(bIndex);
          if (isDigit(aChar) && isDigit(bChar)) {
            let aNum = 0;
            do {
              ++aIndex;
              aNum = aNum * 10 + aChar - DIGIT_0;
              aChar = aStr.charCodeAt(aIndex);
            } while (isDigit(aChar) && aNum > 0);
            let bNum = 0;
            do {
              ++bIndex;
              bNum = bNum * 10 + bChar - DIGIT_0;
              bChar = bStr.charCodeAt(bIndex);
            } while (isDigit(bChar) && bNum > 0);
            if (aNum < bNum) {
              return -1;
            }
            if (aNum > bNum) {
              return 1;
            }
          } else {
            if (aChar < bChar) {
              return -1;
            }
            if (aChar > bChar) {
              return 1;
            }
            ++aIndex;
            ++bIndex;
          }
        }
        return aStr.length - bStr.length;
      }
      var DIGIT_0 = 48;
      var DIGIT_9 = 57;
      function isDigit(code) {
        return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/suggestionList.js
  var require_suggestionList = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/suggestionList.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.suggestionList = suggestionList;
      var _naturalCompare = require_naturalCompare();
      function suggestionList(input, options) {
        const optionsByDistance = /* @__PURE__ */ Object.create(null);
        const lexicalDistance = new LexicalDistance(input);
        const threshold = Math.floor(input.length * 0.4) + 1;
        for (const option of options) {
          const distance = lexicalDistance.measure(option, threshold);
          if (distance !== void 0) {
            optionsByDistance[option] = distance;
          }
        }
        return Object.keys(optionsByDistance).sort((a, b) => {
          const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
          return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
        });
      }
      var LexicalDistance = class {
        constructor(input) {
          this._input = input;
          this._inputLowerCase = input.toLowerCase();
          this._inputArray = stringToArray(this._inputLowerCase);
          this._rows = [
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0)
          ];
        }
        measure(option, threshold) {
          if (this._input === option) {
            return 0;
          }
          const optionLowerCase = option.toLowerCase();
          if (this._inputLowerCase === optionLowerCase) {
            return 1;
          }
          let a = stringToArray(optionLowerCase);
          let b = this._inputArray;
          if (a.length < b.length) {
            const tmp = a;
            a = b;
            b = tmp;
          }
          const aLength = a.length;
          const bLength = b.length;
          if (aLength - bLength > threshold) {
            return void 0;
          }
          const rows = this._rows;
          for (let j = 0; j <= bLength; j++) {
            rows[0][j] = j;
          }
          for (let i = 1; i <= aLength; i++) {
            const upRow = rows[(i - 1) % 3];
            const currentRow = rows[i % 3];
            let smallestCell = currentRow[0] = i;
            for (let j = 1; j <= bLength; j++) {
              const cost = a[i - 1] === b[j - 1] ? 0 : 1;
              let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
              if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
                currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
              }
              if (currentCell < smallestCell) {
                smallestCell = currentCell;
              }
              currentRow[j] = currentCell;
            }
            if (smallestCell > threshold) {
              return void 0;
            }
          }
          const distance = rows[aLength % 3][bLength];
          return distance <= threshold ? distance : void 0;
        }
      };
      function stringToArray(str) {
        const strLength = str.length;
        const array = new Array(strLength);
        for (let i = 0; i < strLength; ++i) {
          array[i] = str.charCodeAt(i);
        }
        return array;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/toObjMap.js
  var require_toObjMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/toObjMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toObjMap = toObjMap;
      function toObjMap(obj) {
        if (obj == null) {
          return /* @__PURE__ */ Object.create(null);
        }
        if (Object.getPrototypeOf(obj) === null) {
          return obj;
        }
        const map = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of Object.entries(obj)) {
          map[key] = value;
        }
        return map;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/printString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printString = printString;
      function printString(str) {
        return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
      }
      var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer(str) {
        return escapeSequences[str.charCodeAt(0)];
      }
      var escapeSequences = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/visitor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BREAK = void 0;
      exports.getEnterLeaveForKind = getEnterLeaveForKind;
      exports.getVisitFn = getVisitFn;
      exports.visit = visit;
      exports.visitInParallel = visitInParallel;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var BREAK = Object.freeze({});
      exports.BREAK = BREAK;
      function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path[path.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(false, `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`);
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i = 0; i < visitors.length; ++i) {
            const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                  if (result === false) {
                    skipping[i] = node;
                  } else if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                  if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i] === node) {
                  skipping[i] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.print = print;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor();
      function print(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer);
      }
      var MAX_LINE_LENGTH = 80;
      var printDocASTReducer = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        Document: {
          leave: (node) => join(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join([
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ], " ");
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block(selections)
        },
        Field: {
          leave({ alias, name, arguments: args, directives, selectionSet }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
              argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([argsLine, join(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name, value }) => name + ": " + value
        },
        FragmentSpread: {
          leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join([
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ], " ")
        },
        FragmentDefinition: {
          leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        },
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name, value }) => name + ": " + value
        },
        Directive: {
          leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
        },
        NamedType: {
          leave: ({ name }) => name
        },
        ListType: {
          leave: ({ type }) => "[" + type + "]"
        },
        NonNullType: {
          leave: ({ type }) => type + "!"
        },
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        FieldDefinition: {
          leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        UnionTypeDefinition: {
          leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
        },
        EnumTypeDefinition: {
          leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
        },
        ScalarTypeExtension: {
          leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join([
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        InterfaceTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join([
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        UnionTypeExtension: {
          leave: ({ name, directives, types }) => join([
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ], " ")
        },
        EnumTypeExtension: {
          leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
        }
      };
      function join(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block(array) {
        return wrap("{\n", indent(join(array, "\n")), "\n}");
      }
      function wrap(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent(str) {
        return wrap("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/valueFromASTUntyped.js
  var require_valueFromASTUntyped = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/valueFromASTUntyped.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromASTUntyped = valueFromASTUntyped;
      var _keyValMap = require_keyValMap();
      var _kinds = require_kinds();
      function valueFromASTUntyped(valueNode, variables) {
        switch (valueNode.kind) {
          case _kinds.Kind.NULL:
            return null;
          case _kinds.Kind.INT:
            return parseInt(valueNode.value, 10);
          case _kinds.Kind.FLOAT:
            return parseFloat(valueNode.value);
          case _kinds.Kind.STRING:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.BOOLEAN:
            return valueNode.value;
          case _kinds.Kind.LIST:
            return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
          case _kinds.Kind.OBJECT:
            return (0, _keyValMap.keyValMap)(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
          case _kinds.Kind.VARIABLE:
            return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/assertName.js
  var require_assertName = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/assertName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertEnumValueName = assertEnumValueName;
      exports.assertName = assertName;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _characterClasses = require_characterClasses();
      function assertName(name) {
        name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.length === 0) {
          throw new _GraphQLError.GraphQLError("Expected name to be a non-empty string.");
        }
        for (let i = 1; i < name.length; ++i) {
          if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
            throw new _GraphQLError.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
          }
        }
        if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
          throw new _GraphQLError.GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
        }
        return name;
      }
      function assertEnumValueName(name) {
        if (name === "true" || name === "false" || name === "null") {
          throw new _GraphQLError.GraphQLError(`Enum values cannot be named: ${name}`);
        }
        return assertName(name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/definition.js
  var require_definition = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/definition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = void 0;
      exports.argsToArgsConfig = argsToArgsConfig;
      exports.assertAbstractType = assertAbstractType;
      exports.assertCompositeType = assertCompositeType;
      exports.assertEnumType = assertEnumType;
      exports.assertInputObjectType = assertInputObjectType;
      exports.assertInputType = assertInputType;
      exports.assertInterfaceType = assertInterfaceType;
      exports.assertLeafType = assertLeafType;
      exports.assertListType = assertListType;
      exports.assertNamedType = assertNamedType;
      exports.assertNonNullType = assertNonNullType;
      exports.assertNullableType = assertNullableType;
      exports.assertObjectType = assertObjectType;
      exports.assertOutputType = assertOutputType;
      exports.assertScalarType = assertScalarType;
      exports.assertType = assertType;
      exports.assertUnionType = assertUnionType;
      exports.assertWrappingType = assertWrappingType;
      exports.defineArguments = defineArguments;
      exports.getNamedType = getNamedType;
      exports.getNullableType = getNullableType;
      exports.isAbstractType = isAbstractType;
      exports.isCompositeType = isCompositeType;
      exports.isEnumType = isEnumType;
      exports.isInputObjectType = isInputObjectType;
      exports.isInputType = isInputType;
      exports.isInterfaceType = isInterfaceType;
      exports.isLeafType = isLeafType;
      exports.isListType = isListType;
      exports.isNamedType = isNamedType;
      exports.isNonNullType = isNonNullType;
      exports.isNullableType = isNullableType;
      exports.isObjectType = isObjectType;
      exports.isOutputType = isOutputType;
      exports.isRequiredArgument = isRequiredArgument;
      exports.isRequiredInputField = isRequiredInputField;
      exports.isScalarType = isScalarType;
      exports.isType = isType;
      exports.isUnionType = isUnionType;
      exports.isWrappingType = isWrappingType;
      exports.resolveObjMapThunk = resolveObjMapThunk;
      exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
      var _devAssert = require_devAssert();
      var _didYouMean = require_didYouMean();
      var _identityFunc = require_identityFunc();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _keyMap = require_keyMap();
      var _keyValMap = require_keyValMap();
      var _mapValue = require_mapValue();
      var _suggestionList = require_suggestionList();
      var _toObjMap = require_toObjMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _assertName = require_assertName();
      function isType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
      }
      function assertType(type) {
        if (!isType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`);
        }
        return type;
      }
      function isScalarType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
      }
      function assertScalarType(type) {
        if (!isScalarType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`);
        }
        return type;
      }
      function isObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
      }
      function assertObjectType(type) {
        if (!isObjectType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`);
        }
        return type;
      }
      function isInterfaceType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
      }
      function assertInterfaceType(type) {
        if (!isInterfaceType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`);
        }
        return type;
      }
      function isUnionType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
      }
      function assertUnionType(type) {
        if (!isUnionType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`);
        }
        return type;
      }
      function isEnumType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
      }
      function assertEnumType(type) {
        if (!isEnumType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`);
        }
        return type;
      }
      function isInputObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
      }
      function assertInputObjectType(type) {
        if (!isInputObjectType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Input Object type.`);
        }
        return type;
      }
      function isListType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLList);
      }
      function assertListType(type) {
        if (!isListType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`);
        }
        return type;
      }
      function isNonNullType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
      }
      function assertNonNullType(type) {
        if (!isNonNullType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`);
        }
        return type;
      }
      function isInputType(type) {
        return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
      }
      function assertInputType(type) {
        if (!isInputType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`);
        }
        return type;
      }
      function isOutputType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
      }
      function assertOutputType(type) {
        if (!isOutputType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`);
        }
        return type;
      }
      function isLeafType(type) {
        return isScalarType(type) || isEnumType(type);
      }
      function assertLeafType(type) {
        if (!isLeafType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`);
        }
        return type;
      }
      function isCompositeType(type) {
        return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
      }
      function assertCompositeType(type) {
        if (!isCompositeType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`);
        }
        return type;
      }
      function isAbstractType(type) {
        return isInterfaceType(type) || isUnionType(type);
      }
      function assertAbstractType(type) {
        if (!isAbstractType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`);
        }
        return type;
      }
      var GraphQLList = class {
        constructor(ofType) {
          isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLList";
        }
        toString() {
          return "[" + String(this.ofType) + "]";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLList = GraphQLList;
      var GraphQLNonNull = class {
        constructor(ofType) {
          isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLNonNull";
        }
        toString() {
          return String(this.ofType) + "!";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLNonNull = GraphQLNonNull;
      function isWrappingType(type) {
        return isListType(type) || isNonNullType(type);
      }
      function assertWrappingType(type) {
        if (!isWrappingType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`);
        }
        return type;
      }
      function isNullableType(type) {
        return isType(type) && !isNonNullType(type);
      }
      function assertNullableType(type) {
        if (!isNullableType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`);
        }
        return type;
      }
      function getNullableType(type) {
        if (type) {
          return isNonNullType(type) ? type.ofType : type;
        }
      }
      function isNamedType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
      }
      function assertNamedType(type) {
        if (!isNamedType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`);
        }
        return type;
      }
      function getNamedType(type) {
        if (type) {
          let unwrappedType = type;
          while (isWrappingType(unwrappedType)) {
            unwrappedType = unwrappedType.ofType;
          }
          return unwrappedType;
        }
      }
      function resolveReadonlyArrayThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      function resolveObjMapThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      var GraphQLScalarType = class {
        constructor(config) {
          var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
          const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.specifiedByURL = config.specifiedByURL;
          this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
          this.parseValue = parseValue;
          this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`);
          config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
          if (config.parseLiteral) {
            typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLScalarType";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLScalarType = GraphQLScalarType;
      var GraphQLObjectType = class {
        constructor(config) {
          var _config$extensionASTN2;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.isTypeOf = config.isTypeOf;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
          this._fields = () => defineFieldMap(config);
          this._interfaces = () => defineInterfaces(config);
          config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLObjectType = GraphQLObjectType;
      function defineInterfaces(config) {
        var _config$interfaces;
        const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
        Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
        return interfaces;
      }
      function defineFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          var _fieldConfig$args;
          isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field config must be an object.`);
          fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);
          const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
          isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            args: defineArguments(argsConfig),
            resolve: fieldConfig.resolve,
            subscribe: fieldConfig.subscribe,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function defineArguments(config) {
        return Object.entries(config).map(([argName, argConfig]) => ({
          name: (0, _assertName.assertName)(argName),
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
          astNode: argConfig.astNode
        }));
      }
      function isPlainObj(obj) {
        return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
      }
      function fieldsToFieldsConfig(fields) {
        return (0, _mapValue.mapValue)(fields, (field) => ({
          description: field.description,
          type: field.type,
          args: argsToArgsConfig(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
      }
      function argsToArgsConfig(args) {
        return (0, _keyValMap.keyValMap)(args, (arg) => arg.name, (arg) => ({
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        }));
      }
      function isRequiredArgument(arg) {
        return isNonNullType(arg.type) && arg.defaultValue === void 0;
      }
      var GraphQLInterfaceType = class {
        constructor(config) {
          var _config$extensionASTN3;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
          this._fields = defineFieldMap.bind(void 0, config);
          this._interfaces = defineInterfaces.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInterfaceType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInterfaceType = GraphQLInterfaceType;
      var GraphQLUnionType = class {
        constructor(config) {
          var _config$extensionASTN4;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
          this._types = defineTypes.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLUnionType";
        }
        getTypes() {
          if (typeof this._types === "function") {
            this._types = this._types();
          }
          return this._types;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLUnionType = GraphQLUnionType;
      function defineTypes(config) {
        const types = resolveReadonlyArrayThunk(config.types);
        Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
        return types;
      }
      var GraphQLEnumType = class {
        constructor(config) {
          var _config$extensionASTN5;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
          this._values = defineEnumValues(this.name, config.values);
          this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
          this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLEnumType";
        }
        getValues() {
          return this._values;
        }
        getValue(name) {
          return this._nameLookup[name];
        }
        serialize(outputValue) {
          const enumValue = this._valueLookup.get(outputValue);
          if (enumValue === void 0) {
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
          }
          return enumValue.name;
        }
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            const valueStr = (0, _inspect.inspect)(inputValue);
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
          }
          const enumValue = this.getValue(inputValue);
          if (enumValue == null) {
            throw new _GraphQLError.GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
          }
          return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
          if (valueNode.kind !== _kinds.Kind.ENUM) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
              nodes: valueNode
            });
          }
          const enumValue = this.getValue(valueNode.value);
          if (enumValue == null) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
              nodes: valueNode
            });
          }
          return enumValue.value;
        }
        toConfig() {
          const values = (0, _keyValMap.keyValMap)(this.getValues(), (value) => value.name, (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLEnumType = GraphQLEnumType;
      function didYouMeanEnumValue(enumType, unknownValueStr) {
        const allNames = enumType.getValues().map((value) => value.name);
        const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);
        return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
      }
      function defineEnumValues(typeName, valueMap) {
        isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);
        return Object.entries(valueMap).map(([valueName, valueConfig]) => {
          isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);
          return {
            name: (0, _assertName.assertEnumValueName)(valueName),
            description: valueConfig.description,
            value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
            deprecationReason: valueConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
            astNode: valueConfig.astNode
          };
        });
      }
      var GraphQLInputObjectType = class {
        constructor(config) {
          var _config$extensionASTN6;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
          this._fields = defineInputFieldMap.bind(void 0, config);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInputObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        toConfig() {
          const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInputObjectType = GraphQLInputObjectType;
      function defineInputFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            defaultValue: fieldConfig.defaultValue,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function isRequiredInputField(field) {
        return isNonNullType(field.type) && field.defaultValue === void 0;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/typeComparators.js
  var require_typeComparators = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/typeComparators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doTypesOverlap = doTypesOverlap;
      exports.isEqualType = isEqualType;
      exports.isTypeSubTypeOf = isTypeSubTypeOf;
      var _definition = require_definition();
      function isEqualType(typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        return false;
      }
      function isTypeSubTypeOf(schema, maybeSubType, superType) {
        if (maybeSubType === superType) {
          return true;
        }
        if ((0, _definition.isNonNullType)(superType)) {
          if ((0, _definition.isNonNullType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
        }
        if ((0, _definition.isListType)(superType)) {
          if ((0, _definition.isListType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isListType)(maybeSubType)) {
          return false;
        }
        return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
      }
      function doTypesOverlap(schema, typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isAbstractType)(typeA)) {
          if ((0, _definition.isAbstractType)(typeB)) {
            return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
          }
          return schema.isSubType(typeA, typeB);
        }
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.isSubType(typeB, typeA);
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/scalars.js
  var require_scalars = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/scalars.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = void 0;
      exports.isSpecifiedScalarType = isSpecifiedScalarType;
      exports.specifiedScalarTypes = void 0;
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var GRAPHQL_MAX_INT = 2147483647;
      exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
      var GRAPHQL_MIN_INT = -2147483648;
      exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
      var GraphQLInt = new _definition.GraphQLScalarType({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(coercedValue)}`);
          }
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue));
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _printer.print)(valueNode)}`, {
              nodes: valueNode
            });
          }
          const num = parseInt(valueNode.value, 10);
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
              nodes: valueNode
            });
          }
          return num;
        }
      });
      exports.GraphQLInt = GraphQLInt;
      var GraphQLFloat = new _definition.GraphQLScalarType({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(coercedValue)}`);
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _printer.print)(valueNode)}`, valueNode);
          }
          return parseFloat(valueNode.value);
        }
      });
      exports.GraphQLFloat = GraphQLFloat;
      var GraphQLString = new _definition.GraphQLScalarType({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
          }
          if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
          }
          throw new _GraphQLError.GraphQLError(`String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING) {
            throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _printer.print)(valueNode)}`, {
              nodes: valueNode
            });
          }
          return valueNode.value;
        }
      });
      exports.GraphQLString = GraphQLString;
      var GraphQLBoolean = new _definition.GraphQLScalarType({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue;
          }
          if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
          }
          throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(coercedValue)}`);
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "boolean") {
            throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
            throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _printer.print)(valueNode)}`, {
              nodes: valueNode
            });
          }
          return valueNode.value;
        }
      });
      exports.GraphQLBoolean = GraphQLBoolean;
      var GraphQLID = new _definition.GraphQLScalarType({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
          }
          throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
        },
        parseValue(inputValue) {
          if (typeof inputValue === "string") {
            return inputValue;
          }
          if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
          }
          throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`);
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), {
              nodes: valueNode
            });
          }
          return valueNode.value;
        }
      });
      exports.GraphQLID = GraphQLID;
      var specifiedScalarTypes = Object.freeze([
        GraphQLString,
        GraphQLInt,
        GraphQLFloat,
        GraphQLBoolean,
        GraphQLID
      ]);
      exports.specifiedScalarTypes = specifiedScalarTypes;
      function isSpecifiedScalarType(type) {
        return specifiedScalarTypes.some(({ name }) => type.name === name);
      }
      function serializeObject(outputValue) {
        if ((0, _isObjectLike.isObjectLike)(outputValue)) {
          if (typeof outputValue.valueOf === "function") {
            const valueOfResult = outputValue.valueOf();
            if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
              return valueOfResult;
            }
          }
          if (typeof outputValue.toJSON === "function") {
            return outputValue.toJSON();
          }
        }
        return outputValue;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/directives.js
  var require_directives = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/directives.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = void 0;
      exports.assertDirective = assertDirective;
      exports.isDirective = isDirective;
      exports.isSpecifiedDirective = isSpecifiedDirective;
      exports.specifiedDirectives = void 0;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _directiveLocation = require_directiveLocation();
      var _assertName = require_assertName();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function isDirective(directive) {
        return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
      }
      function assertDirective(directive) {
        if (!isDirective(directive)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`);
        }
        return directive;
      }
      var GraphQLDirective = class {
        constructor(config) {
          var _config$isRepeatable, _config$args;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.locations = config.locations;
          this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          Array.isArray(config.locations) || (0, _devAssert.devAssert)(false, `@${config.name} locations must be an Array.`);
          const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
          (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(false, `@${config.name} args must be an object with argument names as keys.`);
          this.args = (0, _definition.defineArguments)(args);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLDirective";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: (0, _definition.argsToArgsConfig)(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
          };
        }
        toString() {
          return "@" + this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLDirective = GraphQLDirective;
      var GraphQLIncludeDirective = new GraphQLDirective({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Included when true."
          }
        }
      });
      exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
      var GraphQLSkipDirective = new GraphQLDirective({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Skipped when true."
          }
        }
      });
      exports.GraphQLSkipDirective = GraphQLSkipDirective;
      var DEFAULT_DEPRECATION_REASON = "No longer supported";
      exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
      var GraphQLDeprecatedDirective = new GraphQLDirective({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ENUM_VALUE
        ],
        args: {
          reason: {
            type: _scalars.GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON
          }
        }
      });
      exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
      var GraphQLSpecifiedByDirective = new GraphQLDirective({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behavior of this scalar.",
        locations: [_directiveLocation.DirectiveLocation.SCALAR],
        args: {
          url: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
          }
        }
      });
      exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
      var specifiedDirectives = Object.freeze([
        GraphQLIncludeDirective,
        GraphQLSkipDirective,
        GraphQLDeprecatedDirective,
        GraphQLSpecifiedByDirective
      ]);
      exports.specifiedDirectives = specifiedDirectives;
      function isSpecifiedDirective(directive) {
        return specifiedDirectives.some(({ name }) => name === directive.name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isIterableObject.js
  var require_isIterableObject = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isIterableObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIterableObject = isIterableObject;
      function isIterableObject(maybeIterable) {
        return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/astFromValue.js
  var require_astFromValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/astFromValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.astFromValue = astFromValue;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function astFromValue(value, type) {
        if ((0, _definition.isNonNullType)(type)) {
          const astValue = astFromValue(value, type.ofType);
          if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
            return null;
          }
          return astValue;
        }
        if (value === null) {
          return {
            kind: _kinds.Kind.NULL
          };
        }
        if (value === void 0) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value) {
              const itemNode = astFromValue(item, itemType);
              if (itemNode != null) {
                valuesNodes.push(itemNode);
              }
            }
            return {
              kind: _kinds.Kind.LIST,
              values: valuesNodes
            };
          }
          return astFromValue(value, itemType);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(value)) {
            return null;
          }
          const fieldNodes = [];
          for (const field of Object.values(type.getFields())) {
            const fieldValue = astFromValue(value[field.name], field.type);
            if (fieldValue) {
              fieldNodes.push({
                kind: _kinds.Kind.OBJECT_FIELD,
                name: {
                  kind: _kinds.Kind.NAME,
                  value: field.name
                },
                value: fieldValue
              });
            }
          }
          return {
            kind: _kinds.Kind.OBJECT,
            fields: fieldNodes
          };
        }
        if ((0, _definition.isLeafType)(type)) {
          const serialized = type.serialize(value);
          if (serialized == null) {
            return null;
          }
          if (typeof serialized === "boolean") {
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: serialized
            };
          }
          if (typeof serialized === "number" && Number.isFinite(serialized)) {
            const stringNum = String(serialized);
            return integerStringRegExp.test(stringNum) ? {
              kind: _kinds.Kind.INT,
              value: stringNum
            } : {
              kind: _kinds.Kind.FLOAT,
              value: stringNum
            };
          }
          if (typeof serialized === "string") {
            if ((0, _definition.isEnumType)(type)) {
              return {
                kind: _kinds.Kind.ENUM,
                value: serialized
              };
            }
            if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
              return {
                kind: _kinds.Kind.INT,
                value: serialized
              };
            }
            return {
              kind: _kinds.Kind.STRING,
              value: serialized
            };
          }
          throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);
        }
        (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
      }
      var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/introspection.js
  var require_introspection = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/introspection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = void 0;
      exports.isIntrospectionType = isIntrospectionType;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _directiveLocation = require_directiveLocation();
      var _printer = require_printer();
      var _astFromValue = require_astFromValue();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var __Schema = new _definition.GraphQLObjectType({
        name: "__Schema",
        description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
        fields: () => ({
          description: {
            type: _scalars.GraphQLString,
            resolve: (schema) => schema.description
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
            resolve(schema) {
              return Object.values(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (schema) => schema.getQueryType()
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getMutationType()
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getSubscriptionType()
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
            resolve: (schema) => schema.getDirectives()
          }
        })
      });
      exports.__Schema = __Schema;
      var __Directive = new _definition.GraphQLObjectType({
        name: "__Directive",
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (directive) => directive.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (directive) => directive.description
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (directive) => directive.isRepeatable
          },
          locations: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
            resolve: (directive) => directive.locations
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          }
        })
      });
      exports.__Directive = __Directive;
      var __DirectiveLocation = new _definition.GraphQLEnumType({
        name: "__DirectiveLocation",
        description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
        values: {
          QUERY: {
            value: _directiveLocation.DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
          },
          MUTATION: {
            value: _directiveLocation.DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
          },
          SUBSCRIPTION: {
            value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
          },
          FIELD: {
            value: _directiveLocation.DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
          },
          FRAGMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
          },
          FRAGMENT_SPREAD: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
          },
          INLINE_FRAGMENT: {
            value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
          },
          VARIABLE_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
          },
          SCHEMA: {
            value: _directiveLocation.DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
          },
          SCALAR: {
            value: _directiveLocation.DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
          },
          OBJECT: {
            value: _directiveLocation.DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
          },
          FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
          },
          ARGUMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
          },
          INTERFACE: {
            value: _directiveLocation.DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
          },
          UNION: {
            value: _directiveLocation.DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
          },
          ENUM: {
            value: _directiveLocation.DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
          },
          ENUM_VALUE: {
            value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
          },
          INPUT_OBJECT: {
            value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
          },
          INPUT_FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
          }
        }
      });
      exports.__DirectiveLocation = __DirectiveLocation;
      var __Type = new _definition.GraphQLObjectType({
        name: "__Type",
        description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
        fields: () => ({
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind),
            resolve(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind.NON_NULL;
              }
              (0, _invariant.invariant)(false, `Unexpected type: "${(0, _inspect.inspect)(type)}".`);
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: (type) => "name" in type ? type.name : void 0
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (type) => "description" in type ? type.description : void 0
          },
          specifiedByURL: {
            type: _scalars.GraphQLString,
            resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
          },
          fields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                const fields = Object.values(type.getFields());
                return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type, _args, _context, { schema }) {
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isEnumType)(type)) {
                const values = type.getValues();
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isInputObjectType)(type)) {
                const values = Object.values(type.getFields());
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: (type) => "ofType" in type ? type.ofType : void 0
          }
        })
      });
      exports.__Type = __Type;
      var __Field = new _definition.GraphQLObjectType({
        name: "__Field",
        description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (field) => field.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.description
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (field) => field.type
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.deprecationReason
          }
        })
      });
      exports.__Field = __Field;
      var __InputValue = new _definition.GraphQLObjectType({
        name: "__InputValue",
        description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (inputValue) => inputValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (inputValue) => inputValue.description
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (inputValue) => inputValue.type
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve(inputValue) {
              const { type, defaultValue } = inputValue;
              const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (obj) => obj.deprecationReason
          }
        })
      });
      exports.__InputValue = __InputValue;
      var __EnumValue = new _definition.GraphQLObjectType({
        name: "__EnumValue",
        description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (enumValue) => enumValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.description
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (enumValue) => enumValue.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.deprecationReason
          }
        })
      });
      exports.__EnumValue = __EnumValue;
      var TypeKind;
      exports.TypeKind = TypeKind;
      (function(TypeKind2) {
        TypeKind2["SCALAR"] = "SCALAR";
        TypeKind2["OBJECT"] = "OBJECT";
        TypeKind2["INTERFACE"] = "INTERFACE";
        TypeKind2["UNION"] = "UNION";
        TypeKind2["ENUM"] = "ENUM";
        TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
        TypeKind2["LIST"] = "LIST";
        TypeKind2["NON_NULL"] = "NON_NULL";
      })(TypeKind || (exports.TypeKind = TypeKind = {}));
      var __TypeKind = new _definition.GraphQLEnumType({
        name: "__TypeKind",
        description: "An enum describing what kind of type a given `__Type` is.",
        values: {
          SCALAR: {
            value: TypeKind.SCALAR,
            description: "Indicates this type is a scalar."
          },
          OBJECT: {
            value: TypeKind.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
          },
          INTERFACE: {
            value: TypeKind.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
          },
          UNION: {
            value: TypeKind.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
          },
          ENUM: {
            value: TypeKind.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
          },
          INPUT_OBJECT: {
            value: TypeKind.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
          },
          LIST: {
            value: TypeKind.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
          },
          NON_NULL: {
            value: TypeKind.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
          }
        }
      });
      exports.__TypeKind = __TypeKind;
      var SchemaMetaFieldDef = {
        name: "__schema",
        type: new _definition.GraphQLNonNull(__Schema),
        description: "Access the current type schema of this server.",
        args: [],
        resolve: (_source, _args, _context, { schema }) => schema,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
      var TypeMetaFieldDef = {
        name: "__type",
        type: __Type,
        description: "Request the type information of a single type.",
        args: [
          {
            name: "name",
            description: void 0,
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            defaultValue: void 0,
            deprecationReason: void 0,
            extensions: /* @__PURE__ */ Object.create(null),
            astNode: void 0
          }
        ],
        resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeMetaFieldDef = TypeMetaFieldDef;
      var TypeNameMetaFieldDef = {
        name: "__typename",
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The name of the current Object type at runtime.",
        args: [],
        resolve: (_source, _args, _context, { parentType }) => parentType.name,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
      var introspectionTypes = Object.freeze([
        __Schema,
        __Directive,
        __DirectiveLocation,
        __Type,
        __Field,
        __InputValue,
        __EnumValue,
        __TypeKind
      ]);
      exports.introspectionTypes = introspectionTypes;
      function isIntrospectionType(type) {
        return introspectionTypes.some(({ name }) => type.name === name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/schema.js
  var require_schema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/schema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSchema = void 0;
      exports.assertSchema = assertSchema;
      exports.isSchema = isSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _ast = require_ast();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      function isSchema(schema) {
        return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
      }
      function assertSchema(schema) {
        if (!isSchema(schema)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);
        }
        return schema;
      }
      var GraphQLSchema = class {
        constructor(config) {
          var _config$extensionASTN, _config$directives;
          this.__validationErrors = config.assumeValid === true ? [] : void 0;
          (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
          !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `"types" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);
          !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config.directives)}.`);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          this._queryType = config.query;
          this._mutationType = config.mutation;
          this._subscriptionType = config.subscription;
          this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
          const allReferencedTypes = new Set(config.types);
          if (config.types != null) {
            for (const type of config.types) {
              allReferencedTypes.delete(type);
              collectReferencedTypes(type, allReferencedTypes);
            }
          }
          if (this._queryType != null) {
            collectReferencedTypes(this._queryType, allReferencedTypes);
          }
          if (this._mutationType != null) {
            collectReferencedTypes(this._mutationType, allReferencedTypes);
          }
          if (this._subscriptionType != null) {
            collectReferencedTypes(this._subscriptionType, allReferencedTypes);
          }
          for (const directive of this._directives) {
            if ((0, _directives.isDirective)(directive)) {
              for (const arg of directive.args) {
                collectReferencedTypes(arg.type, allReferencedTypes);
              }
            }
          }
          collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
          this._typeMap = /* @__PURE__ */ Object.create(null);
          this._subTypeMap = /* @__PURE__ */ Object.create(null);
          this._implementationsMap = /* @__PURE__ */ Object.create(null);
          for (const namedType of allReferencedTypes) {
            if (namedType == null) {
              continue;
            }
            const typeName = namedType.name;
            typeName || (0, _devAssert.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
            if (this._typeMap[typeName] !== void 0) {
              throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
            }
            this._typeMap[typeName] = namedType;
            if ((0, _definition.isInterfaceType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.interfaces.push(namedType);
                }
              }
            } else if ((0, _definition.isObjectType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.objects.push(namedType);
                }
              }
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLSchema";
        }
        getQueryType() {
          return this._queryType;
        }
        getMutationType() {
          return this._mutationType;
        }
        getSubscriptionType() {
          return this._subscriptionType;
        }
        getRootType(operation) {
          switch (operation) {
            case _ast.OperationTypeNode.QUERY:
              return this.getQueryType();
            case _ast.OperationTypeNode.MUTATION:
              return this.getMutationType();
            case _ast.OperationTypeNode.SUBSCRIPTION:
              return this.getSubscriptionType();
          }
        }
        getTypeMap() {
          return this._typeMap;
        }
        getType(name) {
          return this.getTypeMap()[name];
        }
        getPossibleTypes(abstractType) {
          return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
          const implementations = this._implementationsMap[interfaceType.name];
          return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
          };
        }
        isSubType(abstractType, maybeSubType) {
          let map = this._subTypeMap[abstractType.name];
          if (map === void 0) {
            map = /* @__PURE__ */ Object.create(null);
            if ((0, _definition.isUnionType)(abstractType)) {
              for (const type of abstractType.getTypes()) {
                map[type.name] = true;
              }
            } else {
              const implementations = this.getImplementations(abstractType);
              for (const type of implementations.objects) {
                map[type.name] = true;
              }
              for (const type of implementations.interfaces) {
                map[type.name] = true;
              }
            }
            this._subTypeMap[abstractType.name] = map;
          }
          return map[maybeSubType.name] !== void 0;
        }
        getDirectives() {
          return this._directives;
        }
        getDirective(name) {
          return this.getDirectives().find((directive) => directive.name === name);
        }
        toConfig() {
          return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== void 0
          };
        }
      };
      exports.GraphQLSchema = GraphQLSchema;
      function collectReferencedTypes(type, typeSet) {
        const namedType = (0, _definition.getNamedType)(type);
        if (!typeSet.has(namedType)) {
          typeSet.add(namedType);
          if ((0, _definition.isUnionType)(namedType)) {
            for (const memberType of namedType.getTypes()) {
              collectReferencedTypes(memberType, typeSet);
            }
          } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
            for (const interfaceType of namedType.getInterfaces()) {
              collectReferencedTypes(interfaceType, typeSet);
            }
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
              for (const arg of field.args) {
                collectReferencedTypes(arg.type, typeSet);
              }
            }
          } else if ((0, _definition.isInputObjectType)(namedType)) {
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
            }
          }
        }
        return typeSet;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/validate.js
  var require_validate = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSchema = assertValidSchema;
      exports.validateSchema = validateSchema;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _typeComparators = require_typeComparators();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function validateSchema(schema) {
        (0, _schema.assertSchema)(schema);
        if (schema.__validationErrors) {
          return schema.__validationErrors;
        }
        const context = new SchemaValidationContext(schema);
        validateRootTypes(context);
        validateDirectives(context);
        validateTypes(context);
        const errors = context.getErrors();
        schema.__validationErrors = errors;
        return errors;
      }
      function assertValidSchema(schema) {
        const errors = validateSchema(schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      var SchemaValidationContext = class {
        constructor(schema) {
          this._errors = [];
          this.schema = schema;
        }
        reportError(message, nodes) {
          const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
          this._errors.push(new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
          }));
        }
        getErrors() {
          return this._errors;
        }
      };
      function validateRootTypes(context) {
        const schema = context.schema;
        const queryType = schema.getQueryType();
        if (!queryType) {
          context.reportError("Query root type must be provided.", schema.astNode);
        } else if (!(0, _definition.isObjectType)(queryType)) {
          var _getOperationTypeNode;
          context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
        }
        const mutationType = schema.getMutationType();
        if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
          var _getOperationTypeNode2;
          context.reportError(`Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
          var _getOperationTypeNode3;
          context.reportError(`Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
        }
      }
      function getOperationTypeNode(schema, operation) {
        var _flatMap$find;
        return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {
          var _schemaNode$operation;
          return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
        }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
      }
      function validateDirectives(context) {
        for (const directive of context.schema.getDirectives()) {
          if (!(0, _directives.isDirective)(directive)) {
            context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);
            continue;
          }
          validateName(context, directive);
          for (const arg of directive.args) {
            validateName(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode;
              context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
              ]);
            }
          }
        }
      }
      function validateName(context, node) {
        if (node.name.startsWith("__")) {
          context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
        }
      }
      function validateTypes(context) {
        const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
        const typeMap = context.schema.getTypeMap();
        for (const type of Object.values(typeMap)) {
          if (!(0, _definition.isNamedType)(type)) {
            context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);
            continue;
          }
          if (!(0, _introspection.isIntrospectionType)(type)) {
            validateName(context, type);
          }
          if ((0, _definition.isObjectType)(type)) {
            validateFields(context, type);
            validateInterfaces(context, type);
          } else if ((0, _definition.isInterfaceType)(type)) {
            validateFields(context, type);
            validateInterfaces(context, type);
          } else if ((0, _definition.isUnionType)(type)) {
            validateUnionMembers(context, type);
          } else if ((0, _definition.isEnumType)(type)) {
            validateEnumValues(context, type);
          } else if ((0, _definition.isInputObjectType)(type)) {
            validateInputFields(context, type);
            validateInputObjectCircularRefs(type);
          }
        }
      }
      function validateFields(context, type) {
        const fields = Object.values(type.getFields());
        if (fields.length === 0) {
          context.reportError(`Type ${type.name} must define one or more fields.`, [
            type.astNode,
            ...type.extensionASTNodes
          ]);
        }
        for (const field of fields) {
          validateName(context, field);
          if (!(0, _definition.isOutputType)(field.type)) {
            var _field$astNode;
            context.reportError(`The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
          }
          for (const arg of field.args) {
            const argName = arg.name;
            validateName(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              var _arg$astNode2;
              context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode3;
              context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
              ]);
            }
          }
        }
      }
      function validateInterfaces(context, type) {
        const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
        for (const iface of type.getInterfaces()) {
          if (!(0, _definition.isInterfaceType)(iface)) {
            context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
          }
          if (type === iface) {
            context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
          }
          if (ifaceTypeNames[iface.name]) {
            context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
          }
          ifaceTypeNames[iface.name] = true;
          validateTypeImplementsAncestors(context, type, iface);
          validateTypeImplementsInterface(context, type, iface);
        }
      }
      function validateTypeImplementsInterface(context, type, iface) {
        const typeFieldMap = type.getFields();
        for (const ifaceField of Object.values(iface.getFields())) {
          const fieldName = ifaceField.name;
          const typeField = typeFieldMap[fieldName];
          if (!typeField) {
            context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
            continue;
          }
          if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
            var _ifaceField$astNode, _typeField$astNode;
            context.reportError(`Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`, [
              (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
              (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]);
          }
          for (const ifaceArg of ifaceField.args) {
            const argName = ifaceArg.name;
            const typeArg = typeField.args.find((arg) => arg.name === argName);
            if (!typeArg) {
              context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
              continue;
            }
            if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
              var _ifaceArg$astNode, _typeArg$astNode;
              context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`, [
                (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
              ]);
            }
          }
          for (const typeArg of typeField.args) {
            const argName = typeArg.name;
            const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
            if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
              context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
            }
          }
        }
      }
      function validateTypeImplementsAncestors(context, type, iface) {
        const ifaceInterfaces = type.getInterfaces();
        for (const transitive of iface.getInterfaces()) {
          if (!ifaceInterfaces.includes(transitive)) {
            context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
              ...getAllImplementsInterfaceNodes(iface, transitive),
              ...getAllImplementsInterfaceNodes(type, iface)
            ]);
          }
        }
      }
      function validateUnionMembers(context, union) {
        const memberTypes = union.getTypes();
        if (memberTypes.length === 0) {
          context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
        }
        const includedTypeNames = /* @__PURE__ */ Object.create(null);
        for (const memberType of memberTypes) {
          if (includedTypeNames[memberType.name]) {
            context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
            continue;
          }
          includedTypeNames[memberType.name] = true;
          if (!(0, _definition.isObjectType)(memberType)) {
            context.reportError(`Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
          }
        }
      }
      function validateEnumValues(context, enumType) {
        const enumValues = enumType.getValues();
        if (enumValues.length === 0) {
          context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
        }
        for (const enumValue of enumValues) {
          validateName(context, enumValue);
        }
      }
      function validateInputFields(context, inputObj) {
        const fields = Object.values(inputObj.getFields());
        if (fields.length === 0) {
          context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
        }
        for (const field of fields) {
          validateName(context, field);
          if (!(0, _definition.isInputType)(field.type)) {
            var _field$astNode2;
            context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
          }
          if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
            var _field$astNode3;
            context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
              getDeprecatedDirectiveNode(field.astNode),
              (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]);
          }
        }
      }
      function createInputObjectCircularRefsValidator(context) {
        const visitedTypes = /* @__PURE__ */ Object.create(null);
        const fieldPath = [];
        const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
        return detectCycleRecursive;
        function detectCycleRecursive(inputObj) {
          if (visitedTypes[inputObj.name]) {
            return;
          }
          visitedTypes[inputObj.name] = true;
          fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
          const fields = Object.values(inputObj.getFields());
          for (const field of fields) {
            if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
              const fieldType = field.type.ofType;
              const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
              fieldPath.push(field);
              if (cycleIndex === void 0) {
                detectCycleRecursive(fieldType);
              } else {
                const cyclePath = fieldPath.slice(cycleIndex);
                const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
                context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
              }
              fieldPath.pop();
            }
          }
          fieldPathIndexByTypeName[inputObj.name] = void 0;
        }
      }
      function getAllImplementsInterfaceNodes(type, iface) {
        const { astNode, extensionASTNodes } = type;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((typeNode) => {
          var _typeNode$interfaces;
          return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
        }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
      }
      function getUnionMemberTypeNodes(union, typeName) {
        const { astNode, extensionASTNodes } = union;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((unionNode) => {
          var _unionNode$types;
          return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
        }).filter((typeNode) => typeNode.name.value === typeName);
      }
      function getDeprecatedDirectiveNode(definitionNode) {
        var _definitionNode$direc;
        return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node) => node.name.value === _directives.GraphQLDeprecatedDirective.name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/typeFromAST.js
  var require_typeFromAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/typeFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typeFromAST = typeFromAST;
      var _kinds = require_kinds();
      var _definition = require_definition();
      function typeFromAST(schema, typeNode) {
        switch (typeNode.kind) {
          case _kinds.Kind.LIST_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLList(innerType);
          }
          case _kinds.Kind.NON_NULL_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLNonNull(innerType);
          }
          case _kinds.Kind.NAMED_TYPE:
            return schema.getType(typeNode.name.value);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/TypeInfo.js
  var require_TypeInfo = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/TypeInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TypeInfo = void 0;
      exports.visitWithTypeInfo = visitWithTypeInfo;
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _typeFromAST = require_typeFromAST();
      var TypeInfo = class {
        constructor(schema, initialType, getFieldDefFn) {
          this._schema = schema;
          this._typeStack = [];
          this._parentTypeStack = [];
          this._inputTypeStack = [];
          this._fieldDefStack = [];
          this._defaultValueStack = [];
          this._directive = null;
          this._argument = null;
          this._enumValue = null;
          this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
          if (initialType) {
            if ((0, _definition.isInputType)(initialType)) {
              this._inputTypeStack.push(initialType);
            }
            if ((0, _definition.isCompositeType)(initialType)) {
              this._parentTypeStack.push(initialType);
            }
            if ((0, _definition.isOutputType)(initialType)) {
              this._typeStack.push(initialType);
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "TypeInfo";
        }
        getType() {
          if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
          }
        }
        getParentType() {
          if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
          }
        }
        getInputType() {
          if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
          }
        }
        getParentInputType() {
          if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
          }
        }
        getFieldDef() {
          if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
          }
        }
        getDefaultValue() {
          if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
          }
        }
        getDirective() {
          return this._directive;
        }
        getArgument() {
          return this._argument;
        }
        getEnumValue() {
          return this._enumValue;
        }
        enter(node) {
          const schema = this._schema;
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET: {
              const namedType = (0, _definition.getNamedType)(this.getType());
              this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : void 0);
              break;
            }
            case _kinds.Kind.FIELD: {
              const parentType = this.getParentType();
              let fieldDef;
              let fieldType;
              if (parentType) {
                fieldDef = this._getFieldDef(schema, parentType, node);
                if (fieldDef) {
                  fieldType = fieldDef.type;
                }
              }
              this._fieldDefStack.push(fieldDef);
              this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : void 0);
              break;
            }
            case _kinds.Kind.DIRECTIVE:
              this._directive = schema.getDirective(node.name.value);
              break;
            case _kinds.Kind.OPERATION_DEFINITION: {
              const rootType = schema.getRootType(node.operation);
              this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : void 0);
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION: {
              const typeConditionAST = node.typeCondition;
              const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
              this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : void 0);
              break;
            }
            case _kinds.Kind.VARIABLE_DEFINITION: {
              const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
              this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : void 0);
              break;
            }
            case _kinds.Kind.ARGUMENT: {
              var _this$getDirective;
              let argDef;
              let argType;
              const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
              if (fieldOrDirective) {
                argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
                if (argDef) {
                  argType = argDef.type;
                }
              }
              this._argument = argDef;
              this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
              this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : void 0);
              break;
            }
            case _kinds.Kind.LIST: {
              const listType = (0, _definition.getNullableType)(this.getInputType());
              const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
              this._defaultValueStack.push(void 0);
              this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : void 0);
              break;
            }
            case _kinds.Kind.OBJECT_FIELD: {
              const objectType = (0, _definition.getNamedType)(this.getInputType());
              let inputFieldType;
              let inputField;
              if ((0, _definition.isInputObjectType)(objectType)) {
                inputField = objectType.getFields()[node.name.value];
                if (inputField) {
                  inputFieldType = inputField.type;
                }
              }
              this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
              this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0);
              break;
            }
            case _kinds.Kind.ENUM: {
              const enumType = (0, _definition.getNamedType)(this.getInputType());
              let enumValue;
              if ((0, _definition.isEnumType)(enumType)) {
                enumValue = enumType.getValue(node.value);
              }
              this._enumValue = enumValue;
              break;
            }
            default:
          }
        }
        leave(node) {
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET:
              this._parentTypeStack.pop();
              break;
            case _kinds.Kind.FIELD:
              this._fieldDefStack.pop();
              this._typeStack.pop();
              break;
            case _kinds.Kind.DIRECTIVE:
              this._directive = null;
              break;
            case _kinds.Kind.OPERATION_DEFINITION:
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
              this._typeStack.pop();
              break;
            case _kinds.Kind.VARIABLE_DEFINITION:
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ARGUMENT:
              this._argument = null;
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.LIST:
            case _kinds.Kind.OBJECT_FIELD:
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ENUM:
              this._enumValue = null;
              break;
            default:
          }
        }
      };
      exports.TypeInfo = TypeInfo;
      function getFieldDef(schema, parentType, fieldNode) {
        const name = fieldNode.name.value;
        if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        }
        if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        }
        if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
          return _introspection.TypeNameMetaFieldDef;
        }
        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
          return parentType.getFields()[name];
        }
      }
      function visitWithTypeInfo(typeInfo, visitor) {
        return {
          enter(...args) {
            const node = args[0];
            typeInfo.enter(node);
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
            if (fn) {
              const result = fn.apply(visitor, args);
              if (result !== void 0) {
                typeInfo.leave(node);
                if ((0, _ast.isNode)(result)) {
                  typeInfo.enter(result);
                }
              }
              return result;
            }
          },
          leave(...args) {
            const node = args[0];
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
            let result;
            if (fn) {
              result = fn.apply(visitor, args);
            }
            typeInfo.leave(node);
            return result;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/predicates.js
  var require_predicates = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/predicates.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isConstValueNode = isConstValueNode;
      exports.isDefinitionNode = isDefinitionNode;
      exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
      exports.isSelectionNode = isSelectionNode;
      exports.isTypeDefinitionNode = isTypeDefinitionNode;
      exports.isTypeExtensionNode = isTypeExtensionNode;
      exports.isTypeNode = isTypeNode;
      exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
      exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
      exports.isValueNode = isValueNode;
      var _kinds = require_kinds();
      function isDefinitionNode(node) {
        return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
      }
      function isExecutableDefinitionNode(node) {
        return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
      }
      function isSelectionNode(node) {
        return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
      }
      function isValueNode(node) {
        return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
      }
      function isConstValueNode(node) {
        return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
      }
      function isTypeNode(node) {
        return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
      }
      function isTypeSystemDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
      }
      function isTypeDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
      }
      function isTypeSystemExtensionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
      }
      function isTypeExtensionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
  var require_ExecutableDefinitionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      function ExecutableDefinitionsRule(context) {
        return {
          Document(node) {
            for (const definition of node.definitions) {
              if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
                context.reportError(new _GraphQLError.GraphQLError(`The ${defName} definition is not executable.`, {
                  nodes: definition
                }));
              }
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
  var require_FieldsOnCorrectTypeRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _naturalCompare = require_naturalCompare();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function FieldsOnCorrectTypeRule(context) {
        return {
          Field(node) {
            const type = context.getParentType();
            if (type) {
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                const schema = context.getSchema();
                const fieldName = node.name.value;
                let suggestion = (0, _didYouMean.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
                if (suggestion === "") {
                  suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type, fieldName));
                }
                context.reportError(new _GraphQLError.GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
                  nodes: node
                }));
              }
            }
          }
        };
      }
      function getSuggestedTypeNames(schema, type, fieldName) {
        if (!(0, _definition.isAbstractType)(type)) {
          return [];
        }
        const suggestedTypes = /* @__PURE__ */ new Set();
        const usageCount = /* @__PURE__ */ Object.create(null);
        for (const possibleType of schema.getPossibleTypes(type)) {
          if (!possibleType.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleType);
          usageCount[possibleType.name] = 1;
          for (const possibleInterface of possibleType.getInterfaces()) {
            var _usageCount$possibleI;
            if (!possibleInterface.getFields()[fieldName]) {
              continue;
            }
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
          }
        }
        return [...suggestedTypes].sort((typeA, typeB) => {
          const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
          if (usageCountDiff !== 0) {
            return usageCountDiff;
          }
          if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
          }
          if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
          }
          return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
        }).map((x) => x.name);
      }
      function getSuggestedFieldNames(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
          const possibleFieldNames = Object.keys(type.getFields());
          return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
        }
        return [];
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
  var require_FragmentsOnCompositeTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function FragmentsOnCompositeTypesRule(context) {
        return {
          InlineFragment(node) {
            const typeCondition = node.typeCondition;
            if (typeCondition) {
              const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
              if (type && !(0, _definition.isCompositeType)(type)) {
                const typeStr = (0, _printer.print)(typeCondition);
                context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
                  nodes: typeCondition
                }));
              }
            }
          },
          FragmentDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(node.typeCondition);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
                nodes: node.typeCondition
              }));
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
  var require_KnownArgumentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
      exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownArgumentNamesRule(context) {
        return {
          ...KnownArgumentNamesOnDirectivesRule(context),
          Argument(argNode) {
            const argDef = context.getArgument();
            const fieldDef = context.getFieldDef();
            const parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
              const argName = argNode.name.value;
              const knownArgsNames = fieldDef.args.map((arg) => arg.name);
              const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgsNames);
              context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
                nodes: argNode
              }));
            }
          }
        };
      }
      function KnownArgumentNamesOnDirectivesRule(context) {
        const directiveArgs = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
          }
        }
        return {
          Directive(directiveNode) {
            const directiveName = directiveNode.name.value;
            const knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
              for (const argNode of directiveNode.arguments) {
                const argName = argNode.name.value;
                if (!knownArgs.includes(argName)) {
                  const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgs);
                  context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions), {
                    nodes: argNode
                  }));
                }
              }
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownDirectivesRule.js
  var require_KnownDirectivesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownDirectivesRule = KnownDirectivesRule;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownDirectivesRule(context) {
        const locationsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          locationsMap[directive.name] = directive.locations;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map((name) => name.value);
          }
        }
        return {
          Directive(node, _key, _parent, _path, ancestors) {
            const name = node.name.value;
            const locations = locationsMap[name];
            if (!locations) {
              context.reportError(new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                nodes: node
              }));
              return;
            }
            const candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && !locations.includes(candidateLocation)) {
              context.reportError(new _GraphQLError.GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
                nodes: node
              }));
            }
          }
        };
      }
      function getDirectiveLocationForASTPath(ancestors) {
        const appliedTo = ancestors[ancestors.length - 1];
        "kind" in appliedTo || (0, _invariant.invariant)(false);
        switch (appliedTo.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
          case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
          case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
          case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
          case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
          case _kinds.Kind.SCHEMA_DEFINITION:
          case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
          case _kinds.Kind.SCALAR_TYPE_DEFINITION:
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
          case _kinds.Kind.OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
          case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
          case _kinds.Kind.UNION_TYPE_DEFINITION:
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
          case _kinds.Kind.ENUM_TYPE_DEFINITION:
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
          case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
          case _kinds.Kind.INPUT_VALUE_DEFINITION: {
            const parentNode = ancestors[ancestors.length - 3];
            "kind" in parentNode || (0, _invariant.invariant)(false);
            return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
          }
          default:
            (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind));
        }
      }
      function getDirectiveLocationForOperation(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return _directiveLocation.DirectiveLocation.QUERY;
          case _ast.OperationTypeNode.MUTATION:
            return _directiveLocation.DirectiveLocation.MUTATION;
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
  var require_KnownFragmentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function KnownFragmentNamesRule(context) {
        return {
          FragmentSpread(node) {
            const fragmentName = node.name.value;
            const fragment = context.getFragment(fragmentName);
            if (!fragment) {
              context.reportError(new _GraphQLError.GraphQLError(`Unknown fragment "${fragmentName}".`, {
                nodes: node.name
              }));
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownTypeNamesRule.js
  var require_KnownTypeNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownTypeNamesRule = KnownTypeNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _predicates = require_predicates();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      function KnownTypeNamesRule(context) {
        const schema = context.getSchema();
        const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
          }
        }
        const typeNames = [
          ...Object.keys(existingTypesMap),
          ...Object.keys(definedTypes)
        ];
        return {
          NamedType(node, _1, parent, _2, ancestors) {
            const typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
              var _ancestors$;
              const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
              const isSDL = definitionNode != null && isSDLNode(definitionNode);
              if (isSDL && standardTypeNames.includes(typeName)) {
                return;
              }
              const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
              context.reportError(new _GraphQLError.GraphQLError(`Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes), {
                nodes: node
              }));
            }
          }
        };
      }
      var standardTypeNames = [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ].map((type) => type.name);
      function isSDLNode(value) {
        return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
  var require_LoneAnonymousOperationRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      function LoneAnonymousOperationRule(context) {
        let operationCount = 0;
        return {
          Document(node) {
            operationCount = node.definitions.filter((definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION).length;
          },
          OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
              context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", {
                nodes: node
              }));
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
  var require_LoneSchemaDefinitionRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
      var _GraphQLError = require_GraphQLError();
      function LoneSchemaDefinitionRule(context) {
        var _ref, _ref2, _oldSchema$astNode;
        const oldSchema = context.getSchema();
        const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
        let schemaDefinitionsCount = 0;
        return {
          SchemaDefinition(node) {
            if (alreadyDefined) {
              context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", {
                nodes: node
              }));
              return;
            }
            if (schemaDefinitionsCount > 0) {
              context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", {
                nodes: node
              }));
            }
            ++schemaDefinitionsCount;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
  var require_NoFragmentCyclesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
      var _GraphQLError = require_GraphQLError();
      function NoFragmentCyclesRule(context) {
        const visitedFrags = /* @__PURE__ */ Object.create(null);
        const spreadPath = [];
        const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
          }
        };
        function detectCycleRecursive(fragment) {
          if (visitedFrags[fragment.name.value]) {
            return;
          }
          const fragmentName = fragment.name.value;
          visitedFrags[fragmentName] = true;
          const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
          if (spreadNodes.length === 0) {
            return;
          }
          spreadPathIndexByName[fragmentName] = spreadPath.length;
          for (const spreadNode of spreadNodes) {
            const spreadName = spreadNode.name.value;
            const cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === void 0) {
              const spreadFragment = context.getFragment(spreadName);
              if (spreadFragment) {
                detectCycleRecursive(spreadFragment);
              }
            } else {
              const cyclePath = spreadPath.slice(cycleIndex);
              const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
              context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
                nodes: cyclePath
              }));
            }
            spreadPath.pop();
          }
          spreadPathIndexByName[fragmentName] = void 0;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
  var require_NoUndefinedVariablesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUndefinedVariablesRule(context) {
        let variableNameDefined = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              variableNameDefined = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                const varName = node.name.value;
                if (variableNameDefined[varName] !== true) {
                  context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, {
                    nodes: [node, operation]
                  }));
                }
              }
            }
          },
          VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
  var require_NoUnusedFragmentsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedFragmentsRule(context) {
        const operationDefs = [];
        const fragmentDefs = [];
        return {
          OperationDefinition(node) {
            operationDefs.push(node);
            return false;
          },
          FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
          },
          Document: {
            leave() {
              const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
              for (const operation of operationDefs) {
                for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
                  fragmentNameUsed[fragment.name.value] = true;
                }
              }
              for (const fragmentDef of fragmentDefs) {
                const fragName = fragmentDef.name.value;
                if (fragmentNameUsed[fragName] !== true) {
                  context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" is never used.`, {
                    nodes: fragmentDef
                  }));
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
  var require_NoUnusedVariablesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedVariablesRule(context) {
        let variableDefs = [];
        return {
          OperationDefinition: {
            enter() {
              variableDefs = [];
            },
            leave(operation) {
              const variableNameUsed = /* @__PURE__ */ Object.create(null);
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                variableNameUsed[node.name.value] = true;
              }
              for (const variableDef of variableDefs) {
                const variableName = variableDef.variable.name.value;
                if (variableNameUsed[variableName] !== true) {
                  context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, {
                    nodes: variableDef
                  }));
                }
              }
            }
          },
          VariableDefinition(def) {
            variableDefs.push(def);
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/sortValueNode.js
  var require_sortValueNode = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/sortValueNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sortValueNode = sortValueNode;
      var _naturalCompare = require_naturalCompare();
      var _kinds = require_kinds();
      function sortValueNode(valueNode) {
        switch (valueNode.kind) {
          case _kinds.Kind.OBJECT:
            return { ...valueNode, fields: sortFields(valueNode.fields) };
          case _kinds.Kind.LIST:
            return { ...valueNode, values: valueNode.values.map(sortValueNode) };
          case _kinds.Kind.INT:
          case _kinds.Kind.FLOAT:
          case _kinds.Kind.STRING:
          case _kinds.Kind.BOOLEAN:
          case _kinds.Kind.NULL:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.VARIABLE:
            return valueNode;
        }
      }
      function sortFields(fields) {
        return fields.map((fieldNode) => ({
          ...fieldNode,
          value: sortValueNode(fieldNode.value)
        })).sort((fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value));
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
  var require_OverlappingFieldsCanBeMergedRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _sortValueNode = require_sortValueNode();
      var _typeFromAST = require_typeFromAST();
      function reasonMessage(reason) {
        if (Array.isArray(reason)) {
          return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
        }
        return reason;
      }
      function OverlappingFieldsCanBeMergedRule(context) {
        const comparedFragmentPairs = new PairSet();
        const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
        return {
          SelectionSet(selectionSet) {
            const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
            for (const [[responseName, reason], fields1, fields2] of conflicts) {
              const reasonMsg = reasonMessage(reason);
              context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
                nodes: fields1.concat(fields2)
              }));
            }
          }
        };
      }
      function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
        const conflicts = [];
        const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
        collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
        if (fragmentNames.length !== 0) {
          for (let i = 0; i < fragmentNames.length; i++) {
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
            for (let j = i + 1; j < fragmentNames.length; j++) {
              collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
            }
          }
        }
        return conflicts;
      }
      function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          return;
        }
        const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
        if (fieldMap === fieldMap2) {
          return;
        }
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
        for (const referencedFragmentName of referencedFragmentNames) {
          if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
            continue;
          }
          comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
        }
      }
      function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
        if (fragmentName1 === fragmentName2) {
          return;
        }
        if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
          return;
        }
        comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
        const fragment1 = context.getFragment(fragmentName1);
        const fragment2 = context.getFragment(fragmentName2);
        if (!fragment1 || !fragment2) {
          return;
        }
        const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
        const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
        for (const referencedFragmentName2 of referencedFragmentNames2) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
        }
        for (const referencedFragmentName1 of referencedFragmentNames1) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
        }
      }
      function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
        const conflicts = [];
        const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
        const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
        }
        for (const fragmentName1 of fragmentNames1) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
        }
        for (const fragmentName1 of fragmentNames1) {
          for (const fragmentName2 of fragmentNames2) {
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
          }
        }
        return conflicts;
      }
      function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
        for (const [responseName, fields] of Object.entries(fieldMap)) {
          if (fields.length > 1) {
            for (let i = 0; i < fields.length; i++) {
              for (let j = i + 1; j < fields.length; j++) {
                const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
        for (const [responseName, fields1] of Object.entries(fieldMap1)) {
          const fields2 = fieldMap2[responseName];
          if (fields2) {
            for (const field1 of fields1) {
              for (const field2 of fields2) {
                const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
        const [parentType1, node1, def1] = field1;
        const [parentType2, node2, def2] = field2;
        const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
        if (!areMutuallyExclusive) {
          const name1 = node1.name.value;
          const name2 = node2.name.value;
          if (name1 !== name2) {
            return [
              [responseName, `"${name1}" and "${name2}" are different fields`],
              [node1],
              [node2]
            ];
          }
          if (stringifyArguments(node1) !== stringifyArguments(node2)) {
            return [
              [responseName, "they have differing arguments"],
              [node1],
              [node2]
            ];
          }
        }
        const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
        const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
        if (type1 && type2 && doTypesConflict(type1, type2)) {
          return [
            [
              responseName,
              `they return conflicting types "${(0, _inspect.inspect)(type1)}" and "${(0, _inspect.inspect)(type2)}"`
            ],
            [node1],
            [node2]
          ];
        }
        const selectionSet1 = node1.selectionSet;
        const selectionSet2 = node2.selectionSet;
        if (selectionSet1 && selectionSet2) {
          const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
          return subfieldConflicts(conflicts, responseName, node1, node2);
        }
      }
      function stringifyArguments(fieldNode) {
        var _fieldNode$arguments;
        const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
        const inputObjectWithArgs = {
          kind: _kinds.Kind.OBJECT,
          fields: args.map((argNode) => ({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: argNode.name,
            value: argNode.value
          }))
        };
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(inputObjectWithArgs));
      }
      function doTypesConflict(type1, type2) {
        if ((0, _definition.isListType)(type1)) {
          return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isListType)(type2)) {
          return true;
        }
        if ((0, _definition.isNonNullType)(type1)) {
          return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return true;
        }
        if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
          return type1 !== type2;
        }
        return false;
      }
      function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
        const cached = cachedFieldsAndFragmentNames.get(selectionSet);
        if (cached) {
          return cached;
        }
        const nodeAndDefs = /* @__PURE__ */ Object.create(null);
        const fragmentNames = /* @__PURE__ */ Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        const result = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, result);
        return result;
      }
      function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
        const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
        if (cached) {
          return cached;
        }
        const fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
        return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
      }
      function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              const fieldName = selection.name.value;
              let fieldDef;
              if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                fieldDef = parentType.getFields()[fieldName];
              }
              const responseName = selection.alias ? selection.alias.value : fieldName;
              if (!nodeAndDefs[responseName]) {
                nodeAndDefs[responseName] = [];
              }
              nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD:
              fragmentNames[selection.name.value] = true;
              break;
            case _kinds.Kind.INLINE_FRAGMENT: {
              const typeCondition = selection.typeCondition;
              const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
              _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
              break;
            }
          }
        }
      }
      function subfieldConflicts(conflicts, responseName, node1, node2) {
        if (conflicts.length > 0) {
          return [
            [responseName, conflicts.map(([reason]) => reason)],
            [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
            [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
          ];
        }
      }
      var PairSet = class {
        constructor() {
          this._data = /* @__PURE__ */ new Map();
        }
        has(a, b, areMutuallyExclusive) {
          var _this$_data$get;
          const [key1, key2] = a < b ? [a, b] : [b, a];
          const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
          if (result === void 0) {
            return false;
          }
          return areMutuallyExclusive ? true : areMutuallyExclusive === result;
        }
        add(a, b, areMutuallyExclusive) {
          const [key1, key2] = a < b ? [a, b] : [b, a];
          const map = this._data.get(key1);
          if (map === void 0) {
            this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
          } else {
            map.set(key2, areMutuallyExclusive);
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
  var require_PossibleFragmentSpreadsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function PossibleFragmentSpreadsRule(context) {
        return {
          InlineFragment(node) {
            const fragType = context.getType();
            const parentType = context.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                nodes: node
              }));
            }
          },
          FragmentSpread(node) {
            const fragName = node.name.value;
            const fragType = getFragmentType(context, fragName);
            const parentType = context.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                nodes: node
              }));
            }
          }
        };
      }
      function getFragmentType(context, name) {
        const frag = context.getFragment(name);
        if (frag) {
          const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
          if ((0, _definition.isCompositeType)(type)) {
            return type;
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
  var require_PossibleTypeExtensionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      function PossibleTypeExtensionsRule(context) {
        const schema = context.getSchema();
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
          }
        }
        return {
          ScalarTypeExtension: checkExtension,
          ObjectTypeExtension: checkExtension,
          InterfaceTypeExtension: checkExtension,
          UnionTypeExtension: checkExtension,
          EnumTypeExtension: checkExtension,
          InputObjectTypeExtension: checkExtension
        };
        function checkExtension(node) {
          const typeName = node.name.value;
          const defNode = definedTypes[typeName];
          const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
          let expectedKind;
          if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
          } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
          }
          if (expectedKind) {
            if (expectedKind !== node.kind) {
              const kindStr = extensionKindToTypeName(node.kind);
              context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
                nodes: defNode ? [defNode, node] : node
              }));
            }
          } else {
            const allTypeNames = Object.keys({
              ...definedTypes,
              ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
            });
            const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);
            context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {
              nodes: node.name
            }));
          }
        }
      }
      var defKindToExtKind = {
        [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
        [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
        [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
      };
      function typeToExtKind(type) {
        if ((0, _definition.isScalarType)(type)) {
          return _kinds.Kind.SCALAR_TYPE_EXTENSION;
        }
        if ((0, _definition.isObjectType)(type)) {
          return _kinds.Kind.OBJECT_TYPE_EXTENSION;
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
        }
        if ((0, _definition.isUnionType)(type)) {
          return _kinds.Kind.UNION_TYPE_EXTENSION;
        }
        if ((0, _definition.isEnumType)(type)) {
          return _kinds.Kind.ENUM_TYPE_EXTENSION;
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function extensionKindToTypeName(kind) {
        switch (kind) {
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar";
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return "object";
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface";
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return "union";
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return "enum";
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";
          default:
            (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(kind));
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
  var require_ProvidedRequiredArgumentsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
      exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      function ProvidedRequiredArgumentsRule(context) {
        return {
          ...ProvidedRequiredArgumentsOnDirectivesRule(context),
          Field: {
            leave(fieldNode) {
              var _fieldNode$arguments;
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                return false;
              }
              const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value));
              for (const argDef of fieldDef.args) {
                if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                  const argTypeStr = (0, _inspect.inspect)(argDef.type);
                  context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                    nodes: fieldNode
                  }));
                }
              }
            }
          }
        };
      }
      function ProvidedRequiredArgumentsOnDirectivesRule(context) {
        var _schema$getDirectives;
        const requiredArgsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(directive.args.filter(_definition.isRequiredArgument), (arg) => arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
          }
        }
        return {
          Directive: {
            leave(directiveNode) {
              const directiveName = directiveNode.name.value;
              const requiredArgs = requiredArgsMap[directiveName];
              if (requiredArgs) {
                var _directiveNode$argume;
                const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
                for (const [argName, argDef] of Object.entries(requiredArgs)) {
                  if (!argNodeMap.has(argName)) {
                    const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                    context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                      nodes: directiveNode
                    }));
                  }
                }
              }
            }
          }
        };
      }
      function isRequiredArgumentNode(arg) {
        return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ScalarLeafsRule.js
  var require_ScalarLeafsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ScalarLeafsRule = ScalarLeafsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function ScalarLeafsRule(context) {
        return {
          Field(node) {
            const type = context.getType();
            const selectionSet = node.selectionSet;
            if (type) {
              if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                if (selectionSet) {
                  const fieldName = node.name.value;
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                    nodes: selectionSet
                  }));
                }
              } else if (!selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
                  nodes: node
                }));
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/printPathArray.js
  var require_printPathArray = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/printPathArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printPathArray = printPathArray;
      function printPathArray(path) {
        return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/Path.js
  var require_Path = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/Path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addPath = addPath;
      exports.pathToArray = pathToArray;
      function addPath(prev, key, typename) {
        return {
          prev,
          key,
          typename
        };
      }
      function pathToArray(path) {
        const flattened = [];
        let curr = path;
        while (curr) {
          flattened.push(curr.key);
          curr = curr.prev;
        }
        return flattened.reverse();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/coerceInputValue.js
  var require_coerceInputValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/coerceInputValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coerceInputValue = coerceInputValue;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _Path = require_Path();
      var _printPathArray = require_printPathArray();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function coerceInputValue(inputValue, type, onError = defaultOnError) {
        return coerceInputValueImpl(inputValue, type, onError, void 0);
      }
      function defaultOnError(path, invalidValue, error) {
        let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
        }
        error.message = errorPrefix + ": " + error.message;
        throw error;
      }
      function coerceInputValueImpl(inputValue, type, onError, path) {
        if ((0, _definition.isNonNullType)(type)) {
          if (inputValue != null) {
            return coerceInputValueImpl(inputValue, type.ofType, onError, path);
          }
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type "${(0, _inspect.inspect)(type)}" not to be null.`));
          return;
        }
        if (inputValue == null) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(inputValue)) {
            return Array.from(inputValue, (itemValue, index) => {
              const itemPath = (0, _Path.addPath)(path, index, void 0);
              return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
            });
          }
          return [coerceInputValueImpl(inputValue, itemType, onError, path)];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}" to be an object.`));
            return;
          }
          const coercedValue = {};
          const fieldDefs = type.getFields();
          for (const field of Object.values(fieldDefs)) {
            const fieldValue = inputValue[field.name];
            if (fieldValue === void 0) {
              if (field.defaultValue !== void 0) {
                coercedValue[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                const typeStr = (0, _inspect.inspect)(field.type);
                onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
              }
              continue;
            }
            coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
          }
          for (const fieldName of Object.keys(inputValue)) {
            if (!fieldDefs[fieldName]) {
              const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type.getFields()));
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)));
            }
          }
          return coercedValue;
        }
        if ((0, _definition.isLeafType)(type)) {
          let parseResult;
          try {
            parseResult = type.parseValue(inputValue);
          } catch (error) {
            if (error instanceof _GraphQLError.GraphQLError) {
              onError((0, _Path.pathToArray)(path), inputValue, error);
            } else {
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}". ` + error.message, {
                originalError: error
              }));
            }
            return;
          }
          if (parseResult === void 0) {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}".`));
          }
          return parseResult;
        }
        (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/valueFromAST.js
  var require_valueFromAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/valueFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromAST = valueFromAST;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _kinds = require_kinds();
      var _definition = require_definition();
      function valueFromAST(valueNode, type, variables) {
        if (!valueNode) {
          return;
        }
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variables == null || variables[variableName] === void 0) {
            return;
          }
          const variableValue = variables[variableName];
          if (variableValue === null && (0, _definition.isNonNullType)(type)) {
            return;
          }
          return variableValue;
        }
        if ((0, _definition.isNonNullType)(type)) {
          if (valueNode.kind === _kinds.Kind.NULL) {
            return;
          }
          return valueFromAST(valueNode, type.ofType, variables);
        }
        if (valueNode.kind === _kinds.Kind.NULL) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if (valueNode.kind === _kinds.Kind.LIST) {
            const coercedValues = [];
            for (const itemNode of valueNode.values) {
              if (isMissingVariable(itemNode, variables)) {
                if ((0, _definition.isNonNullType)(itemType)) {
                  return;
                }
                coercedValues.push(null);
              } else {
                const itemValue = valueFromAST(itemNode, itemType, variables);
                if (itemValue === void 0) {
                  return;
                }
                coercedValues.push(itemValue);
              }
            }
            return coercedValues;
          }
          const coercedValue = valueFromAST(valueNode, itemType, variables);
          if (coercedValue === void 0) {
            return;
          }
          return [coercedValue];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (valueNode.kind !== _kinds.Kind.OBJECT) {
            return;
          }
          const coercedObj = /* @__PURE__ */ Object.create(null);
          const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, (field) => field.name.value);
          for (const field of Object.values(type.getFields())) {
            const fieldNode = fieldNodes[field.name];
            if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
              if (field.defaultValue !== void 0) {
                coercedObj[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                return;
              }
              continue;
            }
            const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
            if (fieldValue === void 0) {
              return;
            }
            coercedObj[field.name] = fieldValue;
          }
          return coercedObj;
        }
        if ((0, _definition.isLeafType)(type)) {
          let result;
          try {
            result = type.parseLiteral(valueNode, variables);
          } catch (_error) {
            return;
          }
          if (result === void 0) {
            return;
          }
          return result;
        }
        (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
      }
      function isMissingVariable(valueNode, variables) {
        return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/values.js
  var require_values = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/values.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getArgumentValues = getArgumentValues;
      exports.getDirectiveValues = getDirectiveValues;
      exports.getVariableValues = getVariableValues;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _printPathArray = require_printPathArray();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _coerceInputValue = require_coerceInputValue();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      function getVariableValues(schema, varDefNodes, inputs, options) {
        const errors = [];
        const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
        try {
          const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error) => {
            if (maxErrors != null && errors.length >= maxErrors) {
              throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
            }
            errors.push(error);
          });
          if (errors.length === 0) {
            return {
              coerced
            };
          }
        } catch (error) {
          errors.push(error);
        }
        return {
          errors
        };
      }
      function coerceVariableValues(schema, varDefNodes, inputs, onError) {
        const coercedValues = {};
        for (const varDefNode of varDefNodes) {
          const varName = varDefNode.variable.name.value;
          const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
          if (!(0, _definition.isInputType)(varType)) {
            const varTypeStr = (0, _printer.print)(varDefNode.type);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
              nodes: varDefNode.type
            }));
            continue;
          }
          if (!hasOwnProperty(inputs, varName)) {
            if (varDefNode.defaultValue) {
              coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
            } else if ((0, _definition.isNonNullType)(varType)) {
              const varTypeStr = (0, _inspect.inspect)(varType);
              onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
                nodes: varDefNode
              }));
            }
            continue;
          }
          const value = inputs[varName];
          if (value === null && (0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
              nodes: varDefNode
            }));
            continue;
          }
          coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error) => {
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
              prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(path)}"`;
            }
            onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
              nodes: varDefNode,
              originalError: error.originalError
            }));
          });
        }
        return coercedValues;
      }
      function getArgumentValues(def, node, variableValues) {
        var _node$arguments;
        const coercedValues = {};
        const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
        const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, (arg) => arg.name.value);
        for (const argDef of def.args) {
          const name = argDef.name;
          const argType = argDef.type;
          const argumentNode = argNodeMap[name];
          if (!argumentNode) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" was not provided.`, {
                nodes: node
              });
            }
            continue;
          }
          const valueNode = argumentNode.value;
          let isNull = valueNode.kind === _kinds.Kind.NULL;
          if (valueNode.kind === _kinds.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
              if (argDef.defaultValue !== void 0) {
                coercedValues[name] = argDef.defaultValue;
              } else if ((0, _definition.isNonNullType)(argType)) {
                throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                  nodes: valueNode
                });
              }
              continue;
            }
            isNull = variableValues[variableName] == null;
          }
          if (isNull && (0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" of non-null type "${(0, _inspect.inspect)(argType)}" must not be null.`, {
              nodes: valueNode
            });
          }
          const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
          if (coercedValue === void 0) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" has invalid value ${(0, _printer.print)(valueNode)}.`, {
              nodes: valueNode
            });
          }
          coercedValues[name] = coercedValue;
        }
        return coercedValues;
      }
      function getDirectiveValues(directiveDef, node, variableValues) {
        var _node$directives;
        const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive) => directive.name.value === directiveDef.name);
        if (directiveNode) {
          return getArgumentValues(directiveDef, directiveNode, variableValues);
        }
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/collectFields.js
  var require_collectFields = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/collectFields.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.collectFields = collectFields;
      exports.collectSubfields = collectSubfields;
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _directives = require_directives();
      var _typeFromAST = require_typeFromAST();
      var _values = require_values();
      function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = /* @__PURE__ */ new Map();
        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, /* @__PURE__ */ new Set());
        return fields;
      }
      function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = /* @__PURE__ */ new Map();
        const visitedFragmentNames = /* @__PURE__ */ new Set();
        for (const node of fieldNodes) {
          if (node.selectionSet) {
            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
          }
        }
        return subFieldNodes;
      }
      function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              if (!shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              const name = getFieldEntryKey(selection);
              const fieldList = fields.get(name);
              if (fieldList !== void 0) {
                fieldList.push(selection);
              } else {
                fields.set(name, [selection]);
              }
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT: {
              if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                continue;
              }
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD: {
              const fragName = selection.name.value;
              if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              visitedFragmentNames.add(fragName);
              const fragment = fragments[fragName];
              if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                continue;
              }
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
              break;
            }
          }
        }
      }
      function shouldIncludeNode(variableValues, node) {
        const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);
        if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
          return false;
        }
        const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);
        if ((include === null || include === void 0 ? void 0 : include.if) === false) {
          return false;
        }
        return true;
      }
      function doesFragmentConditionMatch(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
          return true;
        }
        const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);
        if (conditionalType === type) {
          return true;
        }
        if ((0, _definition.isAbstractType)(conditionalType)) {
          return schema.isSubType(conditionalType, type);
        }
        return false;
      }
      function getFieldEntryKey(node) {
        return node.alias ? node.alias.value : node.name.value;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
  var require_SingleFieldSubscriptionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _collectFields = require_collectFields();
      function SingleFieldSubscriptionsRule(context) {
        return {
          OperationDefinition(node) {
            if (node.operation === "subscription") {
              const schema = context.getSchema();
              const subscriptionType = schema.getSubscriptionType();
              if (subscriptionType) {
                const operationName = node.name ? node.name.value : null;
                const variableValues = /* @__PURE__ */ Object.create(null);
                const document = context.getDocument();
                const fragments = /* @__PURE__ */ Object.create(null);
                for (const definition of document.definitions) {
                  if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    fragments[definition.name.value] = definition;
                  }
                }
                const fields = (0, _collectFields.collectFields)(schema, fragments, variableValues, subscriptionType, node.selectionSet);
                if (fields.size > 1) {
                  const fieldSelectionLists = [...fields.values()];
                  const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                  const extraFieldSelections = extraFieldSelectionLists.flat();
                  context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
                    nodes: extraFieldSelections
                  }));
                }
                for (const fieldNodes of fields.values()) {
                  const field = fieldNodes[0];
                  const fieldName = field.name.value;
                  if (fieldName.startsWith("__")) {
                    context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                      nodes: fieldNodes
                    }));
                  }
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/groupBy.js
  var require_groupBy = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/groupBy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.groupBy = groupBy;
      function groupBy(list, keyFn) {
        const result = /* @__PURE__ */ new Map();
        for (const item of list) {
          const key = keyFn(item);
          const group = result.get(key);
          if (group === void 0) {
            result.set(key, [item]);
          } else {
            group.push(item);
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
  var require_UniqueArgumentDefinitionNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentDefinitionNamesRule(context) {
        return {
          DirectiveDefinition(directiveNode) {
            var _directiveNode$argume;
            const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
          },
          InterfaceTypeDefinition: checkArgUniquenessPerField,
          InterfaceTypeExtension: checkArgUniquenessPerField,
          ObjectTypeDefinition: checkArgUniquenessPerField,
          ObjectTypeExtension: checkArgUniquenessPerField
        };
        function checkArgUniquenessPerField(typeNode) {
          var _typeNode$fields;
          const typeName = typeNode.name.value;
          const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
          for (const fieldDef of fieldNodes) {
            var _fieldDef$arguments;
            const fieldName = fieldDef.name.value;
            const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
            checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
          }
          return false;
        }
        function checkArgUniqueness(parentName, argumentNodes) {
          const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(new _GraphQLError.GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
                nodes: argNodes.map((node) => node.name)
              }));
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
  var require_UniqueArgumentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentNamesRule(context) {
        return {
          Field: checkArgUniqueness,
          Directive: checkArgUniqueness
        };
        function checkArgUniqueness(parentNode) {
          var _parentNode$arguments;
          const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
          const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one argument named "${argName}".`, {
                nodes: argNodes.map((node) => node.name)
              }));
            }
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
  var require_UniqueDirectiveNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueDirectiveNamesRule(context) {
        const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          DirectiveDefinition(node) {
            const directiveName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
              context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
                nodes: node.name
              }));
              return;
            }
            if (knownDirectiveNames[directiveName]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one directive named "@${directiveName}".`, {
                nodes: [knownDirectiveNames[directiveName], node.name]
              }));
            } else {
              knownDirectiveNames[directiveName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
  var require_UniqueDirectivesPerLocationRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _directives = require_directives();
      function UniqueDirectivesPerLocationRule(context) {
        const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
          }
        }
        const schemaDirectives = /* @__PURE__ */ Object.create(null);
        const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
        return {
          enter(node) {
            if (!("directives" in node) || !node.directives) {
              return;
            }
            let seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
              seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
              const typeName = node.name.value;
              seenDirectives = typeDirectivesMap[typeName];
              if (seenDirectives === void 0) {
                typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
              }
            } else {
              seenDirectives = /* @__PURE__ */ Object.create(null);
            }
            for (const directive of node.directives) {
              const directiveName = directive.name.value;
              if (uniqueDirectiveMap[directiveName]) {
                if (seenDirectives[directiveName]) {
                  context.reportError(new _GraphQLError.GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                    nodes: [seenDirectives[directiveName], directive]
                  }));
                } else {
                  seenDirectives[directiveName] = directive;
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
  var require_UniqueEnumValueNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueEnumValueNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownValueNames = /* @__PURE__ */ Object.create(null);
        return {
          EnumTypeDefinition: checkValueUniqueness,
          EnumTypeExtension: checkValueUniqueness
        };
        function checkValueUniqueness(node) {
          var _node$values;
          const typeName = node.name.value;
          if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          const valueNames = knownValueNames[typeName];
          for (const valueDef of valueNodes) {
            const valueName = valueDef.name.value;
            const existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
              context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                nodes: valueDef.name
              }));
            } else if (valueNames[valueName]) {
              context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
                nodes: [valueNames[valueName], valueDef.name]
              }));
            } else {
              valueNames[valueName] = valueDef.name;
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
  var require_UniqueFieldDefinitionNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueFieldDefinitionNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownFieldNames = /* @__PURE__ */ Object.create(null);
        return {
          InputObjectTypeDefinition: checkFieldUniqueness,
          InputObjectTypeExtension: checkFieldUniqueness,
          InterfaceTypeDefinition: checkFieldUniqueness,
          InterfaceTypeExtension: checkFieldUniqueness,
          ObjectTypeDefinition: checkFieldUniqueness,
          ObjectTypeExtension: checkFieldUniqueness
        };
        function checkFieldUniqueness(node) {
          var _node$fields;
          const typeName = node.name.value;
          if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          const fieldNames = knownFieldNames[typeName];
          for (const fieldDef of fieldNodes) {
            const fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
              context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                nodes: fieldDef.name
              }));
            } else if (fieldNames[fieldName]) {
              context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
                nodes: [fieldNames[fieldName], fieldDef.name]
              }));
            } else {
              fieldNames[fieldName] = fieldDef.name;
            }
          }
          return false;
        }
      }
      function hasField(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
          return type.getFields()[fieldName] != null;
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
  var require_UniqueFragmentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueFragmentNamesRule(context) {
        const knownFragmentNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            const fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
                nodes: [knownFragmentNames[fragmentName], node.name]
              }));
            } else {
              knownFragmentNames[fragmentName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
  var require_UniqueInputFieldNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      function UniqueInputFieldNamesRule(context) {
        const knownNameStack = [];
        let knownNames = /* @__PURE__ */ Object.create(null);
        return {
          ObjectValue: {
            enter() {
              knownNameStack.push(knownNames);
              knownNames = /* @__PURE__ */ Object.create(null);
            },
            leave() {
              const prevKnownNames = knownNameStack.pop();
              prevKnownNames || (0, _invariant.invariant)(false);
              knownNames = prevKnownNames;
            }
          },
          ObjectField(node) {
            const fieldName = node.name.value;
            if (knownNames[fieldName]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one input field named "${fieldName}".`, {
                nodes: [knownNames[fieldName], node.name]
              }));
            } else {
              knownNames[fieldName] = node.name;
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
  var require_UniqueOperationNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationNamesRule(context) {
        const knownOperationNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition(node) {
            const operationName = node.name;
            if (operationName) {
              if (knownOperationNames[operationName.value]) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one operation named "${operationName.value}".`, {
                  nodes: [
                    knownOperationNames[operationName.value],
                    operationName
                  ]
                }));
              } else {
                knownOperationNames[operationName.value] = operationName;
              }
            }
            return false;
          },
          FragmentDefinition: () => false
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
  var require_UniqueOperationTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationTypesRule(context) {
        const schema = context.getSchema();
        const definedOperationTypes = /* @__PURE__ */ Object.create(null);
        const existingOperationTypes = schema ? {
          query: schema.getQueryType(),
          mutation: schema.getMutationType(),
          subscription: schema.getSubscriptionType()
        } : {};
        return {
          SchemaDefinition: checkOperationTypes,
          SchemaExtension: checkOperationTypes
        };
        function checkOperationTypes(node) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            const operation = operationType.operation;
            const alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
              context.reportError(new _GraphQLError.GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
                nodes: operationType
              }));
            } else if (alreadyDefinedOperationType) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one ${operation} type in schema.`, {
                nodes: [alreadyDefinedOperationType, operationType]
              }));
            } else {
              definedOperationTypes[operation] = operationType;
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
  var require_UniqueTypeNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueTypeNamesRule(context) {
        const knownTypeNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          ScalarTypeDefinition: checkTypeName,
          ObjectTypeDefinition: checkTypeName,
          InterfaceTypeDefinition: checkTypeName,
          UnionTypeDefinition: checkTypeName,
          EnumTypeDefinition: checkTypeName,
          InputObjectTypeDefinition: checkTypeName
        };
        function checkTypeName(node) {
          const typeName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
            context.reportError(new _GraphQLError.GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
              nodes: node.name
            }));
            return;
          }
          if (knownTypeNames[typeName]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one type named "${typeName}".`, {
              nodes: [knownTypeNames[typeName], node.name]
            }));
          } else {
            knownTypeNames[typeName] = node.name;
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
  var require_UniqueVariableNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueVariableNamesRule(context) {
        return {
          OperationDefinition(operationNode) {
            var _operationNode$variab;
            const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
            const seenVariableDefinitions = (0, _groupBy.groupBy)(variableDefinitions, (node) => node.variable.name.value);
            for (const [variableName, variableNodes] of seenVariableDefinitions) {
              if (variableNodes.length > 1) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one variable named "$${variableName}".`, {
                  nodes: variableNodes.map((node) => node.variable.name)
                }));
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
  var require_ValuesOfCorrectTypeRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      function ValuesOfCorrectTypeRule(context) {
        return {
          ListValue(node) {
            const type = (0, _definition.getNullableType)(context.getParentInputType());
            if (!(0, _definition.isListType)(type)) {
              isValidValueNode(context, node);
              return false;
            }
          },
          ObjectValue(node) {
            const type = (0, _definition.getNamedType)(context.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
              isValidValueNode(context, node);
              return false;
            }
            const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, (field) => field.name.value);
            for (const fieldDef of Object.values(type.getFields())) {
              const fieldNode = fieldNodeMap[fieldDef.name];
              if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                const typeStr = (0, _inspect.inspect)(fieldDef.type);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
                  nodes: node
                }));
              }
            }
          },
          ObjectField(node) {
            const parentType = (0, _definition.getNamedType)(context.getParentInputType());
            const fieldType = context.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
              const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));
              context.reportError(new _GraphQLError.GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
                nodes: node
              }));
            }
          },
          NullValue(node) {
            const type = context.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
              context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${(0, _inspect.inspect)(type)}", found ${(0, _printer.print)(node)}.`, {
                nodes: node
              }));
            }
          },
          EnumValue: (node) => isValidValueNode(context, node),
          IntValue: (node) => isValidValueNode(context, node),
          FloatValue: (node) => isValidValueNode(context, node),
          StringValue: (node) => isValidValueNode(context, node),
          BooleanValue: (node) => isValidValueNode(context, node)
        };
      }
      function isValidValueNode(context, node) {
        const locationType = context.getInputType();
        if (!locationType) {
          return;
        }
        const type = (0, _definition.getNamedType)(locationType);
        if (!(0, _definition.isLeafType)(type)) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
            nodes: node
          }));
          return;
        }
        try {
          const parseResult = type.parseLiteral(node, void 0);
          if (parseResult === void 0) {
            const typeStr = (0, _inspect.inspect)(locationType);
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
              nodes: node
            }));
          }
        } catch (error) {
          const typeStr = (0, _inspect.inspect)(locationType);
          if (error instanceof _GraphQLError.GraphQLError) {
            context.reportError(error);
          } else {
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}; ` + error.message, {
              nodes: node,
              originalError: error
            }));
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
  var require_VariablesAreInputTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function VariablesAreInputTypesRule(context) {
        return {
          VariableDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
            if (type !== void 0 && !(0, _definition.isInputType)(type)) {
              const variableName = node.variable.name.value;
              const typeName = (0, _printer.print)(node.type);
              context.reportError(new _GraphQLError.GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
                nodes: node.type
              }));
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
  var require_VariablesInAllowedPositionRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function VariablesInAllowedPositionRule(context) {
        let varDefMap = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              varDefMap = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node, type, defaultValue } of usages) {
                const varName = node.name.value;
                const varDef = varDefMap[varName];
                if (varDef && type) {
                  const schema = context.getSchema();
                  const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                  if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                    const varTypeStr = (0, _inspect.inspect)(varType);
                    const typeStr = (0, _inspect.inspect)(type);
                    context.reportError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                      nodes: [varDef, node]
                    }));
                  }
                }
              }
            }
          },
          VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
          }
        };
      }
      function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
        if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
          const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
          const hasLocationDefaultValue = locationDefaultValue !== void 0;
          if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
          }
          const nullableLocationType = locationType.ofType;
          return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
        }
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/specifiedRules.js
  var require_specifiedRules = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/specifiedRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.specifiedSDLRules = exports.specifiedRules = void 0;
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var specifiedRules = Object.freeze([
        _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
        _UniqueOperationNamesRule.UniqueOperationNamesRule,
        _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
        _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
        _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
        _ScalarLeafsRule.ScalarLeafsRule,
        _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
        _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
        _KnownFragmentNamesRule.KnownFragmentNamesRule,
        _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
        _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
        _NoFragmentCyclesRule.NoFragmentCyclesRule,
        _UniqueVariableNamesRule.UniqueVariableNamesRule,
        _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
        _NoUnusedVariablesRule.NoUnusedVariablesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _KnownArgumentNamesRule.KnownArgumentNamesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
        _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
        _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
      ]);
      exports.specifiedRules = specifiedRules;
      var specifiedSDLRules = Object.freeze([
        _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
        _UniqueOperationTypesRule.UniqueOperationTypesRule,
        _UniqueTypeNamesRule.UniqueTypeNamesRule,
        _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
        _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
        _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
        _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
        _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
      ]);
      exports.specifiedSDLRules = specifiedSDLRules;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/ValidationContext.js
  var require_ValidationContext = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/ValidationContext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _TypeInfo = require_TypeInfo();
      var ASTValidationContext = class {
        constructor(ast, onError) {
          this._ast = ast;
          this._fragments = void 0;
          this._fragmentSpreads = /* @__PURE__ */ new Map();
          this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
          this._onError = onError;
        }
        get [Symbol.toStringTag]() {
          return "ASTValidationContext";
        }
        reportError(error) {
          this._onError(error);
        }
        getDocument() {
          return this._ast;
        }
        getFragment(name) {
          let fragments;
          if (this._fragments) {
            fragments = this._fragments;
          } else {
            fragments = /* @__PURE__ */ Object.create(null);
            for (const defNode of this.getDocument().definitions) {
              if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[defNode.name.value] = defNode;
              }
            }
            this._fragments = fragments;
          }
          return fragments[name];
        }
        getFragmentSpreads(node) {
          let spreads = this._fragmentSpreads.get(node);
          if (!spreads) {
            spreads = [];
            const setsToVisit = [node];
            let set;
            while (set = setsToVisit.pop()) {
              for (const selection of set.selections) {
                if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                  spreads.push(selection);
                } else if (selection.selectionSet) {
                  setsToVisit.push(selection.selectionSet);
                }
              }
            }
            this._fragmentSpreads.set(node, spreads);
          }
          return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
          let fragments = this._recursivelyReferencedFragments.get(operation);
          if (!fragments) {
            fragments = [];
            const collectedNames = /* @__PURE__ */ Object.create(null);
            const nodesToVisit = [operation.selectionSet];
            let node;
            while (node = nodesToVisit.pop()) {
              for (const spread of this.getFragmentSpreads(node)) {
                const fragName = spread.name.value;
                if (collectedNames[fragName] !== true) {
                  collectedNames[fragName] = true;
                  const fragment = this.getFragment(fragName);
                  if (fragment) {
                    fragments.push(fragment);
                    nodesToVisit.push(fragment.selectionSet);
                  }
                }
              }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
          }
          return fragments;
        }
      };
      exports.ASTValidationContext = ASTValidationContext;
      var SDLValidationContext = class extends ASTValidationContext {
        constructor(ast, schema, onError) {
          super(ast, onError);
          this._schema = schema;
        }
        get [Symbol.toStringTag]() {
          return "SDLValidationContext";
        }
        getSchema() {
          return this._schema;
        }
      };
      exports.SDLValidationContext = SDLValidationContext;
      var ValidationContext = class extends ASTValidationContext {
        constructor(schema, ast, typeInfo, onError) {
          super(ast, onError);
          this._schema = schema;
          this._typeInfo = typeInfo;
          this._variableUsages = /* @__PURE__ */ new Map();
          this._recursiveVariableUsages = /* @__PURE__ */ new Map();
        }
        get [Symbol.toStringTag]() {
          return "ValidationContext";
        }
        getSchema() {
          return this._schema;
        }
        getVariableUsages(node) {
          let usages = this._variableUsages.get(node);
          if (!usages) {
            const newUsages = [];
            const typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            }));
            usages = newUsages;
            this._variableUsages.set(node, usages);
          }
          return usages;
        }
        getRecursiveVariableUsages(operation) {
          let usages = this._recursiveVariableUsages.get(operation);
          if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)) {
              usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
          }
          return usages;
        }
        getType() {
          return this._typeInfo.getType();
        }
        getParentType() {
          return this._typeInfo.getParentType();
        }
        getInputType() {
          return this._typeInfo.getInputType();
        }
        getParentInputType() {
          return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
          return this._typeInfo.getFieldDef();
        }
        getDirective() {
          return this._typeInfo.getDirective();
        }
        getArgument() {
          return this._typeInfo.getArgument();
        }
        getEnumValue() {
          return this._typeInfo.getEnumValue();
        }
      };
      exports.ValidationContext = ValidationContext;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/validate.js
  var require_validate2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSDL = assertValidSDL;
      exports.assertValidSDLExtension = assertValidSDLExtension;
      exports.validate = validate;
      exports.validateSDL = validateSDL;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _visitor = require_visitor();
      var _validate = require_validate();
      var _TypeInfo = require_TypeInfo();
      var _specifiedRules = require_specifiedRules();
      var _ValidationContext = require_ValidationContext();
      function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
        var _options$maxErrors;
        const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
        documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        const abortObj = Object.freeze({});
        const errors = [];
        const context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, (error) => {
          if (errors.length >= maxErrors) {
            errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
            throw abortObj;
          }
          errors.push(error);
        });
        const visitor = (0, _visitor.visitInParallel)(rules.map((rule) => rule(context)));
        try {
          (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
        } catch (e) {
          if (e !== abortObj) {
            throw e;
          }
        }
        return errors;
      }
      function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
        const errors = [];
        const context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, (error) => {
          errors.push(error);
        });
        const visitors = rules.map((rule) => rule(context));
        (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
        return errors;
      }
      function assertValidSDL(documentAST) {
        const errors = validateSDL(documentAST);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      function assertValidSDLExtension(documentAST, schema) {
        const errors = validateSDL(documentAST, schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/memoize3.js
  var require_memoize3 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/memoize3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.memoize3 = memoize3;
      function memoize3(fn) {
        let cache0;
        return function memoized(a1, a2, a3) {
          if (cache0 === void 0) {
            cache0 = /* @__PURE__ */ new WeakMap();
          }
          let cache1 = cache0.get(a1);
          if (cache1 === void 0) {
            cache1 = /* @__PURE__ */ new WeakMap();
            cache0.set(a1, cache1);
          }
          let cache2 = cache1.get(a2);
          if (cache2 === void 0) {
            cache2 = /* @__PURE__ */ new WeakMap();
            cache1.set(a2, cache2);
          }
          let fnResult = cache2.get(a3);
          if (fnResult === void 0) {
            fnResult = fn(a1, a2, a3);
            cache2.set(a3, fnResult);
          }
          return fnResult;
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/promiseForObject.js
  var require_promiseForObject = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/promiseForObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseForObject = promiseForObject;
      function promiseForObject(object) {
        return Promise.all(Object.values(object)).then((resolvedValues) => {
          const resolvedObject = /* @__PURE__ */ Object.create(null);
          for (const [i, key] of Object.keys(object).entries()) {
            resolvedObject[key] = resolvedValues[i];
          }
          return resolvedObject;
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/promiseReduce.js
  var require_promiseReduce = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/promiseReduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseReduce = promiseReduce;
      var _isPromise = require_isPromise();
      function promiseReduce(values, callbackFn, initialValue) {
        let accumulator = initialValue;
        for (const value of values) {
          accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
        }
        return accumulator;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/toError.js
  var require_toError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/toError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toError = toError;
      var _inspect = require_inspect();
      function toError(thrownValue) {
        return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
      }
      var NonErrorThrown = class extends Error {
        constructor(thrownValue) {
          super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
          this.name = "NonErrorThrown";
          this.thrownValue = thrownValue;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/locatedError.js
  var require_locatedError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/locatedError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.locatedError = locatedError;
      var _toError = require_toError();
      var _GraphQLError = require_GraphQLError();
      function locatedError(rawOriginalError, nodes, path) {
        var _nodes;
        const originalError = (0, _toError.toError)(rawOriginalError);
        if (isLocatedGraphQLError(originalError)) {
          return originalError;
        }
        return new _GraphQLError.GraphQLError(originalError.message, {
          nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
          source: originalError.source,
          positions: originalError.positions,
          path,
          originalError
        });
      }
      function isLocatedGraphQLError(error) {
        return Array.isArray(error.path);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/execute.js
  var require_execute = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/execute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidExecutionArguments = assertValidExecutionArguments;
      exports.buildExecutionContext = buildExecutionContext;
      exports.buildResolveInfo = buildResolveInfo;
      exports.defaultTypeResolver = exports.defaultFieldResolver = void 0;
      exports.execute = execute;
      exports.executeSync = executeSync;
      exports.getFieldDef = getFieldDef;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _isPromise = require_isPromise();
      var _memoize = require_memoize3();
      var _Path = require_Path();
      var _promiseForObject = require_promiseForObject();
      var _promiseReduce = require_promiseReduce();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _collectFields = require_collectFields();
      var _values = require_values();
      var collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
      function execute(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
        const { schema, document, variableValues, rootValue } = args;
        assertValidExecutionArguments(schema, document, variableValues);
        const exeContext = buildExecutionContext(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const { operation } = exeContext;
          const result = executeOperation(exeContext, operation, rootValue);
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((data) => buildResponse(data, exeContext.errors), (error) => {
              exeContext.errors.push(error);
              return buildResponse(null, exeContext.errors);
            });
          }
          return buildResponse(result, exeContext.errors);
        } catch (error) {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      }
      function executeSync(args) {
        const result = execute(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function buildResponse(data, errors) {
        return errors.length === 0 ? {
          data
        } : {
          errors,
          data
        };
      }
      function assertValidExecutionArguments(schema, document, rawVariableValues) {
        document || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
      }
      function buildExecutionContext(args) {
        var _definition$name, _operation$variableDe;
        const {
          schema,
          document,
          rootValue,
          contextValue,
          variableValues: rawVariableValues,
          operationName,
          fieldResolver,
          typeResolver,
          subscribeFieldResolver
        } = args;
        let operation;
        const fragments = /* @__PURE__ */ Object.create(null);
        for (const definition of document.definitions) {
          switch (definition.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              if (operationName == null) {
                if (operation !== void 0) {
                  return [
                    new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")
                  ];
                }
                operation = definition;
              } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                operation = definition;
              }
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              fragments[definition.name.value] = definition;
              break;
            default:
          }
        }
        if (!operation) {
          if (operationName != null) {
            return [
              new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)
            ];
          }
          return [new _GraphQLError.GraphQLError("Must provide an operation.")];
        }
        const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
        const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
          maxErrors: 50
        });
        if (coercedVariableValues.errors) {
          return coercedVariableValues.errors;
        }
        return {
          schema,
          fragments,
          rootValue,
          contextValue,
          operation,
          variableValues: coercedVariableValues.coerced,
          fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
          typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
          subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
          errors: []
        };
      }
      function executeOperation(exeContext, operation, rootValue) {
        const rootType = exeContext.schema.getRootType(operation.operation);
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
            nodes: operation
          });
        }
        const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
        const path = void 0;
        switch (operation.operation) {
          case _ast.OperationTypeNode.QUERY:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
          case _ast.OperationTypeNode.MUTATION:
            return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
        }
      }
      function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
        return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, [responseName, fieldNodes]) => {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
          if (result === void 0) {
            return results;
          }
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult) => {
              results[responseName] = resolvedResult;
              return results;
            });
          }
          results[responseName] = result;
          return results;
        }, /* @__PURE__ */ Object.create(null));
      }
      function executeFields(exeContext, parentType, sourceValue, path, fields) {
        const results = /* @__PURE__ */ Object.create(null);
        let containsPromise = false;
        for (const [responseName, fieldNodes] of fields.entries()) {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
          if (result !== void 0) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
              containsPromise = true;
            }
          }
        }
        if (!containsPromise) {
          return results;
        }
        return (0, _promiseForObject.promiseForObject)(results);
      }
      function executeField(exeContext, parentType, source, fieldNodes, path) {
        var _fieldDef$resolve;
        const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
        if (!fieldDef) {
          return;
        }
        const returnType = fieldDef.type;
        const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
        const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
        try {
          const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
          const contextValue = exeContext.contextValue;
          const result = resolveFn(source, args, contextValue, info);
          let completed;
          if ((0, _isPromise.isPromise)(result)) {
            completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
          } else {
            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
          }
          if ((0, _isPromise.isPromise)(completed)) {
            return completed.then(void 0, (rawError) => {
              const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
              return handleFieldError(error, returnType, exeContext);
            });
          }
          return completed;
        } catch (rawError) {
          const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
          return handleFieldError(error, returnType, exeContext);
        }
      }
      function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
        return {
          fieldName: fieldDef.name,
          fieldNodes,
          returnType: fieldDef.type,
          parentType,
          path,
          schema: exeContext.schema,
          fragments: exeContext.fragments,
          rootValue: exeContext.rootValue,
          operation: exeContext.operation,
          variableValues: exeContext.variableValues
        };
      }
      function handleFieldError(error, returnType, exeContext) {
        if ((0, _definition.isNonNullType)(returnType)) {
          throw error;
        }
        exeContext.errors.push(error);
        return null;
      }
      function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (result instanceof Error) {
          throw result;
        }
        if ((0, _definition.isNonNullType)(returnType)) {
          const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
          if (completed === null) {
            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
          }
          return completed;
        }
        if (result == null) {
          return null;
        }
        if ((0, _definition.isListType)(returnType)) {
          return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _definition.isLeafType)(returnType)) {
          return completeLeafValue(returnType, result);
        }
        if ((0, _definition.isAbstractType)(returnType)) {
          return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _definition.isObjectType)(returnType)) {
          return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        (0, _invariant.invariant)(false, "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType));
      }
      function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (!(0, _isIterableObject.isIterableObject)(result)) {
          throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
        }
        const itemType = returnType.ofType;
        let containsPromise = false;
        const completedResults = Array.from(result, (item, index) => {
          const itemPath = (0, _Path.addPath)(path, index, void 0);
          try {
            let completedItem;
            if ((0, _isPromise.isPromise)(item)) {
              completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
            } else {
              completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
            }
            if ((0, _isPromise.isPromise)(completedItem)) {
              containsPromise = true;
              return completedItem.then(void 0, (rawError) => {
                const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
                return handleFieldError(error, itemType, exeContext);
              });
            }
            return completedItem;
          } catch (rawError) {
            const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
            return handleFieldError(error, itemType, exeContext);
          }
        });
        return containsPromise ? Promise.all(completedResults) : completedResults;
      }
      function completeLeafValue(returnType, result) {
        const serializedResult = returnType.serialize(result);
        if (serializedResult == null) {
          throw new Error(`Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);
        }
        return serializedResult;
      }
      function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
        var _returnType$resolveTy;
        const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
        const contextValue = exeContext.contextValue;
        const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
        if ((0, _isPromise.isPromise)(runtimeType)) {
          return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
        }
        return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
      }
      function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
        if (runtimeTypeName == null) {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
        }
        if ((0, _definition.isObjectType)(runtimeTypeName)) {
          throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
        }
        if (typeof runtimeTypeName !== "string") {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`);
        }
        const runtimeType = exeContext.schema.getType(runtimeTypeName);
        if (runtimeType == null) {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
            nodes: fieldNodes
          });
        }
        if (!(0, _definition.isObjectType)(runtimeType)) {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
            nodes: fieldNodes
          });
        }
        if (!exeContext.schema.isSubType(returnType, runtimeType)) {
          throw new _GraphQLError.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
            nodes: fieldNodes
          });
        }
        return runtimeType;
      }
      function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
        const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
        if (returnType.isTypeOf) {
          const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf) => {
              if (!resolvedIsTypeOf) {
                throw invalidReturnTypeError(returnType, result, fieldNodes);
              }
              return executeFields(exeContext, returnType, result, path, subFieldNodes);
            });
          }
          if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
        }
        return executeFields(exeContext, returnType, result, path, subFieldNodes);
      }
      function invalidReturnTypeError(returnType, result, fieldNodes) {
        return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`, {
          nodes: fieldNodes
        });
      }
      var defaultTypeResolver = function(value, contextValue, info, abstractType) {
        if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
          return value.__typename;
        }
        const possibleTypes = info.schema.getPossibleTypes(abstractType);
        const promisedIsTypeOfResults = [];
        for (let i = 0; i < possibleTypes.length; i++) {
          const type = possibleTypes[i];
          if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if ((0, _isPromise.isPromise)(isTypeOfResult)) {
              promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
              return type.name;
            }
          }
        }
        if (promisedIsTypeOfResults.length) {
          return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
            for (let i = 0; i < isTypeOfResults.length; i++) {
              if (isTypeOfResults[i]) {
                return possibleTypes[i].name;
              }
            }
          });
        }
      };
      exports.defaultTypeResolver = defaultTypeResolver;
      var defaultFieldResolver = function(source, args, contextValue, info) {
        if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
          const property = source[info.fieldName];
          if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
          }
          return property;
        }
      };
      exports.defaultFieldResolver = defaultFieldResolver;
      function getFieldDef(schema, parentType, fieldNode) {
        const fieldName = fieldNode.name.value;
        if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
          return _introspection.TypeNameMetaFieldDef;
        }
        return parentType.getFields()[fieldName];
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/graphql.js
  var require_graphql = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/graphql.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.graphql = graphql;
      exports.graphqlSync = graphqlSync;
      var _devAssert = require_devAssert();
      var _isPromise = require_isPromise();
      var _parser = require_parser();
      var _validate = require_validate();
      var _validate2 = require_validate2();
      var _execute = require_execute();
      function graphql(args) {
        return new Promise((resolve2) => resolve2(graphqlImpl(args)));
      }
      function graphqlSync(args) {
        const result = graphqlImpl(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function graphqlImpl(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
        const {
          schema,
          source,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        } = args;
        const schemaValidationErrors = (0, _validate.validateSchema)(schema);
        if (schemaValidationErrors.length > 0) {
          return {
            errors: schemaValidationErrors
          };
        }
        let document;
        try {
          document = (0, _parser.parse)(source);
        } catch (syntaxError) {
          return {
            errors: [syntaxError]
          };
        }
        const validationErrors = (0, _validate2.validate)(schema, document);
        if (validationErrors.length > 0) {
          return {
            errors: validationErrors
          };
        }
        return (0, _execute.execute)({
          schema,
          document,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/index.js
  var require_type = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/type/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _directives.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _schema.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _introspection.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _introspection.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _introspection.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _introspection.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _introspection.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _introspection.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _introspection.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _directives.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _definition.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _assertName.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _definition.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _definition.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _assertName.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _definition.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _definition.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _definition.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _definition.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _schema.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _definition.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _definition.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _validate.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _definition.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _definition.getNullableType;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _introspection.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _directives.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _definition.isEnumType;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _definition.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _introspection.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _definition.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _definition.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _definition.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _definition.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _definition.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _definition.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _schema.isSchema;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _directives.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _scalars.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _definition.isType;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _definition.isUnionType;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.isWrappingType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _directives.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _scalars.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _validate.validateSchema;
        }
      });
      var _schema = require_schema();
      var _definition = require_definition();
      var _directives = require_directives();
      var _scalars = require_scalars();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _assertName = require_assertName();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/index.js
  var require_language = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/language/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _visitor.BREAK;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _directiveLocation.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _kinds.Kind;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _lexer.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _ast.Location;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _ast.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _source.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _ast.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _tokenKind.TokenKind;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _visitor.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _location.getLocation;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _visitor.getVisitFn;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isValueNode;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _parser.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _parser.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _parser.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _parser.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _printer.print;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printLocation;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _visitor.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _visitor.visitInParallel;
        }
      });
      var _source = require_source();
      var _location = require_location();
      var _printLocation = require_printLocation();
      var _kinds = require_kinds();
      var _tokenKind = require_tokenKind();
      var _lexer = require_lexer();
      var _parser = require_parser();
      var _printer = require_printer();
      var _visitor = require_visitor();
      var _ast = require_ast();
      var _predicates = require_predicates();
      var _directiveLocation = require_directiveLocation();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/jsutils/isAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAsyncIterable = isAsyncIterable;
      function isAsyncIterable(maybeAsyncIterable) {
        return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/mapAsyncIterator.js
  var require_mapAsyncIterator = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/mapAsyncIterator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapAsyncIterator = mapAsyncIterator;
      function mapAsyncIterator(iterable, callback) {
        const iterator = iterable[Symbol.asyncIterator]();
        async function mapResult(result) {
          if (result.done) {
            return result;
          }
          try {
            return {
              value: await callback(result.value),
              done: false
            };
          } catch (error) {
            if (typeof iterator.return === "function") {
              try {
                await iterator.return();
              } catch (_e) {
              }
            }
            throw error;
          }
        }
        return {
          async next() {
            return mapResult(await iterator.next());
          },
          async return() {
            return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
              value: void 0,
              done: true
            };
          },
          async throw(error) {
            if (typeof iterator.throw === "function") {
              return mapResult(await iterator.throw(error));
            }
            throw error;
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/subscribe.js
  var require_subscribe = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/subscribe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSourceEventStream = createSourceEventStream;
      exports.subscribe = subscribe;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isAsyncIterable = require_isAsyncIterable();
      var _Path = require_Path();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _collectFields = require_collectFields();
      var _execute = require_execute();
      var _mapAsyncIterator = require_mapAsyncIterator();
      var _values = require_values();
      async function subscribe(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
        const {
          schema,
          document,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          subscribeFieldResolver
        } = args;
        const resultOrStream = await createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
        if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
          return resultOrStream;
        }
        const mapSourceToResponse = (payload) => (0, _execute.execute)({
          schema,
          document,
          rootValue: payload,
          contextValue,
          variableValues,
          operationName,
          fieldResolver
        });
        return (0, _mapAsyncIterator.mapAsyncIterator)(resultOrStream, mapSourceToResponse);
      }
      async function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver) {
        (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
        const exeContext = (0, _execute.buildExecutionContext)({
          schema,
          document,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          subscribeFieldResolver
        });
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const eventStream = await executeSubscription(exeContext);
          if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
            throw new Error(`Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`);
          }
          return eventStream;
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            return {
              errors: [error]
            };
          }
          throw error;
        }
      }
      async function executeSubscription(exeContext) {
        const { schema, fragments, operation, variableValues, rootValue } = exeContext;
        const rootType = schema.getSubscriptionType();
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError("Schema is not configured to execute subscription operation.", {
            nodes: operation
          });
        }
        const rootFields = (0, _collectFields.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
        const [responseName, fieldNodes] = [...rootFields.entries()][0];
        const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
        if (!fieldDef) {
          const fieldName = fieldNodes[0].name.value;
          throw new _GraphQLError.GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
            nodes: fieldNodes
          });
        }
        const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
        const info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, rootType, path);
        try {
          var _fieldDef$subscribe;
          const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
          const contextValue = exeContext.contextValue;
          const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
          const eventStream = await resolveFn(rootValue, args, contextValue, info);
          if (eventStream instanceof Error) {
            throw eventStream;
          }
          return eventStream;
        } catch (error) {
          throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/index.js
  var require_execution = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/execution/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _subscribe.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _execute.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _execute.executeSync;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _values.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _values.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _values.getVariableValues;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _Path.pathToArray;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _subscribe.subscribe;
        }
      });
      var _Path = require_Path();
      var _execute = require_execute();
      var _subscribe = require_subscribe();
      var _values = require_values();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
  var require_NoDeprecatedCustomRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function NoDeprecatedCustomRule(context) {
        return {
          Field(node) {
            const fieldDef = context.getFieldDef();
            const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
            if (fieldDef && deprecationReason != null) {
              const parentType = context.getParentType();
              parentType != null || (0, _invariant.invariant)(false);
              context.reportError(new _GraphQLError.GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            }
          },
          Argument(node) {
            const argDef = context.getArgument();
            const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
            if (argDef && deprecationReason != null) {
              const directiveDef = context.getDirective();
              if (directiveDef != null) {
                context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                  nodes: node
                }));
              } else {
                const parentType = context.getParentType();
                const fieldDef = context.getFieldDef();
                parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                  nodes: node
                }));
              }
            }
          },
          ObjectField(node) {
            const inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
            if ((0, _definition.isInputObjectType)(inputObjectDef)) {
              const inputFieldDef = inputObjectDef.getFields()[node.name.value];
              const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
              if (deprecationReason != null) {
                context.reportError(new _GraphQLError.GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
                  nodes: node
                }));
              }
            }
          },
          EnumValue(node) {
            const enumValueDef = context.getEnumValue();
            const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
            if (enumValueDef && deprecationReason != null) {
              const enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
              enumTypeDef != null || (0, _invariant.invariant)(false);
              context.reportError(new _GraphQLError.GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
  var require_NoSchemaIntrospectionCustomRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _introspection = require_introspection();
      function NoSchemaIntrospectionCustomRule(context) {
        return {
          Field(node) {
            const type = (0, _definition.getNamedType)(context.getType());
            if (type && (0, _introspection.isIntrospectionType)(type)) {
              context.reportError(new _GraphQLError.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, {
                nodes: node
              }));
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/index.js
  var require_validation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/validation/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownArgumentNamesRule.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _KnownDirectivesRule.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownFragmentNamesRule.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownTypeNamesRule.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _NoFragmentCyclesRule.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedVariablesRule.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _ScalarLeafsRule.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationNamesRule.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationTypesRule.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueTypeNamesRule.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueVariableNamesRule.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _ValidationContext.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _specifiedRules.specifiedRules;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _validate.validate;
        }
      });
      var _validate = require_validate2();
      var _ValidationContext = require_ValidationContext();
      var _specifiedRules = require_specifiedRules();
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
      var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/index.js
  var require_error = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/error/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.GraphQLError;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.formatError;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _locatedError.locatedError;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.printError;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _syntaxError.syntaxError;
        }
      });
      var _GraphQLError = require_GraphQLError();
      var _syntaxError = require_syntaxError();
      var _locatedError = require_locatedError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/getIntrospectionQuery.js
  var require_getIntrospectionQuery = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/getIntrospectionQuery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getIntrospectionQuery = getIntrospectionQuery;
      function getIntrospectionQuery(options) {
        const optionsWithDefault = {
          descriptions: true,
          specifiedByUrl: false,
          directiveIsRepeatable: false,
          schemaDescription: false,
          inputValueDeprecation: false,
          ...options
        };
        const descriptions = optionsWithDefault.descriptions ? "description" : "";
        const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
        const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
        const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
        function inputDeprecation(str) {
          return optionsWithDefault.inputValueDeprecation ? str : "";
        }
        return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/getOperationAST.js
  var require_getOperationAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/getOperationAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationAST = getOperationAST;
      var _kinds = require_kinds();
      function getOperationAST(documentAST, operationName) {
        let operation = null;
        for (const definition of documentAST.definitions) {
          if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
            var _definition$name;
            if (operationName == null) {
              if (operation) {
                return null;
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              return definition;
            }
          }
        }
        return operation;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/getOperationRootType.js
  var require_getOperationRootType = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/getOperationRootType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationRootType = getOperationRootType;
      var _GraphQLError = require_GraphQLError();
      function getOperationRootType(schema, operation) {
        if (operation.operation === "query") {
          const queryType = schema.getQueryType();
          if (!queryType) {
            throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", {
              nodes: operation
            });
          }
          return queryType;
        }
        if (operation.operation === "mutation") {
          const mutationType = schema.getMutationType();
          if (!mutationType) {
            throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", {
              nodes: operation
            });
          }
          return mutationType;
        }
        if (operation.operation === "subscription") {
          const subscriptionType = schema.getSubscriptionType();
          if (!subscriptionType) {
            throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", {
              nodes: operation
            });
          }
          return subscriptionType;
        }
        throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", {
          nodes: operation
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/introspectionFromSchema.js
  var require_introspectionFromSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/introspectionFromSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionFromSchema = introspectionFromSchema;
      var _invariant = require_invariant();
      var _parser = require_parser();
      var _execute = require_execute();
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      function introspectionFromSchema(schema, options) {
        const optionsWithDefaults = {
          specifiedByUrl: true,
          directiveIsRepeatable: true,
          schemaDescription: true,
          inputValueDeprecation: true,
          ...options
        };
        const document = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
        const result = (0, _execute.executeSync)({
          schema,
          document
        });
        !result.errors && result.data || (0, _invariant.invariant)(false);
        return result.data;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/buildClientSchema.js
  var require_buildClientSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/buildClientSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildClientSchema = buildClientSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _keyValMap = require_keyValMap();
      var _parser = require_parser();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _valueFromAST = require_valueFromAST();
      function buildClientSchema(introspection, options) {
        (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`);
        const schemaIntrospection = introspection.__schema;
        const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));
        for (const stdType of [
          ..._scalars.specifiedScalarTypes,
          ..._introspection.introspectionTypes
        ]) {
          if (typeMap[stdType.name]) {
            typeMap[stdType.name] = stdType;
          }
        }
        const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
        const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
        const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
        const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
        return new _schema.GraphQLSchema({
          description: schemaIntrospection.description,
          query: queryType,
          mutation: mutationType,
          subscription: subscriptionType,
          types: Object.values(typeMap),
          directives,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
        function getType(typeRef) {
          if (typeRef.kind === _introspection.TypeKind.LIST) {
            const itemRef = typeRef.ofType;
            if (!itemRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            return new _definition.GraphQLList(getType(itemRef));
          }
          if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
            const nullableRef = typeRef.ofType;
            if (!nullableRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            const nullableType = getType(nullableRef);
            return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
          }
          return getNamedType(typeRef);
        }
        function getNamedType(typeRef) {
          const typeName = typeRef.name;
          if (!typeName) {
            throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);
          }
          const type = typeMap[typeName];
          if (!type) {
            throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
          }
          return type;
        }
        function getObjectType(typeRef) {
          return (0, _definition.assertObjectType)(getNamedType(typeRef));
        }
        function getInterfaceType(typeRef) {
          return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
        }
        function buildType(type) {
          if (type != null && type.name != null && type.kind != null) {
            switch (type.kind) {
              case _introspection.TypeKind.SCALAR:
                return buildScalarDef(type);
              case _introspection.TypeKind.OBJECT:
                return buildObjectDef(type);
              case _introspection.TypeKind.INTERFACE:
                return buildInterfaceDef(type);
              case _introspection.TypeKind.UNION:
                return buildUnionDef(type);
              case _introspection.TypeKind.ENUM:
                return buildEnumDef(type);
              case _introspection.TypeKind.INPUT_OBJECT:
                return buildInputObjectDef(type);
            }
          }
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
        }
        function buildScalarDef(scalarIntrospection) {
          return new _definition.GraphQLScalarType({
            name: scalarIntrospection.name,
            description: scalarIntrospection.description,
            specifiedByURL: scalarIntrospection.specifiedByURL
          });
        }
        function buildImplementationsList(implementingIntrospection) {
          if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
            return [];
          }
          if (!implementingIntrospection.interfaces) {
            const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);
            throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
          }
          return implementingIntrospection.interfaces.map(getInterfaceType);
        }
        function buildObjectDef(objectIntrospection) {
          return new _definition.GraphQLObjectType({
            name: objectIntrospection.name,
            description: objectIntrospection.description,
            interfaces: () => buildImplementationsList(objectIntrospection),
            fields: () => buildFieldDefMap(objectIntrospection)
          });
        }
        function buildInterfaceDef(interfaceIntrospection) {
          return new _definition.GraphQLInterfaceType({
            name: interfaceIntrospection.name,
            description: interfaceIntrospection.description,
            interfaces: () => buildImplementationsList(interfaceIntrospection),
            fields: () => buildFieldDefMap(interfaceIntrospection)
          });
        }
        function buildUnionDef(unionIntrospection) {
          if (!unionIntrospection.possibleTypes) {
            const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
            throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
          }
          return new _definition.GraphQLUnionType({
            name: unionIntrospection.name,
            description: unionIntrospection.description,
            types: () => unionIntrospection.possibleTypes.map(getObjectType)
          });
        }
        function buildEnumDef(enumIntrospection) {
          if (!enumIntrospection.enumValues) {
            const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
            throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
          }
          return new _definition.GraphQLEnumType({
            name: enumIntrospection.name,
            description: enumIntrospection.description,
            values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            }))
          });
        }
        function buildInputObjectDef(inputObjectIntrospection) {
          if (!inputObjectIntrospection.inputFields) {
            const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);
            throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
          }
          return new _definition.GraphQLInputObjectType({
            name: inputObjectIntrospection.name,
            description: inputObjectIntrospection.description,
            fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
          });
        }
        function buildFieldDefMap(typeIntrospection) {
          if (!typeIntrospection.fields) {
            throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);
          }
          return (0, _keyValMap.keyValMap)(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);
        }
        function buildField(fieldIntrospection) {
          const type = getType(fieldIntrospection.type);
          if (!(0, _definition.isOutputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
          }
          if (!fieldIntrospection.args) {
            const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
            throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
          }
          return {
            description: fieldIntrospection.description,
            deprecationReason: fieldIntrospection.deprecationReason,
            type,
            args: buildInputValueDefMap(fieldIntrospection.args)
          };
        }
        function buildInputValueDefMap(inputValueIntrospections) {
          return (0, _keyValMap.keyValMap)(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);
        }
        function buildInputValue(inputValueIntrospection) {
          const type = getType(inputValueIntrospection.type);
          if (!(0, _definition.isInputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
          }
          const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : void 0;
          return {
            description: inputValueIntrospection.description,
            type,
            defaultValue,
            deprecationReason: inputValueIntrospection.deprecationReason
          };
        }
        function buildDirective(directiveIntrospection) {
          if (!directiveIntrospection.args) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
            throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
          }
          if (!directiveIntrospection.locations) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
            throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
          }
          return new _directives.GraphQLDirective({
            name: directiveIntrospection.name,
            description: directiveIntrospection.description,
            isRepeatable: directiveIntrospection.isRepeatable,
            locations: directiveIntrospection.locations.slice(),
            args: buildInputValueDefMap(directiveIntrospection.args)
          });
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/extendSchema.js
  var require_extendSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/extendSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.extendSchema = extendSchema;
      exports.extendSchemaImpl = extendSchemaImpl;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _mapValue = require_mapValue();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _values = require_values();
      var _valueFromAST = require_valueFromAST();
      function extendSchema(schema, documentAST, options) {
        (0, _schema.assertSchema)(schema);
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDLExtension)(documentAST, schema);
        }
        const schemaConfig = schema.toConfig();
        const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
        return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
      }
      function extendSchemaImpl(schemaConfig, documentAST, options) {
        var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
        const typeDefs = [];
        const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
        const directiveDefs = [];
        let schemaDef;
        const schemaExtensions = [];
        for (const def of documentAST.definitions) {
          if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
            schemaDef = def;
          } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(def);
          } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
            typeDefs.push(def);
          } else if ((0, _predicates.isTypeExtensionNode)(def)) {
            const extendedTypeName = def.name.value;
            const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
            typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
          } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            directiveDefs.push(def);
          }
        }
        if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
          return schemaConfig;
        }
        const typeMap = /* @__PURE__ */ Object.create(null);
        for (const existingType of schemaConfig.types) {
          typeMap[existingType.name] = extendNamedType(existingType);
        }
        for (const typeNode of typeDefs) {
          var _stdTypeMap$name;
          const name = typeNode.name.value;
          typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
        }
        const operationTypes = {
          query: schemaConfig.query && replaceNamedType(schemaConfig.query),
          mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
          subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
          ...schemaDef && getOperationTypes([schemaDef]),
          ...getOperationTypes(schemaExtensions)
        };
        return {
          description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
          ...operationTypes,
          types: Object.values(typeMap),
          directives: [
            ...schemaConfig.directives.map(replaceDirective),
            ...directiveDefs.map(buildDirective)
          ],
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
          extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
          assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
        };
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          }
          if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            args: (0, _mapValue.mapValue)(config.args, extendArg)
          });
        }
        function extendNamedType(type) {
          if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
            return type;
          }
          if ((0, _definition.isScalarType)(type)) {
            return extendScalarType(type);
          }
          if ((0, _definition.isObjectType)(type)) {
            return extendObjectType(type);
          }
          if ((0, _definition.isInterfaceType)(type)) {
            return extendInterfaceType(type);
          }
          if ((0, _definition.isUnionType)(type)) {
            return extendUnionType(type);
          }
          if ((0, _definition.isEnumType)(type)) {
            return extendEnumType(type);
          }
          if ((0, _definition.isInputObjectType)(type)) {
            return extendInputObjectType(type);
          }
          (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
        }
        function extendInputObjectType(type) {
          var _typeExtensionsMap$co;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
          return new _definition.GraphQLInputObjectType({
            ...config,
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, (field) => ({
                ...field,
                type: replaceType(field.type)
              })),
              ...buildInputFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendEnumType(type) {
          var _typeExtensionsMap$ty;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
          return new _definition.GraphQLEnumType({
            ...config,
            values: { ...config.values, ...buildEnumValueMap(extensions) },
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendScalarType(type) {
          var _typeExtensionsMap$co2;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
          let specifiedByURL = config.specifiedByURL;
          for (const extensionNode of extensions) {
            var _getSpecifiedByURL;
            specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
          }
          return new _definition.GraphQLScalarType({
            ...config,
            specifiedByURL,
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendObjectType(type) {
          var _typeExtensionsMap$co3;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
          return new _definition.GraphQLObjectType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendInterfaceType(type) {
          var _typeExtensionsMap$co4;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
          return new _definition.GraphQLInterfaceType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendUnionType(type) {
          var _typeExtensionsMap$co5;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
          return new _definition.GraphQLUnionType({
            ...config,
            types: () => [
              ...type.getTypes().map(replaceNamedType),
              ...buildUnionTypes(extensions)
            ],
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendField(field) {
          return {
            ...field,
            type: replaceType(field.type),
            args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
          };
        }
        function extendArg(arg) {
          return { ...arg, type: replaceType(arg.type) };
        }
        function getOperationTypes(nodes) {
          const opTypes = {};
          for (const node of nodes) {
            var _node$operationTypes;
            const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
            for (const operationType of operationTypesNodes) {
              opTypes[operationType.operation] = getNamedType(operationType.type);
            }
          }
          return opTypes;
        }
        function getNamedType(node) {
          var _stdTypeMap$name2;
          const name = node.name.value;
          const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
          if (type === void 0) {
            throw new Error(`Unknown type: "${name}".`);
          }
          return type;
        }
        function getWrappedType(node) {
          if (node.kind === _kinds.Kind.LIST_TYPE) {
            return new _definition.GraphQLList(getWrappedType(node.type));
          }
          if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
            return new _definition.GraphQLNonNull(getWrappedType(node.type));
          }
          return getNamedType(node);
        }
        function buildDirective(node) {
          var _node$description;
          return new _directives.GraphQLDirective({
            name: node.name.value,
            description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
            locations: node.locations.map(({ value }) => value),
            isRepeatable: node.repeatable,
            args: buildArgumentMap(node.arguments),
            astNode: node
          });
        }
        function buildFieldMap(nodes) {
          const fieldConfigMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields;
            const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
            for (const field of nodeFields) {
              var _field$description;
              fieldConfigMap[field.name.value] = {
                type: getWrappedType(field.type),
                description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
                args: buildArgumentMap(field.arguments),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return fieldConfigMap;
        }
        function buildArgumentMap(args) {
          const argsNodes = args !== null && args !== void 0 ? args : [];
          const argConfigMap = /* @__PURE__ */ Object.create(null);
          for (const arg of argsNodes) {
            var _arg$description;
            const type = getWrappedType(arg.type);
            argConfigMap[arg.name.value] = {
              type,
              description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
              deprecationReason: getDeprecationReason(arg),
              astNode: arg
            };
          }
          return argConfigMap;
        }
        function buildInputFieldMap(nodes) {
          const inputFieldMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields2;
            const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
            for (const field of fieldsNodes) {
              var _field$description2;
              const type = getWrappedType(field.type);
              inputFieldMap[field.name.value] = {
                type,
                description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
                defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return inputFieldMap;
        }
        function buildEnumValueMap(nodes) {
          const enumValueMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$values;
            const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
            for (const value of valuesNodes) {
              var _value$description;
              enumValueMap[value.name.value] = {
                description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
                deprecationReason: getDeprecationReason(value),
                astNode: value
              };
            }
          }
          return enumValueMap;
        }
        function buildInterfaces(nodes) {
          return nodes.flatMap((node) => {
            var _node$interfaces$map, _node$interfaces;
            return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
          });
        }
        function buildUnionTypes(nodes) {
          return nodes.flatMap((node) => {
            var _node$types$map, _node$types;
            return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
          });
        }
        function buildType(astNode) {
          var _typeExtensionsMap$na;
          const name = astNode.name.value;
          const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
          switch (astNode.kind) {
            case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
              var _astNode$description;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLObjectType({
                name,
                description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
              var _astNode$description2;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInterfaceType({
                name,
                description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.ENUM_TYPE_DEFINITION: {
              var _astNode$description3;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLEnumType({
                name,
                description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
                values: buildEnumValueMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.UNION_TYPE_DEFINITION: {
              var _astNode$description4;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLUnionType({
                name,
                description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
                types: () => buildUnionTypes(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
              var _astNode$description5;
              return new _definition.GraphQLScalarType({
                name,
                description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
                specifiedByURL: getSpecifiedByURL(astNode),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
              var _astNode$description6;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInputObjectType({
                name,
                description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
                fields: () => buildInputFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
          }
        }
      }
      var stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], (type) => type.name);
      function getDeprecationReason(node) {
        const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
        return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
      }
      function getSpecifiedByURL(node) {
        const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
        return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/buildASTSchema.js
  var require_buildASTSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/buildASTSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildASTSchema = buildASTSchema;
      exports.buildSchema = buildSchema;
      var _devAssert = require_devAssert();
      var _kinds = require_kinds();
      var _parser = require_parser();
      var _directives = require_directives();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _extendSchema = require_extendSchema();
      function buildASTSchema(documentAST, options) {
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDL)(documentAST);
        }
        const emptySchemaConfig = {
          description: void 0,
          types: [],
          directives: [],
          extensions: /* @__PURE__ */ Object.create(null),
          extensionASTNodes: [],
          assumeValid: false
        };
        const config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
        if (config.astNode == null) {
          for (const type of config.types) {
            switch (type.name) {
              case "Query":
                config.query = type;
                break;
              case "Mutation":
                config.mutation = type;
                break;
              case "Subscription":
                config.subscription = type;
                break;
            }
          }
        }
        const directives = [
          ...config.directives,
          ..._directives.specifiedDirectives.filter((stdDirective) => config.directives.every((directive) => directive.name !== stdDirective.name))
        ];
        return new _schema.GraphQLSchema({ ...config, directives });
      }
      function buildSchema(source, options) {
        const document = (0, _parser.parse)(source, {
          noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
          allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
        });
        return buildASTSchema(document, {
          assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/lexicographicSortSchema.js
  var require_lexicographicSortSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/lexicographicSortSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lexicographicSortSchema = lexicographicSortSchema;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyValMap = require_keyValMap();
      var _naturalCompare = require_naturalCompare();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function lexicographicSortSchema(schema) {
        const schemaConfig = schema.toConfig();
        const typeMap = (0, _keyValMap.keyValMap)(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
        return new _schema.GraphQLSchema({
          ...schemaConfig,
          types: Object.values(typeMap),
          directives: sortByName(schemaConfig.directives).map(sortDirective),
          query: replaceMaybeType(schemaConfig.query),
          mutation: replaceMaybeType(schemaConfig.mutation),
          subscription: replaceMaybeType(schemaConfig.subscription)
        });
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          } else if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceMaybeType(maybeType) {
          return maybeType && replaceNamedType(maybeType);
        }
        function sortDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            locations: sortBy(config.locations, (x) => x),
            args: sortArgs(config.args)
          });
        }
        function sortArgs(args) {
          return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
        }
        function sortFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type),
            args: field.args && sortArgs(field.args)
          }));
        }
        function sortInputFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type)
          }));
        }
        function sortTypes(array) {
          return sortByName(array).map(replaceNamedType);
        }
        function sortNamedType(type) {
          if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
            return type;
          }
          if ((0, _definition.isObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLObjectType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isInterfaceType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInterfaceType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isUnionType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLUnionType({
              ...config,
              types: () => sortTypes(config.types)
            });
          }
          if ((0, _definition.isEnumType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLEnumType({
              ...config,
              values: sortObjMap(config.values, (value) => value)
            });
          }
          if ((0, _definition.isInputObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInputObjectType({
              ...config,
              fields: () => sortInputFields(config.fields)
            });
          }
          (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
        }
      }
      function sortObjMap(map, sortValueFn) {
        const sortedMap = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
          sortedMap[key] = sortValueFn(map[key]);
        }
        return sortedMap;
      }
      function sortByName(array) {
        return sortBy(array, (obj) => obj.name);
      }
      function sortBy(array, mapToKey) {
        return array.slice().sort((obj1, obj2) => {
          const key1 = mapToKey(obj1);
          const key2 = mapToKey(obj2);
          return (0, _naturalCompare.naturalCompare)(key1, key2);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/printSchema.js
  var require_printSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/printSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printIntrospectionSchema = printIntrospectionSchema;
      exports.printSchema = printSchema;
      exports.printType = printType;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _blockString = require_blockString();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      function printSchema(schema) {
        return printFilteredSchema(schema, (n) => !(0, _directives.isSpecifiedDirective)(n), isDefinedType);
      }
      function printIntrospectionSchema(schema) {
        return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType);
      }
      function isDefinedType(type) {
        return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
      }
      function printFilteredSchema(schema, directiveFilter, typeFilter) {
        const directives = schema.getDirectives().filter(directiveFilter);
        const types = Object.values(schema.getTypeMap()).filter(typeFilter);
        return [
          printSchemaDefinition(schema),
          ...directives.map((directive) => printDirective(directive)),
          ...types.map((type) => printType(type))
        ].filter(Boolean).join("\n\n");
      }
      function printSchemaDefinition(schema) {
        if (schema.description == null && isSchemaOfCommonNames(schema)) {
          return;
        }
        const operationTypes = [];
        const queryType = schema.getQueryType();
        if (queryType) {
          operationTypes.push(`  query: ${queryType.name}`);
        }
        const mutationType = schema.getMutationType();
        if (mutationType) {
          operationTypes.push(`  mutation: ${mutationType.name}`);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          operationTypes.push(`  subscription: ${subscriptionType.name}`);
        }
        return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
      }
      function isSchemaOfCommonNames(schema) {
        const queryType = schema.getQueryType();
        if (queryType && queryType.name !== "Query") {
          return false;
        }
        const mutationType = schema.getMutationType();
        if (mutationType && mutationType.name !== "Mutation") {
          return false;
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && subscriptionType.name !== "Subscription") {
          return false;
        }
        return true;
      }
      function printType(type) {
        if ((0, _definition.isScalarType)(type)) {
          return printScalar(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return printObject(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return printInterface(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return printUnion(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return printEnum(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return printInputObject(type);
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function printScalar(type) {
        return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
      }
      function printImplementedInterfaces(type) {
        const interfaces = type.getInterfaces();
        return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
      }
      function printObject(type) {
        return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printInterface(type) {
        return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printUnion(type) {
        const types = type.getTypes();
        const possibleTypes = types.length ? " = " + types.join(" | ") : "";
        return printDescription(type) + "union " + type.name + possibleTypes;
      }
      function printEnum(type) {
        const values = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
        return printDescription(type) + `enum ${type.name}` + printBlock(values);
      }
      function printInputObject(type) {
        const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
        return printDescription(type) + `input ${type.name}` + printBlock(fields);
      }
      function printFields(type) {
        const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
        return printBlock(fields);
      }
      function printBlock(items) {
        return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
      }
      function printArgs(args, indentation = "") {
        if (args.length === 0) {
          return "";
        }
        if (args.every((arg) => !arg.description)) {
          return "(" + args.map(printInputValue).join(", ") + ")";
        }
        return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
      }
      function printInputValue(arg) {
        const defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
        let argDecl = arg.name + ": " + String(arg.type);
        if (defaultAST) {
          argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
        }
        return argDecl + printDeprecated(arg.deprecationReason);
      }
      function printDirective(directive) {
        return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
      }
      function printDeprecated(reason) {
        if (reason == null) {
          return "";
        }
        if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
          const astValue = (0, _printer.print)({
            kind: _kinds.Kind.STRING,
            value: reason
          });
          return ` @deprecated(reason: ${astValue})`;
        }
        return " @deprecated";
      }
      function printSpecifiedByURL(scalar) {
        if (scalar.specifiedByURL == null) {
          return "";
        }
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: scalar.specifiedByURL
        });
        return ` @specifiedBy(url: ${astValue})`;
      }
      function printDescription(def, indentation = "", firstInBlock = true) {
        const { description } = def;
        if (description == null) {
          return "";
        }
        const blockString = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: description,
          block: (0, _blockString.isPrintableAsBlockString)(description)
        });
        const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
        return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/concatAST.js
  var require_concatAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/concatAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatAST = concatAST;
      var _kinds = require_kinds();
      function concatAST(documents) {
        const definitions = [];
        for (const doc of documents) {
          definitions.push(...doc.definitions);
        }
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/separateOperations.js
  var require_separateOperations = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/separateOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.separateOperations = separateOperations;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      function separateOperations(documentAST) {
        const operations = [];
        const depGraph = /* @__PURE__ */ Object.create(null);
        for (const definitionNode of documentAST.definitions) {
          switch (definitionNode.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              operations.push(definitionNode);
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
              break;
            default:
          }
        }
        const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
        for (const operation of operations) {
          const dependencies = /* @__PURE__ */ new Set();
          for (const fragmentName of collectDependencies(operation.selectionSet)) {
            collectTransitiveDependencies(dependencies, depGraph, fragmentName);
          }
          const operationName = operation.name ? operation.name.value : "";
          separatedDocumentASTs[operationName] = {
            kind: _kinds.Kind.DOCUMENT,
            definitions: documentAST.definitions.filter((node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))
          };
        }
        return separatedDocumentASTs;
      }
      function collectTransitiveDependencies(collected, depGraph, fromName) {
        if (!collected.has(fromName)) {
          collected.add(fromName);
          const immediateDeps = depGraph[fromName];
          if (immediateDeps !== void 0) {
            for (const toName of immediateDeps) {
              collectTransitiveDependencies(collected, depGraph, toName);
            }
          }
        }
      }
      function collectDependencies(selectionSet) {
        const dependencies = [];
        (0, _visitor.visit)(selectionSet, {
          FragmentSpread(node) {
            dependencies.push(node.name.value);
          }
        });
        return dependencies;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/stripIgnoredCharacters.js
  var require_stripIgnoredCharacters = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stripIgnoredCharacters = stripIgnoredCharacters;
      var _blockString = require_blockString();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function stripIgnoredCharacters(source) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        const body = sourceObj.body;
        const lexer = new _lexer.Lexer(sourceObj);
        let strippedBody = "";
        let wasLastAddedTokenNonPunctuator = false;
        while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
          const currentToken = lexer.token;
          const tokenKind = currentToken.kind;
          const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
          if (wasLastAddedTokenNonPunctuator) {
            if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
              strippedBody += " ";
            }
          }
          const tokenBody = body.slice(currentToken.start, currentToken.end);
          if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
            strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
              minimize: true
            });
          } else {
            strippedBody += tokenBody;
          }
          wasLastAddedTokenNonPunctuator = isNonPunctuator;
        }
        return strippedBody;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/assertValidName.js
  var require_assertValidName = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/assertValidName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidName = assertValidName;
      exports.isValidNameError = isValidNameError;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _assertName = require_assertName();
      function assertValidName(name) {
        const error = isValidNameError(name);
        if (error) {
          throw error;
        }
        return name;
      }
      function isValidNameError(name) {
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.startsWith("__")) {
          return new _GraphQLError.GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
        }
        try {
          (0, _assertName.assertName)(name);
        } catch (error) {
          return error;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/findBreakingChanges.js
  var require_findBreakingChanges = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/findBreakingChanges.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DangerousChangeType = exports.BreakingChangeType = void 0;
      exports.findBreakingChanges = findBreakingChanges;
      exports.findDangerousChanges = findDangerousChanges;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _printer = require_printer();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      var _sortValueNode = require_sortValueNode();
      var BreakingChangeType;
      exports.BreakingChangeType = BreakingChangeType;
      (function(BreakingChangeType2) {
        BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
        BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
        BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
        BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
        BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
        BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
        BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
        BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
        BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
        BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
        BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
        BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
        BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
        BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
        BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
        BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
      })(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));
      var DangerousChangeType;
      exports.DangerousChangeType = DangerousChangeType;
      (function(DangerousChangeType2) {
        DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
        DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
        DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
        DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
        DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
        DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
      })(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));
      function findBreakingChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in BreakingChangeType);
      }
      function findDangerousChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in DangerousChangeType);
      }
      function findSchemaChanges(oldSchema, newSchema) {
        return [
          ...findTypeChanges(oldSchema, newSchema),
          ...findDirectiveChanges(oldSchema, newSchema)
        ];
      }
      function findDirectiveChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
        for (const oldDirective of directivesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REMOVED,
            description: `${oldDirective.name} was removed.`
          });
        }
        for (const [oldDirective, newDirective] of directivesDiff.persisted) {
          const argsDiff = diff(oldDirective.args, newDirective.args);
          for (const newArg of argsDiff.added) {
            if ((0, _definition.isRequiredArgument)(newArg)) {
              schemaChanges.push({
                type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
                description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
              });
            }
          }
          for (const oldArg of argsDiff.removed) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
              description: `${oldArg.name} was removed from ${oldDirective.name}.`
            });
          }
          if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
              description: `Repeatable flag was removed from ${oldDirective.name}.`
            });
          }
          for (const location of oldDirective.locations) {
            if (!newDirective.locations.includes(location)) {
              schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
                description: `${location} was removed from ${oldDirective.name}.`
              });
            }
          }
        }
        return schemaChanges;
      }
      function findTypeChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
        for (const oldType of typesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED,
            description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
          });
        }
        for (const [oldType, newType] of typesDiff.persisted) {
          if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
            schemaChanges.push(...findEnumTypeChanges(oldType, newType));
          } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
            schemaChanges.push(...findUnionTypeChanges(oldType, newType));
          } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
            schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
          } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
            schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
          } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
            schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
          } else if (oldType.constructor !== newType.constructor) {
            schemaChanges.push({
              type: BreakingChangeType.TYPE_CHANGED_KIND,
              description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findInputObjectTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
        for (const newField of fieldsDiff.added) {
          if ((0, _definition.isRequiredInputField)(newField)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
              description: `A required field ${newField.name} on input type ${oldType.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
              description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
            });
          }
        }
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findUnionTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
        for (const newPossibleType of possibleTypesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
            description: `${newPossibleType.name} was added to union type ${oldType.name}.`
          });
        }
        for (const oldPossibleType of possibleTypesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
            description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findEnumTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const valuesDiff = diff(oldType.getValues(), newType.getValues());
        for (const newValue of valuesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
            description: `${newValue.name} was added to enum type ${oldType.name}.`
          });
        }
        for (const oldValue of valuesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
            description: `${oldValue.name} was removed from enum type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findImplementedInterfacesChanges(oldType, newType) {
        const schemaChanges = [];
        const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
        for (const newInterface of interfacesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
            description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
          });
        }
        for (const oldInterface of interfacesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
            description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
          });
        }
        return schemaChanges;
      }
      function findFieldChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          schemaChanges.push(...findArgChanges(oldType, oldField, newField));
          const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findArgChanges(oldType, oldField, newField) {
        const schemaChanges = [];
        const argsDiff = diff(oldField.args, newField.args);
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_REMOVED,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
          });
        }
        for (const [oldArg, newArg] of argsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.ARG_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
            });
          } else if (oldArg.defaultValue !== void 0) {
            if (newArg.defaultValue === void 0) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
              });
            } else {
              const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
              const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
              if (oldValueStr !== newValueStr) {
                schemaChanges.push({
                  type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                  description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
                });
              }
            }
          }
        }
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_ARG_ADDED,
              description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_ARG_ADDED,
              description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          }
        }
        return schemaChanges;
      }
      function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
      }
      function typeKindName(type) {
        if ((0, _definition.isScalarType)(type)) {
          return "a Scalar type";
        }
        if ((0, _definition.isObjectType)(type)) {
          return "an Object type";
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return "an Interface type";
        }
        if ((0, _definition.isUnionType)(type)) {
          return "a Union type";
        }
        if ((0, _definition.isEnumType)(type)) {
          return "an Enum type";
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return "an Input type";
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function stringifyValue(value, type) {
        const ast = (0, _astFromValue.astFromValue)(value, type);
        ast != null || (0, _invariant.invariant)(false);
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
      }
      function diff(oldArray, newArray) {
        const added = [];
        const removed = [];
        const persisted = [];
        const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
        const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
        for (const oldItem of oldArray) {
          const newItem = newMap[oldItem.name];
          if (newItem === void 0) {
            removed.push(oldItem);
          } else {
            persisted.push([oldItem, newItem]);
          }
        }
        for (const newItem of newArray) {
          if (oldMap[newItem.name] === void 0) {
            added.push(newItem);
          }
        }
        return {
          added,
          persisted,
          removed
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/index.js
  var require_utilities = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/utilities/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.TypeInfo;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _assertValidName.assertValidName;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _astFromValue.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _buildClientSchema.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _coerceInputValue.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _concatAST.concatAST;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _typeComparators.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _extendSchema.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _getIntrospectionQuery.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _getOperationAST.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _getOperationRootType.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _introspectionFromSchema.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _typeComparators.isEqualType;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _typeComparators.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _assertValidName.isValidNameError;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _lexicographicSortSchema.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printSchema;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _printSchema.printType;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _separateOperations.separateOperations;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _stripIgnoredCharacters.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _typeFromAST.typeFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _valueFromAST.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _valueFromASTUntyped.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.visitWithTypeInfo;
        }
      });
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      var _getOperationAST = require_getOperationAST();
      var _getOperationRootType = require_getOperationRootType();
      var _introspectionFromSchema = require_introspectionFromSchema();
      var _buildClientSchema = require_buildClientSchema();
      var _buildASTSchema = require_buildASTSchema();
      var _extendSchema = require_extendSchema();
      var _lexicographicSortSchema = require_lexicographicSortSchema();
      var _printSchema = require_printSchema();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _astFromValue = require_astFromValue();
      var _TypeInfo = require_TypeInfo();
      var _coerceInputValue = require_coerceInputValue();
      var _concatAST = require_concatAST();
      var _separateOperations = require_separateOperations();
      var _stripIgnoredCharacters = require_stripIgnoredCharacters();
      var _typeComparators = require_typeComparators();
      var _assertValidName = require_assertValidName();
      var _findBreakingChanges = require_findBreakingChanges();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/index.js
  var require_graphql2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.5.0/node_modules/graphql/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _index2.BREAK;
        }
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _index6.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _index.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _index6.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index2.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _index4.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _index.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _index5.GraphQLError;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _index.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _index.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _index.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _index.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _index.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _index2.Kind;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _index2.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _index2.Location;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _index4.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _index4.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _index4.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _index4.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _index2.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _index2.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _index2.TokenKind;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.TypeInfo;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _index.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _index4.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _index.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _index.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _index.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _index.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _index.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _index.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _index.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _index.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _index.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _index.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _index.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _index.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _index.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _index.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _index.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _index.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _index.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _index.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _index.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _index.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _index.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _index.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _index.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _index.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _index6.assertValidName;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _index.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _index.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _index6.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _index6.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _index6.concatAST;
        }
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _index3.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _index6.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _index3.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _index3.executeSync;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _index6.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _index6.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _index6.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _index5.formatError;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _index3.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _index3.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _index2.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _index6.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _index2.getLocation;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _index.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _index.getNullableType;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _index6.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _index6.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _index3.getVariableValues;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _index2.getVisitFn;
        }
      });
      Object.defineProperty(exports, "graphql", {
        enumerable: true,
        get: function() {
          return _graphql.graphql;
        }
      });
      Object.defineProperty(exports, "graphqlSync", {
        enumerable: true,
        get: function() {
          return _graphql.graphqlSync;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _index6.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _index.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _index.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _index.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _index.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _index.isEnumType;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _index6.isEqualType;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _index.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _index.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _index.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _index.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _index.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _index.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _index.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _index.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _index.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _index.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _index.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _index.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _index.isSchema;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _index2.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _index.isType;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _index6.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _index.isUnionType;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _index6.isValidNameError;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isValueNode;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _index.isWrappingType;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _index6.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _index5.locatedError;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _index2.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _index2.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _index2.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _index2.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _index2.print;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _index5.printError;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _index6.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _index2.printLocation;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _index6.printSchema;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _index2.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _index6.printType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _index3.responsePathAsArray;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _index6.separateOperations;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _index.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _index4.specifiedRules;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _index.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _index6.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _index3.subscribe;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _index5.syntaxError;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _index6.typeFromAST;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _index4.validate;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _index.validateSchema;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _index6.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _index6.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function() {
          return _version.version;
        }
      });
      Object.defineProperty(exports, "versionInfo", {
        enumerable: true,
        get: function() {
          return _version.versionInfo;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _index2.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _index2.visitInParallel;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.visitWithTypeInfo;
        }
      });
      var _version = require_version();
      var _graphql = require_graphql();
      var _index = require_type();
      var _index2 = require_language();
      var _index3 = require_execution();
      var _index4 = require_validation();
      var _index5 = require_error();
      var _index6 = require_utilities();
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/autocompleteUtils.js
  var require_autocompleteUtils = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/autocompleteUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hintList = exports.objectValues = exports.forEachState = exports.getFieldDef = exports.getDefinitionState = void 0;
      var graphql_1 = require_graphql2();
      var introspection_1 = require_introspection();
      function getDefinitionState(tokenState) {
        let definitionState;
        forEachState(tokenState, (state) => {
          switch (state.kind) {
            case "Query":
            case "ShortQuery":
            case "Mutation":
            case "Subscription":
            case "FragmentDefinition":
              definitionState = state;
              break;
          }
        });
        return definitionState;
      }
      exports.getDefinitionState = getDefinitionState;
      function getFieldDef(schema, type, fieldName) {
        if (fieldName === introspection_1.SchemaMetaFieldDef.name && schema.getQueryType() === type) {
          return introspection_1.SchemaMetaFieldDef;
        }
        if (fieldName === introspection_1.TypeMetaFieldDef.name && schema.getQueryType() === type) {
          return introspection_1.TypeMetaFieldDef;
        }
        if (fieldName === introspection_1.TypeNameMetaFieldDef.name && graphql_1.isCompositeType(type)) {
          return introspection_1.TypeNameMetaFieldDef;
        }
        if ("getFields" in type) {
          return type.getFields()[fieldName];
        }
        return null;
      }
      exports.getFieldDef = getFieldDef;
      function forEachState(stack, fn) {
        const reverseStateStack = [];
        let state = stack;
        while (state && state.kind) {
          reverseStateStack.push(state);
          state = state.prevState;
        }
        for (let i = reverseStateStack.length - 1; i >= 0; i--) {
          fn(reverseStateStack[i]);
        }
      }
      exports.forEachState = forEachState;
      function objectValues(object) {
        const keys = Object.keys(object);
        const len = keys.length;
        const values = new Array(len);
        for (let i = 0; i < len; ++i) {
          values[i] = object[keys[i]];
        }
        return values;
      }
      exports.objectValues = objectValues;
      function hintList(token, list) {
        return filterAndSortList(list, normalizeText(token.string));
      }
      exports.hintList = hintList;
      function filterAndSortList(list, text) {
        if (!text) {
          return filterNonEmpty(list, (entry) => !entry.isDeprecated);
        }
        const byProximity = list.map((entry) => ({
          proximity: getProximity(normalizeText(entry.label), text),
          entry
        }));
        return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);
      }
      function filterNonEmpty(array, predicate) {
        const filtered = array.filter(predicate);
        return filtered.length === 0 ? array : filtered;
      }
      function normalizeText(text) {
        return text.toLowerCase().replace(/\W/g, "");
      }
      function getProximity(suggestion, text) {
        let proximity = lexicalDistance(text, suggestion);
        if (suggestion.length > text.length) {
          proximity -= suggestion.length - text.length - 1;
          proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;
        }
        return proximity;
      }
      function lexicalDistance(a, b) {
        let i;
        let j;
        const d = [];
        const aLength = a.length;
        const bLength = b.length;
        for (i = 0; i <= aLength; i++) {
          d[i] = [i];
        }
        for (j = 1; j <= bLength; j++) {
          d[0][j] = j;
        }
        for (i = 1; i <= aLength; i++) {
          for (j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
          }
        }
        return d[aLength][bLength];
      }
    }
  });

  // ../../node_modules/.pnpm/vscode-languageserver-types@3.17.1/node_modules/vscode-languageserver-types/lib/umd/main.js
  var require_main = __commonJS({
    "../../node_modules/.pnpm/vscode-languageserver-types@3.17.1/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          var v = factory(__require, exports);
          if (v !== void 0)
            module.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
        var DocumentUri;
        (function(DocumentUri2) {
          function is(value) {
            return typeof value === "string";
          }
          DocumentUri2.is = is;
        })(DocumentUri = exports2.DocumentUri || (exports2.DocumentUri = {}));
        var URI2;
        (function(URI3) {
          function is(value) {
            return typeof value === "string";
          }
          URI3.is = is;
        })(URI2 = exports2.URI || (exports2.URI = {}));
        var integer;
        (function(integer2) {
          integer2.MIN_VALUE = -2147483648;
          integer2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
          }
          integer2.is = is;
        })(integer = exports2.integer || (exports2.integer = {}));
        var uinteger;
        (function(uinteger2) {
          uinteger2.MIN_VALUE = 0;
          uinteger2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
          }
          uinteger2.is = is;
        })(uinteger = exports2.uinteger || (exports2.uinteger = {}));
        var Position2;
        (function(Position3) {
          function create(line, character) {
            if (line === Number.MAX_VALUE) {
              line = uinteger.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
              character = uinteger.MAX_VALUE;
            }
            return { line, character };
          }
          Position3.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
          }
          Position3.is = is;
        })(Position2 = exports2.Position || (exports2.Position = {}));
        var Range2;
        (function(Range3) {
          function create(one, two, three, four) {
            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
              return { start: Position2.create(one, two), end: Position2.create(three, four) };
            } else if (Position2.is(one) && Position2.is(two)) {
              return { start: one, end: two };
            } else {
              throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
          }
          Range3.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
          }
          Range3.is = is;
        })(Range2 = exports2.Range || (exports2.Range = {}));
        var Location;
        (function(Location2) {
          function create(uri, range) {
            return { uri, range };
          }
          Location2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
          }
          Location2.is = is;
        })(Location = exports2.Location || (exports2.Location = {}));
        var LocationLink;
        (function(LocationLink2) {
          function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
          }
          LocationLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
          }
          LocationLink2.is = is;
        })(LocationLink = exports2.LocationLink || (exports2.LocationLink = {}));
        var Color;
        (function(Color2) {
          function create(red, green, blue, alpha) {
            return {
              red,
              green,
              blue,
              alpha
            };
          }
          Color2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
          }
          Color2.is = is;
        })(Color = exports2.Color || (exports2.Color = {}));
        var ColorInformation;
        (function(ColorInformation2) {
          function create(range, color) {
            return {
              range,
              color
            };
          }
          ColorInformation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && Color.is(candidate.color);
          }
          ColorInformation2.is = is;
        })(ColorInformation = exports2.ColorInformation || (exports2.ColorInformation = {}));
        var ColorPresentation;
        (function(ColorPresentation2) {
          function create(label, textEdit, additionalTextEdits) {
            return {
              label,
              textEdit,
              additionalTextEdits
            };
          }
          ColorPresentation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
          }
          ColorPresentation2.is = is;
        })(ColorPresentation = exports2.ColorPresentation || (exports2.ColorPresentation = {}));
        var FoldingRangeKind2;
        (function(FoldingRangeKind3) {
          FoldingRangeKind3.Comment = "comment";
          FoldingRangeKind3.Imports = "imports";
          FoldingRangeKind3.Region = "region";
        })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
        var FoldingRange;
        (function(FoldingRange2) {
          function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
              startLine,
              endLine
            };
            if (Is.defined(startCharacter)) {
              result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
              result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
              result.kind = kind;
            }
            if (Is.defined(collapsedText)) {
              result.collapsedText = collapsedText;
            }
            return result;
          }
          FoldingRange2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
          }
          FoldingRange2.is = is;
        })(FoldingRange = exports2.FoldingRange || (exports2.FoldingRange = {}));
        var DiagnosticRelatedInformation;
        (function(DiagnosticRelatedInformation2) {
          function create(location, message) {
            return {
              location,
              message
            };
          }
          DiagnosticRelatedInformation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
          }
          DiagnosticRelatedInformation2.is = is;
        })(DiagnosticRelatedInformation = exports2.DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = {}));
        var DiagnosticSeverity;
        (function(DiagnosticSeverity2) {
          DiagnosticSeverity2.Error = 1;
          DiagnosticSeverity2.Warning = 2;
          DiagnosticSeverity2.Information = 3;
          DiagnosticSeverity2.Hint = 4;
        })(DiagnosticSeverity = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
        var DiagnosticTag;
        (function(DiagnosticTag2) {
          DiagnosticTag2.Unnecessary = 1;
          DiagnosticTag2.Deprecated = 2;
        })(DiagnosticTag = exports2.DiagnosticTag || (exports2.DiagnosticTag = {}));
        var CodeDescription;
        (function(CodeDescription2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.href);
          }
          CodeDescription2.is = is;
        })(CodeDescription = exports2.CodeDescription || (exports2.CodeDescription = {}));
        var Diagnostic;
        (function(Diagnostic2) {
          function create(range, message, severity, code, source, relatedInformation) {
            var result = { range, message };
            if (Is.defined(severity)) {
              result.severity = severity;
            }
            if (Is.defined(code)) {
              result.code = code;
            }
            if (Is.defined(source)) {
              result.source = source;
            }
            if (Is.defined(relatedInformation)) {
              result.relatedInformation = relatedInformation;
            }
            return result;
          }
          Diagnostic2.create = create;
          function is(value) {
            var _a3;
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
          }
          Diagnostic2.is = is;
        })(Diagnostic = exports2.Diagnostic || (exports2.Diagnostic = {}));
        var Command2;
        (function(Command3) {
          function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var result = { title, command };
            if (Is.defined(args) && args.length > 0) {
              result.arguments = args;
            }
            return result;
          }
          Command3.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
          }
          Command3.is = is;
        })(Command2 = exports2.Command || (exports2.Command = {}));
        var TextEdit;
        (function(TextEdit2) {
          function replace(range, newText) {
            return { range, newText };
          }
          TextEdit2.replace = replace;
          function insert(position, newText) {
            return { range: { start: position, end: position }, newText };
          }
          TextEdit2.insert = insert;
          function del(range) {
            return { range, newText: "" };
          }
          TextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
          }
          TextEdit2.is = is;
        })(TextEdit = exports2.TextEdit || (exports2.TextEdit = {}));
        var ChangeAnnotation;
        (function(ChangeAnnotation2) {
          function create(label, needsConfirmation, description) {
            var result = { label };
            if (needsConfirmation !== void 0) {
              result.needsConfirmation = needsConfirmation;
            }
            if (description !== void 0) {
              result.description = description;
            }
            return result;
          }
          ChangeAnnotation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          ChangeAnnotation2.is = is;
        })(ChangeAnnotation = exports2.ChangeAnnotation || (exports2.ChangeAnnotation = {}));
        var ChangeAnnotationIdentifier;
        (function(ChangeAnnotationIdentifier2) {
          function is(value) {
            var candidate = value;
            return Is.string(candidate);
          }
          ChangeAnnotationIdentifier2.is = is;
        })(ChangeAnnotationIdentifier = exports2.ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = {}));
        var AnnotatedTextEdit;
        (function(AnnotatedTextEdit2) {
          function replace(range, newText, annotation) {
            return { range, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.replace = replace;
          function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.insert = insert;
          function del(range, annotation) {
            return { range, newText: "", annotationId: annotation };
          }
          AnnotatedTextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          AnnotatedTextEdit2.is = is;
        })(AnnotatedTextEdit = exports2.AnnotatedTextEdit || (exports2.AnnotatedTextEdit = {}));
        var TextDocumentEdit;
        (function(TextDocumentEdit2) {
          function create(textDocument, edits) {
            return { textDocument, edits };
          }
          TextDocumentEdit2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
          }
          TextDocumentEdit2.is = is;
        })(TextDocumentEdit = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
        var CreateFile;
        (function(CreateFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "create",
              uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          CreateFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          CreateFile2.is = is;
        })(CreateFile = exports2.CreateFile || (exports2.CreateFile = {}));
        var RenameFile;
        (function(RenameFile2) {
          function create(oldUri, newUri, options, annotation) {
            var result = {
              kind: "rename",
              oldUri,
              newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          RenameFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          RenameFile2.is = is;
        })(RenameFile = exports2.RenameFile || (exports2.RenameFile = {}));
        var DeleteFile;
        (function(DeleteFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "delete",
              uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          DeleteFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          DeleteFile2.is = is;
        })(DeleteFile = exports2.DeleteFile || (exports2.DeleteFile = {}));
        var WorkspaceEdit;
        (function(WorkspaceEdit2) {
          function is(value) {
            var candidate = value;
            return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
              if (Is.string(change.kind)) {
                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
              } else {
                return TextDocumentEdit.is(change);
              }
            }));
          }
          WorkspaceEdit2.is = is;
        })(WorkspaceEdit = exports2.WorkspaceEdit || (exports2.WorkspaceEdit = {}));
        var TextEditChangeImpl = function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }();
        var ChangeAnnotations = function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }();
        var WorkspaceChange = function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }();
        exports2.WorkspaceChange = WorkspaceChange;
        var TextDocumentIdentifier;
        (function(TextDocumentIdentifier2) {
          function create(uri) {
            return { uri };
          }
          TextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
          }
          TextDocumentIdentifier2.is = is;
        })(TextDocumentIdentifier = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
        var VersionedTextDocumentIdentifier;
        (function(VersionedTextDocumentIdentifier2) {
          function create(uri, version) {
            return { uri, version };
          }
          VersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
          }
          VersionedTextDocumentIdentifier2.is = is;
        })(VersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
        var OptionalVersionedTextDocumentIdentifier;
        (function(OptionalVersionedTextDocumentIdentifier2) {
          function create(uri, version) {
            return { uri, version };
          }
          OptionalVersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
          }
          OptionalVersionedTextDocumentIdentifier2.is = is;
        })(OptionalVersionedTextDocumentIdentifier = exports2.OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = {}));
        var TextDocumentItem;
        (function(TextDocumentItem2) {
          function create(uri, languageId, version, text) {
            return { uri, languageId, version, text };
          }
          TextDocumentItem2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
          }
          TextDocumentItem2.is = is;
        })(TextDocumentItem = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
        var MarkupKind;
        (function(MarkupKind2) {
          MarkupKind2.PlainText = "plaintext";
          MarkupKind2.Markdown = "markdown";
          function is(value) {
            var candidate = value;
            return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
          }
          MarkupKind2.is = is;
        })(MarkupKind = exports2.MarkupKind || (exports2.MarkupKind = {}));
        var MarkupContent;
        (function(MarkupContent2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
          }
          MarkupContent2.is = is;
        })(MarkupContent = exports2.MarkupContent || (exports2.MarkupContent = {}));
        var CompletionItemKind2;
        (function(CompletionItemKind3) {
          CompletionItemKind3.Text = 1;
          CompletionItemKind3.Method = 2;
          CompletionItemKind3.Function = 3;
          CompletionItemKind3.Constructor = 4;
          CompletionItemKind3.Field = 5;
          CompletionItemKind3.Variable = 6;
          CompletionItemKind3.Class = 7;
          CompletionItemKind3.Interface = 8;
          CompletionItemKind3.Module = 9;
          CompletionItemKind3.Property = 10;
          CompletionItemKind3.Unit = 11;
          CompletionItemKind3.Value = 12;
          CompletionItemKind3.Enum = 13;
          CompletionItemKind3.Keyword = 14;
          CompletionItemKind3.Snippet = 15;
          CompletionItemKind3.Color = 16;
          CompletionItemKind3.File = 17;
          CompletionItemKind3.Reference = 18;
          CompletionItemKind3.Folder = 19;
          CompletionItemKind3.EnumMember = 20;
          CompletionItemKind3.Constant = 21;
          CompletionItemKind3.Struct = 22;
          CompletionItemKind3.Event = 23;
          CompletionItemKind3.Operator = 24;
          CompletionItemKind3.TypeParameter = 25;
        })(CompletionItemKind2 = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
        var InsertTextFormat;
        (function(InsertTextFormat2) {
          InsertTextFormat2.PlainText = 1;
          InsertTextFormat2.Snippet = 2;
        })(InsertTextFormat = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
        var CompletionItemTag2;
        (function(CompletionItemTag3) {
          CompletionItemTag3.Deprecated = 1;
        })(CompletionItemTag2 = exports2.CompletionItemTag || (exports2.CompletionItemTag = {}));
        var InsertReplaceEdit;
        (function(InsertReplaceEdit2) {
          function create(newText, insert, replace) {
            return { newText, insert, replace };
          }
          InsertReplaceEdit2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
          }
          InsertReplaceEdit2.is = is;
        })(InsertReplaceEdit = exports2.InsertReplaceEdit || (exports2.InsertReplaceEdit = {}));
        var InsertTextMode;
        (function(InsertTextMode2) {
          InsertTextMode2.asIs = 1;
          InsertTextMode2.adjustIndentation = 2;
        })(InsertTextMode = exports2.InsertTextMode || (exports2.InsertTextMode = {}));
        var CompletionItemLabelDetails;
        (function(CompletionItemLabelDetails2) {
          function is(value) {
            var candidate = value;
            return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          CompletionItemLabelDetails2.is = is;
        })(CompletionItemLabelDetails = exports2.CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = {}));
        var CompletionItem;
        (function(CompletionItem2) {
          function create(label) {
            return { label };
          }
          CompletionItem2.create = create;
        })(CompletionItem = exports2.CompletionItem || (exports2.CompletionItem = {}));
        var CompletionList;
        (function(CompletionList2) {
          function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
          }
          CompletionList2.create = create;
        })(CompletionList = exports2.CompletionList || (exports2.CompletionList = {}));
        var MarkedString;
        (function(MarkedString2) {
          function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          MarkedString2.fromPlainText = fromPlainText;
          function is(value) {
            var candidate = value;
            return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
          }
          MarkedString2.is = is;
        })(MarkedString = exports2.MarkedString || (exports2.MarkedString = {}));
        var Hover;
        (function(Hover2) {
          function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
          }
          Hover2.is = is;
        })(Hover = exports2.Hover || (exports2.Hover = {}));
        var ParameterInformation;
        (function(ParameterInformation2) {
          function create(label, documentation) {
            return documentation ? { label, documentation } : { label };
          }
          ParameterInformation2.create = create;
        })(ParameterInformation = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
        var SignatureInformation;
        (function(SignatureInformation2) {
          function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              parameters[_i - 2] = arguments[_i];
            }
            var result = { label };
            if (Is.defined(documentation)) {
              result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
              result.parameters = parameters;
            } else {
              result.parameters = [];
            }
            return result;
          }
          SignatureInformation2.create = create;
        })(SignatureInformation = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
        var DocumentHighlightKind3;
        (function(DocumentHighlightKind4) {
          DocumentHighlightKind4.Text = 1;
          DocumentHighlightKind4.Read = 2;
          DocumentHighlightKind4.Write = 3;
        })(DocumentHighlightKind3 = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
        var DocumentHighlight;
        (function(DocumentHighlight2) {
          function create(range, kind) {
            var result = { range };
            if (Is.number(kind)) {
              result.kind = kind;
            }
            return result;
          }
          DocumentHighlight2.create = create;
        })(DocumentHighlight = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
        var SymbolKind2;
        (function(SymbolKind3) {
          SymbolKind3.File = 1;
          SymbolKind3.Module = 2;
          SymbolKind3.Namespace = 3;
          SymbolKind3.Package = 4;
          SymbolKind3.Class = 5;
          SymbolKind3.Method = 6;
          SymbolKind3.Property = 7;
          SymbolKind3.Field = 8;
          SymbolKind3.Constructor = 9;
          SymbolKind3.Enum = 10;
          SymbolKind3.Interface = 11;
          SymbolKind3.Function = 12;
          SymbolKind3.Variable = 13;
          SymbolKind3.Constant = 14;
          SymbolKind3.String = 15;
          SymbolKind3.Number = 16;
          SymbolKind3.Boolean = 17;
          SymbolKind3.Array = 18;
          SymbolKind3.Object = 19;
          SymbolKind3.Key = 20;
          SymbolKind3.Null = 21;
          SymbolKind3.EnumMember = 22;
          SymbolKind3.Struct = 23;
          SymbolKind3.Event = 24;
          SymbolKind3.Operator = 25;
          SymbolKind3.TypeParameter = 26;
        })(SymbolKind2 = exports2.SymbolKind || (exports2.SymbolKind = {}));
        var SymbolTag2;
        (function(SymbolTag3) {
          SymbolTag3.Deprecated = 1;
        })(SymbolTag2 = exports2.SymbolTag || (exports2.SymbolTag = {}));
        var SymbolInformation;
        (function(SymbolInformation2) {
          function create(name, kind, range, uri, containerName) {
            var result = {
              name,
              kind,
              location: { uri, range }
            };
            if (containerName) {
              result.containerName = containerName;
            }
            return result;
          }
          SymbolInformation2.create = create;
        })(SymbolInformation = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
        var WorkspaceSymbol;
        (function(WorkspaceSymbol2) {
          function create(name, kind, uri, range) {
            return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
          }
          WorkspaceSymbol2.create = create;
        })(WorkspaceSymbol = exports2.WorkspaceSymbol || (exports2.WorkspaceSymbol = {}));
        var DocumentSymbol;
        (function(DocumentSymbol2) {
          function create(name, detail, kind, range, selectionRange, children) {
            var result = {
              name,
              detail,
              kind,
              range,
              selectionRange
            };
            if (children !== void 0) {
              result.children = children;
            }
            return result;
          }
          DocumentSymbol2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
          }
          DocumentSymbol2.is = is;
        })(DocumentSymbol = exports2.DocumentSymbol || (exports2.DocumentSymbol = {}));
        var CodeActionKind;
        (function(CodeActionKind2) {
          CodeActionKind2.Empty = "";
          CodeActionKind2.QuickFix = "quickfix";
          CodeActionKind2.Refactor = "refactor";
          CodeActionKind2.RefactorExtract = "refactor.extract";
          CodeActionKind2.RefactorInline = "refactor.inline";
          CodeActionKind2.RefactorRewrite = "refactor.rewrite";
          CodeActionKind2.Source = "source";
          CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
          CodeActionKind2.SourceFixAll = "source.fixAll";
        })(CodeActionKind = exports2.CodeActionKind || (exports2.CodeActionKind = {}));
        var CodeActionTriggerKind;
        (function(CodeActionTriggerKind2) {
          CodeActionTriggerKind2.Invoked = 1;
          CodeActionTriggerKind2.Automatic = 2;
        })(CodeActionTriggerKind = exports2.CodeActionTriggerKind || (exports2.CodeActionTriggerKind = {}));
        var CodeActionContext;
        (function(CodeActionContext2) {
          function create(diagnostics, only, triggerKind) {
            var result = { diagnostics };
            if (only !== void 0 && only !== null) {
              result.only = only;
            }
            if (triggerKind !== void 0 && triggerKind !== null) {
              result.triggerKind = triggerKind;
            }
            return result;
          }
          CodeActionContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
          }
          CodeActionContext2.is = is;
        })(CodeActionContext = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
        var CodeAction;
        (function(CodeAction2) {
          function create(title, kindOrCommandOrEdit, kind) {
            var result = { title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === "string") {
              checkKind = false;
              result.kind = kindOrCommandOrEdit;
            } else if (Command2.is(kindOrCommandOrEdit)) {
              result.command = kindOrCommandOrEdit;
            } else {
              result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          CodeAction2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
          }
          CodeAction2.is = is;
        })(CodeAction = exports2.CodeAction || (exports2.CodeAction = {}));
        var CodeLens;
        (function(CodeLens2) {
          function create(range, data) {
            var result = { range };
            if (Is.defined(data)) {
              result.data = data;
            }
            return result;
          }
          CodeLens2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
          }
          CodeLens2.is = is;
        })(CodeLens = exports2.CodeLens || (exports2.CodeLens = {}));
        var FormattingOptions;
        (function(FormattingOptions2) {
          function create(tabSize, insertSpaces) {
            return { tabSize, insertSpaces };
          }
          FormattingOptions2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
          }
          FormattingOptions2.is = is;
        })(FormattingOptions = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
        var DocumentLink;
        (function(DocumentLink2) {
          function create(range, target, data) {
            return { range, target, data };
          }
          DocumentLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
          }
          DocumentLink2.is = is;
        })(DocumentLink = exports2.DocumentLink || (exports2.DocumentLink = {}));
        var SelectionRange;
        (function(SelectionRange2) {
          function create(range, parent) {
            return { range, parent };
          }
          SelectionRange2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
          }
          SelectionRange2.is = is;
        })(SelectionRange = exports2.SelectionRange || (exports2.SelectionRange = {}));
        var SemanticTokenTypes;
        (function(SemanticTokenTypes2) {
          SemanticTokenTypes2["namespace"] = "namespace";
          SemanticTokenTypes2["type"] = "type";
          SemanticTokenTypes2["class"] = "class";
          SemanticTokenTypes2["enum"] = "enum";
          SemanticTokenTypes2["interface"] = "interface";
          SemanticTokenTypes2["struct"] = "struct";
          SemanticTokenTypes2["typeParameter"] = "typeParameter";
          SemanticTokenTypes2["parameter"] = "parameter";
          SemanticTokenTypes2["variable"] = "variable";
          SemanticTokenTypes2["property"] = "property";
          SemanticTokenTypes2["enumMember"] = "enumMember";
          SemanticTokenTypes2["event"] = "event";
          SemanticTokenTypes2["function"] = "function";
          SemanticTokenTypes2["method"] = "method";
          SemanticTokenTypes2["macro"] = "macro";
          SemanticTokenTypes2["keyword"] = "keyword";
          SemanticTokenTypes2["modifier"] = "modifier";
          SemanticTokenTypes2["comment"] = "comment";
          SemanticTokenTypes2["string"] = "string";
          SemanticTokenTypes2["number"] = "number";
          SemanticTokenTypes2["regexp"] = "regexp";
          SemanticTokenTypes2["operator"] = "operator";
          SemanticTokenTypes2["decorator"] = "decorator";
        })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
        var SemanticTokenModifiers;
        (function(SemanticTokenModifiers2) {
          SemanticTokenModifiers2["declaration"] = "declaration";
          SemanticTokenModifiers2["definition"] = "definition";
          SemanticTokenModifiers2["readonly"] = "readonly";
          SemanticTokenModifiers2["static"] = "static";
          SemanticTokenModifiers2["deprecated"] = "deprecated";
          SemanticTokenModifiers2["abstract"] = "abstract";
          SemanticTokenModifiers2["async"] = "async";
          SemanticTokenModifiers2["modification"] = "modification";
          SemanticTokenModifiers2["documentation"] = "documentation";
          SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
        })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
        var SemanticTokens;
        (function(SemanticTokens2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
          }
          SemanticTokens2.is = is;
        })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
        var InlineValueText;
        (function(InlineValueText2) {
          function create(range, text) {
            return { range, text };
          }
          InlineValueText2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.string(candidate.text);
          }
          InlineValueText2.is = is;
        })(InlineValueText = exports2.InlineValueText || (exports2.InlineValueText = {}));
        var InlineValueVariableLookup;
        (function(InlineValueVariableLookup2) {
          function create(range, variableName, caseSensitiveLookup) {
            return { range, variableName, caseSensitiveLookup };
          }
          InlineValueVariableLookup2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
          }
          InlineValueVariableLookup2.is = is;
        })(InlineValueVariableLookup = exports2.InlineValueVariableLookup || (exports2.InlineValueVariableLookup = {}));
        var InlineValueEvaluatableExpression;
        (function(InlineValueEvaluatableExpression2) {
          function create(range, expression) {
            return { range, expression };
          }
          InlineValueEvaluatableExpression2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
          }
          InlineValueEvaluatableExpression2.is = is;
        })(InlineValueEvaluatableExpression = exports2.InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = {}));
        var InlineValueContext;
        (function(InlineValueContext2) {
          function create(frameId, stoppedLocation) {
            return { frameId, stoppedLocation };
          }
          InlineValueContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(value.stoppedLocation);
          }
          InlineValueContext2.is = is;
        })(InlineValueContext = exports2.InlineValueContext || (exports2.InlineValueContext = {}));
        var InlayHintKind3;
        (function(InlayHintKind4) {
          InlayHintKind4.Type = 1;
          InlayHintKind4.Parameter = 2;
          function is(value) {
            return value === 1 || value === 2;
          }
          InlayHintKind4.is = is;
        })(InlayHintKind3 = exports2.InlayHintKind || (exports2.InlayHintKind = {}));
        var InlayHintLabelPart;
        (function(InlayHintLabelPart2) {
          function create(value) {
            return { value };
          }
          InlayHintLabelPart2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
          }
          InlayHintLabelPart2.is = is;
        })(InlayHintLabelPart = exports2.InlayHintLabelPart || (exports2.InlayHintLabelPart = {}));
        var InlayHint;
        (function(InlayHint2) {
          function create(position, label, kind) {
            var result = { position, label };
            if (kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          InlayHint2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
          }
          InlayHint2.is = is;
        })(InlayHint = exports2.InlayHint || (exports2.InlayHint = {}));
        var WorkspaceFolder;
        (function(WorkspaceFolder2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
          }
          WorkspaceFolder2.is = is;
        })(WorkspaceFolder = exports2.WorkspaceFolder || (exports2.WorkspaceFolder = {}));
        exports2.EOL = ["\n", "\r\n", "\r"];
        var TextDocument;
        (function(TextDocument2) {
          function create(uri, languageId, version, content) {
            return new FullTextDocument(uri, languageId, version, content);
          }
          TextDocument2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
          }
          TextDocument2.is = is;
          function applyEdits(document, edits) {
            var text = document.getText();
            var sortedEdits = mergeSort(edits, function(a, b) {
              var diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
              var e = sortedEdits[i];
              var startOffset = document.offsetAt(e.range.start);
              var endOffset = document.offsetAt(e.range.end);
              if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
              } else {
                throw new Error("Overlapping edit");
              }
              lastModifiedOffset = startOffset;
            }
            return text;
          }
          TextDocument2.applyEdits = applyEdits;
          function mergeSort(data, compare) {
            if (data.length <= 1) {
              return data;
            }
            var p = data.length / 2 | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
              var ret = compare(left[leftIdx], right[rightIdx]);
              if (ret <= 0) {
                data[i++] = left[leftIdx++];
              } else {
                data[i++] = right[rightIdx++];
              }
            }
            while (leftIdx < left.length) {
              data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
              data[i++] = right[rightIdx++];
            }
            return data;
          }
        })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
        var FullTextDocument = function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position2.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position2.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }();
        var Is;
        (function(Is2) {
          var toString = Object.prototype.toString;
          function defined(value) {
            return typeof value !== "undefined";
          }
          Is2.defined = defined;
          function undefined2(value) {
            return typeof value === "undefined";
          }
          Is2.undefined = undefined2;
          function boolean(value) {
            return value === true || value === false;
          }
          Is2.boolean = boolean;
          function string(value) {
            return toString.call(value) === "[object String]";
          }
          Is2.string = string;
          function number(value) {
            return toString.call(value) === "[object Number]";
          }
          Is2.number = number;
          function numberRange(value, min, max) {
            return toString.call(value) === "[object Number]" && min <= value && value <= max;
          }
          Is2.numberRange = numberRange;
          function integer2(value) {
            return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
          }
          Is2.integer = integer2;
          function uinteger2(value) {
            return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
          }
          Is2.uinteger = uinteger2;
          function func(value) {
            return toString.call(value) === "[object Function]";
          }
          Is2.func = func;
          function objectLiteral(value) {
            return value !== null && typeof value === "object";
          }
          Is2.objectLiteral = objectLiteral;
          function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
          }
          Is2.typedArray = typedArray;
        })(Is || (Is = {}));
      });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/CharacterStream.js
  var require_CharacterStream = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/CharacterStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var CharacterStream = class {
        constructor(sourceText) {
          this.getStartOfToken = () => this._start;
          this.getCurrentPosition = () => this._pos;
          this.eol = () => this._sourceText.length === this._pos;
          this.sol = () => this._pos === 0;
          this.peek = () => {
            return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;
          };
          this.next = () => {
            const char = this._sourceText.charAt(this._pos);
            this._pos++;
            return char;
          };
          this.eat = (pattern) => {
            const isMatched = this._testNextCharacter(pattern);
            if (isMatched) {
              this._start = this._pos;
              this._pos++;
              return this._sourceText.charAt(this._pos - 1);
            }
            return void 0;
          };
          this.eatWhile = (match) => {
            let isMatched = this._testNextCharacter(match);
            let didEat = false;
            if (isMatched) {
              didEat = isMatched;
              this._start = this._pos;
            }
            while (isMatched) {
              this._pos++;
              isMatched = this._testNextCharacter(match);
              didEat = true;
            }
            return didEat;
          };
          this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
          this.skipToEnd = () => {
            this._pos = this._sourceText.length;
          };
          this.skipTo = (position) => {
            this._pos = position;
          };
          this.match = (pattern, consume = true, caseFold = false) => {
            let token = null;
            let match = null;
            if (typeof pattern === "string") {
              const regex = new RegExp(pattern, caseFold ? "i" : "g");
              match = regex.test(this._sourceText.substr(this._pos, pattern.length));
              token = pattern;
            } else if (pattern instanceof RegExp) {
              match = this._sourceText.slice(this._pos).match(pattern);
              token = match && match[0];
            }
            if (match != null) {
              if (typeof pattern === "string" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {
                if (consume) {
                  this._start = this._pos;
                  if (token && token.length) {
                    this._pos += token.length;
                  }
                }
                return match;
              }
            }
            return false;
          };
          this.backUp = (num) => {
            this._pos -= num;
          };
          this.column = () => this._pos;
          this.indentation = () => {
            const match = this._sourceText.match(/\s*/);
            let indent = 0;
            if (match && match.length !== 0) {
              const whitespaces = match[0];
              let pos = 0;
              while (whitespaces.length > pos) {
                if (whitespaces.charCodeAt(pos) === 9) {
                  indent += 2;
                } else {
                  indent++;
                }
                pos++;
              }
            }
            return indent;
          };
          this.current = () => this._sourceText.slice(this._start, this._pos);
          this._start = 0;
          this._pos = 0;
          this._sourceText = sourceText;
        }
        _testNextCharacter(pattern) {
          const character = this._sourceText.charAt(this._pos);
          let isMatched = false;
          if (typeof pattern === "string") {
            isMatched = character === pattern;
          } else {
            isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
          }
          return isMatched;
        }
      };
      exports.default = CharacterStream;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/RuleHelpers.js
  var require_RuleHelpers = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/RuleHelpers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.p = exports.t = exports.butNot = exports.list = exports.opt = void 0;
      function opt(ofRule) {
        return { ofRule };
      }
      exports.opt = opt;
      function list(ofRule, separator) {
        return { ofRule, isList: true, separator };
      }
      exports.list = list;
      function butNot(rule, exclusions) {
        const ruleMatch = rule.match;
        rule.match = (token) => {
          let check = false;
          if (ruleMatch) {
            check = ruleMatch(token);
          }
          return check && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token));
        };
        return rule;
      }
      exports.butNot = butNot;
      function t(kind, style) {
        return { style, match: (token) => token.kind === kind };
      }
      exports.t = t;
      function p(value, style) {
        return {
          style: style || "punctuation",
          match: (token) => token.kind === "Punctuation" && token.value === value
        };
      }
      exports.p = p;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/Rules.js
  var require_Rules = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/Rules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseRules = exports.LexRules = exports.isIgnored = void 0;
      var RuleHelpers_1 = require_RuleHelpers();
      var graphql_1 = require_graphql2();
      var isIgnored = (ch) => ch === " " || ch === "	" || ch === "," || ch === "\n" || ch === "\r" || ch === "\uFEFF" || ch === "\xA0";
      exports.isIgnored = isIgnored;
      exports.LexRules = {
        Name: /^[_A-Za-z][_0-9A-Za-z]*/,
        Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
        Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
        String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
        Comment: /^#.*/
      };
      exports.ParseRules = {
        Document: [RuleHelpers_1.list("Definition")],
        Definition(token) {
          switch (token.value) {
            case "{":
              return "ShortQuery";
            case "query":
              return "Query";
            case "mutation":
              return "Mutation";
            case "subscription":
              return "Subscription";
            case "fragment":
              return graphql_1.Kind.FRAGMENT_DEFINITION;
            case "schema":
              return "SchemaDef";
            case "scalar":
              return "ScalarDef";
            case "type":
              return "ObjectTypeDef";
            case "interface":
              return "InterfaceDef";
            case "union":
              return "UnionDef";
            case "enum":
              return "EnumDef";
            case "input":
              return "InputDef";
            case "extend":
              return "ExtendDef";
            case "directive":
              return "DirectiveDef";
          }
        },
        ShortQuery: ["SelectionSet"],
        Query: [
          word("query"),
          RuleHelpers_1.opt(name("def")),
          RuleHelpers_1.opt("VariableDefinitions"),
          RuleHelpers_1.list("Directive"),
          "SelectionSet"
        ],
        Mutation: [
          word("mutation"),
          RuleHelpers_1.opt(name("def")),
          RuleHelpers_1.opt("VariableDefinitions"),
          RuleHelpers_1.list("Directive"),
          "SelectionSet"
        ],
        Subscription: [
          word("subscription"),
          RuleHelpers_1.opt(name("def")),
          RuleHelpers_1.opt("VariableDefinitions"),
          RuleHelpers_1.list("Directive"),
          "SelectionSet"
        ],
        VariableDefinitions: [RuleHelpers_1.p("("), RuleHelpers_1.list("VariableDefinition"), RuleHelpers_1.p(")")],
        VariableDefinition: ["Variable", RuleHelpers_1.p(":"), "Type", RuleHelpers_1.opt("DefaultValue")],
        Variable: [RuleHelpers_1.p("$", "variable"), name("variable")],
        DefaultValue: [RuleHelpers_1.p("="), "Value"],
        SelectionSet: [RuleHelpers_1.p("{"), RuleHelpers_1.list("Selection"), RuleHelpers_1.p("}")],
        Selection(token, stream) {
          return token.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
        },
        AliasedField: [
          name("property"),
          RuleHelpers_1.p(":"),
          name("qualifier"),
          RuleHelpers_1.opt("Arguments"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.opt("SelectionSet")
        ],
        Field: [
          name("property"),
          RuleHelpers_1.opt("Arguments"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.opt("SelectionSet")
        ],
        Arguments: [RuleHelpers_1.p("("), RuleHelpers_1.list("Argument"), RuleHelpers_1.p(")")],
        Argument: [name("attribute"), RuleHelpers_1.p(":"), "Value"],
        FragmentSpread: [RuleHelpers_1.p("..."), name("def"), RuleHelpers_1.list("Directive")],
        InlineFragment: [
          RuleHelpers_1.p("..."),
          RuleHelpers_1.opt("TypeCondition"),
          RuleHelpers_1.list("Directive"),
          "SelectionSet"
        ],
        FragmentDefinition: [
          word("fragment"),
          RuleHelpers_1.opt(RuleHelpers_1.butNot(name("def"), [word("on")])),
          "TypeCondition",
          RuleHelpers_1.list("Directive"),
          "SelectionSet"
        ],
        TypeCondition: [word("on"), "NamedType"],
        Value(token) {
          switch (token.kind) {
            case "Number":
              return "NumberValue";
            case "String":
              return "StringValue";
            case "Punctuation":
              switch (token.value) {
                case "[":
                  return "ListValue";
                case "{":
                  return "ObjectValue";
                case "$":
                  return "Variable";
                case "&":
                  return "NamedType";
              }
              return null;
            case "Name":
              switch (token.value) {
                case "true":
                case "false":
                  return "BooleanValue";
              }
              if (token.value === "null") {
                return "NullValue";
              }
              return "EnumValue";
          }
        },
        NumberValue: [RuleHelpers_1.t("Number", "number")],
        StringValue: [
          {
            style: "string",
            match: (token) => token.kind === "String",
            update(state, token) {
              if (token.value.startsWith('"""')) {
                state.inBlockstring = !token.value.slice(3).endsWith('"""');
              }
            }
          }
        ],
        BooleanValue: [RuleHelpers_1.t("Name", "builtin")],
        NullValue: [RuleHelpers_1.t("Name", "keyword")],
        EnumValue: [name("string-2")],
        ListValue: [RuleHelpers_1.p("["), RuleHelpers_1.list("Value"), RuleHelpers_1.p("]")],
        ObjectValue: [RuleHelpers_1.p("{"), RuleHelpers_1.list("ObjectField"), RuleHelpers_1.p("}")],
        ObjectField: [name("attribute"), RuleHelpers_1.p(":"), "Value"],
        Type(token) {
          return token.value === "[" ? "ListType" : "NonNullType";
        },
        ListType: [RuleHelpers_1.p("["), "Type", RuleHelpers_1.p("]"), RuleHelpers_1.opt(RuleHelpers_1.p("!"))],
        NonNullType: ["NamedType", RuleHelpers_1.opt(RuleHelpers_1.p("!"))],
        NamedType: [type("atom")],
        Directive: [RuleHelpers_1.p("@", "meta"), name("meta"), RuleHelpers_1.opt("Arguments")],
        DirectiveDef: [
          word("directive"),
          RuleHelpers_1.p("@", "meta"),
          name("meta"),
          RuleHelpers_1.opt("ArgumentsDef"),
          word("on"),
          RuleHelpers_1.list("DirectiveLocation", RuleHelpers_1.p("|"))
        ],
        InterfaceDef: [
          word("interface"),
          name("atom"),
          RuleHelpers_1.opt("Implements"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.p("{"),
          RuleHelpers_1.list("FieldDef"),
          RuleHelpers_1.p("}")
        ],
        Implements: [word("implements"), RuleHelpers_1.list("NamedType", RuleHelpers_1.p("&"))],
        DirectiveLocation: [name("string-2")],
        SchemaDef: [
          word("schema"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.p("{"),
          RuleHelpers_1.list("OperationTypeDef"),
          RuleHelpers_1.p("}")
        ],
        OperationTypeDef: [name("keyword"), RuleHelpers_1.p(":"), name("atom")],
        ScalarDef: [word("scalar"), name("atom"), RuleHelpers_1.list("Directive")],
        ObjectTypeDef: [
          word("type"),
          name("atom"),
          RuleHelpers_1.opt("Implements"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.p("{"),
          RuleHelpers_1.list("FieldDef"),
          RuleHelpers_1.p("}")
        ],
        FieldDef: [
          name("property"),
          RuleHelpers_1.opt("ArgumentsDef"),
          RuleHelpers_1.p(":"),
          "Type",
          RuleHelpers_1.list("Directive")
        ],
        ArgumentsDef: [RuleHelpers_1.p("("), RuleHelpers_1.list("InputValueDef"), RuleHelpers_1.p(")")],
        InputValueDef: [
          name("attribute"),
          RuleHelpers_1.p(":"),
          "Type",
          RuleHelpers_1.opt("DefaultValue"),
          RuleHelpers_1.list("Directive")
        ],
        UnionDef: [
          word("union"),
          name("atom"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.p("="),
          RuleHelpers_1.list("UnionMember", RuleHelpers_1.p("|"))
        ],
        UnionMember: ["NamedType"],
        EnumDef: [
          word("enum"),
          name("atom"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.p("{"),
          RuleHelpers_1.list("EnumValueDef"),
          RuleHelpers_1.p("}")
        ],
        EnumValueDef: [name("string-2"), RuleHelpers_1.list("Directive")],
        InputDef: [
          word("input"),
          name("atom"),
          RuleHelpers_1.list("Directive"),
          RuleHelpers_1.p("{"),
          RuleHelpers_1.list("InputValueDef"),
          RuleHelpers_1.p("}")
        ],
        ExtendDef: [word("extend"), "ObjectTypeDef"]
      };
      function word(value) {
        return {
          style: "keyword",
          match: (token) => token.kind === "Name" && token.value === value
        };
      }
      function name(style) {
        return {
          style,
          match: (token) => token.kind === "Name",
          update(state, token) {
            state.name = token.value;
          }
        };
      }
      function type(style) {
        return {
          style,
          match: (token) => token.kind === "Name",
          update(state, token) {
            if (state.prevState && state.prevState.prevState) {
              state.name = token.value;
              state.prevState.prevState.type = token.value;
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/onlineParser.js
  var require_onlineParser = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/onlineParser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Rules_1 = require_Rules();
      var graphql_1 = require_graphql2();
      function onlineParser(options = {
        eatWhitespace: (stream) => stream.eatWhile(Rules_1.isIgnored),
        lexRules: Rules_1.LexRules,
        parseRules: Rules_1.ParseRules,
        editorConfig: {}
      }) {
        return {
          startState() {
            const initialState = {
              level: 0,
              step: 0,
              name: null,
              kind: null,
              type: null,
              rule: null,
              needsSeperator: false,
              prevState: null
            };
            pushRule(options.parseRules, initialState, graphql_1.Kind.DOCUMENT);
            return initialState;
          },
          token(stream, state) {
            return getToken(stream, state, options);
          }
        };
      }
      exports.default = onlineParser;
      function getToken(stream, state, options) {
        if (state.inBlockstring) {
          if (stream.match(/.*"""/)) {
            state.inBlockstring = false;
            return "string";
          } else {
            stream.skipToEnd();
            return "string";
          }
        }
        const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
        if (state.rule && state.rule.length === 0) {
          popRule(state);
        } else if (state.needsAdvance) {
          state.needsAdvance = false;
          advanceRule(state, true);
        }
        if (stream.sol()) {
          const tabSize = editorConfig && editorConfig.tabSize || 2;
          state.indentLevel = Math.floor(stream.indentation() / tabSize);
        }
        if (eatWhitespace(stream)) {
          return "ws";
        }
        const token = lex(lexRules, stream);
        if (!token) {
          const matchedSomething = stream.match(/\S+/);
          if (!matchedSomething) {
            stream.match(/\s/);
          }
          pushRule(SpecialParseRules, state, "Invalid");
          return "invalidchar";
        }
        if (token.kind === "Comment") {
          pushRule(SpecialParseRules, state, "Comment");
          return "comment";
        }
        const backupState = assign({}, state);
        if (token.kind === "Punctuation") {
          if (/^[{([]/.test(token.value)) {
            if (state.indentLevel !== void 0) {
              state.levels = (state.levels || []).concat(state.indentLevel + 1);
            }
          } else if (/^[})\]]/.test(token.value)) {
            const levels = state.levels = (state.levels || []).slice(0, -1);
            if (state.indentLevel) {
              if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {
                state.indentLevel = levels[levels.length - 1];
              }
            }
          }
        }
        while (state.rule) {
          let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];
          if (state.needsSeperator) {
            expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);
          }
          if (expected) {
            if (expected.ofRule) {
              expected = expected.ofRule;
            }
            if (typeof expected === "string") {
              pushRule(parseRules, state, expected);
              continue;
            }
            if (expected.match && expected.match(token)) {
              if (expected.update) {
                expected.update(state, token);
              }
              if (token.kind === "Punctuation") {
                advanceRule(state, true);
              } else {
                state.needsAdvance = true;
              }
              return expected.style;
            }
          }
          unsuccessful(state);
        }
        assign(state, backupState);
        pushRule(SpecialParseRules, state, "Invalid");
        return "invalidchar";
      }
      function assign(to, from) {
        const keys = Object.keys(from);
        for (let i = 0; i < keys.length; i++) {
          to[keys[i]] = from[keys[i]];
        }
        return to;
      }
      var SpecialParseRules = {
        Invalid: [],
        Comment: []
      };
      function pushRule(rules, state, ruleKind) {
        if (!rules[ruleKind]) {
          throw new TypeError("Unknown rule: " + ruleKind);
        }
        state.prevState = Object.assign({}, state);
        state.kind = ruleKind;
        state.name = null;
        state.type = null;
        state.rule = rules[ruleKind];
        state.step = 0;
        state.needsSeperator = false;
      }
      function popRule(state) {
        if (!state.prevState) {
          return;
        }
        state.kind = state.prevState.kind;
        state.name = state.prevState.name;
        state.type = state.prevState.type;
        state.rule = state.prevState.rule;
        state.step = state.prevState.step;
        state.needsSeperator = state.prevState.needsSeperator;
        state.prevState = state.prevState.prevState;
      }
      function advanceRule(state, successful) {
        if (isList(state) && state.rule) {
          const step = state.rule[state.step];
          if (step.separator) {
            const separator = step.separator;
            state.needsSeperator = !state.needsSeperator;
            if (!state.needsSeperator && separator.ofRule) {
              return;
            }
          }
          if (successful) {
            return;
          }
        }
        state.needsSeperator = false;
        state.step++;
        while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
          popRule(state);
          if (state.rule) {
            if (isList(state)) {
              if (state.rule && state.rule[state.step].separator) {
                state.needsSeperator = !state.needsSeperator;
              }
            } else {
              state.needsSeperator = false;
              state.step++;
            }
          }
        }
      }
      function isList(state) {
        const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];
        return step && step.isList;
      }
      function unsuccessful(state) {
        while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
          popRule(state);
        }
        if (state.rule) {
          advanceRule(state, false);
        }
      }
      function lex(lexRules, stream) {
        const kinds = Object.keys(lexRules);
        for (let i = 0; i < kinds.length; i++) {
          const match = stream.match(lexRules[kinds[i]]);
          if (match && match instanceof Array) {
            return { kind: kinds[i], value: match[0] };
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/types.js
  var require_types = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleKinds = exports.AdditionalRuleKinds = void 0;
      var graphql_1 = require_graphql2();
      exports.AdditionalRuleKinds = {
        ALIASED_FIELD: "AliasedField",
        ARGUMENTS: "Arguments",
        SHORT_QUERY: "ShortQuery",
        QUERY: "Query",
        MUTATION: "Mutation",
        SUBSCRIPTION: "Subscription",
        TYPE_CONDITION: "TypeCondition",
        INVALID: "Invalid",
        COMMENT: "Comment",
        SCHEMA_DEF: "SchemaDef",
        SCALAR_DEF: "ScalarDef",
        OBJECT_TYPE_DEF: "ObjectTypeDef",
        OBJECT_VALUE: "ObjectValue",
        LIST_VALUE: "ListValue",
        INTERFACE_DEF: "InterfaceDef",
        UNION_DEF: "UnionDef",
        ENUM_DEF: "EnumDef",
        ENUM_VALUE: "EnumValue",
        FIELD_DEF: "FieldDef",
        INPUT_DEF: "InputDef",
        INPUT_VALUE_DEF: "InputValueDef",
        ARGUMENTS_DEF: "ArgumentsDef",
        EXTEND_DEF: "ExtendDef",
        DIRECTIVE_DEF: "DirectiveDef",
        IMPLEMENTS: "Implements",
        VARIABLE_DEFINITIONS: "VariableDefinitions",
        TYPE: "Type"
      };
      exports.RuleKinds = Object.assign(Object.assign({}, graphql_1.Kind), exports.AdditionalRuleKinds);
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/index.js
  var require_parser2 = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/parser/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onlineParser = exports.t = exports.p = exports.opt = exports.list = exports.butNot = exports.isIgnored = exports.ParseRules = exports.LexRules = exports.CharacterStream = void 0;
      var CharacterStream_1 = require_CharacterStream();
      Object.defineProperty(exports, "CharacterStream", { enumerable: true, get: function() {
        return __importDefault(CharacterStream_1).default;
      } });
      var Rules_1 = require_Rules();
      Object.defineProperty(exports, "LexRules", { enumerable: true, get: function() {
        return Rules_1.LexRules;
      } });
      Object.defineProperty(exports, "ParseRules", { enumerable: true, get: function() {
        return Rules_1.ParseRules;
      } });
      Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
        return Rules_1.isIgnored;
      } });
      var RuleHelpers_1 = require_RuleHelpers();
      Object.defineProperty(exports, "butNot", { enumerable: true, get: function() {
        return RuleHelpers_1.butNot;
      } });
      Object.defineProperty(exports, "list", { enumerable: true, get: function() {
        return RuleHelpers_1.list;
      } });
      Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
        return RuleHelpers_1.opt;
      } });
      Object.defineProperty(exports, "p", { enumerable: true, get: function() {
        return RuleHelpers_1.p;
      } });
      Object.defineProperty(exports, "t", { enumerable: true, get: function() {
        return RuleHelpers_1.t;
      } });
      var onlineParser_1 = require_onlineParser();
      Object.defineProperty(exports, "onlineParser", { enumerable: true, get: function() {
        return __importDefault(onlineParser_1).default;
      } });
      __exportStar(require_types(), exports);
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getAutocompleteSuggestions.js
  var require_getAutocompleteSuggestions = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getAutocompleteSuggestions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTypeInfo = exports.canUseDirective = exports.runOnlineParser = exports.getTokenAtPosition = exports.getFragmentDefinitions = exports.getVariableCompletions = exports.getAutocompleteSuggestions = exports.SuggestionCommand = void 0;
      var vscode_languageserver_types_1 = require_main();
      var graphql_1 = require_graphql2();
      var graphql_2 = require_graphql2();
      var parser_1 = require_parser2();
      var autocompleteUtils_1 = require_autocompleteUtils();
      exports.SuggestionCommand = {
        command: "editor.action.triggerSuggest",
        title: "Suggestions"
      };
      var collectFragmentDefs = (op) => {
        const externalFragments = [];
        if (op) {
          try {
            graphql_2.visit(graphql_2.parse(op), {
              FragmentDefinition(def) {
                externalFragments.push(def);
              }
            });
          } catch (_a3) {
            return [];
          }
        }
        return externalFragments;
      };
      function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
        var _a3;
        const opts = Object.assign(Object.assign({}, options), { schema });
        const token = contextToken || getTokenAtPosition(queryText, cursor);
        const state = token.state.kind === "Invalid" ? token.state.prevState : token.state;
        if (!state) {
          return [];
        }
        const kind = state.kind;
        const step = state.step;
        const typeInfo = getTypeInfo(schema, token.state);
        if (kind === parser_1.RuleKinds.DOCUMENT) {
          return autocompleteUtils_1.hintList(token, [
            { label: "query", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "mutation", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "subscription", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "fragment", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "{", kind: vscode_languageserver_types_1.CompletionItemKind.Constructor }
          ]);
        }
        if (kind === parser_1.RuleKinds.IMPLEMENTS || kind === parser_1.RuleKinds.NAMED_TYPE && ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === parser_1.RuleKinds.IMPLEMENTS) {
          return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);
        }
        if (kind === parser_1.RuleKinds.SELECTION_SET || kind === parser_1.RuleKinds.FIELD || kind === parser_1.RuleKinds.ALIASED_FIELD) {
          return getSuggestionsForFieldNames(token, typeInfo, opts);
        }
        if (kind === parser_1.RuleKinds.ARGUMENTS || kind === parser_1.RuleKinds.ARGUMENT && step === 0) {
          const argDefs = typeInfo.argDefs;
          if (argDefs) {
            return autocompleteUtils_1.hintList(token, argDefs.map((argDef) => {
              var _a4;
              return {
                label: argDef.name,
                insertText: argDef.name + ": ",
                command: exports.SuggestionCommand,
                detail: String(argDef.type),
                documentation: (_a4 = argDef.description) !== null && _a4 !== void 0 ? _a4 : void 0,
                kind: vscode_languageserver_types_1.CompletionItemKind.Variable,
                type: argDef.type
              };
            }));
          }
        }
        if (kind === parser_1.RuleKinds.OBJECT_VALUE || kind === parser_1.RuleKinds.OBJECT_FIELD && step === 0) {
          if (typeInfo.objectFieldDefs) {
            const objectFields = autocompleteUtils_1.objectValues(typeInfo.objectFieldDefs);
            const completionKind = kind === parser_1.RuleKinds.OBJECT_VALUE ? vscode_languageserver_types_1.CompletionItemKind.Value : vscode_languageserver_types_1.CompletionItemKind.Field;
            return autocompleteUtils_1.hintList(token, objectFields.map((field) => {
              var _a4;
              return {
                label: field.name,
                detail: String(field.type),
                documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
                kind: completionKind,
                type: field.type
              };
            }));
          }
        }
        if (kind === parser_1.RuleKinds.ENUM_VALUE || kind === parser_1.RuleKinds.LIST_VALUE && step === 1 || kind === parser_1.RuleKinds.OBJECT_FIELD && step === 2 || kind === parser_1.RuleKinds.ARGUMENT && step === 2) {
          return getSuggestionsForInputValues(token, typeInfo, queryText, schema);
        }
        if (kind === parser_1.RuleKinds.VARIABLE && step === 1) {
          const namedInputType = graphql_2.getNamedType(typeInfo.inputType);
          const variableDefinitions = getVariableCompletions(queryText, schema, token);
          return autocompleteUtils_1.hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
        }
        if (kind === parser_1.RuleKinds.TYPE_CONDITION && step === 1 || kind === parser_1.RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === parser_1.RuleKinds.TYPE_CONDITION) {
          return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);
        }
        if (kind === parser_1.RuleKinds.FRAGMENT_SPREAD && step === 1) {
          return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
        }
        if (kind === parser_1.RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === parser_1.RuleKinds.LIST_TYPE && step === 1 || kind === parser_1.RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === parser_1.RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === parser_1.RuleKinds.LIST_TYPE || state.prevState.kind === parser_1.RuleKinds.NON_NULL_TYPE)) {
          return getSuggestionsForVariableDefinition(token, schema, kind);
        }
        if (kind === parser_1.RuleKinds.DIRECTIVE) {
          return getSuggestionsForDirective(token, state, schema, kind);
        }
        return [];
      }
      exports.getAutocompleteSuggestions = getAutocompleteSuggestions;
      var insertSuffix = ` {
  $1
}`;
      var getInsertText = (field) => {
        const type = field.type;
        if (graphql_2.isCompositeType(type)) {
          return insertSuffix;
        }
        if (graphql_1.isListType(type) && graphql_2.isCompositeType(type.ofType)) {
          return insertSuffix;
        }
        if (graphql_1.isNonNullType(type)) {
          if (graphql_2.isCompositeType(type.ofType)) {
            return insertSuffix;
          }
          if (graphql_1.isListType(type.ofType) && graphql_2.isCompositeType(type.ofType.ofType)) {
            return insertSuffix;
          }
        }
        return null;
      };
      function getSuggestionsForFieldNames(token, typeInfo, options) {
        var _a3;
        if (typeInfo.parentType) {
          const parentType = typeInfo.parentType;
          let fields = [];
          if ("getFields" in parentType) {
            fields = autocompleteUtils_1.objectValues(parentType.getFields());
          }
          if (graphql_2.isCompositeType(parentType)) {
            fields.push(graphql_2.TypeNameMetaFieldDef);
          }
          if (parentType === ((_a3 = options === null || options === void 0 ? void 0 : options.schema) === null || _a3 === void 0 ? void 0 : _a3.getQueryType())) {
            fields.push(graphql_2.SchemaMetaFieldDef, graphql_2.TypeMetaFieldDef);
          }
          return autocompleteUtils_1.hintList(token, fields.map((field, index) => {
            var _a4;
            const suggestion = {
              sortText: String(index) + field.name,
              label: field.name,
              detail: String(field.type),
              documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
              deprecated: Boolean(field.deprecationReason),
              isDeprecated: Boolean(field.deprecationReason),
              deprecationReason: field.deprecationReason,
              kind: vscode_languageserver_types_1.CompletionItemKind.Field,
              type: field.type
            };
            const insertText = getInsertText(field);
            if (insertText) {
              suggestion.insertText = field.name + insertText;
              suggestion.insertTextFormat = vscode_languageserver_types_1.InsertTextFormat.Snippet;
              suggestion.command = exports.SuggestionCommand;
            }
            return suggestion;
          }));
        }
        return [];
      }
      function getSuggestionsForInputValues(token, typeInfo, queryText, schema) {
        const namedInputType = graphql_2.getNamedType(typeInfo.inputType);
        const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);
        if (namedInputType instanceof graphql_2.GraphQLEnumType) {
          const values = namedInputType.getValues();
          return autocompleteUtils_1.hintList(token, values.map((value) => {
            var _a3;
            return {
              label: value.name,
              detail: String(namedInputType),
              documentation: (_a3 = value.description) !== null && _a3 !== void 0 ? _a3 : void 0,
              deprecated: Boolean(value.deprecationReason),
              isDeprecated: Boolean(value.deprecationReason),
              deprecationReason: value.deprecationReason,
              kind: vscode_languageserver_types_1.CompletionItemKind.EnumMember,
              type: namedInputType
            };
          }).concat(queryVariables));
        } else if (namedInputType === graphql_2.GraphQLBoolean) {
          return autocompleteUtils_1.hintList(token, queryVariables.concat([
            {
              label: "true",
              detail: String(graphql_2.GraphQLBoolean),
              documentation: "Not false.",
              kind: vscode_languageserver_types_1.CompletionItemKind.Variable,
              type: graphql_2.GraphQLBoolean
            },
            {
              label: "false",
              detail: String(graphql_2.GraphQLBoolean),
              documentation: "Not true.",
              kind: vscode_languageserver_types_1.CompletionItemKind.Variable,
              type: graphql_2.GraphQLBoolean
            }
          ]));
        }
        return queryVariables;
      }
      function getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {
        if (tokenState.needsSeperator) {
          return [];
        }
        const typeMap = schema.getTypeMap();
        const schemaInterfaces = autocompleteUtils_1.objectValues(typeMap).filter(graphql_1.isInterfaceType);
        const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);
        const inlineInterfaces = /* @__PURE__ */ new Set();
        runOnlineParser(documentText, (_, state) => {
          var _a3, _b, _c, _d, _e;
          if (state.name) {
            if (state.kind === parser_1.RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {
              inlineInterfaces.add(state.name);
            }
            if (state.kind === parser_1.RuleKinds.NAMED_TYPE && ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === parser_1.RuleKinds.IMPLEMENTS) {
              if (typeInfo.interfaceDef) {
                const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);
                if (existingType) {
                  return;
                }
                const type = schema.getType(state.name);
                const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
                typeInfo.interfaceDef = new graphql_1.GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
                  ...interfaceConfig.interfaces,
                  type || new graphql_1.GraphQLInterfaceType({ name: state.name, fields: {} })
                ] }));
              } else if (typeInfo.objectTypeDef) {
                const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);
                if (existingType) {
                  return;
                }
                const type = schema.getType(state.name);
                const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();
                typeInfo.objectTypeDef = new graphql_1.GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
                  ...objectTypeConfig.interfaces,
                  type || new graphql_1.GraphQLInterfaceType({ name: state.name, fields: {} })
                ] }));
              }
            }
          }
        });
        const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
        const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
        const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);
        const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));
        return autocompleteUtils_1.hintList(token, possibleInterfaces.map((type) => {
          const result = {
            label: type.name,
            kind: vscode_languageserver_types_1.CompletionItemKind.Interface,
            type
          };
          if (type === null || type === void 0 ? void 0 : type.description) {
            result.documentation = type.description;
          }
          return result;
        }));
      }
      function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {
        let possibleTypes;
        if (typeInfo.parentType) {
          if (graphql_2.isAbstractType(typeInfo.parentType)) {
            const abstractType = graphql_2.assertAbstractType(typeInfo.parentType);
            const possibleObjTypes = schema.getPossibleTypes(abstractType);
            const possibleIfaceMap = /* @__PURE__ */ Object.create(null);
            possibleObjTypes.forEach((type) => {
              type.getInterfaces().forEach((iface) => {
                possibleIfaceMap[iface.name] = iface;
              });
            });
            possibleTypes = possibleObjTypes.concat(autocompleteUtils_1.objectValues(possibleIfaceMap));
          } else {
            possibleTypes = [typeInfo.parentType];
          }
        } else {
          const typeMap = schema.getTypeMap();
          possibleTypes = autocompleteUtils_1.objectValues(typeMap).filter(graphql_2.isCompositeType);
        }
        return autocompleteUtils_1.hintList(token, possibleTypes.map((type) => {
          const namedType = graphql_2.getNamedType(type);
          return {
            label: String(type),
            documentation: namedType && namedType.description || "",
            kind: vscode_languageserver_types_1.CompletionItemKind.Field
          };
        }));
      }
      function getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {
        if (!queryText) {
          return [];
        }
        const typeMap = schema.getTypeMap();
        const defState = autocompleteUtils_1.getDefinitionState(token.state);
        const fragments = getFragmentDefinitions(queryText);
        if (fragmentDefs && fragmentDefs.length > 0) {
          fragments.push(...fragmentDefs);
        }
        const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === parser_1.RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && graphql_2.isCompositeType(typeInfo.parentType) && graphql_2.isCompositeType(typeMap[frag.typeCondition.name.value]) && graphql_2.doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
        return autocompleteUtils_1.hintList(token, relevantFrags.map((frag) => ({
          label: frag.name.value,
          detail: String(typeMap[frag.typeCondition.name.value]),
          documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
          kind: vscode_languageserver_types_1.CompletionItemKind.Field,
          type: typeMap[frag.typeCondition.name.value]
        })));
      }
      var getParentDefinition = (state, kind) => {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === kind) {
          return state.prevState;
        }
        if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {
          return state.prevState.prevState;
        }
        if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {
          return state.prevState.prevState.prevState;
        }
        if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {
          return state.prevState.prevState.prevState.prevState;
        }
      };
      function getVariableCompletions(queryText, schema, token) {
        let variableName = null;
        let variableType;
        const definitions = /* @__PURE__ */ Object.create({});
        runOnlineParser(queryText, (_, state) => {
          if ((state === null || state === void 0 ? void 0 : state.kind) === parser_1.RuleKinds.VARIABLE && state.name) {
            variableName = state.name;
          }
          if ((state === null || state === void 0 ? void 0 : state.kind) === parser_1.RuleKinds.NAMED_TYPE && variableName) {
            const parentDefinition = getParentDefinition(state, parser_1.RuleKinds.TYPE);
            if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
              variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
            }
          }
          if (variableName && variableType) {
            if (!definitions[variableName]) {
              definitions[variableName] = {
                detail: variableType.toString(),
                insertText: token.string === "$" ? variableName : "$" + variableName,
                label: variableName,
                type: variableType,
                kind: vscode_languageserver_types_1.CompletionItemKind.Variable
              };
              variableName = null;
              variableType = null;
            }
          }
        });
        return autocompleteUtils_1.objectValues(definitions);
      }
      exports.getVariableCompletions = getVariableCompletions;
      function getFragmentDefinitions(queryText) {
        const fragmentDefs = [];
        runOnlineParser(queryText, (_, state) => {
          if (state.kind === parser_1.RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {
            fragmentDefs.push({
              kind: parser_1.RuleKinds.FRAGMENT_DEFINITION,
              name: {
                kind: graphql_1.Kind.NAME,
                value: state.name
              },
              selectionSet: {
                kind: parser_1.RuleKinds.SELECTION_SET,
                selections: []
              },
              typeCondition: {
                kind: parser_1.RuleKinds.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: state.type
                }
              }
            });
          }
        });
        return fragmentDefs;
      }
      exports.getFragmentDefinitions = getFragmentDefinitions;
      function getSuggestionsForVariableDefinition(token, schema, _kind) {
        const inputTypeMap = schema.getTypeMap();
        const inputTypes = autocompleteUtils_1.objectValues(inputTypeMap).filter(graphql_2.isInputType);
        return autocompleteUtils_1.hintList(token, inputTypes.map((type) => ({
          label: type.name,
          documentation: type.description,
          kind: vscode_languageserver_types_1.CompletionItemKind.Variable
        })));
      }
      function getSuggestionsForDirective(token, state, schema, _kind) {
        if (state.prevState && state.prevState.kind) {
          const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));
          return autocompleteUtils_1.hintList(token, directives.map((directive) => ({
            label: directive.name,
            documentation: directive.description || "",
            kind: vscode_languageserver_types_1.CompletionItemKind.Function
          })));
        }
        return [];
      }
      function getTokenAtPosition(queryText, cursor) {
        let styleAtCursor = null;
        let stateAtCursor = null;
        let stringAtCursor = null;
        const token = runOnlineParser(queryText, (stream, state, style, index) => {
          if (index === cursor.line) {
            if (stream.getCurrentPosition() >= cursor.character) {
              styleAtCursor = style;
              stateAtCursor = Object.assign({}, state);
              stringAtCursor = stream.current();
              return "BREAK";
            }
          }
        });
        return {
          start: token.start,
          end: token.end,
          string: stringAtCursor || token.string,
          state: stateAtCursor || token.state,
          style: styleAtCursor || token.style
        };
      }
      exports.getTokenAtPosition = getTokenAtPosition;
      function runOnlineParser(queryText, callback) {
        const lines = queryText.split("\n");
        const parser = parser_1.onlineParser();
        let state = parser.startState();
        let style = "";
        let stream = new parser_1.CharacterStream("");
        for (let i = 0; i < lines.length; i++) {
          stream = new parser_1.CharacterStream(lines[i]);
          while (!stream.eol()) {
            style = parser.token(stream, state);
            const code = callback(stream, state, style, i);
            if (code === "BREAK") {
              break;
            }
          }
          callback(stream, state, style, i);
          if (!state.kind) {
            state = parser.startState();
          }
        }
        return {
          start: stream.getStartOfToken(),
          end: stream.getCurrentPosition(),
          string: stream.current(),
          state,
          style
        };
      }
      exports.runOnlineParser = runOnlineParser;
      function canUseDirective(state, directive) {
        if (!state || !state.kind) {
          return false;
        }
        const kind = state.kind;
        const locations = directive.locations;
        switch (kind) {
          case parser_1.RuleKinds.QUERY:
            return locations.indexOf(graphql_1.DirectiveLocation.QUERY) !== -1;
          case parser_1.RuleKinds.MUTATION:
            return locations.indexOf(graphql_1.DirectiveLocation.MUTATION) !== -1;
          case parser_1.RuleKinds.SUBSCRIPTION:
            return locations.indexOf(graphql_1.DirectiveLocation.SUBSCRIPTION) !== -1;
          case parser_1.RuleKinds.FIELD:
          case parser_1.RuleKinds.ALIASED_FIELD:
            return locations.indexOf(graphql_1.DirectiveLocation.FIELD) !== -1;
          case parser_1.RuleKinds.FRAGMENT_DEFINITION:
            return locations.indexOf(graphql_1.DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
          case parser_1.RuleKinds.FRAGMENT_SPREAD:
            return locations.indexOf(graphql_1.DirectiveLocation.FRAGMENT_SPREAD) !== -1;
          case parser_1.RuleKinds.INLINE_FRAGMENT:
            return locations.indexOf(graphql_1.DirectiveLocation.INLINE_FRAGMENT) !== -1;
          case parser_1.RuleKinds.SCHEMA_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.SCHEMA) !== -1;
          case parser_1.RuleKinds.SCALAR_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.SCALAR) !== -1;
          case parser_1.RuleKinds.OBJECT_TYPE_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.OBJECT) !== -1;
          case parser_1.RuleKinds.FIELD_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.FIELD_DEFINITION) !== -1;
          case parser_1.RuleKinds.INTERFACE_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.INTERFACE) !== -1;
          case parser_1.RuleKinds.UNION_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.UNION) !== -1;
          case parser_1.RuleKinds.ENUM_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.ENUM) !== -1;
          case parser_1.RuleKinds.ENUM_VALUE:
            return locations.indexOf(graphql_1.DirectiveLocation.ENUM_VALUE) !== -1;
          case parser_1.RuleKinds.INPUT_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.INPUT_OBJECT) !== -1;
          case parser_1.RuleKinds.INPUT_VALUE_DEF:
            const prevStateKind = state.prevState && state.prevState.kind;
            switch (prevStateKind) {
              case parser_1.RuleKinds.ARGUMENTS_DEF:
                return locations.indexOf(graphql_1.DirectiveLocation.ARGUMENT_DEFINITION) !== -1;
              case parser_1.RuleKinds.INPUT_DEF:
                return locations.indexOf(graphql_1.DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;
            }
        }
        return false;
      }
      exports.canUseDirective = canUseDirective;
      function getTypeInfo(schema, tokenState) {
        let argDef;
        let argDefs;
        let directiveDef;
        let enumValue;
        let fieldDef;
        let inputType;
        let objectTypeDef;
        let objectFieldDefs;
        let parentType;
        let type;
        let interfaceDef;
        autocompleteUtils_1.forEachState(tokenState, (state) => {
          switch (state.kind) {
            case parser_1.RuleKinds.QUERY:
            case "ShortQuery":
              type = schema.getQueryType();
              break;
            case parser_1.RuleKinds.MUTATION:
              type = schema.getMutationType();
              break;
            case parser_1.RuleKinds.SUBSCRIPTION:
              type = schema.getSubscriptionType();
              break;
            case parser_1.RuleKinds.INLINE_FRAGMENT:
            case parser_1.RuleKinds.FRAGMENT_DEFINITION:
              if (state.type) {
                type = schema.getType(state.type);
              }
              break;
            case parser_1.RuleKinds.FIELD:
            case parser_1.RuleKinds.ALIASED_FIELD: {
              if (!type || !state.name) {
                fieldDef = null;
              } else {
                fieldDef = parentType ? autocompleteUtils_1.getFieldDef(schema, parentType, state.name) : null;
                type = fieldDef ? fieldDef.type : null;
              }
              break;
            }
            case parser_1.RuleKinds.SELECTION_SET:
              parentType = graphql_2.getNamedType(type);
              break;
            case parser_1.RuleKinds.DIRECTIVE:
              directiveDef = state.name ? schema.getDirective(state.name) : null;
              break;
            case parser_1.RuleKinds.INTERFACE_DEF:
              if (state.name) {
                objectTypeDef = null;
                interfaceDef = new graphql_1.GraphQLInterfaceType({
                  name: state.name,
                  interfaces: [],
                  fields: {}
                });
              }
              break;
            case parser_1.RuleKinds.OBJECT_TYPE_DEF:
              if (state.name) {
                interfaceDef = null;
                objectTypeDef = new graphql_1.GraphQLObjectType({
                  name: state.name,
                  interfaces: [],
                  fields: {}
                });
              }
              break;
            case parser_1.RuleKinds.ARGUMENTS: {
              if (!state.prevState) {
                argDefs = null;
              } else {
                switch (state.prevState.kind) {
                  case parser_1.RuleKinds.FIELD:
                    argDefs = fieldDef && fieldDef.args;
                    break;
                  case parser_1.RuleKinds.DIRECTIVE:
                    argDefs = directiveDef && directiveDef.args;
                    break;
                  case parser_1.RuleKinds.ALIASED_FIELD: {
                    const name = state.prevState && state.prevState.name;
                    if (!name) {
                      argDefs = null;
                      break;
                    }
                    const field = parentType ? autocompleteUtils_1.getFieldDef(schema, parentType, name) : null;
                    if (!field) {
                      argDefs = null;
                      break;
                    }
                    argDefs = field.args;
                    break;
                  }
                  default:
                    argDefs = null;
                    break;
                }
              }
              break;
            }
            case parser_1.RuleKinds.ARGUMENT:
              if (argDefs) {
                for (let i = 0; i < argDefs.length; i++) {
                  if (argDefs[i].name === state.name) {
                    argDef = argDefs[i];
                    break;
                  }
                }
              }
              inputType = argDef && argDef.type;
              break;
            case parser_1.RuleKinds.ENUM_VALUE:
              const enumType = graphql_2.getNamedType(inputType);
              enumValue = enumType instanceof graphql_2.GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;
              break;
            case parser_1.RuleKinds.LIST_VALUE:
              const nullableType = graphql_2.getNullableType(inputType);
              inputType = nullableType instanceof graphql_2.GraphQLList ? nullableType.ofType : null;
              break;
            case parser_1.RuleKinds.OBJECT_VALUE:
              const objectType = graphql_2.getNamedType(inputType);
              objectFieldDefs = objectType instanceof graphql_2.GraphQLInputObjectType ? objectType.getFields() : null;
              break;
            case parser_1.RuleKinds.OBJECT_FIELD:
              const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
              inputType = objectField && objectField.type;
              break;
            case parser_1.RuleKinds.NAMED_TYPE:
              if (state.name) {
                type = schema.getType(state.name);
              }
              break;
          }
        });
        return {
          argDef,
          argDefs,
          directiveDef,
          enumValue,
          fieldDef,
          inputType,
          objectFieldDefs,
          parentType,
          type,
          interfaceDef,
          objectTypeDef
        };
      }
      exports.getTypeInfo = getTypeInfo;
    }
  });

  // ../../node_modules/.pnpm/nullthrows@1.1.1/node_modules/nullthrows/nullthrows.js
  var require_nullthrows = __commonJS({
    "../../node_modules/.pnpm/nullthrows@1.1.1/node_modules/nullthrows/nullthrows.js"(exports, module) {
      "use strict";
      function nullthrows(x, message) {
        if (x != null) {
          return x;
        }
        var error = new Error(message !== void 0 ? message : "Got unexpected " + x);
        error.framesToPop = 1;
        throw error;
      }
      module.exports = nullthrows;
      module.exports.default = nullthrows;
      Object.defineProperty(module.exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/fragmentDependencies.js
  var require_fragmentDependencies = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/fragmentDependencies.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = void 0;
      var graphql_1 = require_graphql2();
      var nullthrows_1 = __importDefault(require_nullthrows());
      var getFragmentDependencies = (operationString, fragmentDefinitions) => {
        if (!fragmentDefinitions) {
          return [];
        }
        let parsedOperation;
        try {
          parsedOperation = graphql_1.parse(operationString);
        } catch (error) {
          return [];
        }
        return exports.getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);
      };
      exports.getFragmentDependencies = getFragmentDependencies;
      var getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {
        if (!fragmentDefinitions) {
          return [];
        }
        const existingFrags = /* @__PURE__ */ new Map();
        const referencedFragNames = /* @__PURE__ */ new Set();
        graphql_1.visit(parsedOperation, {
          FragmentDefinition(node) {
            existingFrags.set(node.name.value, true);
          },
          FragmentSpread(node) {
            if (!referencedFragNames.has(node.name.value)) {
              referencedFragNames.add(node.name.value);
            }
          }
        });
        const asts = /* @__PURE__ */ new Set();
        referencedFragNames.forEach((name) => {
          if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
            asts.add(nullthrows_1.default(fragmentDefinitions.get(name)));
          }
        });
        const referencedFragments = [];
        asts.forEach((ast) => {
          graphql_1.visit(ast, {
            FragmentSpread(node) {
              if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                asts.add(nullthrows_1.default(fragmentDefinitions.get(node.name.value)));
                referencedFragNames.add(node.name.value);
              }
            }
          });
          if (!existingFrags.has(ast.name.value)) {
            referencedFragments.push(ast);
          }
        });
        return referencedFragments;
      };
      exports.getFragmentDependenciesForAST = getFragmentDependenciesForAST;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/getVariablesJSONSchema.js
  var require_getVariablesJSONSchema = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/getVariablesJSONSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getVariablesJSONSchema = exports.defaultJSONSchemaOptions = void 0;
      var graphql_1 = require_graphql2();
      exports.defaultJSONSchemaOptions = {
        useMarkdownDescription: false
      };
      function text(into, newText) {
        into.push(newText);
      }
      function renderType(into, t) {
        if (graphql_1.isNonNullType(t)) {
          renderType(into, t.ofType);
          text(into, "!");
        } else if (graphql_1.isListType(t)) {
          text(into, "[");
          renderType(into, t.ofType);
          text(into, "]");
        } else {
          text(into, t.name);
        }
      }
      function renderTypeToString(t, useMarkdown) {
        const into = [];
        if (useMarkdown) {
          text(into, "```graphql\n");
        }
        renderType(into, t);
        if (useMarkdown) {
          text(into, "\n```");
        }
        return into.join("");
      }
      var scalarTypesMap = {
        Int: "integer",
        String: "string",
        Float: "number",
        ID: "string",
        Boolean: "boolean",
        DateTime: "string"
      };
      function getJSONSchemaFromGraphQLType(type, options) {
        var _a3;
        let required = false;
        let definition = /* @__PURE__ */ Object.create(null);
        const definitions = /* @__PURE__ */ Object.create(null);
        if ("defaultValue" in type && type.defaultValue !== void 0) {
          definition.default = type.defaultValue;
        }
        if (graphql_1.isEnumType(type)) {
          definition.type = "string";
          definition.enum = type.getValues().map((val) => val.name);
        }
        if (graphql_1.isScalarType(type)) {
          definition.type = (_a3 = scalarTypesMap[type.name]) !== null && _a3 !== void 0 ? _a3 : "any";
        }
        if (graphql_1.isListType(type)) {
          definition.type = "array";
          const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type.ofType, options);
          if (def.$ref) {
            definition.items = { $ref: def.$ref };
          } else {
            definition.items = def;
          }
          if (defs) {
            Object.keys(defs).forEach((defName) => {
              definitions[defName] = defs[defName];
            });
          }
        }
        if (graphql_1.isNonNullType(type)) {
          required = true;
          const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type.ofType, options);
          definition = def;
          if (defs) {
            Object.keys(defs).forEach((defName) => {
              definitions[defName] = defs[defName];
            });
          }
        }
        if (graphql_1.isInputObjectType(type)) {
          definition.$ref = `#/definitions/${type.name}`;
          const fields = type.getFields();
          const fieldDef = {
            type: "object",
            properties: {},
            required: []
          };
          if (type.description) {
            fieldDef.description = type.description + `
` + renderTypeToString(type);
            if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
              fieldDef.markdownDescription = type.description + `
` + renderTypeToString(type, true);
            }
          } else {
            fieldDef.description = renderTypeToString(type);
            if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
              fieldDef.markdownDescription = renderTypeToString(type, true);
            }
          }
          Object.keys(fields).forEach((fieldName) => {
            const field = fields[fieldName];
            const { required: fieldRequired, definition: typeDefinition, definitions: typeDefinitions } = getJSONSchemaFromGraphQLType(field.type, options);
            const { definition: fieldDefinition } = getJSONSchemaFromGraphQLType(field, options);
            fieldDef.properties[fieldName] = Object.assign(Object.assign({}, typeDefinition), fieldDefinition);
            const renderedField = renderTypeToString(field.type);
            fieldDef.properties[fieldName].description = field.description ? field.description + "\n" + renderedField : renderedField;
            if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
              const renderedFieldMarkdown = renderTypeToString(field.type, true);
              fieldDef.properties[fieldName].markdownDescription = field.description ? field.description + "\n" + renderedFieldMarkdown : renderedFieldMarkdown;
            }
            if (fieldRequired) {
              fieldDef.required.push(fieldName);
            }
            if (typeDefinitions) {
              Object.keys(typeDefinitions).map((defName) => {
                definitions[defName] = typeDefinitions[defName];
              });
            }
          });
          definitions[type.name] = fieldDef;
        }
        if ("description" in type && !graphql_1.isScalarType(type) && type.description && !definition.description) {
          definition.description = type.description + "\n" + renderTypeToString(type);
          if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
            definition.markdownDescription = type.description + "\n" + renderTypeToString(type, true);
          }
        } else {
          definition.description = renderTypeToString(type);
          if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
            definition.markdownDescription = renderTypeToString(type, true);
          }
        }
        return { required, definition, definitions };
      }
      function getVariablesJSONSchema(variableToType, options) {
        const jsonSchema = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          type: "object",
          properties: {},
          required: []
        };
        if (variableToType) {
          Object.entries(variableToType).forEach(([variableName, type]) => {
            var _a3;
            const { definition, required, definitions } = getJSONSchemaFromGraphQLType(type, options);
            jsonSchema.properties[variableName] = definition;
            if (required) {
              (_a3 = jsonSchema.required) === null || _a3 === void 0 ? void 0 : _a3.push(variableName);
            }
            if (definitions) {
              jsonSchema.definitions = Object.assign(Object.assign({}, jsonSchema === null || jsonSchema === void 0 ? void 0 : jsonSchema.definitions), definitions);
            }
          });
        }
        return jsonSchema;
      }
      exports.getVariablesJSONSchema = getVariablesJSONSchema;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/getASTNodeAtPosition.js
  var require_getASTNodeAtPosition = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/getASTNodeAtPosition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pointToOffset = exports.getASTNodeAtPosition = void 0;
      var graphql_1 = require_graphql2();
      function getASTNodeAtPosition(query, ast, point) {
        const offset = pointToOffset(query, point);
        let nodeContainingPosition;
        graphql_1.visit(ast, {
          enter(node) {
            if (node.kind !== "Name" && node.loc && node.loc.start <= offset && offset <= node.loc.end) {
              nodeContainingPosition = node;
            } else {
              return false;
            }
          },
          leave(node) {
            if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {
              return false;
            }
          }
        });
        return nodeContainingPosition;
      }
      exports.getASTNodeAtPosition = getASTNodeAtPosition;
      function pointToOffset(text, point) {
        const linesUntilPosition = text.split("\n").slice(0, point.line);
        return point.character + linesUntilPosition.map((line) => line.length + 1).reduce((a, b) => a + b, 0);
      }
      exports.pointToOffset = pointToOffset;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/Range.js
  var require_Range = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/Range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.locToRange = exports.offsetToPosition = exports.Position = exports.Range = void 0;
      var Range2 = class {
        constructor(start, end) {
          this.containsPosition = (position) => {
            if (this.start.line === position.line) {
              return this.start.character <= position.character;
            } else if (this.end.line === position.line) {
              return this.end.character >= position.character;
            } else {
              return this.start.line <= position.line && this.end.line >= position.line;
            }
          };
          this.start = start;
          this.end = end;
        }
        setStart(line, character) {
          this.start = new Position2(line, character);
        }
        setEnd(line, character) {
          this.end = new Position2(line, character);
        }
      };
      exports.Range = Range2;
      var Position2 = class {
        constructor(line, character) {
          this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;
          this.line = line;
          this.character = character;
        }
        setLine(line) {
          this.line = line;
        }
        setCharacter(character) {
          this.character = character;
        }
      };
      exports.Position = Position2;
      function offsetToPosition(text, loc) {
        const EOL = "\n";
        const buf = text.slice(0, loc);
        const lines = buf.split(EOL).length - 1;
        const lastLineIndex = buf.lastIndexOf(EOL);
        return new Position2(lines, loc - lastLineIndex - 1);
      }
      exports.offsetToPosition = offsetToPosition;
      function locToRange(text, loc) {
        const start = offsetToPosition(text, loc.start);
        const end = offsetToPosition(text, loc.end);
        return new Range2(start, end);
      }
      exports.locToRange = locToRange;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/validateWithCustomRules.js
  var require_validateWithCustomRules = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/validateWithCustomRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateWithCustomRules = void 0;
      var graphql_1 = require_graphql2();
      var specifiedSDLRules = [
        graphql_1.LoneSchemaDefinitionRule,
        graphql_1.UniqueOperationTypesRule,
        graphql_1.UniqueTypeNamesRule,
        graphql_1.UniqueEnumValueNamesRule,
        graphql_1.UniqueFieldDefinitionNamesRule,
        graphql_1.UniqueDirectiveNamesRule,
        graphql_1.KnownTypeNamesRule,
        graphql_1.KnownDirectivesRule,
        graphql_1.UniqueDirectivesPerLocationRule,
        graphql_1.PossibleTypeExtensionsRule,
        graphql_1.UniqueArgumentNamesRule,
        graphql_1.UniqueInputFieldNamesRule
      ];
      function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {
        const rules = graphql_1.specifiedRules.filter((rule) => {
          if (rule === graphql_1.NoUnusedFragmentsRule || rule === graphql_1.ExecutableDefinitionsRule) {
            return false;
          }
          if (isRelayCompatMode && rule === graphql_1.KnownFragmentNamesRule) {
            return false;
          }
          return true;
        });
        if (customRules) {
          Array.prototype.push.apply(rules, customRules);
        }
        if (isSchemaDocument) {
          Array.prototype.push.apply(rules, specifiedSDLRules);
        }
        const errors = graphql_1.validate(schema, ast, rules);
        return errors.filter((error) => {
          if (error.message.indexOf("Unknown directive") !== -1 && error.nodes) {
            const node = error.nodes[0];
            if (node && node.kind === graphql_1.Kind.DIRECTIVE) {
              const name = node.name.value;
              if (name === "arguments" || name === "argumentDefinitions") {
                return false;
              }
            }
          }
          return true;
        });
      }
      exports.validateWithCustomRules = validateWithCustomRules;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/collectVariables.js
  var require_collectVariables = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/collectVariables.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.collectVariables = void 0;
      var graphql_1 = require_graphql2();
      function collectVariables(schema, documentAST) {
        const variableToType = /* @__PURE__ */ Object.create(null);
        documentAST.definitions.forEach((definition) => {
          if (definition.kind === "OperationDefinition") {
            const variableDefinitions = definition.variableDefinitions;
            if (variableDefinitions) {
              variableDefinitions.forEach(({ variable, type }) => {
                const inputType = graphql_1.typeFromAST(schema, type);
                if (inputType) {
                  variableToType[variable.name.value] = inputType;
                } else if (type.kind === graphql_1.Kind.NAMED_TYPE) {
                  if (type.name.value === "Float") {
                    variableToType[variable.name.value] = graphql_1.GraphQLFloat;
                  }
                }
              });
            }
          }
        });
        return variableToType;
      }
      exports.collectVariables = collectVariables;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/getOperationFacts.js
  var require_getOperationFacts = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/getOperationFacts.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getQueryFacts = exports.getOperationASTFacts = void 0;
      var graphql_1 = require_graphql2();
      var collectVariables_1 = require_collectVariables();
      function getOperationASTFacts(documentAST, schema) {
        const variableToType = schema ? collectVariables_1.collectVariables(schema, documentAST) : void 0;
        const operations = [];
        graphql_1.visit(documentAST, {
          OperationDefinition(node) {
            operations.push(node);
          }
        });
        return { variableToType, operations };
      }
      exports.getOperationASTFacts = getOperationASTFacts;
      function getOperationFacts(schema, documentString) {
        if (!documentString) {
          return;
        }
        try {
          const documentAST = graphql_1.parse(documentString);
          return Object.assign(Object.assign({}, getOperationASTFacts(documentAST, schema)), { documentAST });
        } catch (_a3) {
          return;
        }
      }
      exports.default = getOperationFacts;
      exports.getQueryFacts = getOperationFacts;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/index.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/utils/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getQueryFacts = exports.getOperationASTFacts = exports.getOperationFacts = exports.collectVariables = exports.validateWithCustomRules = exports.offsetToPosition = exports.locToRange = exports.Range = exports.Position = exports.pointToOffset = exports.getASTNodeAtPosition = exports.getVariablesJSONSchema = exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = void 0;
      var fragmentDependencies_1 = require_fragmentDependencies();
      Object.defineProperty(exports, "getFragmentDependencies", { enumerable: true, get: function() {
        return fragmentDependencies_1.getFragmentDependencies;
      } });
      Object.defineProperty(exports, "getFragmentDependenciesForAST", { enumerable: true, get: function() {
        return fragmentDependencies_1.getFragmentDependenciesForAST;
      } });
      var getVariablesJSONSchema_1 = require_getVariablesJSONSchema();
      Object.defineProperty(exports, "getVariablesJSONSchema", { enumerable: true, get: function() {
        return getVariablesJSONSchema_1.getVariablesJSONSchema;
      } });
      var getASTNodeAtPosition_1 = require_getASTNodeAtPosition();
      Object.defineProperty(exports, "getASTNodeAtPosition", { enumerable: true, get: function() {
        return getASTNodeAtPosition_1.getASTNodeAtPosition;
      } });
      Object.defineProperty(exports, "pointToOffset", { enumerable: true, get: function() {
        return getASTNodeAtPosition_1.pointToOffset;
      } });
      var Range_1 = require_Range();
      Object.defineProperty(exports, "Position", { enumerable: true, get: function() {
        return Range_1.Position;
      } });
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return Range_1.Range;
      } });
      Object.defineProperty(exports, "locToRange", { enumerable: true, get: function() {
        return Range_1.locToRange;
      } });
      Object.defineProperty(exports, "offsetToPosition", { enumerable: true, get: function() {
        return Range_1.offsetToPosition;
      } });
      var validateWithCustomRules_1 = require_validateWithCustomRules();
      Object.defineProperty(exports, "validateWithCustomRules", { enumerable: true, get: function() {
        return validateWithCustomRules_1.validateWithCustomRules;
      } });
      var collectVariables_1 = require_collectVariables();
      Object.defineProperty(exports, "collectVariables", { enumerable: true, get: function() {
        return collectVariables_1.collectVariables;
      } });
      var getOperationFacts_1 = require_getOperationFacts();
      Object.defineProperty(exports, "getOperationFacts", { enumerable: true, get: function() {
        return __importDefault(getOperationFacts_1).default;
      } });
      Object.defineProperty(exports, "getOperationASTFacts", { enumerable: true, get: function() {
        return getOperationFacts_1.getOperationASTFacts;
      } });
      Object.defineProperty(exports, "getQueryFacts", { enumerable: true, get: function() {
        return getOperationFacts_1.getQueryFacts;
      } });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getDefinition.js
  var require_getDefinition = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getDefinition.js"(exports) {
      "use strict";
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDefinitionQueryResultForDefinitionNode = exports.getDefinitionQueryResultForFragmentSpread = exports.getDefinitionQueryResultForNamedType = exports.LANGUAGE = void 0;
      var utils_1 = require_utils();
      exports.LANGUAGE = "GraphQL";
      function assert(value, message) {
        if (!value) {
          throw new Error(message);
        }
      }
      function getRange(text, node) {
        const location = node.loc;
        assert(location, "Expected ASTNode to have a location.");
        return utils_1.locToRange(text, location);
      }
      function getPosition(text, node) {
        const location = node.loc;
        assert(location, "Expected ASTNode to have a location.");
        return utils_1.offsetToPosition(text, location.start);
      }
      function getDefinitionQueryResultForNamedType(text, node, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const name = node.name.value;
          const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name);
          if (defNodes.length === 0) {
            throw Error(`Definition not found for GraphQL type ${name}`);
          }
          const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || "", content, definition));
          return {
            definitions,
            queryRange: definitions.map((_) => getRange(text, node))
          };
        });
      }
      exports.getDefinitionQueryResultForNamedType = getDefinitionQueryResultForNamedType;
      function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const name = fragment.name.value;
          const defNodes = dependencies.filter(({ definition }) => definition.name.value === name);
          if (defNodes.length === 0) {
            throw Error(`Definition not found for GraphQL fragment ${name}`);
          }
          const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || "", content, definition));
          return {
            definitions,
            queryRange: definitions.map((_) => getRange(text, fragment))
          };
        });
      }
      exports.getDefinitionQueryResultForFragmentSpread = getDefinitionQueryResultForFragmentSpread;
      function getDefinitionQueryResultForDefinitionNode(path, text, definition) {
        return {
          definitions: [getDefinitionForFragmentDefinition(path, text, definition)],
          queryRange: definition.name ? [getRange(text, definition.name)] : []
        };
      }
      exports.getDefinitionQueryResultForDefinitionNode = getDefinitionQueryResultForDefinitionNode;
      function getDefinitionForFragmentDefinition(path, text, definition) {
        const name = definition.name;
        if (!name) {
          throw Error("Expected ASTNode to have a Name.");
        }
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
      function getDefinitionForNodeDefinition(path, text, definition) {
        const name = definition.name;
        assert(name, "Expected ASTNode to have a Name.");
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getDiagnostics.js
  var require_getDiagnostics = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getDiagnostics.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRange = exports.validateQuery = exports.getDiagnostics = exports.DIAGNOSTIC_SEVERITY = exports.SEVERITY = void 0;
      var graphql_1 = require_graphql2();
      var graphql_2 = require_graphql2();
      var parser_1 = require_parser2();
      var utils_1 = require_utils();
      exports.SEVERITY = {
        Error: "Error",
        Warning: "Warning",
        Information: "Information",
        Hint: "Hint"
      };
      exports.DIAGNOSTIC_SEVERITY = {
        [exports.SEVERITY.Error]: 1,
        [exports.SEVERITY.Warning]: 2,
        [exports.SEVERITY.Information]: 3,
        [exports.SEVERITY.Hint]: 4
      };
      var invariant = (condition, message) => {
        if (!condition) {
          throw new Error(message);
        }
      };
      function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {
        let ast = null;
        if (externalFragments) {
          if (typeof externalFragments === "string") {
            query += "\n\n" + externalFragments;
          } else {
            query += "\n\n" + externalFragments.reduce((agg, node) => {
              agg += graphql_1.print(node) + "\n\n";
              return agg;
            }, "");
          }
        }
        try {
          ast = graphql_2.parse(query);
        } catch (error) {
          const range = getRange(error.locations[0], query);
          return [
            {
              severity: exports.DIAGNOSTIC_SEVERITY.Error,
              message: error.message,
              source: "GraphQL: Syntax",
              range
            }
          ];
        }
        return validateQuery(ast, schema, customRules, isRelayCompatMode);
      }
      exports.getDiagnostics = getDiagnostics;
      function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {
        if (!schema) {
          return [];
        }
        const validationErrorAnnotations = mapCat(utils_1.validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, exports.DIAGNOSTIC_SEVERITY.Error, "Validation"));
        const deprecationWarningAnnotations = mapCat(graphql_1.validate(schema, ast, [graphql_1.NoDeprecatedCustomRule]), (error) => annotations(error, exports.DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));
        return validationErrorAnnotations.concat(deprecationWarningAnnotations);
      }
      exports.validateQuery = validateQuery;
      function mapCat(array, mapper) {
        return Array.prototype.concat.apply([], array.map(mapper));
      }
      function annotations(error, severity, type) {
        if (!error.nodes) {
          return [];
        }
        const highlightedNodes = [];
        error.nodes.forEach((node) => {
          const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;
          if (highlightNode) {
            invariant(error.locations, "GraphQL validation error requires locations.");
            const loc = error.locations[0];
            const highlightLoc = getLocation(highlightNode);
            const end = loc.column + (highlightLoc.end - highlightLoc.start);
            highlightedNodes.push({
              source: `GraphQL: ${type}`,
              message: error.message,
              severity,
              range: new utils_1.Range(new utils_1.Position(loc.line - 1, loc.column - 1), new utils_1.Position(loc.line - 1, end))
            });
          }
        });
        return highlightedNodes;
      }
      function getRange(location, queryText) {
        const parser = parser_1.onlineParser();
        const state = parser.startState();
        const lines = queryText.split("\n");
        invariant(lines.length >= location.line, "Query text must have more lines than where the error happened");
        let stream = null;
        for (let i = 0; i < location.line; i++) {
          stream = new parser_1.CharacterStream(lines[i]);
          while (!stream.eol()) {
            const style = parser.token(stream, state);
            if (style === "invalidchar") {
              break;
            }
          }
        }
        invariant(stream, "Expected Parser stream to be available.");
        const line = location.line - 1;
        const start = stream.getStartOfToken();
        const end = stream.getCurrentPosition();
        return new utils_1.Range(new utils_1.Position(line, start), new utils_1.Position(line, end));
      }
      exports.getRange = getRange;
      function getLocation(node) {
        const typeCastedNode = node;
        const location = typeCastedNode.loc;
        invariant(location, "Expected ASTNode to have a location.");
        return location;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getOutline.js
  var require_getOutline = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getOutline.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOutline = void 0;
      var graphql_1 = require_graphql2();
      var utils_1 = require_utils();
      var { INLINE_FRAGMENT } = graphql_1.Kind;
      function getOutline(documentText) {
        let ast;
        try {
          ast = graphql_1.parse(documentText);
        } catch (error) {
          return null;
        }
        const visitorFns = outlineTreeConverter(documentText);
        const outlineTrees = graphql_1.visit(ast, {
          leave(node) {
            if (visitorFns !== void 0 && node.kind in visitorFns) {
              return visitorFns[node.kind](node);
            }
            return null;
          }
        });
        return { outlineTrees };
      }
      exports.getOutline = getOutline;
      function outlineTreeConverter(docText) {
        const meta = (node) => {
          return {
            representativeName: node.name,
            startPosition: utils_1.offsetToPosition(docText, node.loc.start),
            endPosition: utils_1.offsetToPosition(docText, node.loc.end),
            kind: node.kind,
            children: node.selectionSet || node.fields || node.values || node.arguments || []
          };
        };
        return {
          Field: (node) => {
            const tokenizedText = node.alias ? [buildToken("plain", node.alias), buildToken("plain", ": ")] : [];
            tokenizedText.push(buildToken("plain", node.name));
            return Object.assign({ tokenizedText }, meta(node));
          },
          OperationDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", node.operation),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          Document: (node) => node.definitions,
          SelectionSet: (node) => concatMap(node.selections, (child) => {
            return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;
          }),
          Name: (node) => node.value,
          FragmentDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "fragment"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InterfaceTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "interface"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          EnumTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "enum"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          EnumValueDefinition: (node) => Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node)),
          ObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "type"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InputObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "input"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          FragmentSpread: (node) => Object.assign({ tokenizedText: [
            buildToken("plain", "..."),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InputValueDefinition: (node) => {
            return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
          },
          FieldDefinition: (node) => {
            return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
          },
          InlineFragment: (node) => node.selectionSet
        };
      }
      function buildToken(kind, value) {
        return { kind, value };
      }
      function concatMap(arr, fn) {
        const res = [];
        for (let i = 0; i < arr.length; i++) {
          const x = fn(arr[i], i);
          if (Array.isArray(x)) {
            res.push(...x);
          } else {
            res.push(x);
          }
        }
        return res;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getHoverInformation.js
  var require_getHoverInformation = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/getHoverInformation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHoverInformation = void 0;
      var graphql_1 = require_graphql2();
      var getAutocompleteSuggestions_1 = require_getAutocompleteSuggestions();
      function getHoverInformation(schema, queryText, cursor, contextToken, config) {
        const token = contextToken || getAutocompleteSuggestions_1.getTokenAtPosition(queryText, cursor);
        if (!schema || !token || !token.state) {
          return "";
        }
        const state = token.state;
        const kind = state.kind;
        const step = state.step;
        const typeInfo = getAutocompleteSuggestions_1.getTypeInfo(schema, token.state);
        const options = Object.assign(Object.assign({}, config), { schema });
        if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderField(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.fieldDef);
          return into.join("").trim();
        } else if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderDirective(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.directiveDef);
          return into.join("").trim();
        } else if (kind === "Argument" && step === 0 && typeInfo.argDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderArg(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.argDef);
          return into.join("").trim();
        } else if (kind === "EnumValue" && typeInfo.enumValue && "description" in typeInfo.enumValue) {
          const into = [];
          renderMdCodeStart(into, options);
          renderEnumValue(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.enumValue);
          return into.join("").trim();
        } else if (kind === "NamedType" && typeInfo.type && "description" in typeInfo.type) {
          const into = [];
          renderMdCodeStart(into, options);
          renderType(into, typeInfo, options, typeInfo.type);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.type);
          return into.join("").trim();
        }
        return "";
      }
      exports.getHoverInformation = getHoverInformation;
      function renderMdCodeStart(into, options) {
        if (options.useMarkdown) {
          text(into, "```graphql\n");
        }
      }
      function renderMdCodeEnd(into, options) {
        if (options.useMarkdown) {
          text(into, "\n```");
        }
      }
      function renderField(into, typeInfo, options) {
        renderQualifiedField(into, typeInfo, options);
        renderTypeAnnotation(into, typeInfo, options, typeInfo.type);
      }
      function renderQualifiedField(into, typeInfo, options) {
        if (!typeInfo.fieldDef) {
          return;
        }
        const fieldName = typeInfo.fieldDef.name;
        if (fieldName.slice(0, 2) !== "__") {
          renderType(into, typeInfo, options, typeInfo.parentType);
          text(into, ".");
        }
        text(into, fieldName);
      }
      function renderDirective(into, typeInfo, _options) {
        if (!typeInfo.directiveDef) {
          return;
        }
        const name = "@" + typeInfo.directiveDef.name;
        text(into, name);
      }
      function renderArg(into, typeInfo, options) {
        if (typeInfo.directiveDef) {
          renderDirective(into, typeInfo, options);
        } else if (typeInfo.fieldDef) {
          renderQualifiedField(into, typeInfo, options);
        }
        if (!typeInfo.argDef) {
          return;
        }
        const name = typeInfo.argDef.name;
        text(into, "(");
        text(into, name);
        renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);
        text(into, ")");
      }
      function renderTypeAnnotation(into, typeInfo, options, t) {
        text(into, ": ");
        renderType(into, typeInfo, options, t);
      }
      function renderEnumValue(into, typeInfo, options) {
        if (!typeInfo.enumValue) {
          return;
        }
        const name = typeInfo.enumValue.name;
        renderType(into, typeInfo, options, typeInfo.inputType);
        text(into, ".");
        text(into, name);
      }
      function renderType(into, typeInfo, options, t) {
        if (!t) {
          return;
        }
        if (t instanceof graphql_1.GraphQLNonNull) {
          renderType(into, typeInfo, options, t.ofType);
          text(into, "!");
        } else if (t instanceof graphql_1.GraphQLList) {
          text(into, "[");
          renderType(into, typeInfo, options, t.ofType);
          text(into, "]");
        } else {
          text(into, t.name);
        }
      }
      function renderDescription(into, options, def) {
        if (!def) {
          return;
        }
        const description = typeof def.description === "string" ? def.description : null;
        if (description) {
          text(into, "\n\n");
          text(into, description);
        }
        renderDeprecation(into, options, def);
      }
      function renderDeprecation(into, _options, def) {
        if (!def) {
          return;
        }
        const reason = def.deprecationReason ? def.deprecationReason : null;
        if (!reason) {
          return;
        }
        text(into, "\n\n");
        text(into, "Deprecated: ");
        text(into, reason);
      }
      function text(into, content) {
        into.push(content);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/index.js
  var require_interface = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/interface/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHoverInformation = exports.getOutline = void 0;
      __exportStar(require_autocompleteUtils(), exports);
      __exportStar(require_getAutocompleteSuggestions(), exports);
      __exportStar(require_getDefinition(), exports);
      __exportStar(require_getDiagnostics(), exports);
      var getOutline_1 = require_getOutline();
      Object.defineProperty(exports, "getOutline", { enumerable: true, get: function() {
        return getOutline_1.getOutline;
      } });
      var getHoverInformation_1 = require_getHoverInformation();
      Object.defineProperty(exports, "getHoverInformation", { enumerable: true, get: function() {
        return getHoverInformation_1.getHoverInformation;
      } });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/types.js
  var require_types2 = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompletionItemKind = exports.FileChangeTypeKind = void 0;
      exports.FileChangeTypeKind = {
        Created: 1,
        Changed: 2,
        Deleted: 3
      };
      var CompletionItemKind2;
      (function(CompletionItemKind3) {
        CompletionItemKind3.Text = 1;
        CompletionItemKind3.Method = 2;
        CompletionItemKind3.Function = 3;
        CompletionItemKind3.Constructor = 4;
        CompletionItemKind3.Field = 5;
        CompletionItemKind3.Variable = 6;
        CompletionItemKind3.Class = 7;
        CompletionItemKind3.Interface = 8;
        CompletionItemKind3.Module = 9;
        CompletionItemKind3.Property = 10;
        CompletionItemKind3.Unit = 11;
        CompletionItemKind3.Value = 12;
        CompletionItemKind3.Enum = 13;
        CompletionItemKind3.Keyword = 14;
        CompletionItemKind3.Snippet = 15;
        CompletionItemKind3.Color = 16;
        CompletionItemKind3.File = 17;
        CompletionItemKind3.Reference = 18;
        CompletionItemKind3.Folder = 19;
        CompletionItemKind3.EnumMember = 20;
        CompletionItemKind3.Constant = 21;
        CompletionItemKind3.Struct = 22;
        CompletionItemKind3.Event = 23;
        CompletionItemKind3.Operator = 24;
        CompletionItemKind3.TypeParameter = 25;
      })(CompletionItemKind2 = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.4_graphql@16.5.0/node_modules/graphql-language-service/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Range = exports.validateWithCustomRules = exports.collectVariables = exports.Position = exports.pointToOffset = exports.offsetToPosition = exports.getVariablesJSONSchema = exports.getQueryFacts = exports.getOperationFacts = exports.getOperationASTFacts = exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = exports.getASTNodeAtPosition = exports.FileChangeTypeKind = exports.CompletionItemKind = exports.opt = exports.t = exports.list = exports.p = exports.isIgnored = exports.LexRules = exports.RuleKinds = exports.CharacterStream = exports.ParseRules = exports.onlineParser = exports.validateQuery = exports.SuggestionCommand = exports.canUseDirective = exports.DIAGNOSTIC_SEVERITY = exports.SEVERITY = exports.getVariableCompletions = exports.getTypeInfo = exports.getTokenAtPosition = exports.getRange = exports.getOutline = exports.getHoverInformation = exports.getFragmentDefinitions = exports.getFieldDef = exports.getDiagnostics = exports.getDefinitionState = exports.getDefinitionQueryResultForNamedType = exports.getDefinitionQueryResultForFragmentSpread = exports.getDefinitionQueryResultForDefinitionNode = exports.getAutocompleteSuggestions = void 0;
      var interface_1 = require_interface();
      Object.defineProperty(exports, "getAutocompleteSuggestions", { enumerable: true, get: function() {
        return interface_1.getAutocompleteSuggestions;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForDefinitionNode", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForDefinitionNode;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForFragmentSpread", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForFragmentSpread;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForNamedType", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForNamedType;
      } });
      Object.defineProperty(exports, "getDefinitionState", { enumerable: true, get: function() {
        return interface_1.getDefinitionState;
      } });
      Object.defineProperty(exports, "getDiagnostics", { enumerable: true, get: function() {
        return interface_1.getDiagnostics;
      } });
      Object.defineProperty(exports, "getFieldDef", { enumerable: true, get: function() {
        return interface_1.getFieldDef;
      } });
      Object.defineProperty(exports, "getFragmentDefinitions", { enumerable: true, get: function() {
        return interface_1.getFragmentDefinitions;
      } });
      Object.defineProperty(exports, "getHoverInformation", { enumerable: true, get: function() {
        return interface_1.getHoverInformation;
      } });
      Object.defineProperty(exports, "getOutline", { enumerable: true, get: function() {
        return interface_1.getOutline;
      } });
      Object.defineProperty(exports, "getRange", { enumerable: true, get: function() {
        return interface_1.getRange;
      } });
      Object.defineProperty(exports, "getTokenAtPosition", { enumerable: true, get: function() {
        return interface_1.getTokenAtPosition;
      } });
      Object.defineProperty(exports, "getTypeInfo", { enumerable: true, get: function() {
        return interface_1.getTypeInfo;
      } });
      Object.defineProperty(exports, "getVariableCompletions", { enumerable: true, get: function() {
        return interface_1.getVariableCompletions;
      } });
      Object.defineProperty(exports, "SEVERITY", { enumerable: true, get: function() {
        return interface_1.SEVERITY;
      } });
      Object.defineProperty(exports, "DIAGNOSTIC_SEVERITY", { enumerable: true, get: function() {
        return interface_1.DIAGNOSTIC_SEVERITY;
      } });
      Object.defineProperty(exports, "canUseDirective", { enumerable: true, get: function() {
        return interface_1.canUseDirective;
      } });
      Object.defineProperty(exports, "SuggestionCommand", { enumerable: true, get: function() {
        return interface_1.SuggestionCommand;
      } });
      Object.defineProperty(exports, "validateQuery", { enumerable: true, get: function() {
        return interface_1.validateQuery;
      } });
      var parser_1 = require_parser2();
      Object.defineProperty(exports, "onlineParser", { enumerable: true, get: function() {
        return parser_1.onlineParser;
      } });
      Object.defineProperty(exports, "ParseRules", { enumerable: true, get: function() {
        return parser_1.ParseRules;
      } });
      Object.defineProperty(exports, "CharacterStream", { enumerable: true, get: function() {
        return parser_1.CharacterStream;
      } });
      Object.defineProperty(exports, "RuleKinds", { enumerable: true, get: function() {
        return parser_1.RuleKinds;
      } });
      Object.defineProperty(exports, "LexRules", { enumerable: true, get: function() {
        return parser_1.LexRules;
      } });
      Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
        return parser_1.isIgnored;
      } });
      Object.defineProperty(exports, "p", { enumerable: true, get: function() {
        return parser_1.p;
      } });
      Object.defineProperty(exports, "list", { enumerable: true, get: function() {
        return parser_1.list;
      } });
      Object.defineProperty(exports, "t", { enumerable: true, get: function() {
        return parser_1.t;
      } });
      Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
        return parser_1.opt;
      } });
      var types_1 = require_types2();
      Object.defineProperty(exports, "CompletionItemKind", { enumerable: true, get: function() {
        return types_1.CompletionItemKind;
      } });
      Object.defineProperty(exports, "FileChangeTypeKind", { enumerable: true, get: function() {
        return types_1.FileChangeTypeKind;
      } });
      var utils_1 = require_utils();
      Object.defineProperty(exports, "getASTNodeAtPosition", { enumerable: true, get: function() {
        return utils_1.getASTNodeAtPosition;
      } });
      Object.defineProperty(exports, "getFragmentDependencies", { enumerable: true, get: function() {
        return utils_1.getFragmentDependencies;
      } });
      Object.defineProperty(exports, "getFragmentDependenciesForAST", { enumerable: true, get: function() {
        return utils_1.getFragmentDependenciesForAST;
      } });
      Object.defineProperty(exports, "getOperationASTFacts", { enumerable: true, get: function() {
        return utils_1.getOperationASTFacts;
      } });
      Object.defineProperty(exports, "getOperationFacts", { enumerable: true, get: function() {
        return utils_1.getOperationFacts;
      } });
      Object.defineProperty(exports, "getQueryFacts", { enumerable: true, get: function() {
        return utils_1.getQueryFacts;
      } });
      Object.defineProperty(exports, "getVariablesJSONSchema", { enumerable: true, get: function() {
        return utils_1.getVariablesJSONSchema;
      } });
      Object.defineProperty(exports, "offsetToPosition", { enumerable: true, get: function() {
        return utils_1.offsetToPosition;
      } });
      Object.defineProperty(exports, "pointToOffset", { enumerable: true, get: function() {
        return utils_1.pointToOffset;
      } });
      Object.defineProperty(exports, "Position", { enumerable: true, get: function() {
        return utils_1.Position;
      } });
      Object.defineProperty(exports, "collectVariables", { enumerable: true, get: function() {
        return utils_1.collectVariables;
      } });
      Object.defineProperty(exports, "validateWithCustomRules", { enumerable: true, get: function() {
        return utils_1.validateWithCustomRules;
      } });
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return utils_1.Range;
      } });
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/constants.js"(exports, module) {
      "use strict";
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var SEP = "/";
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR,
        SEP
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
        SEP: "\\"
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        CHAR_0: 48,
        CHAR_9: 57,
        CHAR_UPPERCASE_A: 65,
        CHAR_LOWERCASE_A: 97,
        CHAR_UPPERCASE_Z: 90,
        CHAR_LOWERCASE_Z: 122,
        CHAR_LEFT_PARENTHESES: 40,
        CHAR_RIGHT_PARENTHESES: 41,
        CHAR_ASTERISK: 42,
        CHAR_AMPERSAND: 38,
        CHAR_AT: 64,
        CHAR_BACKWARD_SLASH: 92,
        CHAR_CARRIAGE_RETURN: 13,
        CHAR_CIRCUMFLEX_ACCENT: 94,
        CHAR_COLON: 58,
        CHAR_COMMA: 44,
        CHAR_DOT: 46,
        CHAR_DOUBLE_QUOTE: 34,
        CHAR_EQUAL: 61,
        CHAR_EXCLAMATION_MARK: 33,
        CHAR_FORM_FEED: 12,
        CHAR_FORWARD_SLASH: 47,
        CHAR_GRAVE_ACCENT: 96,
        CHAR_HASH: 35,
        CHAR_HYPHEN_MINUS: 45,
        CHAR_LEFT_ANGLE_BRACKET: 60,
        CHAR_LEFT_CURLY_BRACE: 123,
        CHAR_LEFT_SQUARE_BRACKET: 91,
        CHAR_LINE_FEED: 10,
        CHAR_NO_BREAK_SPACE: 160,
        CHAR_PERCENT: 37,
        CHAR_PLUS: 43,
        CHAR_QUESTION_MARK: 63,
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        CHAR_RIGHT_CURLY_BRACE: 125,
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        CHAR_SEMICOLON: 59,
        CHAR_SINGLE_QUOTE: 39,
        CHAR_SPACE: 32,
        CHAR_TAB: 9,
        CHAR_UNDERSCORE: 95,
        CHAR_VERTICAL_LINE: 124,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/utils.js"(exports) {
      "use strict";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
      exports.basename = (path, { windows } = {}) => {
        if (windows) {
          return path.replace(/[\\/]$/, "").replace(/.*[\\/]/, "");
        } else {
          return path.replace(/\/$/, "").replace(/.*\//, "");
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/scan.js
  var require_scan = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/scan.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var {
        CHAR_ASTERISK,
        CHAR_AT,
        CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
        CHAR_COMMA,
        CHAR_DOT: CHAR_DOT2,
        CHAR_EXCLAMATION_MARK,
        CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
        CHAR_LEFT_CURLY_BRACE,
        CHAR_LEFT_PARENTHESES,
        CHAR_LEFT_SQUARE_BRACKET,
        CHAR_PLUS,
        CHAR_QUESTION_MARK: CHAR_QUESTION_MARK2,
        CHAR_RIGHT_CURLY_BRACE,
        CHAR_RIGHT_PARENTHESES,
        CHAR_RIGHT_SQUARE_BRACKET
      } = require_constants();
      var isPathSeparator2 = (code) => {
        return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH2) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT2 && (code = advance()) === CHAR_DOT2) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH2) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT2 && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH2) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK2) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
            }
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator2(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob)
            glob = utils.removeBackslashes(glob);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator2(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module.exports = scan;
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/parse.js
  var require_parse = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/parse.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var utils = require_utils2();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      };
      var syntaxError = (type, char) => {
        return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const PLATFORM_CHARS = constants.globChars(opts.windows);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index];
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type) => {
          state[type]++;
          stack.push(type);
        };
        const decrement = (type) => {
          state[type]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output = token.close + (opts.capture ? ")" : "");
          if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
              output = token.close = `)$))${extglobStar}`;
            }
            if (token.prev.type === "bos" && eos()) {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star : "");
              }
              return star;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output = output.replace(/\\/g, "");
            } else {
              output = output.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
              slashes = match[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance() || "";
            } else {
              value += advance() || "";
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix2 = POSIX_REGEX_SOURCE[rest2];
                  if (posix2) {
                    prev.value = pre + posix2;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output = "|";
            }
            push({ type: "comma", value, output });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output = `\\${value}`;
              }
              push({ type: "text", value, output });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
              value += match[0];
              state.index += match[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse.fastpaths = (input, options) => {
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        input = REPLACEMENTS[input] || input;
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(opts.windows);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true)
            return star;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
              return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
              return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default: {
              const match = /^(.*?)\.(\w+)$/.exec(str);
              if (!match)
                return;
              const source2 = create(match[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match[2];
            }
          }
        };
        const output = utils.removePrefix(input, state);
        let source = create(output);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module.exports = parse;
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/picomatch.js
  var require_picomatch = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/picomatch.js"(exports, module) {
      "use strict";
      var scan = require_scan();
      var parse = require_parse();
      var utils = require_utils2();
      var constants = require_constants();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch = (glob, options, returnState = false) => {
        if (Array.isArray(glob)) {
          const fns = glob.map((input) => picomatch(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob) && glob.tokens && glob.input;
        if (glob === "" || typeof glob !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix2 = opts.windows;
        const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
          const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
        let match = input === glob;
        let output = match && format ? format(input) : input;
        if (match === false) {
          output = format ? format(input) : input;
          match = output === glob;
        }
        if (match === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match = picomatch.matchBase(input, regex, options, posix2);
          } else {
            match = regex.exec(output);
          }
        }
        return { isMatch: Boolean(match), match, output };
      };
      picomatch.matchBase = (input, glob, options) => {
        const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
        return regex.test(utils.basename(input));
      };
      picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options));
        return parse(pattern, { ...options, fastpaths: false });
      };
      picomatch.scan = (input, options) => scan(input, options);
      picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return parsed.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${parsed.output})${append}`;
        if (parsed && parsed.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
          regex.state = parsed;
        }
        return regex;
      };
      picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        const opts = options || {};
        let parsed = { negated: false, fastpaths: true };
        let prefix = "";
        let output;
        if (input.startsWith("./")) {
          input = input.slice(2);
          prefix = parsed.prefix = "./";
        }
        if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          output = parse.fastpaths(input, options);
        }
        if (output === void 0) {
          parsed = parse(input, options);
          parsed.prefix = prefix + (parsed.prefix || "");
        } else {
          parsed.output = output;
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err) {
          if (options && options.debug === true)
            throw err;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module.exports = picomatch;
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/index.js
  var require_picomatch_browser = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/index.js"(exports, module) {
      "use strict";
      module.exports = require_picomatch();
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/schemaLoader.js
  var require_schemaLoader = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/schemaLoader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultSchemaLoader = void 0;
      var graphql_1 = require_graphql2();
      var defaultSchemaLoader = function(schemaConfig, parser) {
        var schema = schemaConfig.schema, documentAST = schemaConfig.documentAST, introspectionJSON = schemaConfig.introspectionJSON, introspectionJSONString = schemaConfig.introspectionJSONString, buildSchemaOptions = schemaConfig.buildSchemaOptions, documentString = schemaConfig.documentString;
        if (schema) {
          return schema;
        }
        if (introspectionJSONString) {
          var introspectionJSONResult = JSON.parse(introspectionJSONString);
          return graphql_1.buildClientSchema(introspectionJSONResult, buildSchemaOptions);
        }
        if (documentString && parser) {
          var docAST = parser(documentString);
          return graphql_1.buildASTSchema(docAST, buildSchemaOptions);
        }
        if (introspectionJSON) {
          return graphql_1.buildClientSchema(introspectionJSON, buildSchemaOptions);
        }
        if (documentAST) {
          return graphql_1.buildASTSchema(documentAST, buildSchemaOptions);
        }
        throw Error("no schema supplied");
      };
      exports.defaultSchemaLoader = defaultSchemaLoader;
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/LanguageService.js
  var require_LanguageService = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/LanguageService.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LanguageService = void 0;
      var graphql_1 = require_graphql2();
      var picomatch_browser_1 = __importDefault(require_picomatch_browser());
      var graphql_language_service_1 = require_dist();
      var schemaLoader_1 = require_schemaLoader();
      var schemaCache = /* @__PURE__ */ new Map();
      var LanguageService = function() {
        function LanguageService2(_a3) {
          var _this = this;
          var parser = _a3.parser, schemas = _a3.schemas, parseOptions = _a3.parseOptions, externalFragmentDefinitions = _a3.externalFragmentDefinitions, customValidationRules = _a3.customValidationRules;
          this._parser = graphql_1.parse;
          this._schemas = [];
          this._schemaCache = schemaCache;
          this._schemaLoader = schemaLoader_1.defaultSchemaLoader;
          this._parseOptions = void 0;
          this._customValidationRules = void 0;
          this._externalFragmentDefinitionNodes = null;
          this._externalFragmentDefinitionsString = null;
          this.getCompletion = function(uri, documentText, position) {
            var schema = _this.getSchemaForFile(uri);
            if (!documentText || documentText.length < 1 || !(schema === null || schema === void 0 ? void 0 : schema.schema)) {
              return [];
            }
            return graphql_language_service_1.getAutocompleteSuggestions(schema.schema, documentText, position, void 0, _this.getExternalFragmentDefinitions());
          };
          this.getDiagnostics = function(uri, documentText, customRules) {
            var schema = _this.getSchemaForFile(uri);
            if (!documentText || documentText.trim().length < 2 || !(schema === null || schema === void 0 ? void 0 : schema.schema)) {
              return [];
            }
            return graphql_language_service_1.getDiagnostics(documentText, schema.schema, customRules !== null && customRules !== void 0 ? customRules : _this._customValidationRules, false, _this.getExternalFragmentDefinitions());
          };
          this.getHover = function(uri, documentText, position, options) {
            var schema = _this.getSchemaForFile(uri);
            if (schema && (documentText === null || documentText === void 0 ? void 0 : documentText.length) > 3) {
              return graphql_language_service_1.getHoverInformation(schema.schema, documentText, position, void 0, __assign({ useMarkdown: true }, options));
            }
          };
          this.getVariablesJSONSchema = function(uri, documentText, options) {
            var schema = _this.getSchemaForFile(uri);
            if (schema && documentText.length > 3) {
              try {
                var documentAST = _this.parse(documentText);
                var operationFacts = graphql_language_service_1.getOperationASTFacts(documentAST, schema.schema);
                if (operationFacts && operationFacts.variableToType) {
                  return graphql_language_service_1.getVariablesJSONSchema(operationFacts.variableToType, options);
                }
              } catch (err) {
              }
            }
            return null;
          };
          this._schemaLoader = schemaLoader_1.defaultSchemaLoader;
          if (schemas) {
            this._schemas = schemas;
            this._cacheSchemas();
          }
          if (parser) {
            this._parser = parser;
          }
          if (parseOptions) {
            this._parseOptions = parseOptions;
          }
          if (customValidationRules) {
            this._customValidationRules = customValidationRules;
          }
          if (externalFragmentDefinitions) {
            if (Array.isArray(externalFragmentDefinitions)) {
              this._externalFragmentDefinitionNodes = externalFragmentDefinitions;
            } else {
              this._externalFragmentDefinitionsString = externalFragmentDefinitions;
            }
          }
        }
        LanguageService2.prototype._cacheSchemas = function() {
          var _this = this;
          this._schemas.forEach(function(schema) {
            return _this._cacheSchema(schema);
          });
        };
        LanguageService2.prototype._cacheSchema = function(schemaConfig) {
          var schema = this._schemaLoader(schemaConfig, this.parse.bind(this));
          return this._schemaCache.set(schemaConfig.uri, __assign(__assign({}, schemaConfig), { schema }));
        };
        LanguageService2.prototype.getSchemaForFile = function(uri) {
          if (!this._schemas || !this._schemas.length) {
            return;
          }
          if (this._schemas.length === 1) {
            return this._schemaCache.get(this._schemas[0].uri);
          } else {
            var schema = this._schemas.find(function(schemaConfig) {
              if (!schemaConfig.fileMatch) {
                return false;
              }
              return schemaConfig.fileMatch.some(function(glob) {
                var isMatch = picomatch_browser_1.default(glob);
                return isMatch(uri);
              });
            });
            if (schema) {
              var cacheEntry = this._schemaCache.get(schema.uri);
              if (cacheEntry) {
                return cacheEntry;
              }
              var cache = this._cacheSchema(schema);
              return cache.get(schema.uri);
            }
          }
        };
        LanguageService2.prototype.getExternalFragmentDefinitions = function() {
          if (!this._externalFragmentDefinitionNodes && this._externalFragmentDefinitionsString) {
            var definitionNodes_1 = [];
            try {
              graphql_1.visit(this._parser(this._externalFragmentDefinitionsString), {
                FragmentDefinition: function(node) {
                  definitionNodes_1.push(node);
                }
              });
            } catch (err) {
              throw Error("Failed parsing externalFragmentDefinitions string:\n" + this._externalFragmentDefinitionsString);
            }
            this._externalFragmentDefinitionNodes = definitionNodes_1;
          }
          return this._externalFragmentDefinitionNodes;
        };
        LanguageService2.prototype.updateSchemas = function(schemas) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              this._schemas = schemas;
              this._cacheSchemas();
              return [2];
            });
          });
        };
        LanguageService2.prototype.updateSchema = function(schema) {
          var schemaIndex = this._schemas.findIndex(function(c) {
            return c.uri === schema.uri;
          });
          if (schemaIndex < 0) {
            console.warn("updateSchema could not find a schema in your config by that URI", schema.uri);
            return;
          }
          this._schemas[schemaIndex] = schema;
          this._cacheSchema(schema);
        };
        LanguageService2.prototype.addSchema = function(schema) {
          this._schemas.push(schema);
          this._cacheSchema(schema);
        };
        LanguageService2.prototype.parse = function(text, options) {
          return this._parser(text, options || this._parseOptions);
        };
        return LanguageService2;
      }();
      exports.LanguageService = LanguageService;
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/utils.js
  var require_utils3 = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/utils.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStringSchema = exports.toMarkerData = exports.toCompletion = exports.toGraphQLPosition = exports.toMonacoRange = exports.getModelLanguageId = void 0;
      var graphql_1 = require_graphql2();
      var graphql_language_service_1 = require_dist();
      var getModelLanguageId = function(model) {
        if ("getModeId" in model) {
          return model.getModeId();
        }
        return model.getLanguageId();
      };
      exports.getModelLanguageId = getModelLanguageId;
      function toMonacoRange(range) {
        return {
          startLineNumber: range.start.line + 1,
          startColumn: range.start.character + 1,
          endLineNumber: range.end.line + 1,
          endColumn: range.end.character + 1
        };
      }
      exports.toMonacoRange = toMonacoRange;
      function toGraphQLPosition(position) {
        return new graphql_language_service_1.Position(position.lineNumber - 1, position.column - 1);
      }
      exports.toGraphQLPosition = toGraphQLPosition;
      function toCompletion(entry, range) {
        var results = {
          label: entry.label,
          insertText: entry.insertText,
          insertTextFormat: entry.insertTextFormat,
          sortText: entry.sortText,
          filterText: entry.filterText,
          documentation: entry.documentation,
          detail: entry.detail,
          range: range ? toMonacoRange(range) : void 0,
          kind: entry.kind
        };
        if (entry.insertTextFormat) {
          results.insertTextFormat = entry.insertTextFormat;
        }
        if (entry.command) {
          results.command = __assign(__assign({}, entry.command), { id: entry.command.command });
        }
        return results;
      }
      exports.toCompletion = toCompletion;
      function toMarkerData(diagnostic) {
        return {
          startLineNumber: diagnostic.range.start.line + 1,
          endLineNumber: diagnostic.range.end.line + 1,
          startColumn: diagnostic.range.start.character + 1,
          endColumn: diagnostic.range.end.character,
          message: diagnostic.message,
          severity: 5,
          code: diagnostic.code || void 0
        };
      }
      exports.toMarkerData = toMarkerData;
      var getStringSchema = function(schemaConfig) {
        var graphQLSchema = schemaConfig.schema, documentAST = schemaConfig.documentAST, introspectionJSON = schemaConfig.introspectionJSON, introspectionJSONString = schemaConfig.introspectionJSONString, documentString = schemaConfig.documentString, rest = __rest(schemaConfig, ["schema", "documentAST", "introspectionJSON", "introspectionJSONString", "documentString"]);
        if (graphQLSchema) {
          return __assign(__assign({}, rest), { documentString: graphql_1.printSchema(graphQLSchema) });
        }
        if (introspectionJSONString) {
          return __assign(__assign({}, rest), { introspectionJSONString });
        }
        if (documentString) {
          return __assign(__assign({}, rest), { documentString });
        }
        if (introspectionJSON) {
          return __assign(__assign({}, rest), { introspectionJSONString: JSON.stringify(introspectionJSON) });
        }
        if (documentAST) {
          var schema = graphql_1.buildASTSchema(documentAST, rest.buildSchemaOptions);
          return __assign(__assign({}, rest), { documentString: graphql_1.printSchema(schema) });
        }
        throw Error("no schema supplied");
      };
      exports.getStringSchema = getStringSchema;
    }
  });

  // ../../node_modules/.pnpm/prettier@2.6.2/node_modules/prettier/standalone.js
  var require_standalone = __commonJS({
    "../../node_modules/.pnpm/prettier@2.6.2/node_modules/prettier/standalone.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          f.prettier = e();
        }
      })(function() {
        "use strict";
        var be = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
        var Ye = be((yg, ru) => {
          var er = function(e) {
            return e && e.Math == Math && e;
          };
          ru.exports = er(typeof globalThis == "object" && globalThis) || er(typeof window == "object" && window) || er(typeof self == "object" && self) || er(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        });
        var ft = be((hg, nu) => {
          nu.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        });
        var ht = be((Cg, uu) => {
          var vo = ft();
          uu.exports = !vo(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        });
        var tr = be((Eg, su) => {
          var Fo = ft();
          su.exports = !Fo(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        });
        var Ct = be((vg, au) => {
          var Ao = tr(), rr = Function.prototype.call;
          au.exports = Ao ? rr.bind(rr) : function() {
            return rr.apply(rr, arguments);
          };
        });
        var lu = be((cu) => {
          "use strict";
          var iu = {}.propertyIsEnumerable, ou = Object.getOwnPropertyDescriptor, So = ou && !iu.call({ 1: 2 }, 1);
          cu.f = So ? function(n) {
            var t = ou(this, n);
            return !!t && t.enumerable;
          } : iu;
        });
        var nr = be((Ag, pu) => {
          pu.exports = function(e, n) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
          };
        });
        var at = be((Sg, mu) => {
          var fu = tr(), Du = Function.prototype, xo = Du.bind, Lr = Du.call, bo = fu && xo.bind(Lr, Lr);
          mu.exports = fu ? function(e) {
            return e && bo(e);
          } : function(e) {
            return e && function() {
              return Lr.apply(e, arguments);
            };
          };
        });
        var ur = be((xg, gu) => {
          var du = at(), To = du({}.toString), Bo = du("".slice);
          gu.exports = function(e) {
            return Bo(To(e), 8, -1);
          };
        });
        var hu = be((bg, yu) => {
          var No = Ye(), wo = at(), _o = ft(), Po = ur(), Or = No.Object, Io = wo("".split);
          yu.exports = _o(function() {
            return !Or("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return Po(e) == "String" ? Io(e, "") : Or(e);
          } : Or;
        });
        var jr = be((Tg, Cu) => {
          var ko = Ye(), Lo = ko.TypeError;
          Cu.exports = function(e) {
            if (e == null)
              throw Lo("Can't call method on " + e);
            return e;
          };
        });
        var sr = be((Bg, Eu) => {
          var Oo = hu(), jo = jr();
          Eu.exports = function(e) {
            return Oo(jo(e));
          };
        });
        var it = be((Ng, vu) => {
          vu.exports = function(e) {
            return typeof e == "function";
          };
        });
        var Et = be((wg, Fu) => {
          var qo = it();
          Fu.exports = function(e) {
            return typeof e == "object" ? e !== null : qo(e);
          };
        });
        var Mt = be((_g, Au) => {
          var qr = Ye(), Mo = it(), Ro = function(e) {
            return Mo(e) ? e : void 0;
          };
          Au.exports = function(e, n) {
            return arguments.length < 2 ? Ro(qr[e]) : qr[e] && qr[e][n];
          };
        });
        var Mr = be((Pg, Su) => {
          var Vo = at();
          Su.exports = Vo({}.isPrototypeOf);
        });
        var bu = be((Ig, xu) => {
          var Wo = Mt();
          xu.exports = Wo("navigator", "userAgent") || "";
        });
        var Iu = be((kg, Pu) => {
          var _u = Ye(), Rr = bu(), Tu = _u.process, Bu = _u.Deno, Nu = Tu && Tu.versions || Bu && Bu.version, wu = Nu && Nu.v8, lt, ar;
          wu && (lt = wu.split("."), ar = lt[0] > 0 && lt[0] < 4 ? 1 : +(lt[0] + lt[1]));
          !ar && Rr && (lt = Rr.match(/Edge\/(\d+)/), (!lt || lt[1] >= 74) && (lt = Rr.match(/Chrome\/(\d+)/), lt && (ar = +lt[1])));
          Pu.exports = ar;
        });
        var Vr = be((Lg, Lu) => {
          var ku = Iu(), $o = ft();
          Lu.exports = !!Object.getOwnPropertySymbols && !$o(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && ku && ku < 41;
          });
        });
        var Wr = be((Og, Ou) => {
          var Ho = Vr();
          Ou.exports = Ho && !Symbol.sham && typeof Symbol.iterator == "symbol";
        });
        var $r = be((jg, ju) => {
          var Go = Ye(), Jo = Mt(), Uo = it(), zo = Mr(), Xo = Wr(), Ko = Go.Object;
          ju.exports = Xo ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var n = Jo("Symbol");
            return Uo(n) && zo(n.prototype, Ko(e));
          };
        });
        var ir = be((qg, qu) => {
          var Yo = Ye(), Qo = Yo.String;
          qu.exports = function(e) {
            try {
              return Qo(e);
            } catch {
              return "Object";
            }
          };
        });
        var Rt = be((Mg, Mu) => {
          var Zo = Ye(), ec = it(), tc = ir(), rc = Zo.TypeError;
          Mu.exports = function(e) {
            if (ec(e))
              return e;
            throw rc(tc(e) + " is not a function");
          };
        });
        var or = be((Rg, Ru) => {
          var nc = Rt();
          Ru.exports = function(e, n) {
            var t = e[n];
            return t == null ? void 0 : nc(t);
          };
        });
        var Wu = be((Vg, Vu) => {
          var uc = Ye(), Hr = Ct(), Gr = it(), Jr = Et(), sc = uc.TypeError;
          Vu.exports = function(e, n) {
            var t, s;
            if (n === "string" && Gr(t = e.toString) && !Jr(s = Hr(t, e)) || Gr(t = e.valueOf) && !Jr(s = Hr(t, e)) || n !== "string" && Gr(t = e.toString) && !Jr(s = Hr(t, e)))
              return s;
            throw sc("Can't convert object to primitive value");
          };
        });
        var Hu = be((Wg, $u) => {
          $u.exports = false;
        });
        var cr = be(($g, Ju) => {
          var Gu = Ye(), ac = Object.defineProperty;
          Ju.exports = function(e, n) {
            try {
              ac(Gu, e, { value: n, configurable: true, writable: true });
            } catch {
              Gu[e] = n;
            }
            return n;
          };
        });
        var lr = be((Hg, zu) => {
          var ic = Ye(), oc = cr(), Uu = "__core-js_shared__", cc = ic[Uu] || oc(Uu, {});
          zu.exports = cc;
        });
        var Ur = be((Gg, Ku) => {
          var lc = Hu(), Xu = lr();
          (Ku.exports = function(e, n) {
            return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
          })("versions", []).push({ version: "3.21.1", mode: lc ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE", source: "https://github.com/zloirock/core-js" });
        });
        var pr = be((Jg, Yu) => {
          var pc = Ye(), fc = jr(), Dc = pc.Object;
          Yu.exports = function(e) {
            return Dc(fc(e));
          };
        });
        var mt = be((Ug, Qu) => {
          var mc = at(), dc = pr(), gc = mc({}.hasOwnProperty);
          Qu.exports = Object.hasOwn || function(n, t) {
            return gc(dc(n), t);
          };
        });
        var zr = be((zg, Zu) => {
          var yc = at(), hc = 0, Cc = Math.random(), Ec = yc(1 .toString);
          Zu.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Ec(++hc + Cc, 36);
          };
        });
        var Ft = be((Xg, us) => {
          var vc = Ye(), Fc = Ur(), es = mt(), Ac = zr(), ts = Vr(), ns = Wr(), Tt = Fc("wks"), vt = vc.Symbol, rs = vt && vt.for, Sc = ns ? vt : vt && vt.withoutSetter || Ac;
          us.exports = function(e) {
            if (!es(Tt, e) || !(ts || typeof Tt[e] == "string")) {
              var n = "Symbol." + e;
              ts && es(vt, e) ? Tt[e] = vt[e] : ns && rs ? Tt[e] = rs(n) : Tt[e] = Sc(n);
            }
            return Tt[e];
          };
        });
        var os = be((Kg, is) => {
          var xc = Ye(), bc = Ct(), ss = Et(), as = $r(), Tc = or(), Bc = Wu(), Nc = Ft(), wc = xc.TypeError, _c = Nc("toPrimitive");
          is.exports = function(e, n) {
            if (!ss(e) || as(e))
              return e;
            var t = Tc(e, _c), s;
            if (t) {
              if (n === void 0 && (n = "default"), s = bc(t, e, n), !ss(s) || as(s))
                return s;
              throw wc("Can't convert object to primitive value");
            }
            return n === void 0 && (n = "number"), Bc(e, n);
          };
        });
        var fr = be((Yg, cs) => {
          var Pc = os(), Ic = $r();
          cs.exports = function(e) {
            var n = Pc(e, "string");
            return Ic(n) ? n : n + "";
          };
        });
        var fs = be((Qg, ps) => {
          var kc = Ye(), ls = Et(), Xr = kc.document, Lc = ls(Xr) && ls(Xr.createElement);
          ps.exports = function(e) {
            return Lc ? Xr.createElement(e) : {};
          };
        });
        var Kr = be((Zg, Ds) => {
          var Oc = ht(), jc = ft(), qc = fs();
          Ds.exports = !Oc && !jc(function() {
            return Object.defineProperty(qc("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        });
        var Yr = be((ds) => {
          var Mc = ht(), Rc = Ct(), Vc = lu(), Wc = nr(), $c = sr(), Hc = fr(), Gc = mt(), Jc = Kr(), ms = Object.getOwnPropertyDescriptor;
          ds.f = Mc ? ms : function(n, t) {
            if (n = $c(n), t = Hc(t), Jc)
              try {
                return ms(n, t);
              } catch {
              }
            if (Gc(n, t))
              return Wc(!Rc(Vc.f, n, t), n[t]);
          };
        });
        var ys = be((t0, gs) => {
          var Uc = ht(), zc = ft();
          gs.exports = Uc && zc(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        });
        var Bt = be((r0, Cs) => {
          var hs = Ye(), Xc = Et(), Kc = hs.String, Yc = hs.TypeError;
          Cs.exports = function(e) {
            if (Xc(e))
              return e;
            throw Yc(Kc(e) + " is not an object");
          };
        });
        var mr = be((vs) => {
          var Qc = Ye(), Zc = ht(), el = Kr(), tl = ys(), Dr = Bt(), Es = fr(), rl = Qc.TypeError, Qr = Object.defineProperty, nl = Object.getOwnPropertyDescriptor, Zr = "enumerable", en = "configurable", tn = "writable";
          vs.f = Zc ? tl ? function(n, t, s) {
            if (Dr(n), t = Es(t), Dr(s), typeof n == "function" && t === "prototype" && "value" in s && tn in s && !s[tn]) {
              var i = nl(n, t);
              i && i[tn] && (n[t] = s.value, s = { configurable: en in s ? s[en] : i[en], enumerable: Zr in s ? s[Zr] : i[Zr], writable: false });
            }
            return Qr(n, t, s);
          } : Qr : function(n, t, s) {
            if (Dr(n), t = Es(t), Dr(s), el)
              try {
                return Qr(n, t, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw rl("Accessors not supported");
            return "value" in s && (n[t] = s.value), n;
          };
        });
        var dr = be((u0, Fs) => {
          var ul = ht(), sl = mr(), al = nr();
          Fs.exports = ul ? function(e, n, t) {
            return sl.f(e, n, al(1, t));
          } : function(e, n, t) {
            return e[n] = t, e;
          };
        });
        var gr = be((s0, As) => {
          var il = at(), ol = it(), rn = lr(), cl = il(Function.toString);
          ol(rn.inspectSource) || (rn.inspectSource = function(e) {
            return cl(e);
          });
          As.exports = rn.inspectSource;
        });
        var bs = be((a0, xs) => {
          var ll = Ye(), pl = it(), fl = gr(), Ss = ll.WeakMap;
          xs.exports = pl(Ss) && /native code/.test(fl(Ss));
        });
        var Ns = be((i0, Bs) => {
          var Dl = Ur(), ml = zr(), Ts = Dl("keys");
          Bs.exports = function(e) {
            return Ts[e] || (Ts[e] = ml(e));
          };
        });
        var nn = be((o0, ws) => {
          ws.exports = {};
        });
        var Os = be((c0, Ls) => {
          var dl = bs(), ks = Ye(), un = at(), gl = Et(), yl = dr(), sn = mt(), an = lr(), hl = Ns(), Cl = nn(), _s = "Object already initialized", cn = ks.TypeError, El = ks.WeakMap, yr, Vt, hr, vl = function(e) {
            return hr(e) ? Vt(e) : yr(e, {});
          }, Fl = function(e) {
            return function(n) {
              var t;
              if (!gl(n) || (t = Vt(n)).type !== e)
                throw cn("Incompatible receiver, " + e + " required");
              return t;
            };
          };
          dl || an.state ? (dt = an.state || (an.state = new El()), Ps = un(dt.get), on = un(dt.has), Is = un(dt.set), yr = function(e, n) {
            if (on(dt, e))
              throw new cn(_s);
            return n.facade = e, Is(dt, e, n), n;
          }, Vt = function(e) {
            return Ps(dt, e) || {};
          }, hr = function(e) {
            return on(dt, e);
          }) : (At = hl("state"), Cl[At] = true, yr = function(e, n) {
            if (sn(e, At))
              throw new cn(_s);
            return n.facade = e, yl(e, At, n), n;
          }, Vt = function(e) {
            return sn(e, At) ? e[At] : {};
          }, hr = function(e) {
            return sn(e, At);
          });
          var dt, Ps, on, Is, At;
          Ls.exports = { set: yr, get: Vt, has: hr, enforce: vl, getterFor: Fl };
        });
        var Ms = be((l0, qs) => {
          var ln = ht(), Al = mt(), js = Function.prototype, Sl = ln && Object.getOwnPropertyDescriptor, pn = Al(js, "name"), xl = pn && function() {
          }.name === "something", bl = pn && (!ln || ln && Sl(js, "name").configurable);
          qs.exports = { EXISTS: pn, PROPER: xl, CONFIGURABLE: bl };
        });
        var Hs = be((p0, $s) => {
          var Tl = Ye(), Rs = it(), Bl = mt(), Vs = dr(), Nl = cr(), wl = gr(), Ws = Os(), _l = Ms().CONFIGURABLE, Pl = Ws.get, Il = Ws.enforce, kl = String(String).split("String");
          ($s.exports = function(e, n, t, s) {
            var i = s ? !!s.unsafe : false, r = s ? !!s.enumerable : false, u = s ? !!s.noTargetGet : false, a = s && s.name !== void 0 ? s.name : n, c;
            if (Rs(t) && (String(a).slice(0, 7) === "Symbol(" && (a = "[" + String(a).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Bl(t, "name") || _l && t.name !== a) && Vs(t, "name", a), c = Il(t), c.source || (c.source = kl.join(typeof a == "string" ? a : ""))), e === Tl) {
              r ? e[n] = t : Nl(n, t);
              return;
            } else
              i ? !u && e[n] && (r = true) : delete e[n];
            r ? e[n] = t : Vs(e, n, t);
          })(Function.prototype, "toString", function() {
            return Rs(this) && Pl(this).source || wl(this);
          });
        });
        var Cr = be((f0, Gs) => {
          var Ll = Math.ceil, Ol = Math.floor;
          Gs.exports = function(e) {
            var n = +e;
            return n !== n || n === 0 ? 0 : (n > 0 ? Ol : Ll)(n);
          };
        });
        var Us = be((D0, Js) => {
          var jl = Cr(), ql = Math.max, Ml = Math.min;
          Js.exports = function(e, n) {
            var t = jl(e);
            return t < 0 ? ql(t + n, 0) : Ml(t, n);
          };
        });
        var Xs = be((m0, zs) => {
          var Rl = Cr(), Vl = Math.min;
          zs.exports = function(e) {
            return e > 0 ? Vl(Rl(e), 9007199254740991) : 0;
          };
        });
        var Nt = be((d0, Ks) => {
          var Wl = Xs();
          Ks.exports = function(e) {
            return Wl(e.length);
          };
        });
        var Zs = be((g0, Qs) => {
          var $l = sr(), Hl = Us(), Gl = Nt(), Ys = function(e) {
            return function(n, t, s) {
              var i = $l(n), r = Gl(i), u = Hl(s, r), a;
              if (e && t != t) {
                for (; r > u; )
                  if (a = i[u++], a != a)
                    return true;
              } else
                for (; r > u; u++)
                  if ((e || u in i) && i[u] === t)
                    return e || u || 0;
              return !e && -1;
            };
          };
          Qs.exports = { includes: Ys(true), indexOf: Ys(false) };
        });
        var ra = be((y0, ta) => {
          var Jl = at(), fn = mt(), Ul = sr(), zl = Zs().indexOf, Xl = nn(), ea = Jl([].push);
          ta.exports = function(e, n) {
            var t = Ul(e), s = 0, i = [], r;
            for (r in t)
              !fn(Xl, r) && fn(t, r) && ea(i, r);
            for (; n.length > s; )
              fn(t, r = n[s++]) && (~zl(i, r) || ea(i, r));
            return i;
          };
        });
        var ua = be((h0, na) => {
          na.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        });
        var aa = be((sa) => {
          var Kl = ra(), Yl = ua(), Ql = Yl.concat("length", "prototype");
          sa.f = Object.getOwnPropertyNames || function(n) {
            return Kl(n, Ql);
          };
        });
        var oa = be((ia) => {
          ia.f = Object.getOwnPropertySymbols;
        });
        var la = be((v0, ca) => {
          var Zl = Mt(), ep = at(), tp = aa(), rp = oa(), np = Bt(), up = ep([].concat);
          ca.exports = Zl("Reflect", "ownKeys") || function(n) {
            var t = tp.f(np(n)), s = rp.f;
            return s ? up(t, s(n)) : t;
          };
        });
        var Da = be((F0, fa) => {
          var pa = mt(), sp = la(), ap = Yr(), ip = mr();
          fa.exports = function(e, n, t) {
            for (var s = sp(n), i = ip.f, r = ap.f, u = 0; u < s.length; u++) {
              var a = s[u];
              !pa(e, a) && !(t && pa(t, a)) && i(e, a, r(n, a));
            }
          };
        });
        var da = be((A0, ma) => {
          var op = ft(), cp = it(), lp = /#|\.prototype\./, Wt = function(e, n) {
            var t = fp[pp(e)];
            return t == mp ? true : t == Dp ? false : cp(n) ? op(n) : !!n;
          }, pp = Wt.normalize = function(e) {
            return String(e).replace(lp, ".").toLowerCase();
          }, fp = Wt.data = {}, Dp = Wt.NATIVE = "N", mp = Wt.POLYFILL = "P";
          ma.exports = Wt;
        });
        var $t = be((S0, ga) => {
          var Dn = Ye(), dp = Yr().f, gp = dr(), yp = Hs(), hp = cr(), Cp = Da(), Ep = da();
          ga.exports = function(e, n) {
            var t = e.target, s = e.global, i = e.stat, r, u, a, c, l, C;
            if (s ? u = Dn : i ? u = Dn[t] || hp(t, {}) : u = (Dn[t] || {}).prototype, u)
              for (a in n) {
                if (l = n[a], e.noTargetGet ? (C = dp(u, a), c = C && C.value) : c = u[a], r = Ep(s ? a : t + (i ? "." : "#") + a, e.forced), !r && c !== void 0) {
                  if (typeof l == typeof c)
                    continue;
                  Cp(l, c);
                }
                (e.sham || c && c.sham) && gp(l, "sham", true), yp(u, a, l, e);
              }
          };
        });
        var mn = be((x0, ya) => {
          var vp = ur();
          ya.exports = Array.isArray || function(n) {
            return vp(n) == "Array";
          };
        });
        var dn = be((b0, Ca) => {
          var ha = at(), Fp = Rt(), Ap = tr(), Sp = ha(ha.bind);
          Ca.exports = function(e, n) {
            return Fp(e), n === void 0 ? e : Ap ? Sp(e, n) : function() {
              return e.apply(n, arguments);
            };
          };
        });
        var gn = be((T0, va) => {
          "use strict";
          var xp = Ye(), bp = mn(), Tp = Nt(), Bp = dn(), Np = xp.TypeError, Ea = function(e, n, t, s, i, r, u, a) {
            for (var c = i, l = 0, C = u ? Bp(u, a) : false, m, g; l < s; ) {
              if (l in t) {
                if (m = C ? C(t[l], l, n) : t[l], r > 0 && bp(m))
                  g = Tp(m), c = Ea(e, n, m, g, c, r - 1) - 1;
                else {
                  if (c >= 9007199254740991)
                    throw Np("Exceed the acceptable array length");
                  e[c] = m;
                }
                c++;
              }
              l++;
            }
            return c;
          };
          va.exports = Ea;
        });
        var Sa = be((B0, Aa) => {
          var wp = Ft(), _p = wp("toStringTag"), Fa = {};
          Fa[_p] = "z";
          Aa.exports = String(Fa) === "[object z]";
        });
        var yn = be((N0, xa) => {
          var Pp = Ye(), Ip = Sa(), kp = it(), Er = ur(), Lp = Ft(), Op = Lp("toStringTag"), jp = Pp.Object, qp = Er(function() {
            return arguments;
          }()) == "Arguments", Mp = function(e, n) {
            try {
              return e[n];
            } catch {
            }
          };
          xa.exports = Ip ? Er : function(e) {
            var n, t, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Mp(n = jp(e), Op)) == "string" ? t : qp ? Er(n) : (s = Er(n)) == "Object" && kp(n.callee) ? "Arguments" : s;
          };
        });
        var _a3 = be((w0, wa) => {
          var Rp = at(), Vp = ft(), ba = it(), Wp = yn(), $p = Mt(), Hp = gr(), Ta = function() {
          }, Gp = [], Ba = $p("Reflect", "construct"), hn = /^\s*(?:class|function)\b/, Jp = Rp(hn.exec), Up = !hn.exec(Ta), Ht = function(n) {
            if (!ba(n))
              return false;
            try {
              return Ba(Ta, Gp, n), true;
            } catch {
              return false;
            }
          }, Na = function(n) {
            if (!ba(n))
              return false;
            switch (Wp(n)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Up || !!Jp(hn, Hp(n));
            } catch {
              return true;
            }
          };
          Na.sham = true;
          wa.exports = !Ba || Vp(function() {
            var e;
            return Ht(Ht.call) || !Ht(Object) || !Ht(function() {
              e = true;
            }) || e;
          }) ? Na : Ht;
        });
        var La = be((_0, ka) => {
          var zp = Ye(), Pa = mn(), Xp = _a3(), Kp = Et(), Yp = Ft(), Qp = Yp("species"), Ia = zp.Array;
          ka.exports = function(e) {
            var n;
            return Pa(e) && (n = e.constructor, Xp(n) && (n === Ia || Pa(n.prototype)) ? n = void 0 : Kp(n) && (n = n[Qp], n === null && (n = void 0))), n === void 0 ? Ia : n;
          };
        });
        var Cn = be((P0, Oa) => {
          var Zp = La();
          Oa.exports = function(e, n) {
            return new (Zp(e))(n === 0 ? 0 : n);
          };
        });
        var ja = be(() => {
          "use strict";
          var ef = $t(), tf = gn(), rf = Rt(), nf = pr(), uf = Nt(), sf = Cn();
          ef({ target: "Array", proto: true }, { flatMap: function(n) {
            var t = nf(this), s = uf(t), i;
            return rf(n), i = sf(t, 0), i.length = tf(i, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), i;
          } });
        });
        var En = be((L0, qa) => {
          qa.exports = {};
        });
        var Ra = be((O0, Ma) => {
          var af = Ft(), of = En(), cf = af("iterator"), lf = Array.prototype;
          Ma.exports = function(e) {
            return e !== void 0 && (of.Array === e || lf[cf] === e);
          };
        });
        var vn = be((j0, Wa) => {
          var pf = yn(), Va = or(), ff = En(), Df = Ft(), mf = Df("iterator");
          Wa.exports = function(e) {
            if (e != null)
              return Va(e, mf) || Va(e, "@@iterator") || ff[pf(e)];
          };
        });
        var Ha = be((q0, $a) => {
          var df = Ye(), gf = Ct(), yf = Rt(), hf = Bt(), Cf = ir(), Ef = vn(), vf = df.TypeError;
          $a.exports = function(e, n) {
            var t = arguments.length < 2 ? Ef(e) : n;
            if (yf(t))
              return hf(gf(t, e));
            throw vf(Cf(e) + " is not iterable");
          };
        });
        var Ua = be((M0, Ja) => {
          var Ff = Ct(), Ga = Bt(), Af = or();
          Ja.exports = function(e, n, t) {
            var s, i;
            Ga(e);
            try {
              if (s = Af(e, "return"), !s) {
                if (n === "throw")
                  throw t;
                return t;
              }
              s = Ff(s, e);
            } catch (r) {
              i = true, s = r;
            }
            if (n === "throw")
              throw t;
            if (i)
              throw s;
            return Ga(s), t;
          };
        });
        var Qa = be((R0, Ya) => {
          var Sf = Ye(), xf = dn(), bf = Ct(), Tf = Bt(), Bf = ir(), Nf = Ra(), wf = Nt(), za = Mr(), _f = Ha(), Pf = vn(), Xa = Ua(), If = Sf.TypeError, vr = function(e, n) {
            this.stopped = e, this.result = n;
          }, Ka = vr.prototype;
          Ya.exports = function(e, n, t) {
            var s = t && t.that, i = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), a = xf(n, s), c, l, C, m, g, p, f, h = function(T) {
              return c && Xa(c, "normal", T), new vr(true, T);
            }, N = function(T) {
              return i ? (Tf(T), u ? a(T[0], T[1], h) : a(T[0], T[1])) : u ? a(T, h) : a(T);
            };
            if (r)
              c = e;
            else {
              if (l = Pf(e), !l)
                throw If(Bf(e) + " is not iterable");
              if (Nf(l)) {
                for (C = 0, m = wf(e); m > C; C++)
                  if (g = N(e[C]), g && za(Ka, g))
                    return g;
                return new vr(false);
              }
              c = _f(e, l);
            }
            for (p = c.next; !(f = bf(p, c)).done; ) {
              try {
                g = N(f.value);
              } catch (T) {
                Xa(c, "throw", T);
              }
              if (typeof g == "object" && g && za(Ka, g))
                return g;
            }
            return new vr(false);
          };
        });
        var ei = be((V0, Za) => {
          "use strict";
          var kf = fr(), Lf = mr(), Of = nr();
          Za.exports = function(e, n, t) {
            var s = kf(n);
            s in e ? Lf.f(e, s, Of(0, t)) : e[s] = t;
          };
        });
        var ti = be(() => {
          var jf = $t(), qf = Qa(), Mf = ei();
          jf({ target: "Object", stat: true }, { fromEntries: function(n) {
            var t = {};
            return qf(n, function(s, i) {
              Mf(t, s, i);
            }, { AS_ENTRIES: true }), t;
          } });
        });
        var ri = be(() => {
          var Rf = $t(), Vf = Ye();
          Rf({ global: true }, { globalThis: Vf });
        });
        var ni = be(() => {
          ri();
        });
        var ui = be(() => {
          "use strict";
          var Wf = $t(), $f = gn(), Hf = pr(), Gf = Nt(), Jf = Cr(), Uf = Cn();
          Wf({ target: "Array", proto: true }, { flat: function() {
            var n = arguments.length ? arguments[0] : void 0, t = Hf(this), s = Gf(t), i = Uf(t, 0);
            return i.length = $f(i, t, t, s, 0, n === void 0 ? 1 : Jf(n)), i;
          } });
        });
        var dg = be((Y0, yo) => {
          var zf = ["cliName", "cliCategory", "cliDescription"], Xf = ["_"], Kf = ["languageId"], si, ai, ii, oi, ci, li;
          function _n(e, n) {
            if (e == null)
              return {};
            var t = Yf(e, n), s, i;
            if (Object.getOwnPropertySymbols) {
              var r = Object.getOwnPropertySymbols(e);
              for (i = 0; i < r.length; i++)
                s = r[i], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
            }
            return t;
          }
          function Yf(e, n) {
            if (e == null)
              return {};
            var t = {}, s = Object.keys(e), i, r;
            for (r = 0; r < s.length; r++)
              i = s[r], !(n.indexOf(i) >= 0) && (t[i] = e[i]);
            return t;
          }
          ja();
          ti();
          ni();
          ui();
          function wt(e, n) {
            return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(n) } }));
          }
          var Pn = Object.defineProperty, Qf = Object.getOwnPropertyDescriptor, In = Object.getOwnPropertyNames, Zf = Object.prototype.hasOwnProperty, br = (e, n) => function() {
            return e && (n = (0, e[In(e)[0]])(e = 0)), n;
          }, Z = (e, n) => function() {
            return n || (0, e[In(e)[0]])((n = { exports: {} }).exports, n), n.exports;
          }, kn = (e, n) => {
            for (var t in n)
              Pn(e, t, { get: n[t], enumerable: true });
          }, eD = (e, n, t, s) => {
            if (n && typeof n == "object" || typeof n == "function")
              for (let i of In(n))
                !Zf.call(e, i) && i !== t && Pn(e, i, { get: () => n[i], enumerable: !(s = Qf(n, i)) || s.enumerable });
            return e;
          }, pt = (e) => eD(Pn({}, "__esModule", { value: true }), e), pi, fi, xt, ae = br({ "<define:process>"() {
            pi = {}, fi = [], xt = { env: pi, argv: fi };
          } }), gi = Z({ "package.json"(e, n) {
            n.exports = { version: "2.6.2" };
          } }), tD = Z({ "node_modules/diff/lib/diff/base.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
            function n() {
            }
            n.prototype = { diff: function(r, u) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, c = a.callback;
              typeof a == "function" && (c = a, a = {}), this.options = a;
              var l = this;
              function C(b) {
                return c ? (setTimeout(function() {
                  c(void 0, b);
                }, 0), true) : b;
              }
              r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
              var m = u.length, g = r.length, p = 1, f = m + g, h = [{ newPos: -1, components: [] }], N = this.extractCommon(h[0], u, r, 0);
              if (h[0].newPos + 1 >= m && N + 1 >= g)
                return C([{ value: this.join(u), count: u.length }]);
              function T() {
                for (var b = -1 * p; b <= p; b += 2) {
                  var v = void 0, B = h[b - 1], w = h[b + 1], I = (w ? w.newPos : 0) - b;
                  B && (h[b - 1] = void 0);
                  var E = B && B.newPos + 1 < m, D = w && 0 <= I && I < g;
                  if (!E && !D) {
                    h[b] = void 0;
                    continue;
                  }
                  if (!E || D && B.newPos < w.newPos ? (v = s(w), l.pushComponent(v.components, void 0, true)) : (v = B, v.newPos++, l.pushComponent(v.components, true, void 0)), I = l.extractCommon(v, u, r, b), v.newPos + 1 >= m && I + 1 >= g)
                    return C(t(l, v.components, u, r, l.useLongestToken));
                  h[b] = v;
                }
                p++;
              }
              if (c)
                (function b() {
                  setTimeout(function() {
                    if (p > f)
                      return c();
                    T() || b();
                  }, 0);
                })();
              else
                for (; p <= f; ) {
                  var A = T();
                  if (A)
                    return A;
                }
            }, pushComponent: function(r, u, a) {
              var c = r[r.length - 1];
              c && c.added === u && c.removed === a ? r[r.length - 1] = { count: c.count + 1, added: u, removed: a } : r.push({ count: 1, added: u, removed: a });
            }, extractCommon: function(r, u, a, c) {
              for (var l = u.length, C = a.length, m = r.newPos, g = m - c, p = 0; m + 1 < l && g + 1 < C && this.equals(u[m + 1], a[g + 1]); )
                m++, g++, p++;
              return p && r.components.push({ count: p }), r.newPos = m, g;
            }, equals: function(r, u) {
              return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
            }, removeEmpty: function(r) {
              for (var u = [], a = 0; a < r.length; a++)
                r[a] && u.push(r[a]);
              return u;
            }, castInput: function(r) {
              return r;
            }, tokenize: function(r) {
              return r.split("");
            }, join: function(r) {
              return r.join("");
            } };
            function t(i, r, u, a, c) {
              for (var l = 0, C = r.length, m = 0, g = 0; l < C; l++) {
                var p = r[l];
                if (p.removed) {
                  if (p.value = i.join(a.slice(g, g + p.count)), g += p.count, l && r[l - 1].added) {
                    var h = r[l - 1];
                    r[l - 1] = r[l], r[l] = h;
                  }
                } else {
                  if (!p.added && c) {
                    var f = u.slice(m, m + p.count);
                    f = f.map(function(T, A) {
                      var b = a[g + A];
                      return b.length > T.length ? b : T;
                    }), p.value = i.join(f);
                  } else
                    p.value = i.join(u.slice(m, m + p.count));
                  m += p.count, p.added || (g += p.count);
                }
              }
              var N = r[C - 1];
              return C > 1 && typeof N.value == "string" && (N.added || N.removed) && i.equals("", N.value) && (r[C - 2].value += N.value, r.pop()), r;
            }
            function s(i) {
              return { newPos: i.newPos, components: i.components.slice(0) };
            }
          } }), rD = Z({ "node_modules/diff/lib/diff/array.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = i, e.arrayDiff = void 0;
            var n = t(tD());
            function t(r) {
              return r && r.__esModule ? r : { default: r };
            }
            var s = new n.default();
            e.arrayDiff = s, s.tokenize = function(r) {
              return r.slice();
            }, s.join = s.removeEmpty = function(r) {
              return r;
            };
            function i(r, u, a) {
              return s.diff(r, u, a);
            }
          } }), Ln = Z({ "src/document/doc-builders.js"(e, n) {
            "use strict";
            ae();
            function t(y) {
              return { type: "concat", parts: y };
            }
            function s(y) {
              return { type: "indent", contents: y };
            }
            function i(y, o) {
              return { type: "align", contents: o, n: y };
            }
            function r(y) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return { type: "group", id: o.id, contents: y, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
            }
            function u(y) {
              return i(Number.NEGATIVE_INFINITY, y);
            }
            function a(y) {
              return i({ type: "root" }, y);
            }
            function c(y) {
              return i(-1, y);
            }
            function l(y, o) {
              return r(y[0], Object.assign(Object.assign({}, o), {}, { expandedStates: y }));
            }
            function C(y) {
              return { type: "fill", parts: y };
            }
            function m(y, o) {
              let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return { type: "if-break", breakContents: y, flatContents: o, groupId: x.groupId };
            }
            function g(y, o) {
              return { type: "indent-if-break", contents: y, groupId: o.groupId, negate: o.negate };
            }
            function p(y) {
              return { type: "line-suffix", contents: y };
            }
            var f = { type: "line-suffix-boundary" }, h = { type: "break-parent" }, N = { type: "trim" }, T = { type: "line", hard: true }, A = { type: "line", hard: true, literal: true }, b = { type: "line" }, v = { type: "line", soft: true }, B = t([T, h]), w = t([A, h]), I = { type: "cursor", placeholder: Symbol("cursor") };
            function E(y, o) {
              let x = [];
              for (let F = 0; F < o.length; F++)
                F !== 0 && x.push(y), x.push(o[F]);
              return t(x);
            }
            function D(y, o, x) {
              let F = y;
              if (o > 0) {
                for (let S = 0; S < Math.floor(o / x); ++S)
                  F = s(F);
                F = i(o % x, F), F = i(Number.NEGATIVE_INFINITY, F);
              }
              return F;
            }
            function d(y, o) {
              return { type: "label", label: y, contents: o };
            }
            n.exports = { concat: t, join: E, line: b, softline: v, hardline: B, literalline: w, group: r, conditionalGroup: l, fill: C, lineSuffix: p, lineSuffixBoundary: f, cursor: I, breakParent: h, ifBreak: m, trim: N, indent: s, indentIfBreak: g, align: i, addAlignmentToDoc: D, markAsRoot: a, dedentToRoot: u, dedent: c, hardlineWithoutBreakParent: T, literallineWithoutBreakParent: A, label: d };
          } }), On = Z({ "src/common/end-of-line.js"(e, n) {
            "use strict";
            ae();
            function t(u) {
              let a = u.indexOf("\r");
              return a >= 0 ? u.charAt(a + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function s(u) {
              switch (u) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function i(u, a) {
              let c;
              switch (a) {
                case `
`:
                  c = /\n/g;
                  break;
                case "\r":
                  c = /\r/g;
                  break;
                case `\r
`:
                  c = /\r\n/g;
                  break;
                default:
                  throw new Error('Unexpected "eol" '.concat(JSON.stringify(a), "."));
              }
              let l = u.match(c);
              return l ? l.length : 0;
            }
            function r(u) {
              return u.replace(/\r\n?/g, `
`);
            }
            n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: i, normalizeEndOfLine: r };
          } }), st = Z({ "src/utils/get-last.js"(e, n) {
            "use strict";
            ae();
            var t = (s) => s[s.length - 1];
            n.exports = t;
          } }), nD = Z({ "vendors/string-width.js"(e, n) {
            ae();
            var t = Object.create, s = Object.defineProperty, i = Object.getOwnPropertyDescriptor, r = Object.getOwnPropertyNames, u = Object.getPrototypeOf, a = Object.prototype.hasOwnProperty, c = (v, B) => function() {
              return B || (0, v[r(v)[0]])((B = { exports: {} }).exports, B), B.exports;
            }, l = (v, B) => {
              for (var w in B)
                s(v, w, { get: B[w], enumerable: true });
            }, C = (v, B, w, I) => {
              if (B && typeof B == "object" || typeof B == "function")
                for (let E of r(B))
                  !a.call(v, E) && E !== w && s(v, E, { get: () => B[E], enumerable: !(I = i(B, E)) || I.enumerable });
              return v;
            }, m = (v, B, w) => (w = v != null ? t(u(v)) : {}, C(B || !v || !v.__esModule ? s(w, "default", { value: v, enumerable: true }) : w, v)), g = (v) => C(s({}, "__esModule", { value: true }), v), p = c({ "node_modules/emoji-regex/index.js"(v, B) {
              "use strict";
              B.exports = function() {
                return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
              };
            } }), f = {};
            l(f, { default: () => b }), n.exports = g(f);
            function h() {
              let { onlyFirst: v = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, B = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
              return new RegExp(B, v ? void 0 : "g");
            }
            function N(v) {
              if (typeof v != "string")
                throw new TypeError("Expected a `string`, got `".concat(typeof v, "`"));
              return v.replace(h(), "");
            }
            function T(v) {
              return Number.isInteger(v) ? v >= 4352 && (v <= 4447 || v === 9001 || v === 9002 || 11904 <= v && v <= 12871 && v !== 12351 || 12880 <= v && v <= 19903 || 19968 <= v && v <= 42182 || 43360 <= v && v <= 43388 || 44032 <= v && v <= 55203 || 63744 <= v && v <= 64255 || 65040 <= v && v <= 65049 || 65072 <= v && v <= 65131 || 65281 <= v && v <= 65376 || 65504 <= v && v <= 65510 || 110592 <= v && v <= 110593 || 127488 <= v && v <= 127569 || 131072 <= v && v <= 262141) : false;
            }
            var A = m(p(), 1);
            function b(v) {
              if (typeof v != "string" || v.length === 0 || (v = N(v), v.length === 0))
                return 0;
              v = v.replace((0, A.default)(), "  ");
              let B = 0;
              for (let w = 0; w < v.length; w++) {
                let I = v.codePointAt(w);
                I <= 31 || I >= 127 && I <= 159 || I >= 768 && I <= 879 || (I > 65535 && w++, B += T(I) ? 2 : 1);
              }
              return B;
            }
          } }), yi = Z({ "src/utils/get-string-width.js"(e, n) {
            "use strict";
            ae();
            var t = nD().default, s = /[^\x20-\x7F]/;
            function i(r) {
              return r ? s.test(r) ? t(r) : r.length : 0;
            }
            n.exports = i;
          } }), jn = Z({ "src/document/doc-utils.js"(e, n) {
            "use strict";
            ae();
            var t = st(), { literalline: s, join: i } = Ln(), r = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
              if (Array.isArray(o))
                return o;
              if (o.type !== "concat" && o.type !== "fill")
                throw new Error("Expect doc type to be `concat` or `fill`.");
              return o.parts;
            }, a = {};
            function c(o, x, F, S) {
              let k = [o];
              for (; k.length > 0; ) {
                let _ = k.pop();
                if (_ === a) {
                  F(k.pop());
                  continue;
                }
                if (F && k.push(_, a), !x || x(_) !== false)
                  if (r(_) || _.type === "fill") {
                    let O = u(_);
                    for (let R = O.length, M = R - 1; M >= 0; --M)
                      k.push(O[M]);
                  } else if (_.type === "if-break")
                    _.flatContents && k.push(_.flatContents), _.breakContents && k.push(_.breakContents);
                  else if (_.type === "group" && _.expandedStates)
                    if (S)
                      for (let O = _.expandedStates.length, R = O - 1; R >= 0; --R)
                        k.push(_.expandedStates[R]);
                    else
                      k.push(_.contents);
                  else
                    _.contents && k.push(_.contents);
              }
            }
            function l(o, x) {
              let F = /* @__PURE__ */ new Map();
              return S(o);
              function S(_) {
                if (F.has(_))
                  return F.get(_);
                let O = k(_);
                return F.set(_, O), O;
              }
              function k(_) {
                if (Array.isArray(_))
                  return x(_.map(S));
                if (_.type === "concat" || _.type === "fill") {
                  let O = _.parts.map(S);
                  return x(Object.assign(Object.assign({}, _), {}, { parts: O }));
                }
                if (_.type === "if-break") {
                  let O = _.breakContents && S(_.breakContents), R = _.flatContents && S(_.flatContents);
                  return x(Object.assign(Object.assign({}, _), {}, { breakContents: O, flatContents: R }));
                }
                if (_.type === "group" && _.expandedStates) {
                  let O = _.expandedStates.map(S), R = O[0];
                  return x(Object.assign(Object.assign({}, _), {}, { contents: R, expandedStates: O }));
                }
                if (_.contents) {
                  let O = S(_.contents);
                  return x(Object.assign(Object.assign({}, _), {}, { contents: O }));
                }
                return x(_);
              }
            }
            function C(o, x, F) {
              let S = F, k = false;
              function _(O) {
                let R = x(O);
                if (R !== void 0 && (k = true, S = R), k)
                  return false;
              }
              return c(o, _), S;
            }
            function m(o) {
              if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
                return true;
            }
            function g(o) {
              return C(o, m, false);
            }
            function p(o) {
              if (o.length > 0) {
                let x = t(o);
                !x.expandedStates && !x.break && (x.break = "propagated");
              }
              return null;
            }
            function f(o) {
              let x = /* @__PURE__ */ new Set(), F = [];
              function S(_) {
                if (_.type === "break-parent" && p(F), _.type === "group") {
                  if (F.push(_), x.has(_))
                    return false;
                  x.add(_);
                }
              }
              function k(_) {
                _.type === "group" && F.pop().break && p(F);
              }
              c(o, S, k, true);
            }
            function h(o) {
              return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
            }
            function N(o) {
              return l(o, h);
            }
            var T = (o, x) => o && o.type === "line" && o.hard && x && x.type === "break-parent";
            function A(o) {
              if (!o)
                return o;
              if (r(o) || o.type === "fill") {
                let x = u(o);
                for (; x.length > 1 && T(...x.slice(-2)); )
                  x.length -= 2;
                if (x.length > 0) {
                  let F = A(t(x));
                  x[x.length - 1] = F;
                }
                return Array.isArray(o) ? x : Object.assign(Object.assign({}, o), {}, { parts: x });
              }
              switch (o.type) {
                case "align":
                case "indent":
                case "indent-if-break":
                case "group":
                case "line-suffix":
                case "label": {
                  let x = A(o.contents);
                  return Object.assign(Object.assign({}, o), {}, { contents: x });
                }
                case "if-break": {
                  let x = A(o.breakContents), F = A(o.flatContents);
                  return Object.assign(Object.assign({}, o), {}, { breakContents: x, flatContents: F });
                }
              }
              return o;
            }
            function b(o) {
              return A(B(o));
            }
            function v(o) {
              switch (o.type) {
                case "fill":
                  if (o.parts.every((F) => F === ""))
                    return "";
                  break;
                case "group":
                  if (!o.contents && !o.id && !o.break && !o.expandedStates)
                    return "";
                  if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                    return o.contents;
                  break;
                case "align":
                case "indent":
                case "indent-if-break":
                case "line-suffix":
                  if (!o.contents)
                    return "";
                  break;
                case "if-break":
                  if (!o.flatContents && !o.breakContents)
                    return "";
                  break;
              }
              if (!r(o))
                return o;
              let x = [];
              for (let F of u(o)) {
                if (!F)
                  continue;
                let [S, ...k] = r(F) ? u(F) : [F];
                typeof S == "string" && typeof t(x) == "string" ? x[x.length - 1] += S : x.push(S), x.push(...k);
              }
              return x.length === 0 ? "" : x.length === 1 ? x[0] : Array.isArray(o) ? x : Object.assign(Object.assign({}, o), {}, { parts: x });
            }
            function B(o) {
              return l(o, (x) => v(x));
            }
            function w(o) {
              let x = [], F = o.filter(Boolean);
              for (; F.length > 0; ) {
                let S = F.shift();
                if (!!S) {
                  if (r(S)) {
                    F.unshift(...u(S));
                    continue;
                  }
                  if (x.length > 0 && typeof t(x) == "string" && typeof S == "string") {
                    x[x.length - 1] += S;
                    continue;
                  }
                  x.push(S);
                }
              }
              return x;
            }
            function I(o) {
              return l(o, (x) => Array.isArray(x) ? w(x) : x.parts ? Object.assign(Object.assign({}, x), {}, { parts: w(x.parts) }) : x);
            }
            function E(o) {
              return l(o, (x) => typeof x == "string" && x.includes(`
`) ? D(x) : x);
            }
            function D(o) {
              let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
              return i(x, o.split(`
`)).parts;
            }
            function d(o) {
              if (o.type === "line")
                return true;
            }
            function y(o) {
              return C(o, d, false);
            }
            n.exports = { isConcat: r, getDocParts: u, willBreak: g, traverseDoc: c, findInDoc: C, mapDoc: l, propagateBreaks: f, removeLines: N, stripTrailingHardline: b, normalizeParts: w, normalizeDoc: I, cleanDoc: B, replaceTextEndOfLine: D, replaceEndOfLine: E, canBreak: y };
          } }), uD = Z({ "src/document/doc-printer.js"(e, n) {
            "use strict";
            ae();
            var { convertEndOfLineToChars: t } = On(), s = st(), i = yi(), { fill: r, cursor: u, indent: a } = Ln(), { isConcat: c, getDocParts: l } = jn(), C, m = 1, g = 2;
            function p() {
              return { value: "", length: 0, queue: [] };
            }
            function f(v, B) {
              return N(v, { type: "indent" }, B);
            }
            function h(v, B, w) {
              return B === Number.NEGATIVE_INFINITY ? v.root || p() : B < 0 ? N(v, { type: "dedent" }, w) : B ? B.type === "root" ? Object.assign(Object.assign({}, v), {}, { root: v }) : N(v, { type: typeof B == "string" ? "stringAlign" : "numberAlign", n: B }, w) : v;
            }
            function N(v, B, w) {
              let I = B.type === "dedent" ? v.queue.slice(0, -1) : [...v.queue, B], E = "", D = 0, d = 0, y = 0;
              for (let O of I)
                switch (O.type) {
                  case "indent":
                    F(), w.useTabs ? o(1) : x(w.tabWidth);
                    break;
                  case "stringAlign":
                    F(), E += O.n, D += O.n.length;
                    break;
                  case "numberAlign":
                    d += 1, y += O.n;
                    break;
                  default:
                    throw new Error("Unexpected type '".concat(O.type, "'"));
                }
              return k(), Object.assign(Object.assign({}, v), {}, { value: E, length: D, queue: I });
              function o(O) {
                E += "	".repeat(O), D += w.tabWidth * O;
              }
              function x(O) {
                E += " ".repeat(O), D += O;
              }
              function F() {
                w.useTabs ? S() : k();
              }
              function S() {
                d > 0 && o(d), _();
              }
              function k() {
                y > 0 && x(y), _();
              }
              function _() {
                d = 0, y = 0;
              }
            }
            function T(v) {
              if (v.length === 0)
                return 0;
              let B = 0;
              for (; v.length > 0 && typeof s(v) == "string" && /^[\t ]*$/.test(s(v)); )
                B += v.pop().length;
              if (v.length > 0 && typeof s(v) == "string") {
                let w = s(v).replace(/[\t ]*$/, "");
                B += s(v).length - w.length, v[v.length - 1] = w;
              }
              return B;
            }
            function A(v, B, w, I, E, D) {
              let d = B.length, y = [v], o = [];
              for (; w >= 0; ) {
                if (y.length === 0) {
                  if (d === 0)
                    return true;
                  y.push(B[d - 1]), d--;
                  continue;
                }
                let [x, F, S] = y.pop();
                if (typeof S == "string")
                  o.push(S), w -= i(S);
                else if (c(S)) {
                  let k = l(S);
                  for (let _ = k.length - 1; _ >= 0; _--)
                    y.push([x, F, k[_]]);
                } else
                  switch (S.type) {
                    case "indent":
                      y.push([f(x, I), F, S.contents]);
                      break;
                    case "align":
                      y.push([h(x, S.n, I), F, S.contents]);
                      break;
                    case "trim":
                      w += T(o);
                      break;
                    case "group": {
                      if (D && S.break)
                        return false;
                      let k = S.break ? m : F;
                      y.push([x, k, S.expandedStates && k === m ? s(S.expandedStates) : S.contents]), S.id && (C[S.id] = k);
                      break;
                    }
                    case "fill":
                      for (let k = S.parts.length - 1; k >= 0; k--)
                        y.push([x, F, S.parts[k]]);
                      break;
                    case "if-break":
                    case "indent-if-break": {
                      let k = S.groupId ? C[S.groupId] : F;
                      if (k === m) {
                        let _ = S.type === "if-break" ? S.breakContents : S.negate ? S.contents : a(S.contents);
                        _ && y.push([x, F, _]);
                      }
                      if (k === g) {
                        let _ = S.type === "if-break" ? S.flatContents : S.negate ? a(S.contents) : S.contents;
                        _ && y.push([x, F, _]);
                      }
                      break;
                    }
                    case "line":
                      switch (F) {
                        case g:
                          if (!S.hard) {
                            S.soft || (o.push(" "), w -= 1);
                            break;
                          }
                          return true;
                        case m:
                          return true;
                      }
                      break;
                    case "line-suffix":
                      E = true;
                      break;
                    case "line-suffix-boundary":
                      if (E)
                        return false;
                      break;
                    case "label":
                      y.push([x, F, S.contents]);
                      break;
                  }
              }
              return false;
            }
            function b(v, B) {
              C = {};
              let w = B.printWidth, I = t(B.endOfLine), E = 0, D = [[p(), m, v]], d = [], y = false, o = [];
              for (; D.length > 0; ) {
                let [F, S, k] = D.pop();
                if (typeof k == "string") {
                  let _ = I !== `
` ? k.replace(/\n/g, I) : k;
                  d.push(_), E += i(_);
                } else if (c(k)) {
                  let _ = l(k);
                  for (let O = _.length - 1; O >= 0; O--)
                    D.push([F, S, _[O]]);
                } else
                  switch (k.type) {
                    case "cursor":
                      d.push(u.placeholder);
                      break;
                    case "indent":
                      D.push([f(F, B), S, k.contents]);
                      break;
                    case "align":
                      D.push([h(F, k.n, B), S, k.contents]);
                      break;
                    case "trim":
                      E -= T(d);
                      break;
                    case "group":
                      switch (S) {
                        case g:
                          if (!y) {
                            D.push([F, k.break ? m : g, k.contents]);
                            break;
                          }
                        case m: {
                          y = false;
                          let _ = [F, g, k.contents], O = w - E, R = o.length > 0;
                          if (!k.break && A(_, D, O, B, R))
                            D.push(_);
                          else if (k.expandedStates) {
                            let M = s(k.expandedStates);
                            if (k.break) {
                              D.push([F, m, M]);
                              break;
                            } else
                              for (let H = 1; H < k.expandedStates.length + 1; H++)
                                if (H >= k.expandedStates.length) {
                                  D.push([F, m, M]);
                                  break;
                                } else {
                                  let P = k.expandedStates[H], G = [F, g, P];
                                  if (A(G, D, O, B, R)) {
                                    D.push(G);
                                    break;
                                  }
                                }
                          } else
                            D.push([F, m, k.contents]);
                          break;
                        }
                      }
                      k.id && (C[k.id] = s(D)[1]);
                      break;
                    case "fill": {
                      let _ = w - E, { parts: O } = k;
                      if (O.length === 0)
                        break;
                      let [R, M] = O, H = [F, g, R], P = [F, m, R], G = A(H, [], _, B, o.length > 0, true);
                      if (O.length === 1) {
                        G ? D.push(H) : D.push(P);
                        break;
                      }
                      let re = [F, g, M], $ = [F, m, M];
                      if (O.length === 2) {
                        G ? D.push(re, H) : D.push($, P);
                        break;
                      }
                      O.splice(0, 2);
                      let W = [F, S, r(O)], ee = O[0];
                      A([F, g, [R, M, ee]], [], _, B, o.length > 0, true) ? D.push(W, re, H) : G ? D.push(W, $, H) : D.push(W, $, P);
                      break;
                    }
                    case "if-break":
                    case "indent-if-break": {
                      let _ = k.groupId ? C[k.groupId] : S;
                      if (_ === m) {
                        let O = k.type === "if-break" ? k.breakContents : k.negate ? k.contents : a(k.contents);
                        O && D.push([F, S, O]);
                      }
                      if (_ === g) {
                        let O = k.type === "if-break" ? k.flatContents : k.negate ? a(k.contents) : k.contents;
                        O && D.push([F, S, O]);
                      }
                      break;
                    }
                    case "line-suffix":
                      o.push([F, S, k.contents]);
                      break;
                    case "line-suffix-boundary":
                      o.length > 0 && D.push([F, S, { type: "line", hard: true }]);
                      break;
                    case "line":
                      switch (S) {
                        case g:
                          if (k.hard)
                            y = true;
                          else {
                            k.soft || (d.push(" "), E += 1);
                            break;
                          }
                        case m:
                          if (o.length > 0) {
                            D.push([F, S, k], ...o.reverse()), o = [];
                            break;
                          }
                          k.literal ? F.root ? (d.push(I, F.root.value), E = F.root.length) : (d.push(I), E = 0) : (E -= T(d), d.push(I + F.value), E = F.length);
                          break;
                      }
                      break;
                    case "label":
                      D.push([F, S, k.contents]);
                      break;
                    default:
                  }
                D.length === 0 && o.length > 0 && (D.push(...o.reverse()), o = []);
              }
              let x = d.indexOf(u.placeholder);
              if (x !== -1) {
                let F = d.indexOf(u.placeholder, x + 1), S = d.slice(0, x).join(""), k = d.slice(x + 1, F).join(""), _ = d.slice(F + 1).join("");
                return { formatted: S + k + _, cursorNodeStart: S.length, cursorNodeText: k };
              }
              return { formatted: d.join("") };
            }
            n.exports = { printDocToString: b };
          } }), sD = Z({ "src/document/doc-debug.js"(e, n) {
            "use strict";
            ae();
            var { isConcat: t, getDocParts: s } = jn();
            function i(u) {
              if (!u)
                return "";
              if (t(u)) {
                let a = [];
                for (let c of s(u))
                  if (t(c))
                    a.push(...i(c).parts);
                  else {
                    let l = i(c);
                    l !== "" && a.push(l);
                  }
                return { type: "concat", parts: a };
              }
              return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: i(u.breakContents), flatContents: i(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: i(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(i) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(i) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: i(u.contents) }) : u;
            }
            function r(u) {
              let a = /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ new Set();
              return l(i(u));
              function l(m, g, p) {
                if (typeof m == "string")
                  return JSON.stringify(m);
                if (t(m)) {
                  let f = s(m).map(l).filter(Boolean);
                  return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
                }
                if (m.type === "line") {
                  let f = Array.isArray(p) && p[g + 1] && p[g + 1].type === "break-parent";
                  return m.literal ? f ? "literalline" : "literallineWithoutBreakParent" : m.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : m.soft ? "softline" : "line";
                }
                if (m.type === "break-parent")
                  return Array.isArray(p) && p[g - 1] && p[g - 1].type === "line" && p[g - 1].hard ? void 0 : "breakParent";
                if (m.type === "trim")
                  return "trim";
                if (m.type === "indent")
                  return "indent(" + l(m.contents) + ")";
                if (m.type === "align")
                  return m.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + l(m.contents) + ")" : m.n < 0 ? "dedent(" + l(m.contents) + ")" : m.n.type === "root" ? "markAsRoot(" + l(m.contents) + ")" : "align(" + JSON.stringify(m.n) + ", " + l(m.contents) + ")";
                if (m.type === "if-break")
                  return "ifBreak(" + l(m.breakContents) + (m.flatContents ? ", " + l(m.flatContents) : "") + (m.groupId ? (m.flatContents ? "" : ', ""') + ", { groupId: ".concat(C(m.groupId), " }") : "") + ")";
                if (m.type === "indent-if-break") {
                  let f = [];
                  m.negate && f.push("negate: true"), m.groupId && f.push("groupId: ".concat(C(m.groupId)));
                  let h = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                  return "indentIfBreak(".concat(l(m.contents)).concat(h, ")");
                }
                if (m.type === "group") {
                  let f = [];
                  m.break && m.break !== "propagated" && f.push("shouldBreak: true"), m.id && f.push("id: ".concat(C(m.id)));
                  let h = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                  return m.expandedStates ? "conditionalGroup([".concat(m.expandedStates.map((N) => l(N)).join(","), "]").concat(h, ")") : "group(".concat(l(m.contents)).concat(h, ")");
                }
                if (m.type === "fill")
                  return "fill([".concat(m.parts.map((f) => l(f)).join(", "), "])");
                if (m.type === "line-suffix")
                  return "lineSuffix(" + l(m.contents) + ")";
                if (m.type === "line-suffix-boundary")
                  return "lineSuffixBoundary";
                if (m.type === "label")
                  return "label(".concat(JSON.stringify(m.label), ", ").concat(l(m.contents), ")");
                throw new Error("Unknown doc type " + m.type);
              }
              function C(m) {
                if (typeof m != "symbol")
                  return JSON.stringify(String(m));
                if (m in a)
                  return a[m];
                let g = String(m).slice(7, -1) || "symbol";
                for (let p = 0; ; p++) {
                  let f = g + (p > 0 ? " #".concat(p) : "");
                  if (!c.has(f))
                    return c.add(f), a[m] = "Symbol.for(".concat(JSON.stringify(f), ")");
                }
              }
            }
            n.exports = { printDocToDebug: r };
          } }), Le = Z({ "src/document/index.js"(e, n) {
            "use strict";
            ae(), n.exports = { builders: Ln(), printer: uD(), utils: jn(), debug: sD() };
          } }), aD = Z({ "vendors/escape-string-regexp.js"(e, n) {
            ae();
            var t = Object.defineProperty, s = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, r = Object.prototype.hasOwnProperty, u = (m, g) => {
              for (var p in g)
                t(m, p, { get: g[p], enumerable: true });
            }, a = (m, g, p, f) => {
              if (g && typeof g == "object" || typeof g == "function")
                for (let h of i(g))
                  !r.call(m, h) && h !== p && t(m, h, { get: () => g[h], enumerable: !(f = s(g, h)) || f.enumerable });
              return m;
            }, c = (m) => a(t({}, "__esModule", { value: true }), m), l = {};
            u(l, { default: () => C }), n.exports = c(l);
            function C(m) {
              if (typeof m != "string")
                throw new TypeError("Expected a string");
              return m.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
            }
          } }), hi = Z({ "node_modules/semver/internal/debug.js"(e, n) {
            ae();
            var t = typeof xt == "object" && xt.env && xt.env.NODE_DEBUG && /\bsemver\b/i.test(xt.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++)
                i[r] = arguments[r];
              return console.error("SEMVER", ...i);
            } : () => {
            };
            n.exports = t;
          } }), Ci = Z({ "node_modules/semver/internal/constants.js"(e, n) {
            ae();
            var t = "2.0.0", s = 256, i = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
            n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: i, MAX_SAFE_COMPONENT_LENGTH: r };
          } }), iD = Z({ "node_modules/semver/internal/re.js"(e, n) {
            ae();
            var { MAX_SAFE_COMPONENT_LENGTH: t } = Ci(), s = hi();
            e = n.exports = {};
            var i = e.re = [], r = e.src = [], u = e.t = {}, a = 0, c = (l, C, m) => {
              let g = a++;
              s(g, C), u[l] = g, r[g] = C, i[g] = new RegExp(C, m ? "g" : void 0);
            };
            c("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), c("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), c("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), c("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), c("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), c("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), c("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), c("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), c("FULL", "^".concat(r[u.FULLPLAIN], "$")), c("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), c("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), c("GTLT", "((?:<|>)?=?)"), c("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), c("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), c("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), c("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), c("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), c("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), c("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), c("COERCERTL", r[u.COERCE], true), c("LONETILDE", "(?:~>?)"), c("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", c("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), c("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), c("LONECARET", "(?:\\^)"), c("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", c("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), c("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), c("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), c("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), c("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", c("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), c("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), c("STAR", "(<|>)?=?\\s*\\*"), c("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
          } }), oD = Z({ "node_modules/semver/internal/parse-options.js"(e, n) {
            ae();
            var t = ["includePrerelease", "loose", "rtl"], s = (i) => i ? typeof i != "object" ? { loose: true } : t.filter((r) => i[r]).reduce((r, u) => (r[u] = true, r), {}) : {};
            n.exports = s;
          } }), cD = Z({ "node_modules/semver/internal/identifiers.js"(e, n) {
            ae();
            var t = /^[0-9]+$/, s = (r, u) => {
              let a = t.test(r), c = t.test(u);
              return a && c && (r = +r, u = +u), r === u ? 0 : a && !c ? -1 : c && !a ? 1 : r < u ? -1 : 1;
            }, i = (r, u) => s(u, r);
            n.exports = { compareIdentifiers: s, rcompareIdentifiers: i };
          } }), lD = Z({ "node_modules/semver/classes/semver.js"(e, n) {
            ae();
            var t = hi(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: i } = Ci(), { re: r, t: u } = iD(), a = oD(), { compareIdentifiers: c } = cD(), l = class {
              constructor(C, m) {
                if (m = a(m), C instanceof l) {
                  if (C.loose === !!m.loose && C.includePrerelease === !!m.includePrerelease)
                    return C;
                  C = C.version;
                } else if (typeof C != "string")
                  throw new TypeError("Invalid Version: ".concat(C));
                if (C.length > s)
                  throw new TypeError("version is longer than ".concat(s, " characters"));
                t("SemVer", C, m), this.options = m, this.loose = !!m.loose, this.includePrerelease = !!m.includePrerelease;
                let g = C.trim().match(m.loose ? r[u.LOOSE] : r[u.FULL]);
                if (!g)
                  throw new TypeError("Invalid Version: ".concat(C));
                if (this.raw = C, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > i || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > i || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > i || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                g[4] ? this.prerelease = g[4].split(".").map((p) => {
                  if (/^[0-9]+$/.test(p)) {
                    let f = +p;
                    if (f >= 0 && f < i)
                      return f;
                  }
                  return p;
                }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
              }
              format() {
                return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
              }
              toString() {
                return this.version;
              }
              compare(C) {
                if (t("SemVer.compare", this.version, this.options, C), !(C instanceof l)) {
                  if (typeof C == "string" && C === this.version)
                    return 0;
                  C = new l(C, this.options);
                }
                return C.version === this.version ? 0 : this.compareMain(C) || this.comparePre(C);
              }
              compareMain(C) {
                return C instanceof l || (C = new l(C, this.options)), c(this.major, C.major) || c(this.minor, C.minor) || c(this.patch, C.patch);
              }
              comparePre(C) {
                if (C instanceof l || (C = new l(C, this.options)), this.prerelease.length && !C.prerelease.length)
                  return -1;
                if (!this.prerelease.length && C.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !C.prerelease.length)
                  return 0;
                let m = 0;
                do {
                  let g = this.prerelease[m], p = C.prerelease[m];
                  if (t("prerelease compare", m, g, p), g === void 0 && p === void 0)
                    return 0;
                  if (p === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === p)
                    continue;
                  return c(g, p);
                } while (++m);
              }
              compareBuild(C) {
                C instanceof l || (C = new l(C, this.options));
                let m = 0;
                do {
                  let g = this.build[m], p = C.build[m];
                  if (t("prerelease compare", m, g, p), g === void 0 && p === void 0)
                    return 0;
                  if (p === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === p)
                    continue;
                  return c(g, p);
                } while (++m);
              }
              inc(C, m) {
                switch (C) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", m), this.inc("pre", m);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", m), this.inc("pre", m);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let g = this.prerelease.length;
                      for (; --g >= 0; )
                        typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                      g === -1 && this.prerelease.push(0);
                    }
                    m && (this.prerelease[0] === m ? isNaN(this.prerelease[1]) && (this.prerelease = [m, 0]) : this.prerelease = [m, 0]);
                    break;
                  default:
                    throw new Error("invalid increment argument: ".concat(C));
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            n.exports = l;
          } }), qn = Z({ "node_modules/semver/functions/compare.js"(e, n) {
            ae();
            var t = lD(), s = (i, r, u) => new t(i, u).compare(new t(r, u));
            n.exports = s;
          } }), pD = Z({ "node_modules/semver/functions/lt.js"(e, n) {
            ae();
            var t = qn(), s = (i, r, u) => t(i, r, u) < 0;
            n.exports = s;
          } }), fD = Z({ "node_modules/semver/functions/gte.js"(e, n) {
            ae();
            var t = qn(), s = (i, r, u) => t(i, r, u) >= 0;
            n.exports = s;
          } }), DD = Z({ "src/utils/arrayify.js"(e, n) {
            "use strict";
            ae(), n.exports = (t, s) => Object.entries(t).map((i) => {
              let [r, u] = i;
              return Object.assign({ [s]: r }, u);
            });
          } }), mD = Z({ "node_modules/outdent/lib/index.js"(e, n) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function t() {
              for (var A = [], b = 0; b < arguments.length; b++)
                A[b] = arguments[b];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : i();
            }
            function i() {
              return { add: t, delete: t, get: t, set: t, has: function(A) {
                return false;
              } };
            }
            var r = Object.prototype.hasOwnProperty, u = function(A, b) {
              return r.call(A, b);
            };
            function a(A, b) {
              for (var v in b)
                u(b, v) && (A[v] = b[v]);
              return A;
            }
            var c = /^[ \t]*(?:\r\n|\r|\n)/, l = /(?:\r\n|\r|\n)[ \t]*$/, C = /^(?:[\r\n]|$)/, m = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function p(A, b, v) {
              var B = 0, w = A[0].match(m);
              w && (B = w[1].length);
              var I = "(\\r\\n|\\r|\\n).{0," + B + "}", E = new RegExp(I, "g");
              b && (A = A.slice(1));
              var D = v.newline, d = v.trimLeadingNewline, y = v.trimTrailingNewline, o = typeof D == "string", x = A.length, F = A.map(function(S, k) {
                return S = S.replace(E, "$1"), k === 0 && d && (S = S.replace(c, "")), k === x - 1 && y && (S = S.replace(l, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(_) {
                  return D;
                })), S;
              });
              return F;
            }
            function f(A, b) {
              for (var v = "", B = 0, w = A.length; B < w; B++)
                v += A[B], B < w - 1 && (v += b[B]);
              return v;
            }
            function h(A) {
              return u(A, "raw") && u(A, "length");
            }
            function N(A) {
              var b = s(), v = s();
              function B(I) {
                for (var E = [], D = 1; D < arguments.length; D++)
                  E[D - 1] = arguments[D];
                if (h(I)) {
                  var d = I, y = (E[0] === B || E[0] === T) && g.test(d[0]) && C.test(d[1]), o = y ? v : b, x = o.get(d);
                  if (x || (x = p(d, y, A), o.set(d, x)), E.length === 0)
                    return x[0];
                  var F = f(x, y ? E.slice(1) : E);
                  return F;
                } else
                  return N(a(a({}, A), I || {}));
              }
              var w = a(B, { string: function(I) {
                return p([I], false, A)[0];
              } });
              return w;
            }
            var T = N({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = T, e.default = T, typeof n < "u")
              try {
                n.exports = T, Object.defineProperty(T, "__esModule", { value: true }), T.default = T, T.outdent = T;
              } catch {
              }
          } }), dD = Z({ "src/main/core-options.js"(e, n) {
            "use strict";
            ae();
            var { outdent: t } = mD(), s = "Config", i = "Editor", r = "Format", u = "Other", a = "Output", c = "Global", l = "Special", C = { cursorOffset: { since: "1.4.0", category: l, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(si || (si = wt([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: i }, endOfLine: { since: "1.15.0", category: c, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(ai || (ai = wt([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: l, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: l, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: c, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (m) => typeof m == "string" || typeof m == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: c, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (m) => typeof m == "string" || typeof m == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: c, description: t(ii || (ii = wt([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (m) => typeof m == "string" || typeof m == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: c, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: l, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(oi || (oi = wt([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: i }, rangeStart: { since: "1.4.0", category: l, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(ci || (ci = wt([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: i }, requirePragma: { since: "1.7.0", category: l, type: "boolean", default: false, description: t(li || (li = wt([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: u }, tabWidth: { type: "int", category: c, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: c, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: c, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            n.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: i, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: a, CATEGORY_GLOBAL: c, CATEGORY_SPECIAL: l, options: C };
          } }), Mn = Z({ "src/main/support.js"(e, n) {
            "use strict";
            ae();
            var t = { compare: qn(), lt: pD(), gte: fD() }, s = DD(), i = gi().version, r = dD().options;
            function u() {
              let { plugins: c = [], showUnreleased: l = false, showDeprecated: C = false, showInternal: m = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = i.split("-", 1)[0], p = c.flatMap((A) => A.languages || []).filter(h), f = s(Object.assign({}, ...c.map((A) => {
                let { options: b } = A;
                return b;
              }), r), "name").filter((A) => h(A) && N(A)).sort((A, b) => A.name === b.name ? 0 : A.name < b.name ? -1 : 1).map(T).map((A) => {
                A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h).sort((v, B) => t.compare(B.since, v.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter((v) => h(v) && N(v)), A.name === "parser" && a(A, p, c));
                let b = Object.fromEntries(c.filter((v) => v.defaultOptions && v.defaultOptions[A.name] !== void 0).map((v) => [v.name, v.defaultOptions[A.name]]));
                return Object.assign(Object.assign({}, A), {}, { pluginDefaults: b });
              });
              return { languages: p, options: f };
              function h(A) {
                return l || !("since" in A) || A.since && t.gte(g, A.since);
              }
              function N(A) {
                return C || !("deprecated" in A) || A.deprecated && t.lt(g, A.deprecated);
              }
              function T(A) {
                if (m)
                  return A;
                let { cliName: b, cliCategory: v, cliDescription: B } = A;
                return _n(A, zf);
              }
            }
            function a(c, l, C) {
              let m = new Set(c.choices.map((g) => g.value));
              for (let g of l)
                if (g.parsers) {
                  for (let p of g.parsers)
                    if (!m.has(p)) {
                      m.add(p);
                      let f = C.find((N) => N.parsers && N.parsers[p]), h = g.name;
                      f && f.name && (h += " (plugin: ".concat(f.name, ")")), c.choices.push({ value: p, description: h });
                    }
                }
            }
            n.exports = { getSupportInfo: u };
          } }), Rn = Z({ "src/utils/is-non-empty-array.js"(e, n) {
            "use strict";
            ae();
            function t(s) {
              return Array.isArray(s) && s.length > 0;
            }
            n.exports = t;
          } }), Tr = Z({ "src/utils/text/skip.js"(e, n) {
            "use strict";
            ae();
            function t(a) {
              return (c, l, C) => {
                let m = C && C.backwards;
                if (l === false)
                  return false;
                let { length: g } = c, p = l;
                for (; p >= 0 && p < g; ) {
                  let f = c.charAt(p);
                  if (a instanceof RegExp) {
                    if (!a.test(f))
                      return p;
                  } else if (!a.includes(f))
                    return p;
                  m ? p-- : p++;
                }
                return p === -1 || p === g ? p : false;
              };
            }
            var s = t(/\s/), i = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
            n.exports = { skipWhitespace: s, skipSpaces: i, skipToLineEnd: r, skipEverythingButNewLine: u };
          } }), Ei = Z({ "src/utils/text/skip-inline-comment.js"(e, n) {
            "use strict";
            ae();
            function t(s, i) {
              if (i === false)
                return false;
              if (s.charAt(i) === "/" && s.charAt(i + 1) === "*") {
                for (let r = i + 2; r < s.length; ++r)
                  if (s.charAt(r) === "*" && s.charAt(r + 1) === "/")
                    return r + 2;
              }
              return i;
            }
            n.exports = t;
          } }), vi = Z({ "src/utils/text/skip-trailing-comment.js"(e, n) {
            "use strict";
            ae();
            var { skipEverythingButNewLine: t } = Tr();
            function s(i, r) {
              return r === false ? false : i.charAt(r) === "/" && i.charAt(r + 1) === "/" ? t(i, r) : r;
            }
            n.exports = s;
          } }), Fi = Z({ "src/utils/text/skip-newline.js"(e, n) {
            "use strict";
            ae();
            function t(s, i, r) {
              let u = r && r.backwards;
              if (i === false)
                return false;
              let a = s.charAt(i);
              if (u) {
                if (s.charAt(i - 1) === "\r" && a === `
`)
                  return i - 2;
                if (a === `
` || a === "\r" || a === "\u2028" || a === "\u2029")
                  return i - 1;
              } else {
                if (a === "\r" && s.charAt(i + 1) === `
`)
                  return i + 2;
                if (a === `
` || a === "\r" || a === "\u2028" || a === "\u2029")
                  return i + 1;
              }
              return i;
            }
            n.exports = t;
          } }), gD = Z({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
            "use strict";
            ae();
            var t = Ei(), s = Fi(), i = vi(), { skipSpaces: r } = Tr();
            function u(a, c) {
              let l = null, C = c;
              for (; C !== l; )
                l = C, C = r(a, C), C = t(a, C), C = i(a, C), C = s(a, C);
              return C;
            }
            n.exports = u;
          } }), Ge = Z({ "src/common/util.js"(e, n) {
            "use strict";
            ae();
            var { default: t } = aD(), s = st(), { getSupportInfo: i } = Mn(), r = Rn(), u = yi(), { skipWhitespace: a, skipSpaces: c, skipToLineEnd: l, skipEverythingButNewLine: C } = Tr(), m = Ei(), g = vi(), p = Fi(), f = gD(), h = ($) => $[$.length - 2];
            function N($) {
              return (W, ee, U) => {
                let ne = U && U.backwards;
                if (ee === false)
                  return false;
                let { length: se } = W, V = ee;
                for (; V >= 0 && V < se; ) {
                  let oe = W.charAt(V);
                  if ($ instanceof RegExp) {
                    if (!$.test(oe))
                      return V;
                  } else if (!$.includes(oe))
                    return V;
                  ne ? V-- : V++;
                }
                return V === -1 || V === se ? V : false;
              };
            }
            function T($, W) {
              let ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, U = c($, ee.backwards ? W - 1 : W, ee), ne = p($, U, ee);
              return U !== ne;
            }
            function A($, W, ee) {
              for (let U = W; U < ee; ++U)
                if ($.charAt(U) === `
`)
                  return true;
              return false;
            }
            function b($, W, ee) {
              let U = ee(W) - 1;
              U = c($, U, { backwards: true }), U = p($, U, { backwards: true }), U = c($, U, { backwards: true });
              let ne = p($, U, { backwards: true });
              return U !== ne;
            }
            function v($, W) {
              let ee = null, U = W;
              for (; U !== ee; )
                ee = U, U = l($, U), U = m($, U), U = c($, U);
              return U = g($, U), U = p($, U), U !== false && T($, U);
            }
            function B($, W, ee) {
              return v($, ee(W));
            }
            function w($, W, ee) {
              return f($, ee(W));
            }
            function I($, W, ee) {
              return $.charAt(w($, W, ee));
            }
            function E($, W) {
              let ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return c($, ee.backwards ? W - 1 : W, ee) !== W;
            }
            function D($, W) {
              let ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, U = 0;
              for (let ne = ee; ne < $.length; ++ne)
                $[ne] === "	" ? U = U + W - U % W : U++;
              return U;
            }
            function d($, W) {
              let ee = $.lastIndexOf(`
`);
              return ee === -1 ? 0 : D($.slice(ee + 1).match(/^[\t ]*/)[0], W);
            }
            function y($, W) {
              let ee = { quote: '"', regex: /"/g, escaped: "&quot;" }, U = { quote: "'", regex: /'/g, escaped: "&apos;" }, ne = W === "'" ? U : ee, se = ne === U ? ee : U, V = ne;
              if ($.includes(ne.quote) || $.includes(se.quote)) {
                let oe = ($.match(ne.regex) || []).length, K = ($.match(se.regex) || []).length;
                V = oe > K ? se : ne;
              }
              return V;
            }
            function o($, W) {
              let ee = $.slice(1, -1), U = W.parser === "json" || W.parser === "json5" && W.quoteProps === "preserve" && !W.singleQuote ? '"' : W.__isInHtmlAttribute ? "'" : y(ee, W.singleQuote ? "'" : '"').quote;
              return x(ee, U, !(W.parser === "css" || W.parser === "less" || W.parser === "scss" || W.__embeddedInHtml));
            }
            function x($, W, ee) {
              let U = W === '"' ? "'" : '"', ne = /\\(.)|(["'])/gs, se = $.replace(ne, (V, oe, K) => oe === U ? oe : K === W ? "\\" + K : K || (ee && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(oe) ? oe : "\\" + oe));
              return W + se + W;
            }
            function F($) {
              return $.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function S($, W) {
              let ee = $.match(new RegExp("(".concat(t(W), ")+"), "g"));
              return ee === null ? 0 : ee.reduce((U, ne) => Math.max(U, ne.length / W.length), 0);
            }
            function k($, W) {
              let ee = $.match(new RegExp("(".concat(t(W), ")+"), "g"));
              if (ee === null)
                return 0;
              let U = /* @__PURE__ */ new Map(), ne = 0;
              for (let se of ee) {
                let V = se.length / W.length;
                U.set(V, true), V > ne && (ne = V);
              }
              for (let se = 1; se < ne; se++)
                if (!U.get(se))
                  return se;
              return ne + 1;
            }
            function _($, W) {
              ($.comments || ($.comments = [])).push(W), W.printed = false, W.nodeDescription = re($);
            }
            function O($, W) {
              W.leading = true, W.trailing = false, _($, W);
            }
            function R($, W, ee) {
              W.leading = false, W.trailing = false, ee && (W.marker = ee), _($, W);
            }
            function M($, W) {
              W.leading = false, W.trailing = true, _($, W);
            }
            function H($, W) {
              let { languages: ee } = i({ plugins: W.plugins }), U = ee.find((ne) => {
                let { name: se } = ne;
                return se.toLowerCase() === $;
              }) || ee.find((ne) => {
                let { aliases: se } = ne;
                return Array.isArray(se) && se.includes($);
              }) || ee.find((ne) => {
                let { extensions: se } = ne;
                return Array.isArray(se) && se.includes(".".concat($));
              });
              return U && U.parsers[0];
            }
            function P($) {
              return $ && $.type === "front-matter";
            }
            function G($) {
              let W = /* @__PURE__ */ new WeakMap();
              return function(ee) {
                return W.has(ee) || W.set(ee, Symbol($)), W.get(ee);
              };
            }
            function re($) {
              let W = $.type || $.kind || "(unknown type)", ee = String($.name || $.id && (typeof $.id == "object" ? $.id.name : $.id) || $.key && (typeof $.key == "object" ? $.key.name : $.key) || $.value && (typeof $.value == "object" ? "" : String($.value)) || $.operator || "");
              return ee.length > 20 && (ee = ee.slice(0, 19) + "\u2026"), W + (ee ? " " + ee : "");
            }
            n.exports = { inferParserByLanguage: H, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: k, getPenultimate: h, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: w, getNextNonSpaceNonCommentCharacter: I, skip: N, skipWhitespace: a, skipSpaces: c, skipToLineEnd: l, skipEverythingButNewLine: C, skipInlineComment: m, skipTrailingComment: g, skipNewline: p, isNextLineEmptyAfterIndex: v, isNextLineEmpty: B, isPreviousLineEmpty: b, hasNewline: T, hasNewlineInRange: A, hasSpaces: E, getAlignmentSize: D, getIndentSize: d, getPreferredQuote: y, printString: o, printNumber: F, makeString: x, addLeadingComment: O, addDanglingComment: R, addTrailingComment: M, isFrontMatterNode: P, isNonEmptyArray: r, createGroupIdMapper: G };
          } }), Ai = {};
          kn(Ai, { basename: () => Bi, default: () => wi, delimiter: () => bn, dirname: () => Ti, extname: () => Ni, isAbsolute: () => Wn, join: () => xi, normalize: () => Vn, relative: () => bi, resolve: () => xr, sep: () => xn });
          function Si(e, n) {
            for (var t = 0, s = e.length - 1; s >= 0; s--) {
              var i = e[s];
              i === "." ? e.splice(s, 1) : i === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
            }
            if (n)
              for (; t--; t)
                e.unshift("..");
            return e;
          }
          function xr() {
            for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
              var s = t >= 0 ? arguments[t] : "/";
              if (typeof s != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!s)
                continue;
              e = s + "/" + e, n = s.charAt(0) === "/";
            }
            return e = Si($n(e.split("/"), function(i) {
              return !!i;
            }), !n).join("/"), (n ? "/" : "") + e || ".";
          }
          function Vn(e) {
            var n = Wn(e), t = _i(e, -1) === "/";
            return e = Si($n(e.split("/"), function(s) {
              return !!s;
            }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
          }
          function Wn(e) {
            return e.charAt(0) === "/";
          }
          function xi() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Vn($n(e, function(n, t) {
              if (typeof n != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return n;
            }).join("/"));
          }
          function bi(e, n) {
            e = xr(e).substr(1), n = xr(n).substr(1);
            function t(l) {
              for (var C = 0; C < l.length && l[C] === ""; C++)
                ;
              for (var m = l.length - 1; m >= 0 && l[m] === ""; m--)
                ;
              return C > m ? [] : l.slice(C, m - C + 1);
            }
            for (var s = t(e.split("/")), i = t(n.split("/")), r = Math.min(s.length, i.length), u = r, a = 0; a < r; a++)
              if (s[a] !== i[a]) {
                u = a;
                break;
              }
            for (var c = [], a = u; a < s.length; a++)
              c.push("..");
            return c = c.concat(i.slice(u)), c.join("/");
          }
          function Ti(e) {
            var n = Br(e), t = n[0], s = n[1];
            return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
          }
          function Bi(e, n) {
            var t = Br(e)[2];
            return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
          }
          function Ni(e) {
            return Br(e)[3];
          }
          function $n(e, n) {
            if (e.filter)
              return e.filter(n);
            for (var t = [], s = 0; s < e.length; s++)
              n(e[s], s, e) && t.push(e[s]);
            return t;
          }
          var Di, Br, xn, bn, wi, _i, yD = br({ "node-modules-polyfills:path"() {
            ae(), Di = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Br = function(e) {
              return Di.exec(e).slice(1);
            }, xn = "/", bn = ":", wi = { extname: Ni, basename: Bi, dirname: Ti, sep: xn, delimiter: bn, relative: bi, join: xi, isAbsolute: Wn, normalize: Vn, resolve: xr }, _i = "ab".substr(-1) === "b" ? function(e, n, t) {
              return e.substr(n, t);
            } : function(e, n, t) {
              return n < 0 && (n = e.length + n), e.substr(n, t);
            };
          } }), Pi = Z({ "node-modules-polyfills-commonjs:path"(e, n) {
            ae();
            var t = (yD(), pt(Ai));
            if (t && t.default) {
              n.exports = t.default;
              for (let s in t)
                n.exports[s] = t[s];
            } else
              t && (n.exports = t);
          } }), Jt = Z({ "src/common/errors.js"(e, n) {
            "use strict";
            ae();
            var t = class extends Error {
            }, s = class extends Error {
            }, i = class extends Error {
            }, r = class extends Error {
            };
            n.exports = { ConfigError: t, DebugError: s, UndefinedParserError: i, ArgExpansionBailout: r };
          } }), Dt = {};
          kn(Dt, { __assign: () => Sr, __asyncDelegator: () => wD, __asyncGenerator: () => ND, __asyncValues: () => _D, __await: () => Gt, __awaiter: () => AD, __classPrivateFieldGet: () => LD, __classPrivateFieldSet: () => OD, __createBinding: () => xD, __decorate: () => ED, __exportStar: () => bD, __extends: () => hD, __generator: () => SD, __importDefault: () => kD, __importStar: () => ID, __makeTemplateObject: () => PD, __metadata: () => FD, __param: () => vD, __read: () => Ii, __rest: () => CD, __spread: () => TD, __spreadArrays: () => BD, __values: () => Tn });
          function hD(e, n) {
            Ar(e, n);
            function t() {
              this.constructor = e;
            }
            e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
          }
          function CD(e, n) {
            var t = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var i = 0, s = Object.getOwnPropertySymbols(e); i < s.length; i++)
                n.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[i]) && (t[s[i]] = e[s[i]]);
            return t;
          }
          function ED(e, n, t, s) {
            var i = arguments.length, r = i < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              r = Reflect.decorate(e, n, t, s);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (u = e[a]) && (r = (i < 3 ? u(r) : i > 3 ? u(n, t, r) : u(n, t)) || r);
            return i > 3 && r && Object.defineProperty(n, t, r), r;
          }
          function vD(e, n) {
            return function(t, s) {
              n(t, s, e);
            };
          }
          function FD(e, n) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(e, n);
          }
          function AD(e, n, t, s) {
            function i(r) {
              return r instanceof t ? r : new t(function(u) {
                u(r);
              });
            }
            return new (t || (t = Promise))(function(r, u) {
              function a(C) {
                try {
                  l(s.next(C));
                } catch (m) {
                  u(m);
                }
              }
              function c(C) {
                try {
                  l(s.throw(C));
                } catch (m) {
                  u(m);
                }
              }
              function l(C) {
                C.done ? r(C.value) : i(C.value).then(a, c);
              }
              l((s = s.apply(e, n || [])).next());
            });
          }
          function SD(e, n) {
            var t = { label: 0, sent: function() {
              if (r[0] & 1)
                throw r[1];
              return r[1];
            }, trys: [], ops: [] }, s, i, r, u;
            return u = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
              return this;
            }), u;
            function a(l) {
              return function(C) {
                return c([l, C]);
              };
            }
            function c(l) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; t; )
                try {
                  if (s = 1, i && (r = l[0] & 2 ? i.return : l[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, l[1])).done)
                    return r;
                  switch (i = 0, r && (l = [l[0] & 2, r.value]), l[0]) {
                    case 0:
                    case 1:
                      r = l;
                      break;
                    case 4:
                      return t.label++, { value: l[1], done: false };
                    case 5:
                      t.label++, i = l[1], l = [0];
                      continue;
                    case 7:
                      l = t.ops.pop(), t.trys.pop();
                      continue;
                    default:
                      if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                        t = 0;
                        continue;
                      }
                      if (l[0] === 3 && (!r || l[1] > r[0] && l[1] < r[3])) {
                        t.label = l[1];
                        break;
                      }
                      if (l[0] === 6 && t.label < r[1]) {
                        t.label = r[1], r = l;
                        break;
                      }
                      if (r && t.label < r[2]) {
                        t.label = r[2], t.ops.push(l);
                        break;
                      }
                      r[2] && t.ops.pop(), t.trys.pop();
                      continue;
                  }
                  l = n.call(e, t);
                } catch (C) {
                  l = [6, C], i = 0;
                } finally {
                  s = r = 0;
                }
              if (l[0] & 5)
                throw l[1];
              return { value: l[0] ? l[1] : void 0, done: true };
            }
          }
          function xD(e, n, t, s) {
            s === void 0 && (s = t), e[s] = n[t];
          }
          function bD(e, n) {
            for (var t in e)
              t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
          }
          function Tn(e) {
            var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s = 0;
            if (t)
              return t.call(e);
            if (e && typeof e.length == "number")
              return { next: function() {
                return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
              } };
            throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function Ii(e, n) {
            var t = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t)
              return e;
            var s = t.call(e), i, r = [], u;
            try {
              for (; (n === void 0 || n-- > 0) && !(i = s.next()).done; )
                r.push(i.value);
            } catch (a) {
              u = { error: a };
            } finally {
              try {
                i && !i.done && (t = s.return) && t.call(s);
              } finally {
                if (u)
                  throw u.error;
              }
            }
            return r;
          }
          function TD() {
            for (var e = [], n = 0; n < arguments.length; n++)
              e = e.concat(Ii(arguments[n]));
            return e;
          }
          function BD() {
            for (var e = 0, n = 0, t = arguments.length; n < t; n++)
              e += arguments[n].length;
            for (var s = Array(e), i = 0, n = 0; n < t; n++)
              for (var r = arguments[n], u = 0, a = r.length; u < a; u++, i++)
                s[i] = r[u];
            return s;
          }
          function Gt(e) {
            return this instanceof Gt ? (this.v = e, this) : new Gt(e);
          }
          function ND(e, n, t) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t.apply(e, n || []), i, r = [];
            return i = {}, u("next"), u("throw"), u("return"), i[Symbol.asyncIterator] = function() {
              return this;
            }, i;
            function u(g) {
              s[g] && (i[g] = function(p) {
                return new Promise(function(f, h) {
                  r.push([g, p, f, h]) > 1 || a(g, p);
                });
              });
            }
            function a(g, p) {
              try {
                c(s[g](p));
              } catch (f) {
                m(r[0][3], f);
              }
            }
            function c(g) {
              g.value instanceof Gt ? Promise.resolve(g.value.v).then(l, C) : m(r[0][2], g);
            }
            function l(g) {
              a("next", g);
            }
            function C(g) {
              a("throw", g);
            }
            function m(g, p) {
              g(p), r.shift(), r.length && a(r[0][0], r[0][1]);
            }
          }
          function wD(e) {
            var n, t;
            return n = {}, s("next"), s("throw", function(i) {
              throw i;
            }), s("return"), n[Symbol.iterator] = function() {
              return this;
            }, n;
            function s(i, r) {
              n[i] = e[i] ? function(u) {
                return (t = !t) ? { value: Gt(e[i](u)), done: i === "return" } : r ? r(u) : u;
              } : r;
            }
          }
          function _D(e) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var n = e[Symbol.asyncIterator], t;
            return n ? n.call(e) : (e = typeof Tn == "function" ? Tn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
              return this;
            }, t);
            function s(r) {
              t[r] = e[r] && function(u) {
                return new Promise(function(a, c) {
                  u = e[r](u), i(a, c, u.done, u.value);
                });
              };
            }
            function i(r, u, a, c) {
              Promise.resolve(c).then(function(l) {
                r({ value: l, done: a });
              }, u);
            }
          }
          function PD(e, n) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
          }
          function ID(e) {
            if (e && e.__esModule)
              return e;
            var n = {};
            if (e != null)
              for (var t in e)
                Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
            return n.default = e, n;
          }
          function kD(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function LD(e, n) {
            if (!n.has(e))
              throw new TypeError("attempted to get private field on non-instance");
            return n.get(e);
          }
          function OD(e, n, t) {
            if (!n.has(e))
              throw new TypeError("attempted to set private field on non-instance");
            return n.set(e, t), t;
          }
          var Ar, Sr, gt = br({ "node_modules/tslib/tslib.es6.js"() {
            ae(), Ar = function(e, n) {
              return Ar = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
                t.__proto__ = s;
              } || function(t, s) {
                for (var i in s)
                  s.hasOwnProperty(i) && (t[i] = s[i]);
              }, Ar(e, n);
            }, Sr = function() {
              return Sr = Object.assign || function(n) {
                for (var t, s = 1, i = arguments.length; s < i; s++) {
                  t = arguments[s];
                  for (var r in t)
                    Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }, Sr.apply(this, arguments);
            };
          } }), ki = Z({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
              if (n === null || typeof n != "object")
                return JSON.stringify(n);
              if (Array.isArray(n))
                return "[".concat(n.map((s) => e.apiDescriptor.value(s)).join(", "), "]");
              let t = Object.keys(n);
              return t.length === 0 ? "{}" : "{ ".concat(t.map((s) => "".concat(e.apiDescriptor.key(s), ": ").concat(e.apiDescriptor.value(n[s]))).join(", "), " }");
            }, pair: (n) => {
              let { key: t, value: s } = n;
              return e.apiDescriptor.value({ [t]: s });
            } };
          } }), jD = Z({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar(ki(), e);
          } }), Nr = Z({ "scripts/build/shims/chalk.cjs"(e, n) {
            "use strict";
            ae();
            var t = (s) => s;
            t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
          } }), Li = Z({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Nr();
            e.commonDeprecatedHandler = (t, s, i) => {
              let { descriptor: r } = i, u = ["".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")];
              return s && u.push("we now treat it as ".concat(n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s)))), u.join("; ") + ".";
            };
          } }), qD = Z({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar(Li(), e);
          } }), MD = Z({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Nr();
            e.commonInvalidHandler = (t, s, i) => ["Invalid ".concat(n.default.red(i.descriptor.key(t)), " value."), "Expected ".concat(n.default.blue(i.schemas[t].expected(i)), ","), "but received ".concat(n.default.red(i.descriptor.value(s)), ".")].join(" ");
          } }), Oi = Z({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar(MD(), e);
          } }), RD = Z({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
            "use strict";
            ae();
            var t = [], s = [];
            n.exports = function(i, r) {
              if (i === r)
                return 0;
              var u = i;
              i.length > r.length && (i = r, r = u);
              var a = i.length, c = r.length;
              if (a === 0)
                return c;
              if (c === 0)
                return a;
              for (; a > 0 && i.charCodeAt(~-a) === r.charCodeAt(~-c); )
                a--, c--;
              if (a === 0)
                return c;
              for (var l = 0; l < a && i.charCodeAt(l) === r.charCodeAt(l); )
                l++;
              if (a -= l, c -= l, a === 0)
                return c;
              for (var C, m, g, p, f = 0, h = 0; f < a; )
                s[l + f] = i.charCodeAt(l + f), t[f] = ++f;
              for (; h < c; )
                for (C = r.charCodeAt(l + h), g = h++, m = h, f = 0; f < a; f++)
                  p = C === s[l + f] ? g : g + 1, g = t[f], m = t[f] = g > m ? p > m ? m + 1 : p : p > g ? g + 1 : p;
              return m;
            };
          } }), ji = Z({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Nr(), t = RD();
            e.levenUnknownHandler = (s, i, r) => {
              let { descriptor: u, logger: a, schemas: c } = r, l = ["Ignored unknown option ".concat(n.default.yellow(u.pair({ key: s, value: i })), ".")], C = Object.keys(c).sort().find((m) => t(s, m) < 3);
              C && l.push("Did you mean ".concat(n.default.blue(u.key(C)), "?")), a.warn(l.join(" "));
            };
          } }), VD = Z({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar(ji(), e);
          } }), WD = Z({ "node_modules/vnopts/lib/handlers/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar(qD(), e), n.__exportStar(Oi(), e), n.__exportStar(VD(), e);
          } }), yt = Z({ "node_modules/vnopts/lib/schema.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
            function t(r, u) {
              let a = new r(u), c = Object.create(a);
              for (let l of n)
                l in u && (c[l] = i(u[l], a, s.prototype[l].length));
              return c;
            }
            e.createSchema = t;
            var s = class {
              constructor(r) {
                this.name = r.name;
              }
              static create(r) {
                return t(this, r);
              }
              default(r) {
              }
              expected(r) {
                return "nothing";
              }
              validate(r, u) {
                return false;
              }
              deprecated(r, u) {
                return false;
              }
              forward(r, u) {
              }
              redirect(r, u) {
              }
              overlap(r, u, a) {
                return r;
              }
              preprocess(r, u) {
                return r;
              }
              postprocess(r, u) {
                return r;
              }
            };
            e.Schema = s;
            function i(r, u, a) {
              return typeof r == "function" ? function() {
                for (var c = arguments.length, l = new Array(c), C = 0; C < c; C++)
                  l[C] = arguments[C];
                return r(...l.slice(0, a - 1), u, ...l.slice(a - 1));
              } : () => r;
            }
          } }), $D = Z({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = yt(), t = class extends n.Schema {
              constructor(s) {
                super(s);
                this._sourceName = s.sourceName;
              }
              expected(s) {
                return s.schemas[this._sourceName].expected(s);
              }
              validate(s, i) {
                return i.schemas[this._sourceName].validate(s, i);
              }
              redirect(s, i) {
                return this._sourceName;
              }
            };
            e.AliasSchema = t;
          } }), HD = Z({ "node_modules/vnopts/lib/schemas/any.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = yt(), t = class extends n.Schema {
              expected() {
                return "anything";
              }
              validate() {
                return true;
              }
            };
            e.AnySchema = t;
          } }), GD = Z({ "node_modules/vnopts/lib/schemas/array.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt)), t = yt(), s = class extends t.Schema {
              constructor(r) {
                var { valueSchema: u, name: a = u.name } = r, c = n.__rest(r, ["valueSchema", "name"]);
                super(Object.assign({}, c, { name: a }));
                this._valueSchema = u;
              }
              expected(r) {
                return "an array of ".concat(this._valueSchema.expected(r));
              }
              validate(r, u) {
                if (!Array.isArray(r))
                  return false;
                let a = [];
                for (let c of r) {
                  let l = u.normalizeValidateResult(this._valueSchema.validate(c, u), c);
                  l !== true && a.push(l.value);
                }
                return a.length === 0 ? true : { value: a };
              }
              deprecated(r, u) {
                let a = [];
                for (let c of r) {
                  let l = u.normalizeDeprecatedResult(this._valueSchema.deprecated(c, u), c);
                  l !== false && a.push(...l.map((C) => {
                    let { value: m } = C;
                    return { value: [m] };
                  }));
                }
                return a;
              }
              forward(r, u) {
                let a = [];
                for (let c of r) {
                  let l = u.normalizeForwardResult(this._valueSchema.forward(c, u), c);
                  a.push(...l.map(i));
                }
                return a;
              }
              redirect(r, u) {
                let a = [], c = [];
                for (let l of r) {
                  let C = u.normalizeRedirectResult(this._valueSchema.redirect(l, u), l);
                  "remain" in C && a.push(C.remain), c.push(...C.redirect.map(i));
                }
                return a.length === 0 ? { redirect: c } : { redirect: c, remain: a };
              }
              overlap(r, u) {
                return r.concat(u);
              }
            };
            e.ArraySchema = s;
            function i(r) {
              let { from: u, to: a } = r;
              return { from: [u], to: a };
            }
          } }), JD = Z({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = yt(), t = class extends n.Schema {
              expected() {
                return "true or false";
              }
              validate(s) {
                return typeof s == "boolean";
              }
            };
            e.BooleanSchema = t;
          } }), Hn = Z({ "node_modules/vnopts/lib/utils.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            function n(p, f) {
              let h = /* @__PURE__ */ Object.create(null);
              for (let N of p) {
                let T = N[f];
                if (h[T])
                  throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                h[T] = N;
              }
              return h;
            }
            e.recordFromArray = n;
            function t(p, f) {
              let h = /* @__PURE__ */ new Map();
              for (let N of p) {
                let T = N[f];
                if (h.has(T))
                  throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                h.set(T, N);
              }
              return h;
            }
            e.mapFromArray = t;
            function s() {
              let p = /* @__PURE__ */ Object.create(null);
              return (f) => {
                let h = JSON.stringify(f);
                return p[h] ? true : (p[h] = true, false);
              };
            }
            e.createAutoChecklist = s;
            function i(p, f) {
              let h = [], N = [];
              for (let T of p)
                f(T) ? h.push(T) : N.push(T);
              return [h, N];
            }
            e.partition = i;
            function r(p) {
              return p === Math.floor(p);
            }
            e.isInt = r;
            function u(p, f) {
              if (p === f)
                return 0;
              let h = typeof p, N = typeof f, T = ["undefined", "object", "boolean", "number", "string"];
              return h !== N ? T.indexOf(h) - T.indexOf(N) : h !== "string" ? Number(p) - Number(f) : p.localeCompare(f);
            }
            e.comparePrimitive = u;
            function a(p) {
              return p === void 0 ? {} : p;
            }
            e.normalizeDefaultResult = a;
            function c(p, f) {
              return p === true ? true : p === false ? { value: f } : p;
            }
            e.normalizeValidateResult = c;
            function l(p, f) {
              let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return p === false ? false : p === true ? h ? true : [{ value: f }] : "value" in p ? [p] : p.length === 0 ? false : p;
            }
            e.normalizeDeprecatedResult = l;
            function C(p, f) {
              return typeof p == "string" || "key" in p ? { from: f, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: f, to: p.to };
            }
            e.normalizeTransferResult = C;
            function m(p, f) {
              return p === void 0 ? [] : Array.isArray(p) ? p.map((h) => C(h, f)) : [C(p, f)];
            }
            e.normalizeForwardResult = m;
            function g(p, f) {
              let h = m(typeof p == "object" && "redirect" in p ? p.redirect : p, f);
              return h.length === 0 ? { remain: f, redirect: h } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: h } : { redirect: h };
            }
            e.normalizeRedirectResult = g;
          } }), UD = Z({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = yt(), t = Hn(), s = class extends n.Schema {
              constructor(i) {
                super(i);
                this._choices = t.mapFromArray(i.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
              }
              expected(i) {
                let { descriptor: r } = i, u = Array.from(this._choices.keys()).map((l) => this._choices.get(l)).filter((l) => !l.deprecated).map((l) => l.value).sort(t.comparePrimitive).map(r.value), a = u.slice(0, -2), c = u.slice(-2);
                return a.concat(c.join(" or ")).join(", ");
              }
              validate(i) {
                return this._choices.has(i);
              }
              deprecated(i) {
                let r = this._choices.get(i);
                return r && r.deprecated ? { value: i } : false;
              }
              forward(i) {
                let r = this._choices.get(i);
                return r ? r.forward : void 0;
              }
              redirect(i) {
                let r = this._choices.get(i);
                return r ? r.redirect : void 0;
              }
            };
            e.ChoiceSchema = s;
          } }), qi = Z({ "node_modules/vnopts/lib/schemas/number.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = yt(), t = class extends n.Schema {
              expected() {
                return "a number";
              }
              validate(s, i) {
                return typeof s == "number";
              }
            };
            e.NumberSchema = t;
          } }), zD = Z({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Hn(), t = qi(), s = class extends t.NumberSchema {
              expected() {
                return "an integer";
              }
              validate(i, r) {
                return r.normalizeValidateResult(super.validate(i, r), i) === true && n.isInt(i);
              }
            };
            e.IntegerSchema = s;
          } }), XD = Z({ "node_modules/vnopts/lib/schemas/string.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = yt(), t = class extends n.Schema {
              expected() {
                return "a string";
              }
              validate(s) {
                return typeof s == "string";
              }
            };
            e.StringSchema = t;
          } }), KD = Z({ "node_modules/vnopts/lib/schemas/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar($D(), e), n.__exportStar(HD(), e), n.__exportStar(GD(), e), n.__exportStar(JD(), e), n.__exportStar(UD(), e), n.__exportStar(zD(), e), n.__exportStar(qi(), e), n.__exportStar(XD(), e);
          } }), YD = Z({ "node_modules/vnopts/lib/defaults.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = ki(), t = Li(), s = Oi(), i = ji();
            e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = i.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
          } }), QD = Z({ "node_modules/vnopts/lib/normalize.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = YD(), t = Hn();
            e.normalize = (i, r, u) => new s(r, u).normalize(i);
            var s = class {
              constructor(i, r) {
                let { logger: u = console, descriptor: a = n.defaultDescriptor, unknown: c = n.defaultUnknownHandler, invalid: l = n.defaultInvalidHandler, deprecated: C = n.defaultDeprecatedHandler } = r || {};
                this._utils = { descriptor: a, logger: u || { warn: () => {
                } }, schemas: t.recordFromArray(i, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = c, this._invalidHandler = l, this._deprecatedHandler = C, this.cleanHistory();
              }
              cleanHistory() {
                this._hasDeprecationWarned = t.createAutoChecklist();
              }
              normalize(i) {
                let r = {}, u = [i], a = () => {
                  for (; u.length !== 0; ) {
                    let c = u.shift(), l = this._applyNormalization(c, r);
                    u.push(...l);
                  }
                };
                a();
                for (let c of Object.keys(this._utils.schemas)) {
                  let l = this._utils.schemas[c];
                  if (!(c in r)) {
                    let C = t.normalizeDefaultResult(l.default(this._utils));
                    "value" in C && u.push({ [c]: C.value });
                  }
                }
                a();
                for (let c of Object.keys(this._utils.schemas)) {
                  let l = this._utils.schemas[c];
                  c in r && (r[c] = l.postprocess(r[c], this._utils));
                }
                return r;
              }
              _applyNormalization(i, r) {
                let u = [], [a, c] = t.partition(Object.keys(i), (l) => l in this._utils.schemas);
                for (let l of a) {
                  let C = this._utils.schemas[l], m = C.preprocess(i[l], this._utils), g = t.normalizeValidateResult(C.validate(m, this._utils), m);
                  if (g !== true) {
                    let { value: T } = g, A = this._invalidHandler(l, T, this._utils);
                    throw typeof A == "string" ? new Error(A) : A;
                  }
                  let p = (T) => {
                    let { from: A, to: b } = T;
                    u.push(typeof b == "string" ? { [b]: A } : { [b.key]: b.value });
                  }, f = (T) => {
                    let { value: A, redirectTo: b } = T, v = t.normalizeDeprecatedResult(C.deprecated(A, this._utils), m, true);
                    if (v !== false)
                      if (v === true)
                        this._hasDeprecationWarned(l) || this._utils.logger.warn(this._deprecatedHandler(l, b, this._utils));
                      else
                        for (let { value: B } of v) {
                          let w = { key: l, value: B };
                          if (!this._hasDeprecationWarned(w)) {
                            let I = typeof b == "string" ? { key: b, value: B } : b;
                            this._utils.logger.warn(this._deprecatedHandler(w, I, this._utils));
                          }
                        }
                  };
                  t.normalizeForwardResult(C.forward(m, this._utils), m).forEach(p);
                  let N = t.normalizeRedirectResult(C.redirect(m, this._utils), m);
                  if (N.redirect.forEach(p), "remain" in N) {
                    let T = N.remain;
                    r[l] = l in r ? C.overlap(r[l], T, this._utils) : T, f({ value: T });
                  }
                  for (let { from: T, to: A } of N.redirect)
                    f({ value: T, redirectTo: A });
                }
                for (let l of c) {
                  let C = i[l], m = this._unknownHandler(l, C, this._utils);
                  if (m)
                    for (let g of Object.keys(m)) {
                      let p = { [g]: m[g] };
                      g in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                    }
                }
                return u;
              }
            };
            e.Normalizer = s;
          } }), ZD = Z({ "node_modules/vnopts/lib/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (gt(), pt(Dt));
            n.__exportStar(jD(), e), n.__exportStar(WD(), e), n.__exportStar(KD(), e), n.__exportStar(QD(), e), n.__exportStar(yt(), e);
          } }), em = Z({ "src/main/options-normalizer.js"(e, n) {
            "use strict";
            ae();
            var t = ZD(), s = st(), i = { key: (g) => g.length === 1 ? "-".concat(g) : "--".concat(g), value: (g) => t.apiDescriptor.value(g), pair: (g) => {
              let { key: p, value: f } = g;
              return f === false ? "--no-".concat(p) : f === true ? i.key(p) : f === "" ? "".concat(i.key(p), " without an argument") : "".concat(i.key(p), "=").concat(f);
            } }, r = (g) => {
              let { colorsModule: p, levenshteinDistance: f } = g;
              return class extends t.ChoiceSchema {
                constructor(N) {
                  let { name: T, flags: A } = N;
                  super({ name: T, choices: A });
                  this._flags = [...A].sort();
                }
                preprocess(N, T) {
                  if (typeof N == "string" && N.length > 0 && !this._flags.includes(N)) {
                    let A = this._flags.find((b) => f(b, N) < 3);
                    if (A)
                      return T.logger.warn(["Unknown flag ".concat(p.yellow(T.descriptor.value(N)), ","), "did you mean ".concat(p.blue(T.descriptor.value(A)), "?")].join(" ")), A;
                  }
                  return N;
                }
                expected() {
                  return "a flag";
                }
              };
            }, u;
            function a(g, p) {
              let { logger: f, isCLI: h = false, passThrough: N = false, colorsModule: T, levenshteinDistance: A } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, b = N ? Array.isArray(N) ? (D, d) => N.includes(D) ? { [D]: d } : void 0 : (D, d) => ({ [D]: d }) : (D, d, y) => {
                let o = y.schemas, { _: x } = o, F = _n(o, Xf);
                return t.levenUnknownHandler(D, d, Object.assign(Object.assign({}, y), {}, { schemas: F }));
              }, v = h ? i : t.apiDescriptor, B = c(p, { isCLI: h, colorsModule: T, levenshteinDistance: A }), w = new t.Normalizer(B, { logger: f, unknown: b, descriptor: v }), I = f !== false;
              I && u && (w._hasDeprecationWarned = u);
              let E = w.normalize(g);
              return I && (u = w._hasDeprecationWarned), h && E["plugin-search"] === false && (E["plugin-search-dir"] = false), E;
            }
            function c(g, p) {
              let { isCLI: f, colorsModule: h, levenshteinDistance: N } = p, T = [];
              f && T.push(t.AnySchema.create({ name: "_" }));
              for (let A of g)
                T.push(l(A, { isCLI: f, optionInfos: g, colorsModule: h, levenshteinDistance: N })), A.alias && f && T.push(t.AliasSchema.create({ name: A.alias, sourceName: A.name }));
              return T;
            }
            function l(g, p) {
              let { isCLI: f, optionInfos: h, colorsModule: N, levenshteinDistance: T } = p, { name: A } = g;
              if (A === "plugin-search-dir" || A === "pluginSearchDirs")
                return t.AnySchema.create({ name: A, preprocess(w) {
                  return w === false || (w = Array.isArray(w) ? w : [w]), w;
                }, validate(w) {
                  return w === false ? true : w.every((I) => typeof I == "string");
                }, expected() {
                  return "false or paths to plugin search dir";
                } });
              let b = { name: A }, v, B = {};
              switch (g.type) {
                case "int":
                  v = t.IntegerSchema, f && (b.preprocess = (w) => Number(w));
                  break;
                case "string":
                  v = t.StringSchema;
                  break;
                case "choice":
                  v = t.ChoiceSchema, b.choices = g.choices.map((w) => typeof w == "object" && w.redirect ? Object.assign(Object.assign({}, w), {}, { redirect: { to: { key: g.name, value: w.redirect } } }) : w);
                  break;
                case "boolean":
                  v = t.BooleanSchema;
                  break;
                case "flag":
                  v = r({ colorsModule: N, levenshteinDistance: T }), b.flags = h.flatMap((w) => [w.alias, w.description && w.name, w.oppositeDescription && "no-".concat(w.name)].filter(Boolean));
                  break;
                case "path":
                  v = t.StringSchema;
                  break;
                default:
                  throw new Error("Unexpected type ".concat(g.type));
              }
              if (g.exception ? b.validate = (w, I, E) => g.exception(w) || I.validate(w, E) : b.validate = (w, I, E) => w === void 0 || I.validate(w, E), g.redirect && (B.redirect = (w) => w ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (B.deprecated = true), f && !g.array) {
                let w = b.preprocess || ((I) => I);
                b.preprocess = (I, E, D) => E.preprocess(w(Array.isArray(I) ? s(I) : I), D);
              }
              return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (w) => Array.isArray(w) ? w : [w] } : {}), B), {}, { valueSchema: v.create(b) })) : v.create(Object.assign(Object.assign({}, b), B));
            }
            function C(g, p, f) {
              return a(g, p, f);
            }
            function m(g, p, f) {
              return a(g, p, Object.assign({ isCLI: true }, f));
            }
            n.exports = { normalizeApiOptions: C, normalizeCliOptions: m };
          } }), nt = Z({ "src/language-js/loc.js"(e, n) {
            "use strict";
            ae();
            var t = Rn();
            function s(c, l) {
              let { ignoreDecorators: C } = l || {};
              if (!C) {
                let m = c.declaration && c.declaration.decorators || c.decorators;
                if (t(m))
                  return s(m[0]);
              }
              return c.range ? c.range[0] : c.start;
            }
            function i(c) {
              return c.range ? c.range[1] : c.end;
            }
            function r(c, l) {
              let C = s(c);
              return Number.isInteger(C) && C === s(l);
            }
            function u(c, l) {
              let C = i(c);
              return Number.isInteger(C) && C === i(l);
            }
            function a(c, l) {
              return r(c, l) && u(c, l);
            }
            n.exports = { locStart: s, locEnd: i, hasSameLocStart: r, hasSameLoc: a };
          } }), tm = Z({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
            "use strict";
            ae();
            var t = Nr(), s = { shouldHighlight: () => false, getChalk: () => t };
            n.exports = s;
          } }), rm = Z({ "node_modules/@babel/code-frame/lib/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = a;
            var n = tm(), t = false;
            function s(c) {
              return { gutter: c.grey, marker: c.red.bold, message: c.red.bold };
            }
            var i = /\r\n|[\n\r\u2028\u2029]/;
            function r(c, l, C) {
              let m = Object.assign({ column: 0, line: -1 }, c.start), g = Object.assign({}, m, c.end), { linesAbove: p = 2, linesBelow: f = 3 } = C || {}, h = m.line, N = m.column, T = g.line, A = g.column, b = Math.max(h - (p + 1), 0), v = Math.min(l.length, T + f);
              h === -1 && (b = 0), T === -1 && (v = l.length);
              let B = T - h, w = {};
              if (B)
                for (let I = 0; I <= B; I++) {
                  let E = I + h;
                  if (!N)
                    w[E] = true;
                  else if (I === 0) {
                    let D = l[E - 1].length;
                    w[E] = [N, D - N + 1];
                  } else if (I === B)
                    w[E] = [0, A];
                  else {
                    let D = l[E - I].length;
                    w[E] = [0, D];
                  }
                }
              else
                N === A ? N ? w[h] = [N, 0] : w[h] = true : w[h] = [N, A - N];
              return { start: b, end: v, markerLines: w };
            }
            function u(c, l) {
              let C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m = (C.highlightCode || C.forceColor) && (0, n.shouldHighlight)(C), g = (0, n.getChalk)(C), p = s(g), f = (I, E) => m ? I(E) : E, h = c.split(i), { start: N, end: T, markerLines: A } = r(l, h, C), b = l.start && typeof l.start.column == "number", v = String(T).length, w = (m ? (0, n.default)(c, C) : c).split(i, T).slice(N, T).map((I, E) => {
                let D = N + 1 + E, d = " ".concat(D).slice(-v), y = " ".concat(d, " |"), o = A[D], x = !A[D + 1];
                if (o) {
                  let F = "";
                  if (Array.isArray(o)) {
                    let S = I.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), k = o[1] || 1;
                    F = [`
 `, f(p.gutter, y.replace(/\d/g, " ")), " ", S, f(p.marker, "^").repeat(k)].join(""), x && C.message && (F += " " + f(p.message, C.message));
                  }
                  return [f(p.marker, ">"), f(p.gutter, y), I.length > 0 ? " ".concat(I) : "", F].join("");
                } else
                  return " ".concat(f(p.gutter, y)).concat(I.length > 0 ? " ".concat(I) : "");
              }).join(`
`);
              return C.message && !b && (w = "".concat(" ".repeat(v + 1)).concat(C.message, `
`).concat(w)), m ? g.reset(w) : w;
            }
            function a(c, l, C) {
              let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              if (!t) {
                t = true;
                let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                if (xt.emitWarning)
                  xt.emitWarning(p, "DeprecationWarning");
                else {
                  let f = new Error(p);
                  f.name = "DeprecationWarning", console.warn(new Error(p));
                }
              }
              return C = Math.max(C, 0), u(c, { start: { column: C, line: l } }, m);
            }
          } }), Gn = Z({ "src/main/parser.js"(e, n) {
            "use strict";
            ae();
            var t = Pi(), { ConfigError: s } = Jt(), i = nt(), { locStart: r, locEnd: u } = i, a = Object.getOwnPropertyNames, c = Object.getOwnPropertyDescriptor;
            function l(g) {
              let p = {};
              for (let f of g.plugins)
                if (!!f.parsers)
                  for (let h of a(f.parsers))
                    Object.defineProperty(p, h, c(f.parsers, h));
              return p;
            }
            function C(g) {
              let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : l(g);
              if (typeof g.parser == "function")
                return { parse: g.parser, astFormat: "estree", locStart: r, locEnd: u };
              if (typeof g.parser == "string") {
                if (Object.prototype.hasOwnProperty.call(p, g.parser))
                  return p[g.parser];
                throw new s(`Couldn't resolve parser "`.concat(g.parser, '". Parsers must be explicitly added to the standalone bundle.'));
              }
            }
            function m(g, p) {
              let f = l(p), h = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((T) => [T, { enumerable: true, get() {
                return f[T].parse;
              } }]))), N = C(p, f);
              try {
                return N.preprocess && (g = N.preprocess(g, p)), { text: g, ast: N.parse(g, h, p) };
              } catch (T) {
                let { loc: A } = T;
                if (A) {
                  let { codeFrameColumns: b } = rm();
                  throw T.codeFrame = b(g, A, { highlightCode: true }), T.message += `
` + T.codeFrame, T;
                }
                throw T.stack;
              }
            }
            n.exports = { parse: m, resolveParser: C };
          } }), Mi = Z({ "src/main/options.js"(e, n) {
            "use strict";
            ae();
            var t = Pi(), { UndefinedParserError: s } = Jt(), { getSupportInfo: i } = Mn(), r = em(), { resolveParser: u } = Gn(), a = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
            function c(m) {
              let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, m), f = i({ plugins: m.plugins, showUnreleased: true, showDeprecated: true }).options, h = Object.assign(Object.assign({}, a), Object.fromEntries(f.filter((v) => v.default !== void 0).map((v) => [v.name, v.default])));
              if (!p.parser) {
                if (!p.filepath)
                  (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
                else if (p.parser = C(p.filepath, p.plugins), !p.parser)
                  throw new s("No parser could be inferred for file: ".concat(p.filepath));
              }
              let N = u(r.normalizeApiOptions(p, [f.find((v) => v.name === "parser")], { passThrough: true, logger: false }));
              p.astFormat = N.astFormat, p.locEnd = N.locEnd, p.locStart = N.locStart;
              let T = l(p);
              p.printer = T.printers[p.astFormat];
              let A = Object.fromEntries(f.filter((v) => v.pluginDefaults && v.pluginDefaults[T.name] !== void 0).map((v) => [v.name, v.pluginDefaults[T.name]])), b = Object.assign(Object.assign({}, h), A);
              for (let [v, B] of Object.entries(b))
                (p[v] === null || p[v] === void 0) && (p[v] = B);
              return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, f, Object.assign({ passThrough: Object.keys(a) }, g));
            }
            function l(m) {
              let { astFormat: g } = m;
              if (!g)
                throw new Error("getPlugin() requires astFormat to be set");
              let p = m.plugins.find((f) => f.printers && f.printers[g]);
              if (!p)
                throw new Error(`Couldn't find plugin for AST format "`.concat(g, '"'));
              return p;
            }
            function C(m, g) {
              let p = t.basename(m).toLowerCase(), h = i({ plugins: g }).languages.filter((N) => N.since !== null).find((N) => N.extensions && N.extensions.some((T) => p.endsWith(T)) || N.filenames && N.filenames.some((T) => T.toLowerCase() === p));
              return h && h.parsers[0];
            }
            n.exports = { normalize: c, hiddenDefaults: a, inferParser: C };
          } }), nm = Z({ "src/main/massage-ast.js"(e, n) {
            "use strict";
            ae();
            function t(s, i, r) {
              if (Array.isArray(s))
                return s.map((l) => t(l, i, r)).filter(Boolean);
              if (!s || typeof s != "object")
                return s;
              let u = i.printer.massageAstNode, a;
              u && u.ignoredProperties ? a = u.ignoredProperties : a = /* @__PURE__ */ new Set();
              let c = {};
              for (let [l, C] of Object.entries(s))
                !a.has(l) && typeof C != "function" && (c[l] = t(C, i, s));
              if (u) {
                let l = u(s, c, r);
                if (l === null)
                  return;
                if (l)
                  return l;
              }
              return c;
            }
            n.exports = t;
          } }), Ut = Z({ "scripts/build/shims/assert.cjs"(e, n) {
            "use strict";
            ae();
            var t = () => {
            };
            t.ok = t, t.strictEqual = t, n.exports = t;
          } }), Qe = Z({ "src/main/comments.js"(e, n) {
            "use strict";
            ae();
            var t = Ut(), { builders: { line: s, hardline: i, breakParent: r, indent: u, lineSuffix: a, join: c, cursor: l } } = Le(), { hasNewline: C, skipNewline: m, skipSpaces: g, isPreviousLineEmpty: p, addLeadingComment: f, addDanglingComment: h, addTrailingComment: N } = Ge(), T = /* @__PURE__ */ new WeakMap();
            function A(O, R, M) {
              if (!O)
                return;
              let { printer: H, locStart: P, locEnd: G } = R;
              if (M) {
                if (H.canAttachComment && H.canAttachComment(O)) {
                  let $;
                  for ($ = M.length - 1; $ >= 0 && !(P(M[$]) <= P(O) && G(M[$]) <= G(O)); --$)
                    ;
                  M.splice($ + 1, 0, O);
                  return;
                }
              } else if (T.has(O))
                return T.get(O);
              let re = H.getCommentChildNodes && H.getCommentChildNodes(O, R) || typeof O == "object" && Object.entries(O).filter(($) => {
                let [W] = $;
                return W !== "enclosingNode" && W !== "precedingNode" && W !== "followingNode" && W !== "tokens" && W !== "comments" && W !== "parent";
              }).map(($) => {
                let [, W] = $;
                return W;
              });
              if (!!re) {
                M || (M = [], T.set(O, M));
                for (let $ of re)
                  A($, R, M);
                return M;
              }
            }
            function b(O, R, M, H) {
              let { locStart: P, locEnd: G } = M, re = P(R), $ = G(R), W = A(O, M), ee, U, ne = 0, se = W.length;
              for (; ne < se; ) {
                let V = ne + se >> 1, oe = W[V], K = P(oe), Ee = G(oe);
                if (K <= re && $ <= Ee)
                  return b(oe, R, M, oe);
                if (Ee <= re) {
                  ee = oe, ne = V + 1;
                  continue;
                }
                if ($ <= K) {
                  U = oe, se = V;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if (H && H.type === "TemplateLiteral") {
                let { quasis: V } = H, oe = y(V, R, M);
                ee && y(V, ee, M) !== oe && (ee = null), U && y(V, U, M) !== oe && (U = null);
              }
              return { enclosingNode: H, precedingNode: ee, followingNode: U };
            }
            var v = () => false;
            function B(O, R, M, H) {
              if (!Array.isArray(O))
                return;
              let P = [], { locStart: G, locEnd: re, printer: { handleComments: $ = {} } } = H, { avoidAstMutation: W, ownLine: ee = v, endOfLine: U = v, remaining: ne = v } = $, se = O.map((V, oe) => Object.assign(Object.assign({}, b(R, V, H)), {}, { comment: V, text: M, options: H, ast: R, isLastComment: O.length - 1 === oe }));
              for (let [V, oe] of se.entries()) {
                let { comment: K, precedingNode: Ee, enclosingNode: q, followingNode: le, text: ue, options: Q, ast: de, isLastComment: ge } = oe;
                if (Q.parser === "json" || Q.parser === "json5" || Q.parser === "__js_expression" || Q.parser === "__vue_expression") {
                  if (G(K) - G(de) <= 0) {
                    f(de, K);
                    continue;
                  }
                  if (re(K) - re(de) >= 0) {
                    N(de, K);
                    continue;
                  }
                }
                let ve;
                if (W ? ve = [oe] : (K.enclosingNode = q, K.precedingNode = Ee, K.followingNode = le, ve = [K, ue, Q, de, ge]), I(ue, Q, se, V))
                  K.placement = "ownLine", ee(...ve) || (le ? f(le, K) : Ee ? N(Ee, K) : h(q || de, K));
                else if (E(ue, Q, se, V))
                  K.placement = "endOfLine", U(...ve) || (Ee ? N(Ee, K) : le ? f(le, K) : h(q || de, K));
                else if (K.placement = "remaining", !ne(...ve))
                  if (Ee && le) {
                    let xe = P.length;
                    xe > 0 && P[xe - 1].followingNode !== le && D(P, ue, Q), P.push(oe);
                  } else
                    Ee ? N(Ee, K) : le ? f(le, K) : h(q || de, K);
              }
              if (D(P, M, H), !W)
                for (let V of O)
                  delete V.precedingNode, delete V.enclosingNode, delete V.followingNode;
            }
            var w = (O) => !/[\S\n\u2028\u2029]/.test(O);
            function I(O, R, M, H) {
              let { comment: P, precedingNode: G } = M[H], { locStart: re, locEnd: $ } = R, W = re(P);
              if (G)
                for (let ee = H - 1; ee >= 0; ee--) {
                  let { comment: U, precedingNode: ne } = M[ee];
                  if (ne !== G || !w(O.slice($(U), W)))
                    break;
                  W = re(U);
                }
              return C(O, W, { backwards: true });
            }
            function E(O, R, M, H) {
              let { comment: P, followingNode: G } = M[H], { locStart: re, locEnd: $ } = R, W = $(P);
              if (G)
                for (let ee = H + 1; ee < M.length; ee++) {
                  let { comment: U, followingNode: ne } = M[ee];
                  if (ne !== G || !w(O.slice(W, re(U))))
                    break;
                  W = $(U);
                }
              return C(O, W);
            }
            function D(O, R, M) {
              let H = O.length;
              if (H === 0)
                return;
              let { precedingNode: P, followingNode: G, enclosingNode: re } = O[0], $ = M.printer.getGapRegex && M.printer.getGapRegex(re) || /^[\s(]*$/, W = M.locStart(G), ee;
              for (ee = H; ee > 0; --ee) {
                let { comment: U, precedingNode: ne, followingNode: se } = O[ee - 1];
                t.strictEqual(ne, P), t.strictEqual(se, G);
                let V = R.slice(M.locEnd(U), W);
                if ($.test(V))
                  W = M.locStart(U);
                else
                  break;
              }
              for (let [U, { comment: ne }] of O.entries())
                U < ee ? N(P, ne) : f(G, ne);
              for (let U of [P, G])
                U.comments && U.comments.length > 1 && U.comments.sort((ne, se) => M.locStart(ne) - M.locStart(se));
              O.length = 0;
            }
            function d(O, R) {
              let M = O.getValue();
              return M.printed = true, R.printer.printComment(O, R);
            }
            function y(O, R, M) {
              let H = M.locStart(R) - 1;
              for (let P = 1; P < O.length; ++P)
                if (H < M.locStart(O[P]))
                  return P - 1;
              return 0;
            }
            function o(O, R) {
              let M = O.getValue(), H = [d(O, R)], { printer: P, originalText: G, locStart: re, locEnd: $ } = R;
              if (P.isBlockComment && P.isBlockComment(M)) {
                let U = C(G, $(M)) ? C(G, re(M), { backwards: true }) ? i : s : " ";
                H.push(U);
              } else
                H.push(i);
              let ee = m(G, g(G, $(M)));
              return ee !== false && C(G, ee) && H.push(i), H;
            }
            function x(O, R) {
              let M = O.getValue(), H = d(O, R), { printer: P, originalText: G, locStart: re } = R, $ = P.isBlockComment && P.isBlockComment(M);
              if (C(G, re(M), { backwards: true })) {
                let ee = p(G, M, re);
                return a([i, ee ? i : "", H]);
              }
              let W = [" ", H];
              return $ || (W = [a(W), r]), W;
            }
            function F(O, R, M, H) {
              let P = [], G = O.getValue();
              return !G || !G.comments || (O.each(() => {
                let re = O.getValue();
                !re.leading && !re.trailing && (!H || H(re)) && P.push(d(O, R));
              }, "comments"), P.length === 0) ? "" : M ? c(i, P) : u([i, c(i, P)]);
            }
            function S(O, R, M) {
              let H = O.getValue();
              if (!H)
                return {};
              let P = H.comments || [];
              M && (P = P.filter((W) => !M.has(W)));
              let G = H === R.cursorNode;
              if (P.length === 0) {
                let W = G ? l : "";
                return { leading: W, trailing: W };
              }
              let re = [], $ = [];
              return O.each(() => {
                let W = O.getValue();
                if (M && M.has(W))
                  return;
                let { leading: ee, trailing: U } = W;
                ee ? re.push(o(O, R)) : U && $.push(x(O, R));
              }, "comments"), G && (re.unshift(l), $.push(l)), { leading: re, trailing: $ };
            }
            function k(O, R, M, H) {
              let { leading: P, trailing: G } = S(O, M, H);
              return !P && !G ? R : [P, R, G];
            }
            function _(O) {
              if (!!O)
                for (let R of O) {
                  if (!R.printed)
                    throw new Error('Comment "' + R.value.trim() + '" was not printed. Please report this error!');
                  delete R.printed;
                }
            }
            n.exports = { attach: B, printComments: k, printCommentsSeparately: S, printDanglingComments: F, getSortedChildNodes: A, ensureAllCommentsPrinted: _ };
          } }), um = Z({ "src/common/ast-path.js"(e, n) {
            "use strict";
            ae();
            var t = st();
            function s(u, a) {
              let c = i(u.stack, a);
              return c === -1 ? null : u.stack[c];
            }
            function i(u, a) {
              for (let c = u.length - 1; c >= 0; c -= 2) {
                let l = u[c];
                if (l && !Array.isArray(l) && --a < 0)
                  return c;
              }
              return -1;
            }
            var r = class {
              constructor(u) {
                this.stack = [u];
              }
              getName() {
                let { stack: u } = this, { length: a } = u;
                return a > 1 ? u[a - 2] : null;
              }
              getValue() {
                return t(this.stack);
              }
              getNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
              getParentNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
              call(u) {
                let { stack: a } = this, { length: c } = a, l = t(a);
                for (var C = arguments.length, m = new Array(C > 1 ? C - 1 : 0), g = 1; g < C; g++)
                  m[g - 1] = arguments[g];
                for (let f of m)
                  l = l[f], a.push(f, l);
                let p = u(this);
                return a.length = c, p;
              }
              callParent(u) {
                let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = i(this.stack, a + 1), l = this.stack.splice(c + 1), C = u(this);
                return this.stack.push(...l), C;
              }
              each(u) {
                let { stack: a } = this, { length: c } = a, l = t(a);
                for (var C = arguments.length, m = new Array(C > 1 ? C - 1 : 0), g = 1; g < C; g++)
                  m[g - 1] = arguments[g];
                for (let p of m)
                  l = l[p], a.push(p, l);
                for (let p = 0; p < l.length; ++p)
                  a.push(p, l[p]), u(this, p, l), a.length -= 2;
                a.length = c;
              }
              map(u) {
                let a = [];
                for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), C = 1; C < c; C++)
                  l[C - 1] = arguments[C];
                return this.each((m, g, p) => {
                  a[g] = u(m, g, p);
                }, ...l), a;
              }
              try(u) {
                let { stack: a } = this, c = [...a];
                try {
                  return u();
                } finally {
                  a.length = 0, a.push(...c);
                }
              }
              match() {
                let u = this.stack.length - 1, a = null, c = this.stack[u--];
                for (var l = arguments.length, C = new Array(l), m = 0; m < l; m++)
                  C[m] = arguments[m];
                for (let g of C) {
                  if (c === void 0)
                    return false;
                  let p = null;
                  if (typeof a == "number" && (p = a, a = this.stack[u--], c = this.stack[u--]), g && !g(c, a, p))
                    return false;
                  a = this.stack[u--], c = this.stack[u--];
                }
                return true;
              }
              findAncestor(u) {
                let a = this.stack.length - 1, c = null, l = this.stack[a--];
                for (; l; ) {
                  let C = null;
                  if (typeof c == "number" && (C = c, c = this.stack[a--], l = this.stack[a--]), c !== null && u(l, c, C))
                    return l;
                  c = this.stack[a--], l = this.stack[a--];
                }
              }
            };
            n.exports = r;
          } }), sm = Z({ "src/main/multiparser.js"(e, n) {
            "use strict";
            ae();
            var { utils: { stripTrailingHardline: t } } = Le(), { normalize: s } = Mi(), i = Qe();
            function r(a, c, l, C) {
              if (l.printer.embed && l.embeddedLanguageFormatting === "auto")
                return l.printer.embed(a, c, (m, g, p) => u(m, g, l, C, p), l);
            }
            function u(a, c, l, C) {
              let { stripTrailingHardline: m = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, l), c), {}, { parentParser: l.parser, originalText: a }), { passThrough: true }), p = Gn().parse(a, g), { ast: f } = p;
              a = p.text;
              let h = f.comments;
              delete f.comments, i.attach(h, f, a, g), g[Symbol.for("comments")] = h || [], g[Symbol.for("tokens")] = f.tokens || [];
              let N = C(f, g);
              return i.ensureAllCommentsPrinted(h), m ? typeof N == "string" ? N.replace(/(?:\r?\n)*$/, "") : t(N) : N;
            }
            n.exports = { printSubtree: r };
          } }), am = Z({ "src/main/ast-to-doc.js"(e, n) {
            "use strict";
            ae();
            var t = um(), { builders: { hardline: s, addAlignmentToDoc: i }, utils: { propagateBreaks: r } } = Le(), { printComments: u } = Qe(), a = sm();
            function c(m, g) {
              let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
              f.preprocess && (m = f.preprocess(m, g));
              let h = /* @__PURE__ */ new Map(), N = new t(m), T = A();
              return p > 0 && (T = i([s, T], p, g.tabWidth)), r(T), T;
              function A(v, B) {
                return v === void 0 || v === N ? b(B) : Array.isArray(v) ? N.call(() => b(B), ...v) : N.call(() => b(B), v);
              }
              function b(v) {
                let B = N.getValue(), w = B && typeof B == "object" && v === void 0;
                if (w && h.has(B))
                  return h.get(B);
                let I = C(N, g, A, v);
                return w && h.set(B, I), I;
              }
            }
            function l(m, g) {
              let { originalText: p, [Symbol.for("comments")]: f, locStart: h, locEnd: N } = g, T = h(m), A = N(m), b = /* @__PURE__ */ new Set();
              for (let v of f)
                h(v) >= T && N(v) <= A && (v.printed = true, b.add(v));
              return { doc: p.slice(T, A), printedComments: b };
            }
            function C(m, g, p, f) {
              let h = m.getValue(), { printer: N } = g, T, A;
              if (N.hasPrettierIgnore && N.hasPrettierIgnore(m))
                ({ doc: T, printedComments: A } = l(h, g));
              else {
                if (h)
                  try {
                    T = a.printSubtree(m, p, g, c);
                  } catch (b) {
                    if (globalThis.PRETTIER_DEBUG)
                      throw b;
                  }
                T || (T = N.print(m, g, p, f));
              }
              return (!N.willPrintOwnComments || !N.willPrintOwnComments(m, g)) && (T = u(m, T, g, A)), T;
            }
            n.exports = c;
          } }), im = Z({ "src/main/range-util.js"(e, n) {
            "use strict";
            ae();
            var t = Ut(), s = Qe(), i = (f) => {
              let { parser: h } = f;
              return h === "json" || h === "json5" || h === "json-stringify";
            };
            function r(f, h) {
              let N = [f.node, ...f.parentNodes], T = /* @__PURE__ */ new Set([h.node, ...h.parentNodes]);
              return N.find((A) => C.has(A.type) && T.has(A));
            }
            function u(f) {
              let h = f.length - 1;
              for (; ; ) {
                let N = f[h];
                if (N && (N.type === "Program" || N.type === "File"))
                  h--;
                else
                  break;
              }
              return f.slice(0, h + 1);
            }
            function a(f, h, N) {
              let { locStart: T, locEnd: A } = N, b = f.node, v = h.node;
              if (b === v)
                return { startNode: b, endNode: v };
              let B = T(f.node);
              for (let I of u(h.parentNodes))
                if (T(I) >= B)
                  v = I;
                else
                  break;
              let w = A(h.node);
              for (let I of u(f.parentNodes))
                if (A(I) <= w)
                  b = I;
                else
                  break;
              return { startNode: b, endNode: v };
            }
            function c(f, h, N, T) {
              let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], b = arguments.length > 5 ? arguments[5] : void 0, { locStart: v, locEnd: B } = N, w = v(f), I = B(f);
              if (!(h > I || h < w || b === "rangeEnd" && h === w || b === "rangeStart" && h === I)) {
                for (let E of s.getSortedChildNodes(f, N)) {
                  let D = c(E, h, N, T, [f, ...A], b);
                  if (D)
                    return D;
                }
                if (!T || T(f, A[0]))
                  return { node: f, parentNodes: A };
              }
            }
            function l(f, h) {
              return h !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
            }
            var C = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), m = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
            function g(f, h, N) {
              if (!h)
                return false;
              switch (f.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript":
                case "acorn":
                case "espree":
                case "meriyah":
                case "__babel_estree":
                  return l(h.type, N && N.type);
                case "json":
                case "json5":
                case "json-stringify":
                  return C.has(h.type);
                case "graphql":
                  return m.has(h.kind);
                case "vue":
                  return h.tag !== "root";
              }
              return false;
            }
            function p(f, h, N) {
              let { rangeStart: T, rangeEnd: A, locStart: b, locEnd: v } = h;
              t.ok(A > T);
              let B = f.slice(T, A).search(/\S/), w = B === -1;
              if (!w)
                for (T += B; A > T && !/\S/.test(f[A - 1]); --A)
                  ;
              let I = c(N, T, h, (y, o) => g(h, y, o), [], "rangeStart"), E = w ? I : c(N, A, h, (y) => g(h, y), [], "rangeEnd");
              if (!I || !E)
                return { rangeStart: 0, rangeEnd: 0 };
              let D, d;
              if (i(h)) {
                let y = r(I, E);
                D = y, d = y;
              } else
                ({ startNode: D, endNode: d } = a(I, E, h));
              return { rangeStart: Math.min(b(D), b(d)), rangeEnd: Math.max(v(D), v(d)) };
            }
            n.exports = { calculateRange: p, findNodeAtOffset: c };
          } }), om = Z({ "src/main/core.js"(e, n) {
            "use strict";
            ae();
            var { diffArrays: t } = rD(), { printer: { printDocToString: s }, debug: { printDocToDebug: i } } = Le(), { getAlignmentSize: r } = Ge(), { guessEndOfLine: u, convertEndOfLineToChars: a, countEndOfLineChars: c, normalizeEndOfLine: l } = On(), C = Mi().normalize, m = nm(), g = Qe(), p = Gn(), f = am(), h = im(), N = "\uFEFF", T = Symbol("cursor");
            function A(d, y, o) {
              let x = y.comments;
              return x && (delete y.comments, g.attach(x, y, d, o)), o[Symbol.for("comments")] = x || [], o[Symbol.for("tokens")] = y.tokens || [], o.originalText = d, x;
            }
            function b(d, y) {
              let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              if (!d || d.trim().length === 0)
                return { formatted: "", cursorOffset: -1, comments: [] };
              let { ast: x, text: F } = p.parse(d, y);
              if (y.cursorOffset >= 0) {
                let O = h.findNodeAtOffset(x, y.cursorOffset, y);
                O && O.node && (y.cursorNode = O.node);
              }
              let S = A(F, x, y), k = f(x, y, o), _ = s(k, y);
              if (g.ensureAllCommentsPrinted(S), o > 0) {
                let O = _.formatted.trim();
                _.cursorNodeStart !== void 0 && (_.cursorNodeStart -= _.formatted.indexOf(O)), _.formatted = O + a(y.endOfLine);
              }
              if (y.cursorOffset >= 0) {
                let O, R, M, H, P;
                if (y.cursorNode && _.cursorNodeText ? (O = y.locStart(y.cursorNode), R = F.slice(O, y.locEnd(y.cursorNode)), M = y.cursorOffset - O, H = _.cursorNodeStart, P = _.cursorNodeText) : (O = 0, R = F, M = y.cursorOffset, H = 0, P = _.formatted), R === P)
                  return { formatted: _.formatted, cursorOffset: H + M, comments: S };
                let G = [...R];
                G.splice(M, 0, T);
                let re = [...P], $ = t(G, re), W = H;
                for (let ee of $)
                  if (ee.removed) {
                    if (ee.value.includes(T))
                      break;
                  } else
                    W += ee.count;
                return { formatted: _.formatted, cursorOffset: W, comments: S };
              }
              return { formatted: _.formatted, cursorOffset: -1, comments: S };
            }
            function v(d, y) {
              let { ast: o, text: x } = p.parse(d, y), { rangeStart: F, rangeEnd: S } = h.calculateRange(x, y, o), k = x.slice(F, S), _ = Math.min(F, x.lastIndexOf(`
`, F) + 1), O = x.slice(_, F).match(/^\s*/)[0], R = r(O, y.tabWidth), M = b(k, Object.assign(Object.assign({}, y), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: y.cursorOffset > F && y.cursorOffset <= S ? y.cursorOffset - F : -1, endOfLine: "lf" }), R), H = M.formatted.trimEnd(), { cursorOffset: P } = y;
              P > S ? P += H.length - k.length : M.cursorOffset >= 0 && (P = M.cursorOffset + F);
              let G = x.slice(0, F) + H + x.slice(S);
              if (y.endOfLine !== "lf") {
                let re = a(y.endOfLine);
                P >= 0 && re === `\r
` && (P += c(G.slice(0, P), `
`)), G = G.replace(/\n/g, re);
              }
              return { formatted: G, cursorOffset: P, comments: M.comments };
            }
            function B(d, y, o) {
              return typeof y != "number" || Number.isNaN(y) || y < 0 || y > d.length ? o : y;
            }
            function w(d, y) {
              let { cursorOffset: o, rangeStart: x, rangeEnd: F } = y;
              return o = B(d, o, -1), x = B(d, x, 0), F = B(d, F, d.length), Object.assign(Object.assign({}, y), {}, { cursorOffset: o, rangeStart: x, rangeEnd: F });
            }
            function I(d, y) {
              let { cursorOffset: o, rangeStart: x, rangeEnd: F, endOfLine: S } = w(d, y), k = d.charAt(0) === N;
              if (k && (d = d.slice(1), o--, x--, F--), S === "auto" && (S = u(d)), d.includes("\r")) {
                let _ = (O) => c(d.slice(0, Math.max(O, 0)), `\r
`);
                o -= _(o), x -= _(x), F -= _(F), d = l(d);
              }
              return { hasBOM: k, text: d, options: w(d, Object.assign(Object.assign({}, y), {}, { cursorOffset: o, rangeStart: x, rangeEnd: F, endOfLine: S })) };
            }
            function E(d, y) {
              let o = p.resolveParser(y);
              return !o.hasPragma || o.hasPragma(d);
            }
            function D(d, y) {
              let { hasBOM: o, text: x, options: F } = I(d, C(y));
              if (F.rangeStart >= F.rangeEnd && x !== "" || F.requirePragma && !E(x, F))
                return { formatted: d, cursorOffset: y.cursorOffset, comments: [] };
              let S;
              return F.rangeStart > 0 || F.rangeEnd < x.length ? S = v(x, F) : (!F.requirePragma && F.insertPragma && F.printer.insertPragma && !E(x, F) && (x = F.printer.insertPragma(x)), S = b(x, F)), o && (S.formatted = N + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
            }
            n.exports = { formatWithCursor: D, parse(d, y, o) {
              let { text: x, options: F } = I(d, C(y)), S = p.parse(x, F);
              return o && (S.ast = m(S.ast, F)), S;
            }, formatAST(d, y) {
              y = C(y);
              let o = f(d, y);
              return s(o, y);
            }, formatDoc(d, y) {
              return D(i(d), Object.assign(Object.assign({}, y), {}, { parser: "__js_expression" })).formatted;
            }, printToDoc(d, y) {
              y = C(y);
              let { ast: o, text: x } = p.parse(d, y);
              return A(x, o, y), f(o, y);
            }, printDocToString(d, y) {
              return s(d, C(y));
            } };
          } }), cm = Z({ "src/common/util-shared.js"(e, n) {
            "use strict";
            ae();
            var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: i, getIndentSize: r, skip: u, skipWhitespace: a, skipSpaces: c, skipNewline: l, skipToLineEnd: C, skipEverythingButNewLine: m, skipInlineComment: g, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h, hasSpaces: N, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: b, getNextNonSpaceNonCommentCharacterIndex: v, makeString: B, addLeadingComment: w, addDanglingComment: I, addTrailingComment: E } = Ge();
            n.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: i, getIndentSize: r, skip: u, skipWhitespace: a, skipSpaces: c, skipNewline: l, skipToLineEnd: C, skipEverythingButNewLine: m, skipInlineComment: g, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h, hasSpaces: N, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: b, getNextNonSpaceNonCommentCharacterIndex: v, makeString: B, addLeadingComment: w, addDanglingComment: I, addTrailingComment: E };
          } }), bt = Z({ "src/utils/create-language.js"(e, n) {
            "use strict";
            ae(), n.exports = function(t, s) {
              let { languageId: i } = t, r = _n(t, Kf);
              return Object.assign(Object.assign({ linguistLanguageId: i }, r), s(t));
            };
          } }), lm = Z({ "node_modules/esutils/lib/ast.js"(e, n) {
            ae(), function() {
              "use strict";
              function t(c) {
                if (c == null)
                  return false;
                switch (c.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return true;
                }
                return false;
              }
              function s(c) {
                if (c == null)
                  return false;
                switch (c.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return true;
                }
                return false;
              }
              function i(c) {
                if (c == null)
                  return false;
                switch (c.type) {
                  case "BlockStatement":
                  case "BreakStatement":
                  case "ContinueStatement":
                  case "DebuggerStatement":
                  case "DoWhileStatement":
                  case "EmptyStatement":
                  case "ExpressionStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "IfStatement":
                  case "LabeledStatement":
                  case "ReturnStatement":
                  case "SwitchStatement":
                  case "ThrowStatement":
                  case "TryStatement":
                  case "VariableDeclaration":
                  case "WhileStatement":
                  case "WithStatement":
                    return true;
                }
                return false;
              }
              function r(c) {
                return i(c) || c != null && c.type === "FunctionDeclaration";
              }
              function u(c) {
                switch (c.type) {
                  case "IfStatement":
                    return c.alternate != null ? c.alternate : c.consequent;
                  case "LabeledStatement":
                  case "ForStatement":
                  case "ForInStatement":
                  case "WhileStatement":
                  case "WithStatement":
                    return c.body;
                }
                return null;
              }
              function a(c) {
                var l;
                if (c.type !== "IfStatement" || c.alternate == null)
                  return false;
                l = c.consequent;
                do {
                  if (l.type === "IfStatement" && l.alternate == null)
                    return true;
                  l = u(l);
                } while (l);
                return false;
              }
              n.exports = { isExpression: t, isStatement: i, isIterationStatement: s, isSourceElement: r, isProblematicIfStatement: a, trailingStatement: u };
            }();
          } }), Ri = Z({ "node_modules/esutils/lib/code.js"(e, n) {
            ae(), function() {
              "use strict";
              var t, s, i, r, u, a;
              s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
              function c(A) {
                return 48 <= A && A <= 57;
              }
              function l(A) {
                return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;
              }
              function C(A) {
                return A >= 48 && A <= 55;
              }
              i = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
              function m(A) {
                return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && i.indexOf(A) >= 0;
              }
              function g(A) {
                return A === 10 || A === 13 || A === 8232 || A === 8233;
              }
              function p(A) {
                if (A <= 65535)
                  return String.fromCharCode(A);
                var b = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296), v = String.fromCharCode((A - 65536) % 1024 + 56320);
                return b + v;
              }
              for (r = new Array(128), a = 0; a < 128; ++a)
                r[a] = a >= 97 && a <= 122 || a >= 65 && a <= 90 || a === 36 || a === 95;
              for (u = new Array(128), a = 0; a < 128; ++a)
                u[a] = a >= 97 && a <= 122 || a >= 65 && a <= 90 || a >= 48 && a <= 57 || a === 36 || a === 95;
              function f(A) {
                return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p(A));
              }
              function h(A) {
                return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p(A));
              }
              function N(A) {
                return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p(A));
              }
              function T(A) {
                return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p(A));
              }
              n.exports = { isDecimalDigit: c, isHexDigit: l, isOctalDigit: C, isWhiteSpace: m, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: h, isIdentifierStartES6: N, isIdentifierPartES6: T };
            }();
          } }), pm = Z({ "node_modules/esutils/lib/keyword.js"(e, n) {
            ae(), function() {
              "use strict";
              var t = Ri();
              function s(f) {
                switch (f) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }
              function i(f, h) {
                return !h && f === "yield" ? false : r(f, h);
              }
              function r(f, h) {
                if (h && s(f))
                  return true;
                switch (f.length) {
                  case 2:
                    return f === "if" || f === "in" || f === "do";
                  case 3:
                    return f === "var" || f === "for" || f === "new" || f === "try";
                  case 4:
                    return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                  case 5:
                    return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                  case 6:
                    return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                  case 7:
                    return f === "default" || f === "finally" || f === "extends";
                  case 8:
                    return f === "function" || f === "continue" || f === "debugger";
                  case 10:
                    return f === "instanceof";
                  default:
                    return false;
                }
              }
              function u(f, h) {
                return f === "null" || f === "true" || f === "false" || i(f, h);
              }
              function a(f, h) {
                return f === "null" || f === "true" || f === "false" || r(f, h);
              }
              function c(f) {
                return f === "eval" || f === "arguments";
              }
              function l(f) {
                var h, N, T;
                if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T)))
                  return false;
                for (h = 1, N = f.length; h < N; ++h)
                  if (T = f.charCodeAt(h), !t.isIdentifierPartES5(T))
                    return false;
                return true;
              }
              function C(f, h) {
                return (f - 55296) * 1024 + (h - 56320) + 65536;
              }
              function m(f) {
                var h, N, T, A, b;
                if (f.length === 0)
                  return false;
                for (b = t.isIdentifierStartES6, h = 0, N = f.length; h < N; ++h) {
                  if (T = f.charCodeAt(h), 55296 <= T && T <= 56319) {
                    if (++h, h >= N || (A = f.charCodeAt(h), !(56320 <= A && A <= 57343)))
                      return false;
                    T = C(T, A);
                  }
                  if (!b(T))
                    return false;
                  b = t.isIdentifierPartES6;
                }
                return true;
              }
              function g(f, h) {
                return l(f) && !u(f, h);
              }
              function p(f, h) {
                return m(f) && !a(f, h);
              }
              n.exports = { isKeywordES5: i, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: a, isRestrictedWord: c, isIdentifierNameES5: l, isIdentifierNameES6: m, isIdentifierES5: g, isIdentifierES6: p };
            }();
          } }), fm = Z({ "node_modules/esutils/lib/utils.js"(e) {
            ae(), function() {
              "use strict";
              e.ast = lm(), e.code = Ri(), e.keyword = pm();
            }();
          } }), Pt = Z({ "src/language-js/utils/is-block-comment.js"(e, n) {
            "use strict";
            ae();
            function t(s) {
              return s.type === "Block" || s.type === "CommentBlock" || s.type === "MultiLine";
            }
            n.exports = t;
          } }), Xe = Z({ "src/language-js/utils/index.js"(e, n) {
            "use strict";
            ae();
            var t = fm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: i, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: a, getStringWidth: c } = Ge(), { locStart: l, locEnd: C, hasSameLocStart: m } = nt(), g = Pt(), p = "(?:(?=.)\\s)", f = new RegExp("^".concat(p, "*:")), h = new RegExp("^".concat(p, "*::"));
            function N(L) {
              return L.extra && L.extra.parenthesized && u(L.trailingComments) && g(L.trailingComments[0]) && f.test(L.trailingComments[0].value);
            }
            function T(L) {
              return u(L) && g(L[0]) && h.test(L[0].value);
            }
            function A(L, De) {
              if (!L || typeof L != "object")
                return false;
              if (Array.isArray(L))
                return L.some((We) => A(We, De));
              let ke = De(L);
              return typeof ke == "boolean" ? ke : Object.values(L).some((We) => A(We, De));
            }
            function b(L) {
              return L.type === "AssignmentExpression" || L.type === "BinaryExpression" || L.type === "LogicalExpression" || L.type === "NGPipeExpression" || L.type === "ConditionalExpression" || Ee(L) || q(L) || L.type === "SequenceExpression" || L.type === "TaggedTemplateExpression" || L.type === "BindExpression" || L.type === "UpdateExpression" && !L.prefix || L.type === "TSAsExpression" || L.type === "TSNonNullExpression";
            }
            function v(L) {
              return L.expressions ? L.expressions[0] : L.left || L.test || L.callee || L.object || L.tag || L.argument || L.expression;
            }
            function B(L, De) {
              if (De.expressions)
                return ["expressions", 0];
              if (De.left)
                return ["left"];
              if (De.test)
                return ["test"];
              if (De.object)
                return ["object"];
              if (De.callee)
                return ["callee"];
              if (De.tag)
                return ["tag"];
              if (De.argument)
                return ["argument"];
              if (De.expression)
                return ["expression"];
              throw new Error("Unexpected node has no left side.");
            }
            function w(L) {
              return L.type === "Line" || L.type === "CommentLine" || L.type === "SingleLine" || L.type === "HashbangComment" || L.type === "HTMLOpen" || L.type === "HTMLClose";
            }
            var I = /* @__PURE__ */ new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
            function E(L) {
              return L && I.has(L.type);
            }
            function D(L) {
              let De = L.getParentNode();
              return L.getName() === "declaration" && E(De) ? De : null;
            }
            function d(L) {
              return L.type === "BooleanLiteral" || L.type === "DirectiveLiteral" || L.type === "Literal" || L.type === "NullLiteral" || L.type === "NumericLiteral" || L.type === "BigIntLiteral" || L.type === "DecimalLiteral" || L.type === "RegExpLiteral" || L.type === "StringLiteral" || L.type === "TemplateLiteral" || L.type === "TSTypeLiteral" || L.type === "JSXText";
            }
            function y(L) {
              return L.type === "NumericLiteral" || L.type === "Literal" && typeof L.value == "number";
            }
            function o(L) {
              return L.type === "UnaryExpression" && (L.operator === "+" || L.operator === "-") && y(L.argument);
            }
            function x(L) {
              return L.type === "StringLiteral" || L.type === "Literal" && typeof L.value == "string";
            }
            function F(L) {
              return L.type === "ObjectTypeAnnotation" || L.type === "TSTypeLiteral" || L.type === "TSMappedType";
            }
            function S(L) {
              return L.type === "FunctionExpression" || L.type === "ArrowFunctionExpression";
            }
            function k(L) {
              return L.type === "FunctionExpression" || L.type === "ArrowFunctionExpression" && L.body.type === "BlockStatement";
            }
            function _(L) {
              return L.type === "TemplateLiteral";
            }
            function O(L) {
              return Ee(L) && L.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(L.callee.name);
            }
            function R(L) {
              return L.type === "JSXElement" || L.type === "JSXFragment";
            }
            function M(L, De) {
              if (L.parentParser !== "markdown" && L.parentParser !== "mdx")
                return false;
              let ke = De.getNode();
              if (!ke.expression || !R(ke.expression))
                return false;
              let We = De.getParentNode();
              return We.type === "Program" && We.body.length === 1;
            }
            function H(L) {
              return L.kind === "get" || L.kind === "set";
            }
            function P(L) {
              return H(L) || m(L, L.value);
            }
            function G(L) {
              return (L.type === "ObjectTypeProperty" || L.type === "ObjectTypeInternalSlot") && L.value.type === "FunctionTypeAnnotation" && !L.static && !P(L);
            }
            function re(L) {
              return (L.type === "TypeAnnotation" || L.type === "TSTypeAnnotation") && L.typeAnnotation.type === "FunctionTypeAnnotation" && !L.static && !m(L, L.typeAnnotation);
            }
            var $ = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
            function W(L) {
              return $.has(L.type);
            }
            function ee(L) {
              return q(L) || L.type === "BindExpression" && Boolean(L.object);
            }
            var U = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
            function ne(L) {
              return L ? !!((L.type === "GenericTypeAnnotation" || L.type === "TSTypeReference") && !L.typeParameters || U.has(L.type)) : false;
            }
            var se = /^(?:skip|[fx]?(?:it|describe|test))$/;
            function V(L) {
              return q(L.callee) && L.callee.object.type === "Identifier" && L.callee.property.type === "Identifier" && se.test(L.callee.object.name) && (L.callee.property.name === "only" || L.callee.property.name === "skip");
            }
            function oe(L) {
              let De = /^(?:before|after)(?:Each|All)$/;
              return L.callee.type === "Identifier" && De.test(L.callee.name) && L.arguments.length === 1;
            }
            function K(L, De) {
              if (L.type !== "CallExpression")
                return false;
              if (L.arguments.length === 1) {
                if (O(L) && De && K(De))
                  return S(L.arguments[0]);
                if (oe(L))
                  return O(L.arguments[0]);
              } else if ((L.arguments.length === 2 || L.arguments.length === 3) && (L.callee.type === "Identifier" && se.test(L.callee.name) || V(L)) && (_(L.arguments[0]) || x(L.arguments[0])))
                return L.arguments[2] && !y(L.arguments[2]) ? false : (L.arguments.length === 2 ? S(L.arguments[1]) : k(L.arguments[1]) && Ke(L.arguments[1]).length <= 1) || O(L.arguments[1]);
              return false;
            }
            function Ee(L) {
              return L && (L.type === "CallExpression" || L.type === "OptionalCallExpression");
            }
            function q(L) {
              return L && (L.type === "MemberExpression" || L.type === "OptionalMemberExpression");
            }
            function le(L) {
              let De = "expressions";
              L.type === "TSTemplateLiteralType" && (De = "types");
              let ke = L[De];
              return ke.length === 0 ? false : ke.every((We) => {
                if (Me(We))
                  return false;
                if (We.type === "Identifier" || We.type === "ThisExpression")
                  return true;
                if (q(We)) {
                  let $e = We;
                  for (; q($e); )
                    if ($e.property.type !== "Identifier" && $e.property.type !== "Literal" && $e.property.type !== "StringLiteral" && $e.property.type !== "NumericLiteral" || ($e = $e.object, Me($e)))
                      return false;
                  return $e.type === "Identifier" || $e.type === "ThisExpression";
                }
                return false;
              });
            }
            function ue(L, De) {
              return L === "+" ? "+" + De : L === "-" ? "-" + De : De;
            }
            function Q(L, De) {
              let ke = l(De), We = r(L, C(De));
              return We !== false && L.slice(ke, ke + 2) === "/*" && L.slice(We, We + 2) === "*/";
            }
            function de(L, De) {
              return R(De) ? Ae(De) : Me(De, Pe.Leading, (ke) => i(L, C(ke)));
            }
            function ge(L, De) {
              return De.parser !== "json" && x(L.key) && J(L.key).slice(1, -1) === L.key.value && (t(L.key.value) && !(De.parser === "babel-ts" && L.type === "ClassProperty" || De.parser === "typescript" && L.type === "PropertyDefinition") || ve(L.key.value) && String(Number(L.key.value)) === L.key.value && (De.parser === "babel" || De.parser === "acorn" || De.parser === "espree" || De.parser === "meriyah" || De.parser === "__babel_estree"));
            }
            function ve(L) {
              return /^(?:\d+|\d+\.\d+)$/.test(L);
            }
            function xe(L, De) {
              let ke = /^[fx]?(?:describe|it|test)$/;
              return De.type === "TaggedTemplateExpression" && De.quasi === L && De.tag.type === "MemberExpression" && De.tag.property.type === "Identifier" && De.tag.property.name === "each" && (De.tag.object.type === "Identifier" && ke.test(De.tag.object.name) || De.tag.object.type === "MemberExpression" && De.tag.object.property.type === "Identifier" && (De.tag.object.property.name === "only" || De.tag.object.property.name === "skip") && De.tag.object.object.type === "Identifier" && ke.test(De.tag.object.object.name));
            }
            function we(L) {
              return L.quasis.some((De) => De.value.raw.includes(`
`));
            }
            function fe(L, De) {
              return (L.type === "TemplateLiteral" && we(L) || L.type === "TaggedTemplateExpression" && we(L.quasi)) && !i(De, l(L), { backwards: true });
            }
            function pe(L) {
              if (!Me(L))
                return false;
              let De = s(qe(L, Pe.Dangling));
              return De && !g(De);
            }
            function me(L) {
              if (L.length <= 1)
                return false;
              let De = 0;
              for (let ke of L)
                if (S(ke)) {
                  if (De += 1, De > 1)
                    return true;
                } else if (Ee(ke)) {
                  for (let We of ke.arguments)
                    if (S(We))
                      return true;
                }
              return false;
            }
            function ce(L) {
              let De = L.getValue(), ke = L.getParentNode();
              return Ee(De) && Ee(ke) && ke.callee === De && De.arguments.length > ke.arguments.length && ke.arguments.length > 0;
            }
            function he(L, De) {
              if (De >= 2)
                return false;
              let ke = ($e) => he($e, De + 1), We = L.type === "Literal" && "regex" in L && L.regex.pattern || L.type === "RegExpLiteral" && L.pattern;
              return We && c(We) > 5 ? false : L.type === "Literal" || L.type === "BigIntLiteral" || L.type === "DecimalLiteral" || L.type === "BooleanLiteral" || L.type === "NullLiteral" || L.type === "NumericLiteral" || L.type === "RegExpLiteral" || L.type === "StringLiteral" || L.type === "Identifier" || L.type === "ThisExpression" || L.type === "Super" || L.type === "PrivateName" || L.type === "PrivateIdentifier" || L.type === "ArgumentPlaceholder" || L.type === "Import" ? true : L.type === "TemplateLiteral" ? L.quasis.every(($e) => !$e.value.raw.includes(`
`)) && L.expressions.every(ke) : L.type === "ObjectExpression" ? L.properties.every(($e) => !$e.computed && ($e.shorthand || $e.value && ke($e.value))) : L.type === "ArrayExpression" ? L.elements.every(($e) => $e === null || ke($e)) : rt(L) ? (L.type === "ImportExpression" || he(L.callee, De)) && Be(L).every(ke) : q(L) ? he(L.object, De) && he(L.property, De) : L.type === "UnaryExpression" && (L.operator === "!" || L.operator === "-") ? he(L.argument, De) : L.type === "TSNonNullExpression" ? he(L.expression, De) : false;
            }
            function J(L) {
              return L.extra ? L.extra.raw : L.raw;
            }
            function ye(L) {
              return L;
            }
            function X(L) {
              return L.filepath && /\.tsx$/i.test(L.filepath);
            }
            function Y(L) {
              let De = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
              return L.trailingComma === "es5" && De === "es5" || L.trailingComma === "all" && (De === "all" || De === "es5");
            }
            function te(L, De) {
              switch (L = tt(L), L.type) {
                case "FunctionExpression":
                case "ClassExpression":
                case "DoExpression":
                  return De;
                case "ObjectExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return te(L.object, De);
                case "TaggedTemplateExpression":
                  return L.tag.type === "FunctionExpression" ? false : te(L.tag, De);
                case "CallExpression":
                case "OptionalCallExpression":
                  return L.callee.type === "FunctionExpression" ? false : te(L.callee, De);
                case "ConditionalExpression":
                  return te(L.test, De);
                case "UpdateExpression":
                  return !L.prefix && te(L.argument, De);
                case "BindExpression":
                  return L.object && te(L.object, De);
                case "SequenceExpression":
                  return te(L.expressions[0], De);
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return te(L.expression, De);
                default:
                  return false;
              }
            }
            var z = { "==": true, "!=": true, "===": true, "!==": true }, j = { "*": true, "/": true, "%": true }, Ce = { ">>": true, ">>>": true, "<<": true };
            function Ne(L, De) {
              return !(Ue(De) !== Ue(L) || L === "**" || z[L] && z[De] || De === "%" && j[L] || L === "%" && j[De] || De !== L && j[De] && j[L] || Ce[L] && Ce[De]);
            }
            var je = {};
            for (let [L, De] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
              for (let ke of De)
                je[ke] = L;
            function Ue(L) {
              return je[L];
            }
            function tt(L) {
              for (; L.left; )
                L = L.left;
              return L;
            }
            function Te(L) {
              return Boolean(Ce[L]) || L === "|" || L === "^" || L === "&";
            }
            function _e(L) {
              if (L.rest)
                return true;
              let De = Ke(L);
              return De.length > 0 && s(De).type === "RestElement";
            }
            var Fe = /* @__PURE__ */ new WeakMap();
            function Ke(L) {
              if (Fe.has(L))
                return Fe.get(L);
              let De = [];
              return L.this && De.push(L.this), Array.isArray(L.parameters) ? De.push(...L.parameters) : Array.isArray(L.params) && De.push(...L.params), L.rest && De.push(L.rest), Fe.set(L, De), De;
            }
            function Se(L, De) {
              let ke = L.getValue(), We = 0, $e = (ut) => De(ut, We++);
              ke.this && L.call($e, "this"), Array.isArray(ke.parameters) ? L.each($e, "parameters") : Array.isArray(ke.params) && L.each($e, "params"), ke.rest && L.call($e, "rest");
            }
            var ze = /* @__PURE__ */ new WeakMap();
            function Be(L) {
              if (ze.has(L))
                return ze.get(L);
              let De = L.arguments;
              return L.type === "ImportExpression" && (De = [L.source], L.attributes && De.push(L.attributes)), ze.set(L, De), De;
            }
            function Ie(L, De) {
              let ke = L.getValue();
              ke.type === "ImportExpression" ? (L.call((We) => De(We, 0), "source"), ke.attributes && L.call((We) => De(We, 1), "attributes")) : L.each(De, "arguments");
            }
            function Ve(L) {
              return L.value.trim() === "prettier-ignore" && !L.unignore;
            }
            function Ae(L) {
              return L && (L.prettierIgnore || Me(L, Pe.PrettierIgnore));
            }
            function Oe(L) {
              let De = L.getValue();
              return Ae(De);
            }
            var Pe = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, ie = (L, De) => {
              if (typeof L == "function" && (De = L, L = 0), L || De)
                return (ke, We, $e) => !(L & Pe.Leading && !ke.leading || L & Pe.Trailing && !ke.trailing || L & Pe.Dangling && (ke.leading || ke.trailing) || L & Pe.Block && !g(ke) || L & Pe.Line && !w(ke) || L & Pe.First && We !== 0 || L & Pe.Last && We !== $e.length - 1 || L & Pe.PrettierIgnore && !Ve(ke) || De && !De(ke));
            };
            function Me(L, De, ke) {
              if (!L || !u(L.comments))
                return false;
              let We = ie(De, ke);
              return We ? L.comments.some(We) : true;
            }
            function qe(L, De, ke) {
              if (!L || !Array.isArray(L.comments))
                return [];
              let We = ie(De, ke);
              return We ? L.comments.filter(We) : L.comments;
            }
            var Je = (L, De) => {
              let { originalText: ke } = De;
              return a(ke, C(L));
            };
            function rt(L) {
              return Ee(L) || L.type === "NewExpression" || L.type === "ImportExpression";
            }
            function Ze(L) {
              return L && (L.type === "ObjectProperty" || L.type === "Property" && !L.method && L.kind === "init");
            }
            function ct(L) {
              return Boolean(L.__isUsingHackPipeline);
            }
            var qt = Symbol("ifWithoutBlockAndSameLineComment");
            n.exports = { getFunctionParameters: Ke, iterateFunctionParametersPath: Se, getCallArguments: Be, iterateCallArgumentsPath: Ie, hasRestParameter: _e, getLeftSide: v, getLeftSidePathName: B, getParentExportDeclaration: D, getTypeScriptMappedTypeModifier: ue, hasFlowAnnotationComment: T, hasFlowShorthandAnnotationComment: N, hasLeadingOwnLineComment: de, hasNakedLeftSide: b, hasNode: A, hasIgnoreComment: Oe, hasNodeIgnoreComment: Ae, identity: ye, isBinaryish: W, isCallLikeExpression: rt, isEnabledHackPipeline: ct, isLineComment: w, isPrettierIgnoreComment: Ve, isCallExpression: Ee, isMemberExpression: q, isExportDeclaration: E, isFlowAnnotationComment: Q, isFunctionCompositionArgs: me, isFunctionNotation: P, isFunctionOrArrowExpression: S, isGetterOrSetter: H, isJestEachTemplateLiteral: xe, isJsxNode: R, isLiteral: d, isLongCurriedCallExpression: ce, isSimpleCallArgument: he, isMemberish: ee, isNumericLiteral: y, isSignedNumericLiteral: o, isObjectProperty: Ze, isObjectType: F, isObjectTypePropertyAFunction: G, isSimpleType: ne, isSimpleNumber: ve, isSimpleTemplateLiteral: le, isStringLiteral: x, isStringPropSafeToUnquote: ge, isTemplateOnItsOwnLine: fe, isTestCall: K, isTheOnlyJsxElementInMarkdown: M, isTSXFile: X, isTypeAnnotationAFunction: re, isNextLineEmpty: Je, needsHardlineAfterDanglingComment: pe, rawText: J, shouldPrintComma: Y, isBitwiseOperator: Te, shouldFlatten: Ne, startsWithNoLookaheadToken: te, getPrecedence: Ue, hasComment: Me, getComments: qe, CommentCheckFlags: Pe, markerForIfWithoutBlockAndSameLineComment: qt };
          } }), It = Z({ "src/language-js/print/template-literal.js"(e, n) {
            "use strict";
            ae();
            var t = st(), { getStringWidth: s, getIndentSize: i } = Ge(), { builders: { join: r, hardline: u, softline: a, group: c, indent: l, align: C, lineSuffixBoundary: m, addAlignmentToDoc: g }, printer: { printDocToString: p }, utils: { mapDoc: f } } = Le(), { isBinaryish: h, isJestEachTemplateLiteral: N, isSimpleTemplateLiteral: T, hasComment: A, isMemberExpression: b } = Xe();
            function v(d, y, o) {
              let x = d.getValue();
              if (x.type === "TemplateLiteral" && N(x, d.getParentNode())) {
                let R = B(d, o, y);
                if (R)
                  return R;
              }
              let S = "expressions";
              x.type === "TSTemplateLiteralType" && (S = "types");
              let k = [], _ = d.map(y, S), O = T(x);
              return O && (_ = _.map((R) => p(R, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), k.push(m, "`"), d.each((R) => {
                let M = R.getName();
                if (k.push(y()), M < _.length) {
                  let { tabWidth: H } = o, P = R.getValue(), G = i(P.value.raw, H), re = _[M];
                  if (!O) {
                    let W = x[S][M];
                    (A(W) || b(W) || W.type === "ConditionalExpression" || W.type === "SequenceExpression" || W.type === "TSAsExpression" || h(W)) && (re = [l([a, re]), a]);
                  }
                  let $ = G === 0 && P.value.raw.endsWith(`
`) ? C(Number.NEGATIVE_INFINITY, re) : g(re, G, H);
                  k.push(c(["${", $, m, "}"]));
                }
              }, "quasis"), k.push("`"), k;
            }
            function B(d, y, o) {
              let x = d.getNode(), F = x.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (F.length > 1 || F.some((S) => S.length > 0)) {
                y.__inJestEach = true;
                let S = d.map(o, "expressions");
                y.__inJestEach = false;
                let k = [], _ = S.map((P) => "${" + p(P, Object.assign(Object.assign({}, y), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), O = [{ hasLineBreak: false, cells: [] }];
                for (let P = 1; P < x.quasis.length; P++) {
                  let G = t(O), re = _[P - 1];
                  G.cells.push(re), re.includes(`
`) && (G.hasLineBreak = true), x.quasis[P].value.raw.includes(`
`) && O.push({ hasLineBreak: false, cells: [] });
                }
                let R = Math.max(F.length, ...O.map((P) => P.cells.length)), M = Array.from({ length: R }).fill(0), H = [{ cells: F }, ...O.filter((P) => P.cells.length > 0)];
                for (let { cells: P } of H.filter((G) => !G.hasLineBreak))
                  for (let [G, re] of P.entries())
                    M[G] = Math.max(M[G], s(re));
                return k.push(m, "`", l([u, r(u, H.map((P) => r(" | ", P.cells.map((G, re) => P.hasLineBreak ? G : G + " ".repeat(M[re] - s(G))))))]), u, "`"), k;
              }
            }
            function w(d, y) {
              let o = d.getValue(), x = y();
              return A(o) && (x = c([l([a, x]), a])), ["${", x, m, "}"];
            }
            function I(d, y) {
              return d.map((o) => w(o, y), "expressions");
            }
            function E(d, y) {
              return f(d, (o) => typeof o == "string" ? y ? o.replace(/(\\*)`/g, "$1$1\\`") : D(o) : o);
            }
            function D(d) {
              return d.replace(/([\\`]|\${)/g, "\\$1");
            }
            n.exports = { printTemplateLiteral: v, printTemplateExpressions: I, escapeTemplateCharacters: E, uncookTemplateElementValue: D };
          } }), Dm = Z({ "src/language-js/embed/markdown.js"(e, n) {
            "use strict";
            ae();
            var { builders: { indent: t, softline: s, literalline: i, dedentToRoot: r } } = Le(), { escapeTemplateCharacters: u } = It();
            function a(l, C, m) {
              let p = l.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T, A) => "\\".repeat(A.length / 2) + "`"), f = c(p), h = f !== "";
              h && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
              let N = u(m(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
              return ["`", h ? t([s, N]) : [i, r(N)], s, "`"];
            }
            function c(l) {
              let C = l.match(/^([^\S\n]*)\S/m);
              return C === null ? "" : C[1];
            }
            n.exports = a;
          } }), mm = Z({ "src/language-js/embed/css.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, hardline: i, softline: r }, utils: { mapDoc: u, replaceEndOfLine: a, cleanDoc: c } } = Le(), { printTemplateExpressions: l } = It();
            function C(p, f, h) {
              let N = p.getValue(), T = N.quasis.map((w) => w.value.raw), A = 0, b = T.reduce((w, I, E) => E === 0 ? I : w + "@prettier-placeholder-" + A++ + "-id" + I, ""), v = h(b, { parser: "scss" }, { stripTrailingHardline: true }), B = l(p, f);
              return m(v, N, B);
            }
            function m(p, f, h) {
              if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
                return "``";
              let T = g(p, h);
              if (!T)
                throw new Error("Couldn't insert all the expressions");
              return ["`", s([i, T]), r, "`"];
            }
            function g(p, f) {
              if (!t(f))
                return p;
              let h = 0, N = u(c(p), (T) => typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map((A, b) => b % 2 === 0 ? a(A) : (h++, f[A])));
              return f.length === h ? N : null;
            }
            n.exports = C;
          } }), dm = Z({ "src/language-js/embed/graphql.js"(e, n) {
            "use strict";
            ae();
            var { builders: { indent: t, join: s, hardline: i } } = Le(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = It();
            function a(l, C, m) {
              let g = l.getValue(), p = g.quasis.length;
              if (p === 1 && g.quasis[0].value.raw.trim() === "")
                return "``";
              let f = u(l, C), h = [];
              for (let N = 0; N < p; N++) {
                let T = g.quasis[N], A = N === 0, b = N === p - 1, v = T.value.cooked, B = v.split(`
`), w = B.length, I = f[N], E = w > 2 && B[0].trim() === "" && B[1].trim() === "", D = w > 2 && B[w - 1].trim() === "" && B[w - 2].trim() === "", d = B.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
                if (!b && /#[^\n\r]*$/.test(B[w - 1]))
                  return null;
                let y = null;
                d ? y = c(B) : y = m(v, { parser: "graphql" }, { stripTrailingHardline: true }), y ? (y = r(y, false), !A && E && h.push(""), h.push(y), !b && D && h.push("")) : !A && !b && E && h.push(""), I && h.push(I);
              }
              return ["`", t([i, s(i, h)]), i, "`"];
            }
            function c(l) {
              let C = [], m = false, g = l.map((p) => p.trim());
              for (let [p, f] of g.entries())
                f !== "" && (g[p - 1] === "" && m ? C.push([i, f]) : C.push(f), m = true);
              return C.length === 0 ? null : s(i, C);
            }
            n.exports = a;
          } }), gm = Z({ "src/language-js/embed/html.js"(e, n) {
            "use strict";
            ae();
            var { builders: { indent: t, line: s, hardline: i, group: r }, utils: { mapDoc: u } } = Le(), { printTemplateExpressions: a, uncookTemplateElementValue: c } = It(), l = 0;
            function C(m, g, p, f, h) {
              let { parser: N } = h, T = m.getValue(), A = l;
              l = l + 1 >>> 0;
              let b = (x) => "PRETTIER_HTML_PLACEHOLDER_".concat(x, "_").concat(A, "_IN_JS"), v = T.quasis.map((x, F, S) => F === S.length - 1 ? x.value.cooked : x.value.cooked + b(F)).join(""), B = a(m, g);
              if (B.length === 0 && v.trim().length === 0)
                return "``";
              let w = new RegExp(b("(\\d+)"), "g"), I = 0, E = p(v, { parser: N, __onHtmlRoot(x) {
                I = x.children.length;
              } }, { stripTrailingHardline: true }), D = u(E, (x) => {
                if (typeof x != "string")
                  return x;
                let F = [], S = x.split(w);
                for (let k = 0; k < S.length; k++) {
                  let _ = S[k];
                  if (k % 2 === 0) {
                    _ && (_ = c(_), f.__embeddedInHtml && (_ = _.replace(/<\/(script)\b/gi, "<\\/$1")), F.push(_));
                    continue;
                  }
                  let O = Number(_);
                  F.push(B[O]);
                }
                return F;
              }), d = /^\s/.test(v) ? " " : "", y = /\s$/.test(v) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? i : d && y ? s : null;
              return r(o ? ["`", t([o, r(D)]), o, "`"] : ["`", d, I > 1 ? t(r(D)) : r(D), y, "`"]);
            }
            n.exports = C;
          } }), ym = Z({ "src/language-js/embed.js"(e, n) {
            "use strict";
            ae();
            var { hasComment: t, CommentCheckFlags: s, isObjectProperty: i } = Xe(), r = Dm(), u = mm(), a = dm(), c = gm();
            function l(E) {
              if (g(E) || N(E) || T(E) || p(E))
                return "css";
              if (v(E))
                return "graphql";
              if (w(E))
                return "html";
              if (f(E))
                return "angular";
              if (m(E))
                return "markdown";
            }
            function C(E, D, d, y) {
              let o = E.getValue();
              if (o.type !== "TemplateLiteral" || I(o))
                return;
              let x = l(E);
              if (!!x) {
                if (x === "markdown")
                  return r(E, D, d);
                if (x === "css")
                  return u(E, D, d);
                if (x === "graphql")
                  return a(E, D, d);
                if (x === "html" || x === "angular")
                  return c(E, D, d, y, { parser: x });
              }
            }
            function m(E) {
              let D = E.getValue(), d = E.getParentNode();
              return d && d.type === "TaggedTemplateExpression" && D.quasis.length === 1 && d.tag.type === "Identifier" && (d.tag.name === "md" || d.tag.name === "markdown");
            }
            function g(E) {
              let D = E.getValue(), d = E.getParentNode(), y = E.getParentNode(1);
              return y && D.quasis && d.type === "JSXExpressionContainer" && y.type === "JSXElement" && y.openingElement.name.name === "style" && y.openingElement.attributes.some((o) => o.name.name === "jsx") || d && d.type === "TaggedTemplateExpression" && d.tag.type === "Identifier" && d.tag.name === "css" || d && d.type === "TaggedTemplateExpression" && d.tag.type === "MemberExpression" && d.tag.object.name === "css" && (d.tag.property.name === "global" || d.tag.property.name === "resolve");
            }
            function p(E) {
              return E.match((D) => D.type === "TemplateLiteral", (D, d) => D.type === "ArrayExpression" && d === "elements", (D, d) => i(D) && D.key.type === "Identifier" && D.key.name === "styles" && d === "value", ...h);
            }
            function f(E) {
              return E.match((D) => D.type === "TemplateLiteral", (D, d) => i(D) && D.key.type === "Identifier" && D.key.name === "template" && d === "value", ...h);
            }
            var h = [(E, D) => E.type === "ObjectExpression" && D === "properties", (E, D) => E.type === "CallExpression" && E.callee.type === "Identifier" && E.callee.name === "Component" && D === "arguments", (E, D) => E.type === "Decorator" && D === "expression"];
            function N(E) {
              let D = E.getParentNode();
              if (!D || D.type !== "TaggedTemplateExpression")
                return false;
              let d = D.tag.type === "ParenthesizedExpression" ? D.tag.expression : D.tag;
              switch (d.type) {
                case "MemberExpression":
                  return A(d.object) || b(d);
                case "CallExpression":
                  return A(d.callee) || d.callee.type === "MemberExpression" && (d.callee.object.type === "MemberExpression" && (A(d.callee.object.object) || b(d.callee.object)) || d.callee.object.type === "CallExpression" && A(d.callee.object.callee));
                case "Identifier":
                  return d.name === "css";
                default:
                  return false;
              }
            }
            function T(E) {
              let D = E.getParentNode(), d = E.getParentNode(1);
              return d && D.type === "JSXExpressionContainer" && d.type === "JSXAttribute" && d.name.type === "JSXIdentifier" && d.name.name === "css";
            }
            function A(E) {
              return E.type === "Identifier" && E.name === "styled";
            }
            function b(E) {
              return /^[A-Z]/.test(E.object.name) && E.property.name === "extend";
            }
            function v(E) {
              let D = E.getValue(), d = E.getParentNode();
              return B(D, "GraphQL") || d && (d.type === "TaggedTemplateExpression" && (d.tag.type === "MemberExpression" && d.tag.object.name === "graphql" && d.tag.property.name === "experimental" || d.tag.type === "Identifier" && (d.tag.name === "gql" || d.tag.name === "graphql")) || d.type === "CallExpression" && d.callee.type === "Identifier" && d.callee.name === "graphql");
            }
            function B(E, D) {
              return t(E, s.Block | s.Leading, (d) => {
                let { value: y } = d;
                return y === " ".concat(D, " ");
              });
            }
            function w(E) {
              return B(E.getValue(), "HTML") || E.match((D) => D.type === "TemplateLiteral", (D, d) => D.type === "TaggedTemplateExpression" && D.tag.type === "Identifier" && D.tag.name === "html" && d === "quasi");
            }
            function I(E) {
              let { quasis: D } = E;
              return D.some((d) => {
                let { value: { cooked: y } } = d;
                return y === null;
              });
            }
            n.exports = C;
          } }), hm = Z({ "src/language-js/clean.js"(e, n) {
            "use strict";
            ae();
            var t = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), i = (u) => {
              for (let a of u.quasis)
                delete a.value;
            };
            function r(u, a, c) {
              if (u.type === "Program" && delete a.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && a.value && (a.value = a.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && a.bigint && (a.bigint = a.bigint.toLowerCase()), u.type === "DecimalLiteral" && (a.value = Number(a.value)), u.type === "Literal" && a.decimal && (a.decimal = Number(a.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
                return null;
              if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete a.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((C) => C.name.name === "jsx"))
                for (let { type: C, expression: m } of a.children)
                  C === "JSXExpressionContainer" && m.type === "TemplateLiteral" && i(m);
              u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && i(a.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (a.value.value = a.value.value.replace(/["']|&quot;|&apos;/g, '"'));
              let l = u.expression || u.callee;
              if (u.type === "Decorator" && l.type === "CallExpression" && l.callee.name === "Component" && l.arguments.length === 1) {
                let C = u.expression.arguments[0].properties;
                for (let [m, g] of a.expression.arguments[0].properties.entries())
                  switch (C[m].key.name) {
                    case "styles":
                      g.value.type === "ArrayExpression" && i(g.value.elements[0]);
                      break;
                    case "template":
                      g.value.type === "TemplateLiteral" && i(g.value);
                      break;
                  }
              }
              if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && i(a.quasi), u.type === "TemplateLiteral" && (u.leadingComments && u.leadingComments.some((m) => t(m) && ["GraphQL", "HTML"].some((g) => m.value === " ".concat(g, " "))) || c.type === "CallExpression" && c.callee.name === "graphql" || !u.leadingComments) && i(a), u.type === "InterpreterDirective" && (a.value = a.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
                return a.types[0];
            }
            r.ignoredProperties = s, n.exports = r;
          } }), Vi = {};
          kn(Vi, { EOL: () => wn, arch: () => Cm, cpus: () => zi, default: () => Zi, endianness: () => Wi, freemem: () => Ji, getNetworkInterfaces: () => Qi, hostname: () => $i, loadavg: () => Hi, networkInterfaces: () => Yi, platform: () => Em, release: () => Ki, tmpDir: () => Bn, tmpdir: () => Nn, totalmem: () => Ui, type: () => Xi, uptime: () => Gi });
          function Wi() {
            if (typeof Fr > "u") {
              var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
              if (n[0] = 1, n[1] = 2, t[0] === 258)
                Fr = "BE";
              else if (t[0] === 513)
                Fr = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return Fr;
          }
          function $i() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function Hi() {
            return [];
          }
          function Gi() {
            return 0;
          }
          function Ji() {
            return Number.MAX_VALUE;
          }
          function Ui() {
            return Number.MAX_VALUE;
          }
          function zi() {
            return [];
          }
          function Xi() {
            return "Browser";
          }
          function Ki() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function Yi() {
          }
          function Qi() {
          }
          function Cm() {
            return "javascript";
          }
          function Em() {
            return "browser";
          }
          function Bn() {
            return "/tmp";
          }
          var Fr, Nn, wn, Zi, vm = br({ "node-modules-polyfills:os"() {
            ae(), Nn = Bn, wn = `
`, Zi = { EOL: wn, tmpdir: Nn, tmpDir: Bn, networkInterfaces: Yi, getNetworkInterfaces: Qi, release: Ki, type: Xi, cpus: zi, totalmem: Ui, freemem: Ji, uptime: Gi, loadavg: Hi, hostname: $i, endianness: Wi };
          } }), Fm = Z({ "node-modules-polyfills-commonjs:os"(e, n) {
            ae();
            var t = (vm(), pt(Vi));
            if (t && t.default) {
              n.exports = t.default;
              for (let s in t)
                n.exports[s] = t[s];
            } else
              t && (n.exports = t);
          } }), Am = Z({ "node_modules/detect-newline/index.js"(e, n) {
            "use strict";
            ae();
            var t = (s) => {
              if (typeof s != "string")
                throw new TypeError("Expected a string");
              let i = s.match(/(?:\r?\n)/g) || [];
              if (i.length === 0)
                return;
              let r = i.filter((a) => a === `\r
`).length, u = i.length - r;
              return r > u ? `\r
` : `
`;
            };
            n.exports = t, n.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
          } }), Sm = Z({ "node_modules/jest-docblock/build/index.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p, e.parse = h, e.parseWithComments = N, e.print = T, e.strip = f;
            function n() {
              let b = Fm();
              return n = function() {
                return b;
              }, b;
            }
            function t() {
              let b = s(Am());
              return t = function() {
                return b;
              }, b;
            }
            function s(b) {
              return b && b.__esModule ? b : { default: b };
            }
            var i = /\*\/$/, r = /^\/\*\*/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a = /(^|\s+)\/\/([^\r\n]*)/g, c = /^(\r?\n)+/, l = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, C = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, m = /(\r?\n|^) *\* ?/g, g = [];
            function p(b) {
              let v = b.match(u);
              return v ? v[0].trimLeft() : "";
            }
            function f(b) {
              let v = b.match(u);
              return v && v[0] ? b.substring(v[0].length) : b;
            }
            function h(b) {
              return N(b).pragmas;
            }
            function N(b) {
              let v = (0, t().default)(b) || n().EOL;
              b = b.replace(r, "").replace(i, "").replace(m, "$1");
              let B = "";
              for (; B !== b; )
                B = b, b = b.replace(l, "".concat(v, "$1 $2").concat(v));
              b = b.replace(c, "").trimRight();
              let w = /* @__PURE__ */ Object.create(null), I = b.replace(C, "").replace(c, "").trimRight(), E;
              for (; E = C.exec(b); ) {
                let D = E[2].replace(a, "");
                typeof w[E[1]] == "string" || Array.isArray(w[E[1]]) ? w[E[1]] = g.concat(w[E[1]], D) : w[E[1]] = D;
              }
              return { comments: I, pragmas: w };
            }
            function T(b) {
              let { comments: v = "", pragmas: B = {} } = b, w = (0, t().default)(v) || n().EOL, I = "/**", E = " *", D = " */", d = Object.keys(B), y = d.map((x) => A(x, B[x])).reduce((x, F) => x.concat(F), []).map((x) => E + " " + x + w).join("");
              if (!v) {
                if (d.length === 0)
                  return "";
                if (d.length === 1 && !Array.isArray(B[d[0]])) {
                  let x = B[d[0]];
                  return "".concat(I, " ").concat(A(d[0], x)[0]).concat(D);
                }
              }
              let o = v.split(w).map((x) => "".concat(E, " ").concat(x)).join(w) + w;
              return I + w + (v ? o : "") + (v && d.length ? E + w : "") + y + D;
            }
            function A(b, v) {
              return g.concat(v).map((B) => "@".concat(b, " ").concat(B).trim());
            }
          } }), xm = Z({ "src/language-js/utils/get-shebang.js"(e, n) {
            "use strict";
            ae();
            function t(s) {
              if (!s.startsWith("#!"))
                return "";
              let i = s.indexOf(`
`);
              return i === -1 ? s : s.slice(0, i);
            }
            n.exports = t;
          } }), eo = Z({ "src/language-js/pragma.js"(e, n) {
            "use strict";
            ae();
            var { parseWithComments: t, strip: s, extract: i, print: r } = Sm(), { normalizeEndOfLine: u } = On(), a = xm();
            function c(m) {
              let g = a(m);
              g && (m = m.slice(g.length + 1));
              let p = i(m), { pragmas: f, comments: h } = t(p);
              return { shebang: g, text: m, pragmas: f, comments: h };
            }
            function l(m) {
              let g = Object.keys(c(m).pragmas);
              return g.includes("prettier") || g.includes("format");
            }
            function C(m) {
              let { shebang: g, text: p, pragmas: f, comments: h } = c(m), N = s(p), T = r({ pragmas: Object.assign({ format: "" }, f), comments: h.trimStart() });
              return (g ? "".concat(g, `
`) : "") + u(T) + (N.startsWith(`
`) ? `
` : `

`) + N;
            }
            n.exports = { hasPragma: l, insertPragma: C };
          } }), to = Z({ "src/language-js/comments.js"(e, n) {
            "use strict";
            ae();
            var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: i, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: a, addTrailingComment: c, addDanglingComment: l, getNextNonSpaceNonCommentCharacterIndex: C, isNonEmptyArray: m } = Ge(), { getFunctionParameters: g, isPrettierIgnoreComment: p, isJsxNode: f, hasFlowShorthandAnnotationComment: h, hasFlowAnnotationComment: N, hasIgnoreComment: T, isCallLikeExpression: A, getCallArguments: b, isCallExpression: v, isMemberExpression: B, isObjectProperty: w, isLineComment: I, getComments: E, CommentCheckFlags: D, markerForIfWithoutBlockAndSameLineComment: d } = Xe(), { locStart: y, locEnd: o } = nt(), x = Pt();
            function F(X) {
              return [fe, V, G, M, H, P, W, oe, de, le, Q, ge, ve, ee, K, Ee].some((Y) => Y(X));
            }
            function S(X) {
              return [R, V, re, oe, M, H, P, W, K, q, ue, Q, xe, Ee, me].some((Y) => Y(X));
            }
            function k(X) {
              return [fe, M, H, $, se, ee, Q, ne, U, pe, Ee, we].some((Y) => Y(X));
            }
            function _(X, Y) {
              let te = (X.body || X.properties).find((z) => {
                let { type: j } = z;
                return j !== "EmptyStatement";
              });
              te ? a(te, Y) : l(X, Y);
            }
            function O(X, Y) {
              X.type === "BlockStatement" ? _(X, Y) : a(X, Y);
            }
            function R(X) {
              let { comment: Y, followingNode: te } = X;
              return te && J(Y) ? (a(te, Y), true) : false;
            }
            function M(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X;
              if (!z || z.type !== "IfStatement" || !j)
                return false;
              if (r(Ce, Y, o) === ")")
                return c(te, Y), true;
              if (te === z.consequent && j === z.alternate) {
                if (te.type === "BlockStatement")
                  c(te, Y);
                else {
                  let je = Y.type === "SingleLine" || Y.loc.start.line === Y.loc.end.line, Ue = Y.loc.start.line === te.loc.start.line;
                  je && Ue ? l(te, Y, d) : l(z, Y);
                }
                return true;
              }
              return j.type === "BlockStatement" ? (_(j, Y), true) : j.type === "IfStatement" ? (O(j.consequent, Y), true) : z.consequent === j ? (a(j, Y), true) : false;
            }
            function H(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X;
              return !z || z.type !== "WhileStatement" || !j ? false : r(Ce, Y, o) === ")" ? (c(te, Y), true) : j.type === "BlockStatement" ? (_(j, Y), true) : z.body === j ? (a(j, Y), true) : false;
            }
            function P(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
              return !z || z.type !== "TryStatement" && z.type !== "CatchClause" || !j ? false : z.type === "CatchClause" && te ? (c(te, Y), true) : j.type === "BlockStatement" ? (_(j, Y), true) : j.type === "TryStatement" ? (O(j.finalizer, Y), true) : j.type === "CatchClause" ? (O(j.body, Y), true) : false;
            }
            function G(X) {
              let { comment: Y, enclosingNode: te, followingNode: z } = X;
              return B(te) && z && z.type === "Identifier" ? (a(te, Y), true) : false;
            }
            function re(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X, Ne = te && !u(Ce, o(te), y(Y));
              return (!te || !Ne) && z && (z.type === "ConditionalExpression" || z.type === "TSConditionalType") && j ? (a(j, Y), true) : false;
            }
            function $(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z } = X;
              return w(z) && z.shorthand && z.key === te && z.value.type === "AssignmentPattern" ? (c(z.value.left, Y), true) : false;
            }
            function W(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
              if (z && (z.type === "ClassDeclaration" || z.type === "ClassExpression" || z.type === "DeclareClass" || z.type === "DeclareInterface" || z.type === "InterfaceDeclaration" || z.type === "TSInterfaceDeclaration")) {
                if (m(z.decorators) && !(j && j.type === "Decorator"))
                  return c(t(z.decorators), Y), true;
                if (z.body && j === z.body)
                  return _(z.body, Y), true;
                if (j) {
                  if (z.superClass && j === z.superClass && te && (te === z.id || te === z.typeParameters))
                    return c(te, Y), true;
                  for (let Ce of ["implements", "extends", "mixins"])
                    if (z[Ce] && j === z[Ce][0])
                      return te && (te === z.id || te === z.typeParameters || te === z.superClass) ? c(te, Y) : l(z, Y, Ce), true;
                }
              }
              return false;
            }
            function ee(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, text: j } = X;
              return z && te && r(j, Y, o) === "(" && (z.type === "Property" || z.type === "TSDeclareMethod" || z.type === "TSAbstractMethodDefinition") && te.type === "Identifier" && z.key === te && r(j, te, o) !== ":" || te && z && te.type === "Decorator" && (z.type === "ClassMethod" || z.type === "ClassProperty" || z.type === "PropertyDefinition" || z.type === "TSAbstractPropertyDefinition" || z.type === "TSAbstractMethodDefinition" || z.type === "TSDeclareMethod" || z.type === "MethodDefinition") ? (c(te, Y), true) : false;
            }
            function U(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, text: j } = X;
              return r(j, Y, o) !== "(" ? false : te && z && (z.type === "FunctionDeclaration" || z.type === "FunctionExpression" || z.type === "ClassMethod" || z.type === "MethodDefinition" || z.type === "ObjectMethod") ? (c(te, Y), true) : false;
            }
            function ne(X) {
              let { comment: Y, enclosingNode: te, text: z } = X;
              if (!(te && te.type === "ArrowFunctionExpression"))
                return false;
              let j = C(z, Y, o);
              return j !== false && z.slice(j, j + 2) === "=>" ? (l(te, Y), true) : false;
            }
            function se(X) {
              let { comment: Y, enclosingNode: te, text: z } = X;
              return r(z, Y, o) !== ")" ? false : te && (ce(te) && g(te).length === 0 || A(te) && b(te).length === 0) ? (l(te, Y), true) : te && (te.type === "MethodDefinition" || te.type === "TSAbstractMethodDefinition") && g(te.value).length === 0 ? (l(te.value, Y), true) : false;
            }
            function V(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X;
              if (te && te.type === "FunctionTypeParam" && z && z.type === "FunctionTypeAnnotation" && j && j.type !== "FunctionTypeParam" || te && (te.type === "Identifier" || te.type === "AssignmentPattern") && z && ce(z) && r(Ce, Y, o) === ")")
                return c(te, Y), true;
              if (z && z.type === "FunctionDeclaration" && j && j.type === "BlockStatement") {
                let Ne = (() => {
                  let je = g(z);
                  if (je.length > 0)
                    return i(Ce, o(t(je)));
                  let Ue = i(Ce, o(z.id));
                  return Ue !== false && i(Ce, Ue + 1);
                })();
                if (y(Y) > Ne)
                  return _(j, Y), true;
              }
              return false;
            }
            function oe(X) {
              let { comment: Y, enclosingNode: te } = X;
              return te && te.type === "ImportSpecifier" ? (a(te, Y), true) : false;
            }
            function K(X) {
              let { comment: Y, enclosingNode: te } = X;
              return te && te.type === "LabeledStatement" ? (a(te, Y), true) : false;
            }
            function Ee(X) {
              let { comment: Y, enclosingNode: te } = X;
              return te && (te.type === "ContinueStatement" || te.type === "BreakStatement") && !te.label ? (c(te, Y), true) : false;
            }
            function q(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z } = X;
              return v(z) && te && z.callee === te && z.arguments.length > 0 ? (a(z.arguments[0], Y), true) : false;
            }
            function le(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
              return z && (z.type === "UnionTypeAnnotation" || z.type === "TSUnionType") ? (p(Y) && (j.prettierIgnore = true, Y.unignore = true), te ? (c(te, Y), true) : false) : (j && (j.type === "UnionTypeAnnotation" || j.type === "TSUnionType") && p(Y) && (j.types[0].prettierIgnore = true, Y.unignore = true), false);
            }
            function ue(X) {
              let { comment: Y, enclosingNode: te } = X;
              return w(te) ? (a(te, Y), true) : false;
            }
            function Q(X) {
              let { comment: Y, enclosingNode: te, followingNode: z, ast: j, isLastComment: Ce } = X;
              return j && j.body && j.body.length === 0 ? (Ce ? l(j, Y) : a(j, Y), true) : te && te.type === "Program" && te.body.length === 0 && !m(te.directives) ? (Ce ? l(te, Y) : a(te, Y), true) : z && z.type === "Program" && z.body.length === 0 && te && te.type === "ModuleExpression" ? (l(z, Y), true) : false;
            }
            function de(X) {
              let { comment: Y, enclosingNode: te } = X;
              return te && (te.type === "ForInStatement" || te.type === "ForOfStatement") ? (a(te, Y), true) : false;
            }
            function ge(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, text: j } = X;
              return te && te.type === "ImportSpecifier" && z && z.type === "ImportDeclaration" && s(j, o(Y)) ? (c(te, Y), true) : false;
            }
            function ve(X) {
              let { comment: Y, enclosingNode: te } = X;
              return te && te.type === "AssignmentPattern" ? (a(te, Y), true) : false;
            }
            function xe(X) {
              let { comment: Y, enclosingNode: te, followingNode: z } = X;
              return te && (te.type === "VariableDeclarator" || te.type === "AssignmentExpression" || te.type === "TypeAlias" || te.type === "TSTypeAliasDeclaration") && z && (z.type === "ObjectExpression" || z.type === "ArrayExpression" || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "ObjectTypeAnnotation" || z.type === "TSTypeLiteral" || x(Y)) ? (a(z, Y), true) : false;
            }
            function we(X) {
              let { comment: Y, enclosingNode: te, followingNode: z, text: j } = X;
              return !z && te && (te.type === "TSMethodSignature" || te.type === "TSDeclareFunction" || te.type === "TSAbstractMethodDefinition") && r(j, Y, o) === ";" ? (c(te, Y), true) : false;
            }
            function fe(X) {
              let { comment: Y, enclosingNode: te, followingNode: z } = X;
              if (p(Y) && te && te.type === "TSMappedType" && z && z.type === "TSTypeParameter" && z.constraint)
                return te.prettierIgnore = true, Y.unignore = true, true;
            }
            function pe(X) {
              let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
              return !z || z.type !== "TSMappedType" ? false : j && j.type === "TSTypeParameter" && j.name ? (a(j.name, Y), true) : te && te.type === "TSTypeParameter" && te.constraint ? (c(te.constraint, Y), true) : false;
            }
            function me(X) {
              let { comment: Y, enclosingNode: te, followingNode: z } = X;
              return !te || te.type !== "SwitchCase" || te.test ? false : (z.type === "BlockStatement" && I(Y) ? _(z, Y) : l(te, Y), true);
            }
            function ce(X) {
              return X.type === "ArrowFunctionExpression" || X.type === "FunctionExpression" || X.type === "FunctionDeclaration" || X.type === "ObjectMethod" || X.type === "ClassMethod" || X.type === "TSDeclareFunction" || X.type === "TSCallSignatureDeclaration" || X.type === "TSConstructSignatureDeclaration" || X.type === "TSMethodSignature" || X.type === "TSConstructorType" || X.type === "TSFunctionType" || X.type === "TSDeclareMethod";
            }
            function he(X, Y) {
              if ((Y.parser === "typescript" || Y.parser === "flow" || Y.parser === "acorn" || Y.parser === "espree" || Y.parser === "meriyah" || Y.parser === "__babel_estree") && X.type === "MethodDefinition" && X.value && X.value.type === "FunctionExpression" && g(X.value).length === 0 && !X.value.returnType && !m(X.value.typeParameters) && X.value.body)
                return [...X.decorators || [], X.key, X.value.body];
            }
            function J(X) {
              return x(X) && X.value[0] === "*" && /@type\b/.test(X.value);
            }
            function ye(X) {
              let Y = X.getValue(), te = X.getParentNode(), z = (j) => N(E(j, D.Leading)) || N(E(j, D.Trailing));
              return (Y && (f(Y) || h(Y) || v(te) && z(Y)) || te && (te.type === "JSXSpreadAttribute" || te.type === "JSXSpreadChild" || te.type === "UnionTypeAnnotation" || te.type === "TSUnionType" || (te.type === "ClassDeclaration" || te.type === "ClassExpression") && te.superClass === Y)) && (!T(X) || te.type === "UnionTypeAnnotation" || te.type === "TSUnionType");
            }
            n.exports = { handleOwnLineComment: F, handleEndOfLineComment: S, handleRemainingComment: k, isTypeCastComment: J, getCommentChildNodes: he, willPrintOwnComments: ye };
          } }), kt = Z({ "src/language-js/needs-parens.js"(e, n) {
            "use strict";
            ae();
            var t = st(), s = Rn(), { getFunctionParameters: i, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: a, hasNode: c, isBitwiseOperator: l, startsWithNoLookaheadToken: C, shouldFlatten: m, getPrecedence: g, isCallExpression: p, isMemberExpression: f, isObjectProperty: h } = Xe();
            function N(I, E) {
              let D = I.getParentNode();
              if (!D)
                return false;
              let d = I.getName(), y = I.getNode();
              if (E.__isInHtmlInterpolation && !E.bracketSpacing && v(y) && B(I))
                return true;
              if (T(y))
                return false;
              if (E.parser !== "flow" && u(I.getValue()))
                return true;
              if (y.type === "Identifier")
                return !!(y.extra && y.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(y.name) || d === "left" && y.name === "async" && D.type === "ForOfStatement" && !D.await);
              switch (D.type) {
                case "ParenthesizedExpression":
                  return false;
                case "ClassDeclaration":
                case "ClassExpression": {
                  if (d === "superClass" && (y.type === "ArrowFunctionExpression" || y.type === "AssignmentExpression" || y.type === "AwaitExpression" || y.type === "BinaryExpression" || y.type === "ConditionalExpression" || y.type === "LogicalExpression" || y.type === "NewExpression" || y.type === "ObjectExpression" || y.type === "SequenceExpression" || y.type === "TaggedTemplateExpression" || y.type === "UnaryExpression" || y.type === "UpdateExpression" || y.type === "YieldExpression" || y.type === "TSNonNullExpression"))
                    return true;
                  break;
                }
                case "ExportDefaultDeclaration":
                  return w(I, E) || y.type === "SequenceExpression";
                case "Decorator": {
                  if (d === "expression") {
                    let o = false, x = false, F = y;
                    for (; F; )
                      switch (F.type) {
                        case "MemberExpression":
                          x = true, F = F.object;
                          break;
                        case "CallExpression":
                          if (x || o)
                            return E.parser !== "typescript";
                          o = true, F = F.callee;
                          break;
                        case "Identifier":
                          return false;
                        case "TaggedTemplateExpression":
                          return E.parser !== "typescript";
                        default:
                          return true;
                      }
                    return true;
                  }
                  break;
                }
                case "ExpressionStatement": {
                  if (C(y, true))
                    return true;
                  break;
                }
                case "ArrowFunctionExpression": {
                  if (d === "body" && y.type !== "SequenceExpression" && C(y, false))
                    return true;
                  break;
                }
              }
              switch (y.type) {
                case "UpdateExpression":
                  if (D.type === "UnaryExpression")
                    return y.prefix && (y.operator === "++" && D.operator === "+" || y.operator === "--" && D.operator === "-");
                case "UnaryExpression":
                  switch (D.type) {
                    case "UnaryExpression":
                      return y.operator === D.operator && (y.operator === "+" || y.operator === "-");
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return d === "object";
                    case "TaggedTemplateExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return d === "callee";
                    case "BinaryExpression":
                      return d === "left" && D.operator === "**";
                    case "TSNonNullExpression":
                      return true;
                    default:
                      return false;
                  }
                case "BinaryExpression": {
                  if (D.type === "UpdateExpression" || y.operator === "in" && A(I))
                    return true;
                  if (y.operator === "|>" && y.extra && y.extra.parenthesized) {
                    let o = I.getParentNode(1);
                    if (o.type === "BinaryExpression" && o.operator === "|>")
                      return true;
                  }
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "LogicalExpression":
                  switch (D.type) {
                    case "TSAsExpression":
                      return y.type !== "TSAsExpression";
                    case "ConditionalExpression":
                      return y.type === "TSAsExpression";
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                      return d === "callee";
                    case "ClassExpression":
                    case "ClassDeclaration":
                      return d === "superClass";
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return d === "object";
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                      return d === "left" && (y.type === "TSTypeAssertion" || y.type === "TSAsExpression");
                    case "LogicalExpression":
                      if (y.type === "LogicalExpression")
                        return D.operator !== y.operator;
                    case "BinaryExpression": {
                      let { operator: o, type: x } = y;
                      if (!o && x !== "TSTypeAssertion")
                        return true;
                      let F = g(o), S = D.operator, k = g(S);
                      return k > F || d === "right" && k === F || k === F && !m(S, o) ? true : k < F && o === "%" ? S === "+" || S === "-" : !!l(S);
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (D.type) {
                    case "ReturnStatement":
                      return false;
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return d !== "expression";
                    case "ArrowFunctionExpression":
                      return d !== "body";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  if (D.type === "UnaryExpression" || D.type === "AwaitExpression" || D.type === "TSAsExpression" || D.type === "TSNonNullExpression")
                    return true;
                case "AwaitExpression":
                  switch (D.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return d === "object";
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return d === "callee";
                    case "ConditionalExpression":
                      return d === "test";
                    case "BinaryExpression":
                      return !(!y.argument && D.operator === "|>");
                    default:
                      return false;
                  }
                case "TSConditionalType":
                  if (d === "extendsType" && D.type === "TSConditionalType")
                    return true;
                case "TSFunctionType":
                case "TSConstructorType":
                  if (d === "checkType" && D.type === "TSConditionalType")
                    return true;
                case "TSUnionType":
                case "TSIntersectionType":
                  if ((D.type === "TSUnionType" || D.type === "TSIntersectionType") && D.types.length > 1 && (!y.types || y.types.length > 1))
                    return true;
                case "TSInferType":
                  if (y.type === "TSInferType" && D.type === "TSRestType")
                    return false;
                case "TSTypeOperator":
                  return D.type === "TSArrayType" || D.type === "TSOptionalType" || D.type === "TSRestType" || d === "objectType" && D.type === "TSIndexedAccessType" || D.type === "TSTypeOperator" || D.type === "TSTypeAnnotation" && I.getParentNode(1).type.startsWith("TSJSDoc");
                case "ArrayTypeAnnotation":
                  return D.type === "NullableTypeAnnotation";
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation":
                  return D.type === "ArrayTypeAnnotation" || D.type === "NullableTypeAnnotation" || D.type === "IntersectionTypeAnnotation" || D.type === "UnionTypeAnnotation" || d === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                case "NullableTypeAnnotation":
                  return D.type === "ArrayTypeAnnotation" || d === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                case "FunctionTypeAnnotation": {
                  let o = D.type === "NullableTypeAnnotation" ? I.getParentNode(1) : D;
                  return o.type === "UnionTypeAnnotation" || o.type === "IntersectionTypeAnnotation" || o.type === "ArrayTypeAnnotation" || d === "objectType" && (o.type === "IndexedAccessType" || o.type === "OptionalIndexedAccessType") || o.type === "NullableTypeAnnotation" || D.type === "FunctionTypeParam" && D.name === null && i(y).some((x) => x.typeAnnotation && x.typeAnnotation.type === "NullableTypeAnnotation");
                }
                case "OptionalIndexedAccessType":
                  return d === "objectType" && D.type === "IndexedAccessType";
                case "TypeofTypeAnnotation":
                  return d === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                  if (typeof y.value == "string" && D.type === "ExpressionStatement" && !D.directive) {
                    let o = I.getParentNode(1);
                    return o.type === "Program" || o.type === "BlockStatement";
                  }
                  return d === "object" && D.type === "MemberExpression" && typeof y.value == "number";
                case "AssignmentExpression": {
                  let o = I.getParentNode(1);
                  return d === "body" && D.type === "ArrowFunctionExpression" ? true : d === "key" && (D.type === "ClassProperty" || D.type === "PropertyDefinition") && D.computed || (d === "init" || d === "update") && D.type === "ForStatement" ? false : D.type === "ExpressionStatement" ? y.left.type === "ObjectPattern" : !(d === "key" && D.type === "TSPropertySignature" || D.type === "AssignmentExpression" || D.type === "SequenceExpression" && o && o.type === "ForStatement" && (o.init === D || o.update === D) || d === "value" && D.type === "Property" && o && o.type === "ObjectPattern" && o.properties.includes(D) || D.type === "NGChainedExpression");
                }
                case "ConditionalExpression":
                  switch (D.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return d === "callee";
                    case "ConditionalExpression":
                      return d === "test";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return d === "object";
                    default:
                      return false;
                  }
                case "FunctionExpression":
                  switch (D.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return d === "callee";
                    case "TaggedTemplateExpression":
                      return true;
                    default:
                      return false;
                  }
                case "ArrowFunctionExpression":
                  switch (D.type) {
                    case "BinaryExpression":
                      return D.operator !== "|>" || y.extra && y.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return d === "callee";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return d === "object";
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                      return true;
                    case "ConditionalExpression":
                      return d === "test";
                    default:
                      return false;
                  }
                case "ClassExpression":
                  if (s(y.decorators))
                    return true;
                  switch (D.type) {
                    case "NewExpression":
                      return d === "callee";
                    default:
                      return false;
                  }
                case "OptionalMemberExpression":
                case "OptionalCallExpression": {
                  let o = I.getParentNode(1);
                  if (d === "object" && D.type === "MemberExpression" || d === "callee" && (D.type === "CallExpression" || D.type === "NewExpression") || D.type === "TSNonNullExpression" && o.type === "MemberExpression" && o.object === D)
                    return true;
                }
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  if (d === "callee" && (D.type === "BindExpression" || D.type === "NewExpression")) {
                    let o = y;
                    for (; o; )
                      switch (o.type) {
                        case "CallExpression":
                        case "OptionalCallExpression":
                          return true;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                          o = o.object;
                          break;
                        case "TaggedTemplateExpression":
                          o = o.tag;
                          break;
                        case "TSNonNullExpression":
                          o = o.expression;
                          break;
                        default:
                          return false;
                      }
                  }
                  return false;
                case "BindExpression":
                  return d === "callee" && (D.type === "BindExpression" || D.type === "NewExpression") || d === "object" && f(D);
                case "NGPipeExpression":
                  return !(D.type === "NGRoot" || D.type === "NGMicrosyntaxExpression" || D.type === "ObjectProperty" && !(y.extra && y.extra.parenthesized) || D.type === "ArrayExpression" || p(D) && D.arguments[d] === y || d === "right" && D.type === "NGPipeExpression" || d === "property" && D.type === "MemberExpression" || D.type === "AssignmentExpression");
                case "JSXFragment":
                case "JSXElement":
                  return d === "callee" || d === "left" && D.type === "BinaryExpression" && D.operator === "<" || D.type !== "ArrayExpression" && D.type !== "ArrowFunctionExpression" && D.type !== "AssignmentExpression" && D.type !== "AssignmentPattern" && D.type !== "BinaryExpression" && D.type !== "NewExpression" && D.type !== "ConditionalExpression" && D.type !== "ExpressionStatement" && D.type !== "JsExpressionRoot" && D.type !== "JSXAttribute" && D.type !== "JSXElement" && D.type !== "JSXExpressionContainer" && D.type !== "JSXFragment" && D.type !== "LogicalExpression" && !p(D) && !h(D) && D.type !== "ReturnStatement" && D.type !== "ThrowStatement" && D.type !== "TypeCastExpression" && D.type !== "VariableDeclarator" && D.type !== "YieldExpression";
                case "TypeAnnotation":
                  return d === "returnType" && D.type === "ArrowFunctionExpression" && b(y);
              }
              return false;
            }
            function T(I) {
              return I.type === "BlockStatement" || I.type === "BreakStatement" || I.type === "ClassBody" || I.type === "ClassDeclaration" || I.type === "ClassMethod" || I.type === "ClassProperty" || I.type === "PropertyDefinition" || I.type === "ClassPrivateProperty" || I.type === "ContinueStatement" || I.type === "DebuggerStatement" || I.type === "DeclareClass" || I.type === "DeclareExportAllDeclaration" || I.type === "DeclareExportDeclaration" || I.type === "DeclareFunction" || I.type === "DeclareInterface" || I.type === "DeclareModule" || I.type === "DeclareModuleExports" || I.type === "DeclareVariable" || I.type === "DoWhileStatement" || I.type === "EnumDeclaration" || I.type === "ExportAllDeclaration" || I.type === "ExportDefaultDeclaration" || I.type === "ExportNamedDeclaration" || I.type === "ExpressionStatement" || I.type === "ForInStatement" || I.type === "ForOfStatement" || I.type === "ForStatement" || I.type === "FunctionDeclaration" || I.type === "IfStatement" || I.type === "ImportDeclaration" || I.type === "InterfaceDeclaration" || I.type === "LabeledStatement" || I.type === "MethodDefinition" || I.type === "ReturnStatement" || I.type === "SwitchStatement" || I.type === "ThrowStatement" || I.type === "TryStatement" || I.type === "TSDeclareFunction" || I.type === "TSEnumDeclaration" || I.type === "TSImportEqualsDeclaration" || I.type === "TSInterfaceDeclaration" || I.type === "TSModuleDeclaration" || I.type === "TSNamespaceExportDeclaration" || I.type === "TypeAlias" || I.type === "VariableDeclaration" || I.type === "WhileStatement" || I.type === "WithStatement";
            }
            function A(I) {
              let E = 0, D = I.getValue();
              for (; D; ) {
                let d = I.getParentNode(E++);
                if (d && d.type === "ForStatement" && d.init === D)
                  return true;
                D = d;
              }
              return false;
            }
            function b(I) {
              return c(I, (E) => E.type === "ObjectTypeAnnotation" && c(E, (D) => D.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }
            function v(I) {
              switch (I.type) {
                case "ObjectExpression":
                  return true;
                default:
                  return false;
              }
            }
            function B(I) {
              let E = I.getValue(), D = I.getParentNode(), d = I.getName();
              switch (D.type) {
                case "NGPipeExpression":
                  if (typeof d == "number" && D.arguments[d] === E && D.arguments.length - 1 === d)
                    return I.callParent(B);
                  break;
                case "ObjectProperty":
                  if (d === "value") {
                    let y = I.getParentNode(1);
                    return t(y.properties) === D;
                  }
                  break;
                case "BinaryExpression":
                case "LogicalExpression":
                  if (d === "right")
                    return I.callParent(B);
                  break;
                case "ConditionalExpression":
                  if (d === "alternate")
                    return I.callParent(B);
                  break;
                case "UnaryExpression":
                  if (D.prefix)
                    return I.callParent(B);
                  break;
              }
              return false;
            }
            function w(I, E) {
              let D = I.getValue(), d = I.getParentNode();
              return D.type === "FunctionExpression" || D.type === "ClassExpression" ? d.type === "ExportDefaultDeclaration" || !N(I, E) : !a(D) || d.type !== "ExportDefaultDeclaration" && N(I, E) ? false : I.call((y) => w(y, E), ...r(I, D));
            }
            n.exports = N;
          } }), ro = Z({ "src/language-js/print-preprocess.js"(e, n) {
            "use strict";
            ae();
            function t(s, i) {
              switch (i.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression":
                  return Object.assign(Object.assign({}, s), {}, { type: i.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: i.rootMarker });
                default:
                  return s;
              }
            }
            n.exports = t;
          } }), bm = Z({ "src/language-js/print/html-binding.js"(e, n) {
            "use strict";
            ae();
            var { builders: { join: t, line: s, group: i, softline: r, indent: u } } = Le();
            function a(l, C, m) {
              let g = l.getValue();
              if (C.__onHtmlBindingRoot && l.getName() === null && C.__onHtmlBindingRoot(g, C), g.type === "File") {
                if (C.__isVueForBindingLeft)
                  return l.call((p) => {
                    let f = t([",", s], p.map(m, "params")), { params: h } = p.getValue();
                    return h.length === 1 ? f : ["(", u([r, i(f)]), r, ")"];
                  }, "program", "body", 0);
                if (C.__isVueBindings)
                  return l.call((p) => t([",", s], p.map(m, "params")), "program", "body", 0);
              }
            }
            function c(l) {
              switch (l.type) {
                case "MemberExpression":
                  switch (l.property.type) {
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                      return c(l.object);
                  }
                  return false;
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = { isVueEventBindingExpression: c, printHtmlBinding: a };
          } }), Jn = Z({ "src/language-js/print/binaryish.js"(e, n) {
            "use strict";
            ae();
            var { printComments: t } = Qe(), { getLast: s } = Ge(), { builders: { join: i, line: r, softline: u, group: a, indent: c, align: l, ifBreak: C, indentIfBreak: m }, utils: { cleanDoc: g, getDocParts: p, isConcat: f } } = Le(), { hasLeadingOwnLineComment: h, isBinaryish: N, isJsxNode: T, shouldFlatten: A, hasComment: b, CommentCheckFlags: v, isCallExpression: B, isMemberExpression: w, isObjectProperty: I, isEnabledHackPipeline: E } = Xe(), D = 0;
            function d(x, F, S) {
              let k = x.getValue(), _ = x.getParentNode(), O = x.getParentNode(1), R = k !== _.body && (_.type === "IfStatement" || _.type === "WhileStatement" || _.type === "SwitchStatement" || _.type === "DoWhileStatement"), M = E(F) && k.operator === "|>", H = y(x, S, F, false, R);
              if (R)
                return H;
              if (M)
                return a(H);
              if (B(_) && _.callee === k || _.type === "UnaryExpression" || w(_) && !_.computed)
                return a([c([u, ...H]), u]);
              let P = _.type === "ReturnStatement" || _.type === "ThrowStatement" || _.type === "JSXExpressionContainer" && O.type === "JSXAttribute" || k.operator !== "|" && _.type === "JsExpressionRoot" || k.type !== "NGPipeExpression" && (_.type === "NGRoot" && F.parser === "__ng_binding" || _.type === "NGMicrosyntaxExpression" && O.type === "NGMicrosyntax" && O.body.length === 1) || k === _.body && _.type === "ArrowFunctionExpression" || k !== _.body && _.type === "ForStatement" || _.type === "ConditionalExpression" && O.type !== "ReturnStatement" && O.type !== "ThrowStatement" && !B(O) || _.type === "TemplateLiteral", G = _.type === "AssignmentExpression" || _.type === "VariableDeclarator" || _.type === "ClassProperty" || _.type === "PropertyDefinition" || _.type === "TSAbstractPropertyDefinition" || _.type === "ClassPrivateProperty" || I(_), re = N(k.left) && A(k.operator, k.left.operator);
              if (P || o(k) && !re || !o(k) && G)
                return a(H);
              if (H.length === 0)
                return "";
              let $ = T(k.right), W = H.findIndex((oe) => typeof oe != "string" && !Array.isArray(oe) && oe.type === "group"), ee = H.slice(0, W === -1 ? 1 : W + 1), U = H.slice(ee.length, $ ? -1 : void 0), ne = Symbol("logicalChain-" + ++D), se = a([...ee, c(U)], { id: ne });
              if (!$)
                return se;
              let V = s(H);
              return a([se, m(V, { groupId: ne })]);
            }
            function y(x, F, S, k, _) {
              let O = x.getValue();
              if (!N(O))
                return [a(F())];
              let R = [];
              A(O.operator, O.left.operator) ? R = x.call((U) => y(U, F, S, true, _), "left") : R.push(a(F("left")));
              let M = o(O), H = (O.operator === "|>" || O.type === "NGPipeExpression" || O.operator === "|" && S.parser === "__vue_expression") && !h(S.originalText, O.right), P = O.type === "NGPipeExpression" ? "|" : O.operator, G = O.type === "NGPipeExpression" && O.arguments.length > 0 ? a(c([u, ": ", i([u, ":", C(" ")], x.map(F, "arguments").map((U) => l(2, a(U))))])) : "", re;
              if (M)
                re = [P, " ", F("right"), G];
              else {
                let ne = E(S) && P === "|>" ? x.call((se) => y(se, F, S, true, _), "right") : F("right");
                re = [H ? r : "", P, H ? " " : r, ne, G];
              }
              let $ = x.getParentNode(), W = b(O.left, v.Trailing | v.Line), ee = W || !(_ && O.type === "LogicalExpression") && $.type !== O.type && O.left.type !== O.type && O.right.type !== O.type;
              if (R.push(H ? "" : " ", ee ? a(re, { shouldBreak: W }) : re), k && b(O)) {
                let U = g(t(x, R, S));
                return f(U) || U.type === "fill" ? p(U) : [U];
              }
              return R;
            }
            function o(x) {
              return x.type !== "LogicalExpression" ? false : !!(x.right.type === "ObjectExpression" && x.right.properties.length > 0 || x.right.type === "ArrayExpression" && x.right.elements.length > 0 || T(x.right));
            }
            n.exports = { printBinaryishExpression: d, shouldInlineLogicalExpression: o };
          } }), Tm = Z({ "src/language-js/print/angular.js"(e, n) {
            "use strict";
            ae();
            var { builders: { join: t, line: s, group: i } } = Le(), { hasNode: r, hasComment: u, getComments: a } = Xe(), { printBinaryishExpression: c } = Jn();
            function l(g, p, f) {
              let h = g.getValue();
              if (!!h.type.startsWith("NG"))
                switch (h.type) {
                  case "NGRoot":
                    return [f("node"), u(h.node) ? " //" + a(h.node)[0].value.trimEnd() : ""];
                  case "NGPipeExpression":
                    return c(g, p, f);
                  case "NGChainedExpression":
                    return i(t([";", s], g.map((N) => m(N) ? f() : ["(", f(), ")"], "expressions")));
                  case "NGEmptyExpression":
                    return "";
                  case "NGQuotedExpression":
                    return [h.prefix, ": ", h.value.trim()];
                  case "NGMicrosyntax":
                    return g.map((N, T) => [T === 0 ? "" : C(N.getValue(), T, h) ? " " : [";", s], f()], "body");
                  case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h.name) ? h.name : JSON.stringify(h.name);
                  case "NGMicrosyntaxExpression":
                    return [f("expression"), h.alias === null ? "" : [" as ", f("alias")]];
                  case "NGMicrosyntaxKeyedExpression": {
                    let N = g.getName(), T = g.getParentNode(), A = C(h, N, T) || (N === 1 && (h.key.name === "then" || h.key.name === "else") || N === 2 && h.key.name === "else" && T.body[N - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[N - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                    return [f("key"), A ? " " : ": ", f("expression")];
                  }
                  case "NGMicrosyntaxLet":
                    return ["let ", f("key"), h.value === null ? "" : [" = ", f("value")]];
                  case "NGMicrosyntaxAs":
                    return [f("key"), " as ", f("alias")];
                  default:
                    throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h.type), "."));
                }
            }
            function C(g, p, f) {
              return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && p === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
            }
            function m(g) {
              return r(g.getValue(), (p) => {
                switch (p.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }
            n.exports = { printAngular: l };
          } }), Bm = Z({ "src/language-js/print/jsx.js"(e, n) {
            "use strict";
            ae();
            var { printComments: t, printDanglingComments: s } = Qe(), { builders: { line: i, hardline: r, softline: u, group: a, indent: c, conditionalGroup: l, fill: C, ifBreak: m, lineSuffixBoundary: g, join: p }, utils: { willBreak: f } } = Le(), { getLast: h, getPreferredQuote: N } = Ge(), { isJsxNode: T, rawText: A, isLiteral: b, isCallExpression: v, isStringLiteral: B, isBinaryish: w, hasComment: I, CommentCheckFlags: E, hasNodeIgnoreComment: D } = Xe(), d = kt(), { willPrintOwnComments: y } = to(), o = (q) => q === "" || q === i || q === r || q === u;
            function x(q, le, ue) {
              let Q = q.getValue();
              if (Q.type === "JSXElement" && V(Q))
                return [ue("openingElement"), ue("closingElement")];
              let de = Q.type === "JSXElement" ? ue("openingElement") : ue("openingFragment"), ge = Q.type === "JSXElement" ? ue("closingElement") : ue("closingFragment");
              if (Q.children.length === 1 && Q.children[0].type === "JSXExpressionContainer" && (Q.children[0].expression.type === "TemplateLiteral" || Q.children[0].expression.type === "TaggedTemplateExpression"))
                return [de, ...q.map(ue, "children"), ge];
              Q.children = Q.children.map((z) => K(z) ? { type: "JSXText", value: " ", raw: " " } : z);
              let ve = Q.children.some(T), xe = Q.children.filter((z) => z.type === "JSXExpressionContainer").length > 1, we = Q.type === "JSXElement" && Q.openingElement.attributes.length > 1, fe = f(de) || ve || we || xe, pe = q.getParentNode().rootMarker === "mdx", me = le.singleQuote ? "{' '}" : '{" "}', ce = pe ? " " : m([me, u], " "), he = Q.openingElement && Q.openingElement.name && Q.openingElement.name.name === "fbt", J = F(q, le, ue, ce, he), ye = Q.children.some((z) => oe(z));
              for (let z = J.length - 2; z >= 0; z--) {
                let j = J[z] === "" && J[z + 1] === "", Ce = J[z] === r && J[z + 1] === "" && J[z + 2] === r, Ne = (J[z] === u || J[z] === r) && J[z + 1] === "" && J[z + 2] === ce, je = J[z] === ce && J[z + 1] === "" && (J[z + 2] === u || J[z + 2] === r), Ue = J[z] === ce && J[z + 1] === "" && J[z + 2] === ce, tt = J[z] === u && J[z + 1] === "" && J[z + 2] === r || J[z] === r && J[z + 1] === "" && J[z + 2] === u;
                Ce && ye || j || Ne || Ue || tt ? J.splice(z, 2) : je && J.splice(z + 1, 2);
              }
              for (; J.length > 0 && o(h(J)); )
                J.pop();
              for (; J.length > 1 && o(J[0]) && o(J[1]); )
                J.shift(), J.shift();
              let X = [];
              for (let [z, j] of J.entries()) {
                if (j === ce) {
                  if (z === 1 && J[z - 1] === "") {
                    if (J.length === 2) {
                      X.push(me);
                      continue;
                    }
                    X.push([me, r]);
                    continue;
                  } else if (z === J.length - 1) {
                    X.push(me);
                    continue;
                  } else if (J[z - 1] === "" && J[z - 2] === r) {
                    X.push(me);
                    continue;
                  }
                }
                X.push(j), f(j) && (fe = true);
              }
              let Y = ye ? C(X) : a(X, { shouldBreak: true });
              if (pe)
                return Y;
              let te = a([de, c([r, Y]), r, ge]);
              return fe ? te : l([a([de, ...J, ge]), te]);
            }
            function F(q, le, ue, Q, de) {
              let ge = [];
              return q.each((ve, xe, we) => {
                let fe = ve.getValue();
                if (b(fe)) {
                  let pe = A(fe);
                  if (oe(fe)) {
                    let me = pe.split(U);
                    if (me[0] === "") {
                      if (ge.push(""), me.shift(), /\n/.test(me[0])) {
                        let he = we[xe + 1];
                        ge.push(k(de, me[1], fe, he));
                      } else
                        ge.push(Q);
                      me.shift();
                    }
                    let ce;
                    if (h(me) === "" && (me.pop(), ce = me.pop()), me.length === 0)
                      return;
                    for (let [he, J] of me.entries())
                      he % 2 === 1 ? ge.push(i) : ge.push(J);
                    if (ce !== void 0)
                      if (/\n/.test(ce)) {
                        let he = we[xe + 1];
                        ge.push(k(de, h(ge), fe, he));
                      } else
                        ge.push(Q);
                    else {
                      let he = we[xe + 1];
                      ge.push(S(de, h(ge), fe, he));
                    }
                  } else
                    /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge.push("", r) : ge.push("", Q);
                } else {
                  let pe = ue();
                  ge.push(pe);
                  let me = we[xe + 1];
                  if (me && oe(me)) {
                    let he = se(A(me)).split(U)[0];
                    ge.push(S(de, he, fe, me));
                  } else
                    ge.push(r);
                }
              }, "children"), ge;
            }
            function S(q, le, ue, Q) {
              return q ? "" : ue.type === "JSXElement" && !ue.closingElement || Q && Q.type === "JSXElement" && !Q.closingElement ? le.length === 1 ? u : r : u;
            }
            function k(q, le, ue, Q) {
              return q ? r : le.length === 1 ? ue.type === "JSXElement" && !ue.closingElement || Q && Q.type === "JSXElement" && !Q.closingElement ? r : u : r;
            }
            function _(q, le, ue) {
              let Q = q.getParentNode();
              if (!Q || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[Q.type])
                return le;
              let ge = q.match(void 0, (xe) => xe.type === "ArrowFunctionExpression", v, (xe) => xe.type === "JSXExpressionContainer"), ve = d(q, ue);
              return a([ve ? "" : m("("), c([u, le]), u, ve ? "" : m(")")], { shouldBreak: ge });
            }
            function O(q, le, ue) {
              let Q = q.getValue(), de = [];
              if (de.push(ue("name")), Q.value) {
                let ge;
                if (B(Q.value)) {
                  let xe = A(Q.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: we, quote: fe, regex: pe } = N(xe, le.jsxSingleQuote ? "'" : '"');
                  xe = xe.replace(pe, we), ge = [fe, xe, fe];
                } else
                  ge = ue("value");
                de.push("=", ge);
              }
              return de;
            }
            function R(q, le, ue) {
              let Q = q.getValue(), de = (ge, ve) => ge.type === "JSXEmptyExpression" || !I(ge) && (ge.type === "ArrayExpression" || ge.type === "ObjectExpression" || ge.type === "ArrowFunctionExpression" || ge.type === "AwaitExpression" && (de(ge.argument, ge) || ge.argument.type === "JSXElement") || v(ge) || ge.type === "FunctionExpression" || ge.type === "TemplateLiteral" || ge.type === "TaggedTemplateExpression" || ge.type === "DoExpression" || T(ve) && (ge.type === "ConditionalExpression" || w(ge)));
              return de(Q.expression, q.getParentNode(0)) ? a(["{", ue("expression"), g, "}"]) : a(["{", c([u, ue("expression")]), u, g, "}"]);
            }
            function M(q, le, ue) {
              let Q = q.getValue(), de = Q.name && I(Q.name) || Q.typeParameters && I(Q.typeParameters);
              if (Q.selfClosing && Q.attributes.length === 0 && !de)
                return ["<", ue("name"), ue("typeParameters"), " />"];
              if (Q.attributes && Q.attributes.length === 1 && Q.attributes[0].value && B(Q.attributes[0].value) && !Q.attributes[0].value.value.includes(`
`) && !de && !I(Q.attributes[0]))
                return a(["<", ue("name"), ue("typeParameters"), " ", ...q.map(ue, "attributes"), Q.selfClosing ? " />" : ">"]);
              let ge = Q.attributes.length > 0 && I(h(Q.attributes), E.Trailing), ve = Q.attributes.length === 0 && !de || (le.bracketSameLine || le.jsxBracketSameLine) && (!de || Q.attributes.length > 0) && !ge, xe = Q.attributes && Q.attributes.some((fe) => fe.value && B(fe.value) && fe.value.value.includes(`
`)), we = le.singleAttributePerLine && Q.attributes.length > 1 ? r : i;
              return a(["<", ue("name"), ue("typeParameters"), c(q.map(() => [we, ue()], "attributes")), Q.selfClosing ? i : ve ? ">" : u, Q.selfClosing ? "/>" : ve ? "" : ">"], { shouldBreak: xe });
            }
            function H(q, le, ue) {
              let Q = q.getValue(), de = [];
              de.push("</");
              let ge = ue("name");
              return I(Q.name, E.Leading | E.Line) ? de.push(c([r, ge]), r) : I(Q.name, E.Leading | E.Block) ? de.push(" ", ge) : de.push(ge), de.push(">"), de;
            }
            function P(q, le) {
              let ue = q.getValue(), Q = I(ue), de = I(ue, E.Line), ge = ue.type === "JSXOpeningFragment";
              return [ge ? "<" : "</", c([de ? r : Q && !ge ? " " : "", s(q, le, true)]), de ? r : "", ">"];
            }
            function G(q, le, ue) {
              let Q = t(q, x(q, le, ue), le);
              return _(q, Q, le);
            }
            function re(q, le) {
              let ue = q.getValue(), Q = I(ue, E.Line);
              return [s(q, le, !Q), Q ? r : ""];
            }
            function $(q, le, ue) {
              let Q = q.getValue();
              return ["{", q.call((de) => {
                let ge = ["...", ue()], ve = de.getValue();
                return !I(ve) || !y(de) ? ge : [c([u, t(de, ge, le)]), u];
              }, Q.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
            }
            function W(q, le, ue) {
              let Q = q.getValue();
              if (!!Q.type.startsWith("JSX"))
                switch (Q.type) {
                  case "JSXAttribute":
                    return O(q, le, ue);
                  case "JSXIdentifier":
                    return String(Q.name);
                  case "JSXNamespacedName":
                    return p(":", [ue("namespace"), ue("name")]);
                  case "JSXMemberExpression":
                    return p(".", [ue("object"), ue("property")]);
                  case "JSXSpreadAttribute":
                    return $(q, le, ue);
                  case "JSXSpreadChild":
                    return $(q, le, ue);
                  case "JSXExpressionContainer":
                    return R(q, le, ue);
                  case "JSXFragment":
                  case "JSXElement":
                    return G(q, le, ue);
                  case "JSXOpeningElement":
                    return M(q, le, ue);
                  case "JSXClosingElement":
                    return H(q, le, ue);
                  case "JSXOpeningFragment":
                  case "JSXClosingFragment":
                    return P(q, le);
                  case "JSXEmptyExpression":
                    return re(q, le);
                  case "JSXText":
                    throw new Error("JSXTest should be handled by JSXElement");
                  default:
                    throw new Error("Unknown JSX node type: ".concat(JSON.stringify(Q.type), "."));
                }
            }
            var ee = ` 
\r	`, U = new RegExp("([" + ee + "]+)"), ne = new RegExp("[^" + ee + "]"), se = (q) => q.replace(new RegExp("(?:^" + U.source + "|" + U.source + "$)"), "");
            function V(q) {
              if (q.children.length === 0)
                return true;
              if (q.children.length > 1)
                return false;
              let le = q.children[0];
              return b(le) && !oe(le);
            }
            function oe(q) {
              return b(q) && (ne.test(A(q)) || !/\n/.test(A(q)));
            }
            function K(q) {
              return q.type === "JSXExpressionContainer" && b(q.expression) && q.expression.value === " " && !I(q.expression);
            }
            function Ee(q) {
              let le = q.getValue(), ue = q.getParentNode();
              if (!ue || !le || !T(le) || !T(ue))
                return false;
              let Q = ue.children.indexOf(le), de = null;
              for (let ge = Q; ge > 0; ge--) {
                let ve = ue.children[ge - 1];
                if (!(ve.type === "JSXText" && !oe(ve))) {
                  de = ve;
                  break;
                }
              }
              return de && de.type === "JSXExpressionContainer" && de.expression.type === "JSXEmptyExpression" && D(de.expression);
            }
            n.exports = { hasJsxIgnoreComment: Ee, printJsx: W };
          } }), ot = Z({ "src/language-js/print/misc.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, join: i, line: r } } = Le(), { isFlowAnnotationComment: u } = Xe();
            function a(h) {
              let N = h.getValue();
              return !N.optional || N.type === "Identifier" && N === h.getParentNode().key ? "" : N.type === "OptionalCallExpression" || N.type === "OptionalMemberExpression" && N.computed ? "?." : "?";
            }
            function c(h) {
              return h.getValue().definite || h.match(void 0, (N, T) => T === "id" && N.type === "VariableDeclarator" && N.definite) ? "!" : "";
            }
            function l(h, N, T) {
              let A = h.getValue();
              return A.typeArguments ? T("typeArguments") : A.typeParameters ? T("typeParameters") : "";
            }
            function C(h, N, T) {
              let A = h.getValue();
              if (!A.typeAnnotation)
                return "";
              let b = h.getParentNode(), v = b.type === "DeclareFunction" && b.id === A;
              return u(N.originalText, A.typeAnnotation) ? [" /*: ", T("typeAnnotation"), " */"] : [v ? "" : ": ", T("typeAnnotation")];
            }
            function m(h, N, T) {
              return ["::", T("callee")];
            }
            function g(h, N, T) {
              let A = h.getValue();
              return t(A.modifiers) ? [i(" ", h.map(T, "modifiers")), " "] : "";
            }
            function p(h, N, T) {
              return h.type === "EmptyStatement" ? ";" : h.type === "BlockStatement" || T ? [" ", N] : s([r, N]);
            }
            function f(h, N, T) {
              return ["...", T("argument"), C(h, N, T)];
            }
            n.exports = { printOptionalToken: a, printDefiniteToken: c, printFunctionTypeParameters: l, printBindExpressionCallee: m, printTypeScriptModifiers: g, printTypeAnnotation: C, printRestSpread: f, adjustClause: p };
          } }), zt = Z({ "src/language-js/print/array.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { builders: { line: s, softline: i, hardline: r, group: u, indent: a, ifBreak: c, fill: l } } = Le(), { getLast: C, hasNewline: m } = Ge(), { shouldPrintComma: g, hasComment: p, CommentCheckFlags: f, isNextLineEmpty: h, isNumericLiteral: N, isSignedNumericLiteral: T } = Xe(), { locStart: A } = nt(), { printOptionalToken: b, printTypeAnnotation: v } = ot();
            function B(D, d, y) {
              let o = D.getValue(), x = [], F = o.type === "TupleExpression" ? "#[" : "[", S = "]";
              if (o.elements.length === 0)
                p(o, f.Dangling) ? x.push(u([F, t(D, d), i, S])) : x.push(F, S);
              else {
                let k = C(o.elements), _ = !(k && k.type === "RestElement"), O = k === null, R = Symbol("array"), M = !d.__inJestEach && o.elements.length > 1 && o.elements.every((G, re, $) => {
                  let W = G && G.type;
                  if (W !== "ArrayExpression" && W !== "ObjectExpression")
                    return false;
                  let ee = $[re + 1];
                  if (ee && W !== ee.type)
                    return false;
                  let U = W === "ArrayExpression" ? "elements" : "properties";
                  return G[U] && G[U].length > 1;
                }), H = w(o, d), P = _ ? O ? "," : g(d) ? H ? c(",", "", { groupId: R }) : c(",") : "" : "";
                x.push(u([F, a([i, H ? E(D, d, y, P) : [I(D, d, "elements", y), P], t(D, d, true)]), i, S], { shouldBreak: M, id: R }));
              }
              return x.push(b(D), v(D, d, y)), x;
            }
            function w(D, d) {
              return D.elements.length > 1 && D.elements.every((y) => y && (N(y) || T(y) && !p(y.argument)) && !p(y, f.Trailing | f.Line, (o) => !m(d.originalText, A(o), { backwards: true })));
            }
            function I(D, d, y, o) {
              let x = [], F = [];
              return D.each((S) => {
                x.push(F, u(o())), F = [",", s], S.getValue() && h(S.getValue(), d) && F.push(i);
              }, y), x;
            }
            function E(D, d, y, o) {
              let x = [];
              return D.each((F, S, k) => {
                let _ = S === k.length - 1;
                x.push([y(), _ ? o : ","]), _ || x.push(h(F.getValue(), d) ? [r, r] : p(k[S + 1], f.Leading | f.Line) ? r : s);
              }, "elements"), l(x);
            }
            n.exports = { printArray: B, printArrayItems: I, isConciselyPrintedArray: w };
          } }), no = Z({ "src/language-js/print/call-arguments.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { getLast: s, getPenultimate: i } = Ge(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: a, isFunctionCompositionArgs: c, isJsxNode: l, isLongCurriedCallExpression: C, shouldPrintComma: m, getCallArguments: g, iterateCallArgumentsPath: p, isNextLineEmpty: f, isCallExpression: h, isStringLiteral: N, isObjectProperty: T } = Xe(), { builders: { line: A, hardline: b, softline: v, group: B, indent: w, conditionalGroup: I, ifBreak: E, breakParent: D }, utils: { willBreak: d } } = Le(), { ArgExpansionBailout: y } = Jt(), { isConciselyPrintedArray: o } = zt();
            function x(M, H, P) {
              let G = M.getValue(), re = G.type === "ImportExpression", $ = g(G);
              if ($.length === 0)
                return ["(", t(M, H, true), ")"];
              if (_($))
                return ["(", P(["arguments", 0]), ", ", P(["arguments", 1]), ")"];
              let W = false, ee = false, U = $.length - 1, ne = [];
              p(M, (q, le) => {
                let ue = q.getNode(), Q = [P()];
                le === U || (f(ue, H) ? (le === 0 && (ee = true), W = true, Q.push(",", b, b)) : Q.push(",", A)), ne.push(Q);
              });
              let se = !(re || G.callee && G.callee.type === "Import") && m(H, "all") ? "," : "";
              function V() {
                return B(["(", w([A, ...ne]), se, A, ")"], { shouldBreak: true });
              }
              if (W || M.getParentNode().type !== "Decorator" && c($))
                return V();
              let oe = k($), K = S($, H);
              if (oe || K) {
                if (oe ? ne.slice(1).some(d) : ne.slice(0, -1).some(d))
                  return V();
                let q = [];
                try {
                  M.try(() => {
                    p(M, (le, ue) => {
                      oe && ue === 0 && (q = [[P([], { expandFirstArg: true }), ne.length > 1 ? "," : "", ee ? b : A, ee ? b : ""], ...ne.slice(1)]), K && ue === U && (q = [...ne.slice(0, -1), P([], { expandLastArg: true })]);
                    });
                  });
                } catch (le) {
                  if (le instanceof y)
                    return V();
                  throw le;
                }
                return [ne.some(d) ? D : "", I([["(", ...q, ")"], oe ? ["(", B(q[0], { shouldBreak: true }), ...q.slice(1), ")"] : ["(", ...ne.slice(0, -1), B(s(q), { shouldBreak: true }), ")"], V()])];
              }
              let Ee = ["(", w([v, ...ne]), E(se), v, ")"];
              return C(M) ? Ee : B(Ee, { shouldBreak: ne.some(d) || W });
            }
            function F(M) {
              let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return M.type === "ObjectExpression" && (M.properties.length > 0 || u(M)) || M.type === "ArrayExpression" && (M.elements.length > 0 || u(M)) || M.type === "TSTypeAssertion" && F(M.expression) || M.type === "TSAsExpression" && F(M.expression) || M.type === "FunctionExpression" || M.type === "ArrowFunctionExpression" && (!M.returnType || !M.returnType.typeAnnotation || M.returnType.typeAnnotation.type !== "TSTypeReference" || O(M.body)) && (M.body.type === "BlockStatement" || M.body.type === "ArrowFunctionExpression" && F(M.body, true) || M.body.type === "ObjectExpression" || M.body.type === "ArrayExpression" || !H && (h(M.body) || M.body.type === "ConditionalExpression") || l(M.body)) || M.type === "DoExpression" || M.type === "ModuleExpression";
            }
            function S(M, H) {
              let P = s(M), G = i(M);
              return !u(P, a.Leading) && !u(P, a.Trailing) && F(P) && (!G || G.type !== P.type) && (M.length !== 2 || G.type !== "ArrowFunctionExpression" || P.type !== "ArrayExpression") && !(M.length > 1 && P.type === "ArrayExpression" && o(P, H));
            }
            function k(M) {
              if (M.length !== 2)
                return false;
              let [H, P] = M;
              return H.type === "ModuleExpression" && R(P) ? true : !u(H) && (H.type === "FunctionExpression" || H.type === "ArrowFunctionExpression" && H.body.type === "BlockStatement") && P.type !== "FunctionExpression" && P.type !== "ArrowFunctionExpression" && P.type !== "ConditionalExpression" && !F(P);
            }
            function _(M) {
              return M.length === 2 && M[0].type === "ArrowFunctionExpression" && r(M[0]).length === 0 && M[0].body.type === "BlockStatement" && M[1].type === "ArrayExpression" && !M.some((H) => u(H));
            }
            function O(M) {
              return M.type === "BlockStatement" && (M.body.some((H) => H.type !== "EmptyStatement") || u(M, a.Dangling));
            }
            function R(M) {
              return M.type === "ObjectExpression" && M.properties.length === 1 && T(M.properties[0]) && M.properties[0].key.type === "Identifier" && M.properties[0].key.name === "type" && N(M.properties[0].value) && M.properties[0].value.value === "module";
            }
            n.exports = x;
          } }), uo = Z({ "src/language-js/print/member.js"(e, n) {
            "use strict";
            ae();
            var { builders: { softline: t, group: s, indent: i, label: r } } = Le(), { isNumericLiteral: u, isMemberExpression: a, isCallExpression: c } = Xe(), { printOptionalToken: l } = ot();
            function C(g, p, f) {
              let h = g.getValue(), N = g.getParentNode(), T, A = 0;
              do
                T = g.getParentNode(A), A++;
              while (T && (a(T) || T.type === "TSNonNullExpression"));
              let b = f("object"), v = m(g, p, f), B = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || h.computed || h.object.type === "Identifier" && h.property.type === "Identifier" && !a(N) || (N.type === "AssignmentExpression" || N.type === "VariableDeclarator") && (c(h.object) && h.object.arguments.length > 0 || h.object.type === "TSNonNullExpression" && c(h.object.expression) && h.object.expression.arguments.length > 0 || b.label === "member-chain");
              return r(b.label === "member-chain" ? "member-chain" : "member", [b, B ? v : s(i([t, v]))]);
            }
            function m(g, p, f) {
              let h = f("property"), N = g.getValue(), T = l(g);
              return N.computed ? !N.property || u(N.property) ? [T, "[", h, "]"] : s([T, "[", i([t, h]), t, "]"]) : [T, ".", h];
            }
            n.exports = { printMemberExpression: C, printMemberLookup: m };
          } }), Nm = Z({ "src/language-js/print/member-chain.js"(e, n) {
            "use strict";
            ae();
            var { printComments: t } = Qe(), { getLast: s, isNextLineEmptyAfterIndex: i, getNextNonSpaceNonCommentCharacterIndex: r } = Ge(), u = kt(), { isCallExpression: a, isMemberExpression: c, isFunctionOrArrowExpression: l, isLongCurriedCallExpression: C, isMemberish: m, isNumericLiteral: g, isSimpleCallArgument: p, hasComment: f, CommentCheckFlags: h, isNextLineEmpty: N } = Xe(), { locEnd: T } = nt(), { builders: { join: A, hardline: b, group: v, indent: B, conditionalGroup: w, breakParent: I, label: E }, utils: { willBreak: D } } = Le(), d = no(), { printMemberLookup: y } = uo(), { printOptionalToken: o, printFunctionTypeParameters: x, printBindExpressionCallee: F } = ot();
            function S(k, _, O) {
              let R = k.getParentNode(), M = !R || R.type === "ExpressionStatement", H = [];
              function P(me) {
                let { originalText: ce } = _, he = r(ce, me, T);
                return ce.charAt(he) === ")" ? he !== false && i(ce, he + 1) : N(me, _);
              }
              function G(me) {
                let ce = me.getValue();
                a(ce) && (m(ce.callee) || a(ce.callee)) ? (H.unshift({ node: ce, printed: [t(me, [o(me), x(me, _, O), d(me, _, O)], _), P(ce) ? b : ""] }), me.call((he) => G(he), "callee")) : m(ce) ? (H.unshift({ node: ce, needsParens: u(me, _), printed: t(me, c(ce) ? y(me, _, O) : F(me, _, O), _) }), me.call((he) => G(he), "object")) : ce.type === "TSNonNullExpression" ? (H.unshift({ node: ce, printed: t(me, "!", _) }), me.call((he) => G(he), "expression")) : H.unshift({ node: ce, printed: O() });
              }
              let re = k.getValue();
              H.unshift({ node: re, printed: [o(k), x(k, _, O), d(k, _, O)] }), re.callee && k.call((me) => G(me), "callee");
              let $ = [], W = [H[0]], ee = 1;
              for (; ee < H.length && (H[ee].node.type === "TSNonNullExpression" || a(H[ee].node) || c(H[ee].node) && H[ee].node.computed && g(H[ee].node.property)); ++ee)
                W.push(H[ee]);
              if (!a(H[0].node))
                for (; ee + 1 < H.length && (m(H[ee].node) && m(H[ee + 1].node)); ++ee)
                  W.push(H[ee]);
              $.push(W), W = [];
              let U = false;
              for (; ee < H.length; ++ee) {
                if (U && m(H[ee].node)) {
                  if (H[ee].node.computed && g(H[ee].node.property)) {
                    W.push(H[ee]);
                    continue;
                  }
                  $.push(W), W = [], U = false;
                }
                (a(H[ee].node) || H[ee].node.type === "ImportExpression") && (U = true), W.push(H[ee]), f(H[ee].node, h.Trailing) && ($.push(W), W = [], U = false);
              }
              W.length > 0 && $.push(W);
              function ne(me) {
                return /^[A-Z]|^[$_]+$/.test(me);
              }
              function se(me) {
                return me.length <= _.tabWidth;
              }
              function V(me) {
                let ce = me[1].length > 0 && me[1][0].node.computed;
                if (me[0].length === 1) {
                  let J = me[0][0].node;
                  return J.type === "ThisExpression" || J.type === "Identifier" && (ne(J.name) || M && se(J.name) || ce);
                }
                let he = s(me[0]).node;
                return c(he) && he.property.type === "Identifier" && (ne(he.property.name) || ce);
              }
              let oe = $.length >= 2 && !f($[1][0].node) && V($);
              function K(me) {
                let ce = me.map((he) => he.printed);
                return me.length > 0 && s(me).needsParens ? ["(", ...ce, ")"] : ce;
              }
              function Ee(me) {
                return me.length === 0 ? "" : B(v([b, A(b, me.map(K))]));
              }
              let q = $.map(K), le = q, ue = oe ? 3 : 2, Q = $.flat(), de = Q.slice(1, -1).some((me) => f(me.node, h.Leading)) || Q.slice(0, -1).some((me) => f(me.node, h.Trailing)) || $[ue] && f($[ue][0].node, h.Leading);
              if ($.length <= ue && !de)
                return C(k) ? le : v(le);
              let ge = s($[oe ? 1 : 0]).node, ve = !a(ge) && P(ge), xe = [K($[0]), oe ? $.slice(1, 2).map(K) : "", ve ? b : "", Ee($.slice(oe ? 2 : 1))], we = H.map((me) => {
                let { node: ce } = me;
                return ce;
              }).filter(a);
              function fe() {
                let me = s(s($)).node, ce = s(q);
                return a(me) && D(ce) && we.slice(0, -1).some((he) => he.arguments.some(l));
              }
              let pe;
              return de || we.length > 2 && we.some((me) => !me.arguments.every((ce) => p(ce, 0))) || q.slice(0, -1).some(D) || fe() ? pe = v(xe) : pe = [D(le) || ve ? I : "", w([le, xe])], E("member-chain", pe);
            }
            n.exports = S;
          } }), so = Z({ "src/language-js/print/call-expression.js"(e, n) {
            "use strict";
            ae();
            var { builders: { join: t, group: s } } = Le(), i = kt(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: a, isMemberish: c, isStringLiteral: l, isTemplateOnItsOwnLine: C, isTestCall: m, iterateCallArgumentsPath: g } = Xe(), p = Nm(), f = no(), { printOptionalToken: h, printFunctionTypeParameters: N } = ot();
            function T(b, v, B) {
              let w = b.getValue(), I = b.getParentNode(), E = w.type === "NewExpression", D = w.type === "ImportExpression", d = h(b), y = r(w);
              if (y.length > 0 && (!D && !E && A(w, I) || y.length === 1 && C(y[0], v.originalText) || !E && m(w, I))) {
                let F = [];
                return g(b, () => {
                  F.push(B());
                }), [E ? "new " : "", B("callee"), d, N(b, v, B), "(", t(", ", F), ")"];
              }
              let o = (v.parser === "babel" || v.parser === "babel-flow") && w.callee && w.callee.type === "Identifier" && u(w.callee.trailingComments);
              if (o && (w.callee.trailingComments[0].printed = true), !D && !E && c(w.callee) && !b.call((F) => i(F, v), "callee"))
                return p(b, v, B);
              let x = [E ? "new " : "", D ? "import" : B("callee"), d, o ? "/*:: ".concat(w.callee.trailingComments[0].value.slice(2).trim(), " */") : "", N(b, v, B), f(b, v, B)];
              return D || a(w.callee) ? s(x) : x;
            }
            function A(b, v) {
              if (b.callee.type !== "Identifier")
                return false;
              if (b.callee.name === "require")
                return true;
              if (b.callee.name === "define") {
                let B = r(b);
                return v.type === "ExpressionStatement" && (B.length === 1 || B.length === 2 && B[0].type === "ArrayExpression" || B.length === 3 && l(B[0]) && B[1].type === "ArrayExpression");
              }
              return false;
            }
            n.exports = { printCallExpression: T };
          } }), Xt = Z({ "src/language-js/print/assignment.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t, getStringWidth: s } = Ge(), { builders: { line: i, group: r, indent: u, indentIfBreak: a, lineSuffixBoundary: c }, utils: { cleanDoc: l, willBreak: C, canBreak: m } } = Le(), { hasLeadingOwnLineComment: g, isBinaryish: p, isStringLiteral: f, isLiteral: h, isNumericLiteral: N, isCallExpression: T, isMemberExpression: A, getCallArguments: b, rawText: v, hasComment: B, isSignedNumericLiteral: w, isObjectProperty: I } = Xe(), { shouldInlineLogicalExpression: E } = Jn(), { printCallExpression: D } = so();
            function d(V, oe, K, Ee, q, le) {
              let ue = x(V, oe, K, Ee, le), Q = K(le, { assignmentLayout: ue });
              switch (ue) {
                case "break-after-operator":
                  return r([r(Ee), q, r(u([i, Q]))]);
                case "never-break-after-operator":
                  return r([r(Ee), q, " ", Q]);
                case "fluid": {
                  let de = Symbol("assignment");
                  return r([r(Ee), q, r(u(i), { id: de }), c, a(Q, { groupId: de })]);
                }
                case "break-lhs":
                  return r([Ee, q, " ", r(Q)]);
                case "chain":
                  return [r(Ee), q, i, Q];
                case "chain-tail":
                  return [r(Ee), q, u([i, Q])];
                case "chain-tail-arrow-chain":
                  return [r(Ee), q, Q];
                case "only-left":
                  return Ee;
              }
            }
            function y(V, oe, K) {
              let Ee = V.getValue();
              return d(V, oe, K, K("left"), [" ", Ee.operator], "right");
            }
            function o(V, oe, K) {
              return d(V, oe, K, K("id"), " =", "init");
            }
            function x(V, oe, K, Ee, q) {
              let le = V.getValue(), ue = le[q];
              if (!ue)
                return "only-left";
              let Q = !k(ue);
              if (V.match(k, _, (xe) => !Q || xe.type !== "ExpressionStatement" && xe.type !== "VariableDeclaration"))
                return Q ? ue.type === "ArrowFunctionExpression" && ue.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
              if (!Q && k(ue.right) || g(oe.originalText, ue))
                return "break-after-operator";
              if (ue.type === "CallExpression" && ue.callee.name === "require" || oe.parser === "json5" || oe.parser === "json")
                return "never-break-after-operator";
              if (S(le) || O(le) || H(le) || P(le) && m(Ee))
                return "break-lhs";
              let ve = U(le, Ee, oe);
              return V.call(() => F(V, oe, K, ve), q) ? "break-after-operator" : ve || ue.type === "TemplateLiteral" || ue.type === "TaggedTemplateExpression" || ue.type === "BooleanLiteral" || N(ue) || ue.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
            }
            function F(V, oe, K, Ee) {
              let q = V.getValue();
              if (p(q) && !E(q))
                return true;
              switch (q.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  let { test: Q } = q;
                  return p(Q) && !E(Q);
                }
                case "ClassExpression":
                  return t(q.decorators);
              }
              if (Ee)
                return false;
              let le = q, ue = [];
              for (; ; )
                if (le.type === "UnaryExpression")
                  le = le.argument, ue.push("argument");
                else if (le.type === "TSNonNullExpression")
                  le = le.expression, ue.push("expression");
                else
                  break;
              return !!(f(le) || V.call(() => $(V, oe, K), ...ue));
            }
            function S(V) {
              if (_(V)) {
                let oe = V.left || V.id;
                return oe.type === "ObjectPattern" && oe.properties.length > 2 && oe.properties.some((K) => I(K) && (!K.shorthand || K.value && K.value.type === "AssignmentPattern"));
              }
              return false;
            }
            function k(V) {
              return V.type === "AssignmentExpression";
            }
            function _(V) {
              return k(V) || V.type === "VariableDeclarator";
            }
            function O(V) {
              let oe = R(V);
              if (t(oe)) {
                let K = V.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (oe.length > 1 && oe.some((Ee) => Ee[K] || Ee.default))
                  return true;
              }
              return false;
            }
            function R(V) {
              return M(V) && V.typeParameters && V.typeParameters.params ? V.typeParameters.params : null;
            }
            function M(V) {
              return V.type === "TSTypeAliasDeclaration" || V.type === "TypeAlias";
            }
            function H(V) {
              if (V.type !== "VariableDeclarator")
                return false;
              let { typeAnnotation: oe } = V.id;
              if (!oe || !oe.typeAnnotation)
                return false;
              let K = G(oe.typeAnnotation);
              return t(K) && K.length > 1 && K.some((Ee) => t(G(Ee)) || Ee.type === "TSConditionalType");
            }
            function P(V) {
              return V.type === "VariableDeclarator" && V.init && V.init.type === "ArrowFunctionExpression";
            }
            function G(V) {
              return re(V) && V.typeParameters && V.typeParameters.params ? V.typeParameters.params : null;
            }
            function re(V) {
              return V.type === "TSTypeReference" || V.type === "GenericTypeAnnotation";
            }
            function $(V, oe, K) {
              let Ee = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, q = V.getValue(), le = () => $(V, oe, K, true);
              if (q.type === "TSNonNullExpression")
                return V.call(le, "expression");
              if (T(q)) {
                if (D(V, oe, K).label === "member-chain")
                  return false;
                let Q = b(q);
                return !(Q.length === 0 || Q.length === 1 && ee(Q[0], oe)) || ne(q, K) ? false : V.call(le, "callee");
              }
              return A(q) ? V.call(le, "object") : Ee && (q.type === "Identifier" || q.type === "ThisExpression");
            }
            var W = 0.25;
            function ee(V, oe) {
              let { printWidth: K } = oe;
              if (B(V))
                return false;
              let Ee = K * W;
              if (V.type === "ThisExpression" || V.type === "Identifier" && V.name.length <= Ee || w(V) && !B(V.argument))
                return true;
              let q = V.type === "Literal" && "regex" in V && V.regex.pattern || V.type === "RegExpLiteral" && V.pattern;
              return q ? q.length <= Ee : f(V) ? v(V).length <= Ee : V.type === "TemplateLiteral" ? V.expressions.length === 0 && V.quasis[0].value.raw.length <= Ee && !V.quasis[0].value.raw.includes(`
`) : h(V);
            }
            function U(V, oe, K) {
              if (!I(V))
                return false;
              oe = l(oe);
              let Ee = 3;
              return typeof oe == "string" && s(oe) < K.tabWidth + Ee;
            }
            function ne(V, oe) {
              let K = se(V);
              if (t(K)) {
                if (K.length > 1)
                  return true;
                if (K.length === 1) {
                  let q = K[0];
                  if (q.type === "TSUnionType" || q.type === "UnionTypeAnnotation" || q.type === "TSIntersectionType" || q.type === "IntersectionTypeAnnotation" || q.type === "TSTypeLiteral" || q.type === "ObjectTypeAnnotation")
                    return true;
                }
                let Ee = V.typeParameters ? "typeParameters" : "typeArguments";
                if (C(oe(Ee)))
                  return true;
              }
              return false;
            }
            function se(V) {
              return V.typeParameters && V.typeParameters.params || V.typeArguments && V.typeArguments.params;
            }
            n.exports = { printVariableDeclarator: o, printAssignmentExpression: y, printAssignment: d, isArrowFunctionVariableDeclarator: P };
          } }), wr = Z({ "src/language-js/print/function-parameters.js"(e, n) {
            "use strict";
            ae();
            var { getNextNonSpaceNonCommentCharacter: t } = Ge(), { printDanglingComments: s } = Qe(), { builders: { line: i, hardline: r, softline: u, group: a, indent: c, ifBreak: l }, utils: { removeLines: C, willBreak: m } } = Le(), { getFunctionParameters: g, iterateFunctionParametersPath: p, isSimpleType: f, isTestCall: h, isTypeAnnotationAFunction: N, isObjectType: T, isObjectTypePropertyAFunction: A, hasRestParameter: b, shouldPrintComma: v, hasComment: B, isNextLineEmpty: w } = Xe(), { locEnd: I } = nt(), { ArgExpansionBailout: E } = Jt(), { printFunctionTypeParameters: D } = ot();
            function d(F, S, k, _, O) {
              let R = F.getValue(), M = g(R), H = O ? D(F, k, S) : "";
              if (M.length === 0)
                return [H, "(", s(F, k, true, (U) => t(k.originalText, U, I) === ")"), ")"];
              let P = F.getParentNode(), G = h(P), re = y(R), $ = [];
              if (p(F, (U, ne) => {
                let se = ne === M.length - 1;
                se && R.rest && $.push("..."), $.push(S()), !se && ($.push(","), G || re ? $.push(" ") : w(M[ne], k) ? $.push(r, r) : $.push(i));
              }), _) {
                if (m(H) || m($))
                  throw new E();
                return a([C(H), "(", C($), ")"]);
              }
              let W = M.every((U) => !U.decorators);
              return re && W ? [H, "(", ...$, ")"] : G ? [H, "(", ...$, ")"] : (A(P) || N(P) || P.type === "TypeAlias" || P.type === "UnionTypeAnnotation" || P.type === "TSUnionType" || P.type === "IntersectionTypeAnnotation" || P.type === "FunctionTypeAnnotation" && P.returnType === R) && M.length === 1 && M[0].name === null && R.this !== M[0] && M[0].typeAnnotation && R.typeParameters === null && f(M[0].typeAnnotation) && !R.rest ? k.arrowParens === "always" ? ["(", ...$, ")"] : $ : [H, "(", c([u, ...$]), l(!b(R) && v(k, "all") ? "," : ""), u, ")"];
            }
            function y(F) {
              if (!F)
                return false;
              let S = g(F);
              if (S.length !== 1)
                return false;
              let [k] = S;
              return !B(k) && (k.type === "ObjectPattern" || k.type === "ArrayPattern" || k.type === "Identifier" && k.typeAnnotation && (k.typeAnnotation.type === "TypeAnnotation" || k.typeAnnotation.type === "TSTypeAnnotation") && T(k.typeAnnotation.typeAnnotation) || k.type === "FunctionTypeParam" && T(k.typeAnnotation) || k.type === "AssignmentPattern" && (k.left.type === "ObjectPattern" || k.left.type === "ArrayPattern") && (k.right.type === "Identifier" || k.right.type === "ObjectExpression" && k.right.properties.length === 0 || k.right.type === "ArrayExpression" && k.right.elements.length === 0));
            }
            function o(F) {
              let S;
              return F.returnType ? (S = F.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : F.typeAnnotation && (S = F.typeAnnotation), S;
            }
            function x(F, S) {
              let k = o(F);
              if (!k)
                return false;
              let _ = F.typeParameters && F.typeParameters.params;
              if (_) {
                if (_.length > 1)
                  return false;
                if (_.length === 1) {
                  let O = _[0];
                  if (O.constraint || O.default)
                    return false;
                }
              }
              return g(F).length === 1 && (T(k) || m(S));
            }
            n.exports = { printFunctionParameters: d, shouldHugFunctionParameters: y, shouldGroupFunctionParameters: x };
          } }), _r = Z({ "src/language-js/print/type-annotation.js"(e, n) {
            "use strict";
            ae();
            var { printComments: t, printDanglingComments: s } = Qe(), { isNonEmptyArray: i } = Ge(), { builders: { group: r, join: u, line: a, softline: c, indent: l, align: C, ifBreak: m } } = Le(), g = kt(), { locStart: p } = nt(), { isSimpleType: f, isObjectType: h, hasLeadingOwnLineComment: N, isObjectTypePropertyAFunction: T, shouldPrintComma: A } = Xe(), { printAssignment: b } = Xt(), { printFunctionParameters: v, shouldGroupFunctionParameters: B } = wr(), { printArrayItems: w } = zt();
            function I(S) {
              if (f(S) || h(S))
                return true;
              if (S.type === "UnionTypeAnnotation" || S.type === "TSUnionType") {
                let k = S.types.filter((O) => O.type === "VoidTypeAnnotation" || O.type === "TSVoidKeyword" || O.type === "NullLiteralTypeAnnotation" || O.type === "TSNullKeyword").length, _ = S.types.some((O) => O.type === "ObjectTypeAnnotation" || O.type === "TSTypeLiteral" || O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference");
                if (S.types.length - 1 === k && _)
                  return true;
              }
              return false;
            }
            function E(S, k, _) {
              let O = k.semi ? ";" : "", R = S.getValue(), M = [];
              return M.push("opaque type ", _("id"), _("typeParameters")), R.supertype && M.push(": ", _("supertype")), R.impltype && M.push(" = ", _("impltype")), M.push(O), M;
            }
            function D(S, k, _) {
              let O = k.semi ? ";" : "", R = S.getValue(), M = [];
              R.declare && M.push("declare "), M.push("type ", _("id"), _("typeParameters"));
              let H = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
              return [b(S, k, _, M, " =", H), O];
            }
            function d(S, k, _) {
              let O = S.getValue(), R = S.map(_, "types"), M = [], H = false;
              for (let P = 0; P < R.length; ++P)
                P === 0 ? M.push(R[P]) : h(O.types[P - 1]) && h(O.types[P]) ? M.push([" & ", H ? l(R[P]) : R[P]]) : !h(O.types[P - 1]) && !h(O.types[P]) ? M.push(l([" &", a, R[P]])) : (P > 1 && (H = true), M.push(" & ", P > 1 ? l(R[P]) : R[P]));
              return r(M);
            }
            function y(S, k, _) {
              let O = S.getValue(), R = S.getParentNode(), M = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && S.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && N(k.originalText, O)), H = I(O), P = S.map(($) => {
                let W = _();
                return H || (W = C(2, W)), t($, W, k);
              }, "types");
              if (H)
                return u(" | ", P);
              let G = M && !N(k.originalText, O), re = [m([G ? a : "", "| "]), u([a, "| "], P)];
              return g(S, k) ? r([l(re), c]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? r([l([m(["(", c]), re]), c, m(")")]) : r(M ? l(re) : re);
            }
            function o(S, k, _) {
              let O = S.getValue(), R = [], M = S.getParentNode(0), H = S.getParentNode(1), P = S.getParentNode(2), G = O.type === "TSFunctionType" || !((M.type === "ObjectTypeProperty" || M.type === "ObjectTypeInternalSlot") && !M.variance && !M.optional && p(M) === p(O) || M.type === "ObjectTypeCallProperty" || P && P.type === "DeclareFunction"), re = G && (M.type === "TypeAnnotation" || M.type === "TSTypeAnnotation"), $ = re && G && (M.type === "TypeAnnotation" || M.type === "TSTypeAnnotation") && H.type === "ArrowFunctionExpression";
              T(M) && (G = true, re = true), $ && R.push("(");
              let W = v(S, _, k, false, true), ee = O.returnType || O.predicate || O.typeAnnotation ? [G ? " => " : ": ", _("returnType"), _("predicate"), _("typeAnnotation")] : "", U = B(O, ee);
              return R.push(U ? r(W) : W), ee && R.push(ee), $ && R.push(")"), r(R);
            }
            function x(S, k, _) {
              let O = S.getValue(), R = O.type === "TSTupleType" ? "elementTypes" : "types", M = O[R], H = i(M), P = H ? c : "";
              return r(["[", l([P, w(S, k, R, _)]), m(H && A(k, "all") ? "," : ""), s(S, k, true), P, "]"]);
            }
            function F(S, k, _) {
              let O = S.getValue(), R = O.type === "OptionalIndexedAccessType" && O.optional ? "?.[" : "[";
              return [_("objectType"), R, _("indexType"), "]"];
            }
            n.exports = { printOpaqueType: E, printTypeAlias: D, printIntersectionType: d, printUnionType: y, printFunctionType: o, printTupleType: x, printIndexedAccessType: F, shouldHugType: I };
          } }), Pr = Z({ "src/language-js/print/type-parameters.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { builders: { join: s, line: i, hardline: r, softline: u, group: a, indent: c, ifBreak: l } } = Le(), { isTestCall: C, hasComment: m, CommentCheckFlags: g, isTSXFile: p, shouldPrintComma: f, getFunctionParameters: h, isObjectType: N } = Xe(), { createGroupIdMapper: T } = Ge(), { shouldHugType: A } = _r(), { isArrowFunctionVariableDeclarator: b } = Xt(), v = T("typeParameters");
            function B(E, D, d, y) {
              let o = E.getValue();
              if (!o[y])
                return "";
              if (!Array.isArray(o[y]))
                return d(y);
              let x = E.getNode(2), F = x && C(x);
              if (!E.match((O) => !(O[y].length === 1 && N(O[y][0])), void 0, (O, R) => R === "typeAnnotation", (O) => O.type === "Identifier", b) && (F || o[y].length === 0 || o[y].length === 1 && (o[y][0].type === "NullableTypeAnnotation" || A(o[y][0]))))
                return ["<", s(", ", E.map(d, y)), w(E, D), ">"];
              let _ = o.type === "TSTypeParameterInstantiation" ? "" : h(o).length === 1 && p(D) && !o[y][0].constraint && E.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D, "all") ? l(",") : "";
              return a(["<", c([u, s([",", i], E.map(d, y))]), _, u, ">"], { id: v(o) });
            }
            function w(E, D) {
              let d = E.getValue();
              if (!m(d, g.Dangling))
                return "";
              let y = !m(d, g.Line), o = t(E, D, y);
              return y ? o : [o, r];
            }
            function I(E, D, d) {
              let y = E.getValue(), o = [], x = E.getParentNode();
              return x.type === "TSMappedType" ? (o.push("[", d("name")), y.constraint && o.push(" in ", d("constraint")), x.nameType && o.push(" as ", E.callParent(() => d("nameType"))), o.push("]"), o) : (y.variance && o.push(d("variance")), o.push(d("name")), y.bound && o.push(": ", d("bound")), y.constraint && o.push(" extends ", d("constraint")), y.default && o.push(" = ", d("default")), o);
            }
            n.exports = { printTypeParameter: I, printTypeParameters: B, getTypeParametersGroupId: v };
          } }), Kt = Z({ "src/language-js/print/property.js"(e, n) {
            "use strict";
            ae();
            var { printComments: t } = Qe(), { printString: s, printNumber: i } = Ge(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: a, isStringPropSafeToUnquote: c, rawText: l } = Xe(), { printAssignment: C } = Xt(), m = /* @__PURE__ */ new WeakMap();
            function g(f, h, N) {
              let T = f.getNode();
              if (T.computed)
                return ["[", N("key"), "]"];
              let A = f.getParentNode(), { key: b } = T;
              if (T.type === "ClassPrivateProperty" && b.type === "Identifier")
                return ["#", N("key")];
              if (h.quoteProps === "consistent" && !m.has(A)) {
                let v = (A.properties || A.body || A.members).some((B) => !B.computed && B.key && a(B.key) && !c(B, h));
                m.set(A, v);
              }
              if ((b.type === "Identifier" || r(b) && u(i(l(b))) && String(b.value) === i(l(b)) && !(h.parser === "typescript" || h.parser === "babel-ts")) && (h.parser === "json" || h.quoteProps === "consistent" && m.get(A))) {
                let v = s(JSON.stringify(b.type === "Identifier" ? b.name : b.value.toString()), h);
                return f.call((B) => t(B, v, h), "key");
              }
              return c(T, h) && (h.quoteProps === "as-needed" || h.quoteProps === "consistent" && !m.get(A)) ? f.call((v) => t(v, /^\d/.test(b.value) ? i(b.value) : b.value, h), "key") : N("key");
            }
            function p(f, h, N) {
              return f.getValue().shorthand ? N("value") : C(f, h, N, g(f, h, N), ":", "value");
            }
            n.exports = { printProperty: p, printPropertyKey: g };
          } }), Ir = Z({ "src/language-js/print/function.js"(e, n) {
            "use strict";
            ae();
            var t = Ut(), { printDanglingComments: s, printCommentsSeparately: i } = Qe(), r = st(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ge(), { builders: { line: a, softline: c, group: l, indent: C, ifBreak: m, hardline: g, join: p, indentIfBreak: f }, utils: { removeLines: h, willBreak: N } } = Le(), { ArgExpansionBailout: T } = Jt(), { getFunctionParameters: A, hasLeadingOwnLineComment: b, isFlowAnnotationComment: v, isJsxNode: B, isTemplateOnItsOwnLine: w, shouldPrintComma: I, startsWithNoLookaheadToken: E, isBinaryish: D, isLineComment: d, hasComment: y, getComments: o, CommentCheckFlags: x, isCallLikeExpression: F, isCallExpression: S, getCallArguments: k, hasNakedLeftSide: _, getLeftSide: O } = Xe(), { locEnd: R } = nt(), { printFunctionParameters: M, shouldGroupFunctionParameters: H } = wr(), { printPropertyKey: P } = Kt(), { printFunctionTypeParameters: G } = ot();
            function re(ue, Q, de, ge) {
              let ve = ue.getValue(), xe = false;
              if ((ve.type === "FunctionDeclaration" || ve.type === "FunctionExpression") && ge && ge.expandLastArg) {
                let ce = ue.getParentNode();
                S(ce) && k(ce).length > 1 && (xe = true);
              }
              let we = [];
              ve.type === "TSDeclareFunction" && ve.declare && we.push("declare "), ve.async && we.push("async "), ve.generator ? we.push("function* ") : we.push("function "), ve.id && we.push(Q("id"));
              let fe = M(ue, Q, de, xe), pe = oe(ue, Q, de), me = H(ve, pe);
              return we.push(G(ue, de, Q), l([me ? l(fe) : fe, pe]), ve.body ? " " : "", Q("body")), de.semi && (ve.declare || !ve.body) && we.push(";"), we;
            }
            function $(ue, Q, de) {
              let ge = ue.getNode(), { kind: ve } = ge, xe = ge.value || ge, we = [];
              return !ve || ve === "init" || ve === "method" || ve === "constructor" ? xe.async && we.push("async ") : (t.ok(ve === "get" || ve === "set"), we.push(ve, " ")), xe.generator && we.push("*"), we.push(P(ue, Q, de), ge.optional || ge.key.optional ? "?" : ""), ge === xe ? we.push(W(ue, Q, de)) : xe.type === "FunctionExpression" ? we.push(ue.call((fe) => W(fe, Q, de), "value")) : we.push(de("value")), we;
            }
            function W(ue, Q, de) {
              let ge = ue.getNode(), ve = M(ue, de, Q), xe = oe(ue, de, Q), we = H(ge, xe), fe = [G(ue, Q, de), l([we ? l(ve) : ve, xe])];
              return ge.body ? fe.push(" ", de("body")) : fe.push(Q.semi ? ";" : ""), fe;
            }
            function ee(ue, Q, de, ge) {
              let ve = ue.getValue(), xe = [];
              if (ve.async && xe.push("async "), V(ue, Q))
                xe.push(de(["params", 0]));
              else {
                let fe = ge && (ge.expandLastArg || ge.expandFirstArg), pe = oe(ue, de, Q);
                if (fe) {
                  if (N(pe))
                    throw new T();
                  pe = l(h(pe));
                }
                xe.push(l([M(ue, de, Q, fe, true), pe]));
              }
              let we = s(ue, Q, true, (fe) => {
                let pe = u(Q.originalText, fe, R);
                return pe !== false && Q.originalText.slice(pe, pe + 2) === "=>";
              });
              return we && xe.push(" ", we), xe;
            }
            function U(ue, Q, de, ge, ve, xe) {
              let we = ue.getName(), fe = ue.getParentNode(), pe = F(fe) && we === "callee", me = Boolean(Q && Q.assignmentLayout), ce = xe.body.type !== "BlockStatement" && xe.body.type !== "ObjectExpression" && xe.body.type !== "SequenceExpression", he = pe && ce || Q && Q.assignmentLayout === "chain-tail-arrow-chain", J = Symbol("arrow-chain");
              return xe.body.type === "SequenceExpression" && (ve = l(["(", C([c, ve]), c, ")"])), l([l(C([pe || me ? c : "", l(p([" =>", a], de), { shouldBreak: ge })]), { id: J, shouldBreak: he }), " =>", f(ce ? C([a, ve]) : [" ", ve], { groupId: J }), pe ? m(c, "", { groupId: J }) : ""]);
            }
            function ne(ue, Q, de, ge) {
              let ve = ue.getValue(), xe = [], we = [], fe = false;
              if (function J() {
                let ye = ee(ue, Q, de, ge);
                if (xe.length === 0)
                  xe.push(ye);
                else {
                  let { leading: X, trailing: Y } = i(ue, Q);
                  xe.push([X, ye]), we.unshift(Y);
                }
                fe = fe || ve.returnType && A(ve).length > 0 || ve.typeParameters || A(ve).some((X) => X.type !== "Identifier"), ve.body.type !== "ArrowFunctionExpression" || ge && ge.expandLastArg ? we.unshift(de("body", ge)) : (ve = ve.body, ue.call(J, "body"));
              }(), xe.length > 1)
                return U(ue, ge, xe, fe, we, ve);
              let pe = xe;
              if (pe.push(" =>"), !b(Q.originalText, ve.body) && (ve.body.type === "ArrayExpression" || ve.body.type === "ObjectExpression" || ve.body.type === "BlockStatement" || B(ve.body) || w(ve.body, Q.originalText) || ve.body.type === "ArrowFunctionExpression" || ve.body.type === "DoExpression"))
                return l([...pe, " ", we]);
              if (ve.body.type === "SequenceExpression")
                return l([...pe, l([" (", C([c, we]), c, ")"])]);
              let me = (ge && ge.expandLastArg || ue.getParentNode().type === "JSXExpressionContainer") && !y(ve), ce = ge && ge.expandLastArg && I(Q, "all"), he = ve.body.type === "ConditionalExpression" && !E(ve.body, false);
              return l([...pe, l([C([a, he ? m("", "(") : "", we, he ? m("", ")") : ""]), me ? [m(ce ? "," : ""), c] : ""])]);
            }
            function se(ue) {
              let Q = A(ue);
              return Q.length === 1 && !ue.typeParameters && !y(ue, x.Dangling) && Q[0].type === "Identifier" && !Q[0].typeAnnotation && !y(Q[0]) && !Q[0].optional && !ue.predicate && !ue.returnType;
            }
            function V(ue, Q) {
              if (Q.arrowParens === "always")
                return false;
              if (Q.arrowParens === "avoid") {
                let de = ue.getValue();
                return se(de);
              }
              return false;
            }
            function oe(ue, Q, de) {
              let ge = ue.getValue(), ve = Q("returnType");
              if (ge.returnType && v(de.originalText, ge.returnType))
                return [" /*: ", ve, " */"];
              let xe = [ve];
              return ge.returnType && ge.returnType.typeAnnotation && xe.unshift(": "), ge.predicate && xe.push(ge.returnType ? " " : ": ", Q("predicate")), xe;
            }
            function K(ue, Q, de) {
              let ge = ue.getValue(), ve = Q.semi ? ";" : "", xe = [];
              ge.argument && (le(Q, ge.argument) ? xe.push([" (", C([g, de("argument")]), g, ")"]) : D(ge.argument) || ge.argument.type === "SequenceExpression" ? xe.push(l([m(" (", " "), C([c, de("argument")]), c, m(")")])) : xe.push(" ", de("argument")));
              let we = o(ge), fe = r(we), pe = fe && d(fe);
              return pe && xe.push(ve), y(ge, x.Dangling) && xe.push(" ", s(ue, Q, true)), pe || xe.push(ve), xe;
            }
            function Ee(ue, Q, de) {
              return ["return", K(ue, Q, de)];
            }
            function q(ue, Q, de) {
              return ["throw", K(ue, Q, de)];
            }
            function le(ue, Q) {
              if (b(ue.originalText, Q))
                return true;
              if (_(Q)) {
                let de = Q, ge;
                for (; ge = O(de); )
                  if (de = ge, b(ue.originalText, de))
                    return true;
              }
              return false;
            }
            n.exports = { printFunction: re, printArrowFunction: ne, printMethod: $, printReturnStatement: Ee, printThrowStatement: q, printMethodInternal: W, shouldPrintParamsWithoutParens: V };
          } }), Un = Z({ "src/language-js/print/decorators.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t, hasNewline: s } = Ge(), { builders: { line: i, hardline: r, join: u, breakParent: a, group: c } } = Le(), { locStart: l, locEnd: C } = nt(), { getParentExportDeclaration: m } = Xe();
            function g(T, A, b) {
              let v = T.getValue();
              return c([u(i, T.map(b, "decorators")), h(v, A) ? r : i]);
            }
            function p(T, A, b) {
              return [u(r, T.map(b, "declaration", "decorators")), r];
            }
            function f(T, A, b) {
              let v = T.getValue(), { decorators: B } = v;
              if (!t(B) || N(T.getParentNode()))
                return;
              let w = v.type === "ClassExpression" || v.type === "ClassDeclaration" || h(v, A);
              return [m(T) ? r : w ? a : "", u(i, T.map(b, "decorators")), i];
            }
            function h(T, A) {
              return T.decorators.some((b) => s(A.originalText, C(b)));
            }
            function N(T) {
              if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration")
                return false;
              let A = T.declaration && T.declaration.decorators;
              return t(A) && l(T, { ignoreDecorators: true }) > l(A[0]);
            }
            n.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: N };
          } }), Yt = Z({ "src/language-js/print/class.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t, createGroupIdMapper: s } = Ge(), { printComments: i, printDanglingComments: r } = Qe(), { builders: { join: u, line: a, hardline: c, softline: l, group: C, indent: m, ifBreak: g } } = Le(), { hasComment: p, CommentCheckFlags: f } = Xe(), { getTypeParametersGroupId: h } = Pr(), { printMethod: N } = Ir(), { printOptionalToken: T, printTypeAnnotation: A, printDefiniteToken: b } = ot(), { printPropertyKey: v } = Kt(), { printAssignment: B } = Xt(), { printClassMemberDecorators: w } = Un();
            function I(k, _, O) {
              let R = k.getValue(), M = [];
              R.declare && M.push("declare "), R.abstract && M.push("abstract "), M.push("class");
              let H = R.id && p(R.id, f.Trailing) || R.typeParameters && p(R.typeParameters, f.Trailing) || R.superClass && p(R.superClass) || t(R.extends) || t(R.mixins) || t(R.implements), P = [], G = [];
              if (R.id && P.push(" ", O("id")), P.push(O("typeParameters")), R.superClass) {
                let re = [x(k, _, O), O("superTypeParameters")], $ = k.call((W) => ["extends ", i(W, re, _)], "superClass");
                H ? G.push(a, C($)) : G.push(" ", $);
              } else
                G.push(o(k, _, O, "extends"));
              if (G.push(o(k, _, O, "mixins"), o(k, _, O, "implements")), H) {
                let re;
                y(R) ? re = [...P, m(G)] : re = m([...P, G]), M.push(C(re, { id: E(R) }));
              } else
                M.push(...P, ...G);
              return M.push(" ", O("body")), M;
            }
            var E = s("heritageGroup");
            function D(k) {
              return g(c, "", { groupId: E(k) });
            }
            function d(k) {
              return ["superClass", "extends", "mixins", "implements"].filter((_) => Boolean(k[_])).length > 1;
            }
            function y(k) {
              return k.typeParameters && !p(k.typeParameters, f.Trailing | f.Line) && !d(k);
            }
            function o(k, _, O, R) {
              let M = k.getValue();
              if (!t(M[R]))
                return "";
              let H = r(k, _, true, (P) => {
                let { marker: G } = P;
                return G === R;
              });
              return [y(M) ? g(" ", a, { groupId: h(M.typeParameters) }) : a, H, H && c, R, C(m([a, u([",", a], k.map(O, R))]))];
            }
            function x(k, _, O) {
              let R = O("superClass");
              return k.getParentNode().type === "AssignmentExpression" ? C(g(["(", m([l, R]), l, ")"], R)) : R;
            }
            function F(k, _, O) {
              let R = k.getValue(), M = [];
              return t(R.decorators) && M.push(w(k, _, O)), R.accessibility && M.push(R.accessibility + " "), R.readonly && M.push("readonly "), R.declare && M.push("declare "), R.static && M.push("static "), (R.type === "TSAbstractMethodDefinition" || R.abstract) && M.push("abstract "), R.override && M.push("override "), M.push(N(k, _, O)), M;
            }
            function S(k, _, O) {
              let R = k.getValue(), M = [], H = _.semi ? ";" : "";
              return t(R.decorators) && M.push(w(k, _, O)), R.accessibility && M.push(R.accessibility + " "), R.declare && M.push("declare "), R.static && M.push("static "), (R.type === "TSAbstractPropertyDefinition" || R.abstract) && M.push("abstract "), R.override && M.push("override "), R.readonly && M.push("readonly "), R.variance && M.push(O("variance")), R.type === "ClassAccessorProperty" && M.push("accessor "), M.push(v(k, _, O), T(k), b(k), A(k, _, O)), [B(k, _, O, M, " =", "value"), H];
            }
            n.exports = { printClass: I, printClassMethod: F, printClassProperty: S, printHardlineAfterHeritage: D };
          } }), ao = Z({ "src/language-js/print/interface.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t } = Ge(), { builders: { join: s, line: i, group: r, indent: u, ifBreak: a } } = Le(), { hasComment: c, identity: l, CommentCheckFlags: C } = Xe(), { getTypeParametersGroupId: m } = Pr(), { printTypeScriptModifiers: g } = ot();
            function p(f, h, N) {
              let T = f.getValue(), A = [];
              T.declare && A.push("declare "), T.type === "TSInterfaceDeclaration" && A.push(T.abstract ? "abstract " : "", g(f, h, N)), A.push("interface");
              let b = [], v = [];
              T.type !== "InterfaceTypeAnnotation" && b.push(" ", N("id"), N("typeParameters"));
              let B = T.typeParameters && !c(T.typeParameters, C.Trailing | C.Line);
              return t(T.extends) && v.push(B ? a(" ", i, { groupId: m(T.typeParameters) }) : i, "extends ", (T.extends.length === 1 ? l : u)(s([",", i], f.map(N, "extends")))), T.id && c(T.id, C.Trailing) || t(T.extends) ? B ? A.push(r([...b, u(v)])) : A.push(r(u([...b, ...v]))) : A.push(...b, ...v), A.push(" ", N("body")), r(A);
            }
            n.exports = { printInterface: p };
          } }), io = Z({ "src/language-js/print/module.js"(e, n) {
            "use strict";
            ae();
            var { isNonEmptyArray: t } = Ge(), { builders: { softline: s, group: i, indent: r, join: u, line: a, ifBreak: c, hardline: l } } = Le(), { printDanglingComments: C } = Qe(), { hasComment: m, CommentCheckFlags: g, shouldPrintComma: p, needsHardlineAfterDanglingComment: f, isStringLiteral: h, rawText: N } = Xe(), { locStart: T, hasSameLoc: A } = nt(), { hasDecoratorsBeforeExport: b, printDecoratorsBeforeExport: v } = Un();
            function B(S, k, _) {
              let O = S.getValue(), R = k.semi ? ";" : "", M = [], { importKind: H } = O;
              return M.push("import"), H && H !== "value" && M.push(" ", H), M.push(d(S, k, _), D(S, k, _), o(S, k, _), R), M;
            }
            function w(S, k, _) {
              let O = S.getValue(), R = [];
              b(O) && R.push(v(S, k, _));
              let { type: M, exportKind: H, declaration: P } = O;
              return R.push("export"), (O.default || M === "ExportDefaultDeclaration") && R.push(" default"), m(O, g.Dangling) && (R.push(" ", C(S, k, true)), f(O) && R.push(l)), P ? R.push(" ", _("declaration")) : R.push(H === "type" ? " type" : "", d(S, k, _), D(S, k, _), o(S, k, _)), E(O, k) && R.push(";"), R;
            }
            function I(S, k, _) {
              let O = S.getValue(), R = k.semi ? ";" : "", M = [], { exportKind: H, exported: P } = O;
              return M.push("export"), H === "type" && M.push(" type"), M.push(" *"), P && M.push(" as ", _("exported")), M.push(D(S, k, _), o(S, k, _), R), M;
            }
            function E(S, k) {
              if (!k.semi)
                return false;
              let { type: _, declaration: O } = S, R = S.default || _ === "ExportDefaultDeclaration";
              if (!O)
                return true;
              let { type: M } = O;
              return !!(R && M !== "ClassDeclaration" && M !== "FunctionDeclaration" && M !== "TSInterfaceDeclaration" && M !== "DeclareClass" && M !== "DeclareFunction" && M !== "TSDeclareFunction" && M !== "EnumDeclaration");
            }
            function D(S, k, _) {
              let O = S.getValue();
              if (!O.source)
                return "";
              let R = [];
              return y(O, k) || R.push(" from"), R.push(" ", _("source")), R;
            }
            function d(S, k, _) {
              let O = S.getValue();
              if (y(O, k))
                return "";
              let R = [" "];
              if (t(O.specifiers)) {
                let M = [], H = [];
                S.each(() => {
                  let P = S.getValue().type;
                  if (P === "ExportNamespaceSpecifier" || P === "ExportDefaultSpecifier" || P === "ImportNamespaceSpecifier" || P === "ImportDefaultSpecifier")
                    M.push(_());
                  else if (P === "ExportSpecifier" || P === "ImportSpecifier")
                    H.push(_());
                  else
                    throw new Error("Unknown specifier type ".concat(JSON.stringify(P)));
                }, "specifiers"), R.push(u(", ", M)), H.length > 0 && (M.length > 0 && R.push(", "), H.length > 1 || M.length > 0 || O.specifiers.some((G) => m(G)) ? R.push(i(["{", r([k.bracketSpacing ? a : s, u([",", a], H)]), c(p(k) ? "," : ""), k.bracketSpacing ? a : s, "}"])) : R.push(["{", k.bracketSpacing ? " " : "", ...H, k.bracketSpacing ? " " : "", "}"]));
              } else
                R.push("{}");
              return R;
            }
            function y(S, k) {
              let { type: _, importKind: O, source: R, specifiers: M } = S;
              return _ !== "ImportDeclaration" || t(M) || O === "type" ? false : !/{\s*}/.test(k.originalText.slice(T(S), T(R)));
            }
            function o(S, k, _) {
              let O = S.getNode();
              return t(O.assertions) ? [" assert {", k.bracketSpacing ? " " : "", u(", ", S.map(_, "assertions")), k.bracketSpacing ? " " : "", "}"] : "";
            }
            function x(S, k, _) {
              let O = S.getNode(), { type: R } = O, M = [], H = R === "ImportSpecifier" ? O.importKind : O.exportKind;
              H && H !== "value" && M.push(H, " ");
              let P = R.startsWith("Import"), G = P ? "imported" : "local", re = P ? "local" : "exported", $ = O[G], W = O[re], ee = "", U = "";
              return R === "ExportNamespaceSpecifier" || R === "ImportNamespaceSpecifier" ? ee = "*" : $ && (ee = _(G)), W && !F(O) && (U = _(re)), M.push(ee, ee && U ? " as " : "", U), M;
            }
            function F(S) {
              if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
                return false;
              let { local: k, [S.type === "ImportSpecifier" ? "imported" : "exported"]: _ } = S;
              if (k.type !== _.type || !A(k, _))
                return false;
              if (h(k))
                return k.value === _.value && N(k) === N(_);
              switch (k.type) {
                case "Identifier":
                  return k.name === _.name;
                default:
                  return false;
              }
            }
            n.exports = { printImportDeclaration: B, printExportDeclaration: w, printExportAllDeclaration: I, printModuleSpecifier: x };
          } }), zn = Z({ "src/language-js/print/object.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { builders: { line: s, softline: i, group: r, indent: u, ifBreak: a, hardline: c } } = Le(), { getLast: l, hasNewlineInRange: C, hasNewline: m, isNonEmptyArray: g } = Ge(), { shouldPrintComma: p, hasComment: f, getComments: h, CommentCheckFlags: N, isNextLineEmpty: T } = Xe(), { locStart: A, locEnd: b } = nt(), { printOptionalToken: v, printTypeAnnotation: B } = ot(), { shouldHugFunctionParameters: w } = wr(), { shouldHugType: I } = _r(), { printHardlineAfterHeritage: E } = Yt();
            function D(d, y, o) {
              let x = y.semi ? ";" : "", F = d.getValue(), S;
              F.type === "TSTypeLiteral" ? S = "members" : F.type === "TSInterfaceBody" ? S = "body" : S = "properties";
              let k = F.type === "ObjectTypeAnnotation", _ = [S];
              k && _.push("indexers", "callProperties", "internalSlots");
              let O = _.map((V) => F[V][0]).sort((V, oe) => A(V) - A(oe))[0], R = d.getParentNode(0), M = k && R && (R.type === "InterfaceDeclaration" || R.type === "DeclareInterface" || R.type === "DeclareClass") && d.getName() === "body", H = F.type === "TSInterfaceBody" || M || F.type === "ObjectPattern" && R.type !== "FunctionDeclaration" && R.type !== "FunctionExpression" && R.type !== "ArrowFunctionExpression" && R.type !== "ObjectMethod" && R.type !== "ClassMethod" && R.type !== "ClassPrivateMethod" && R.type !== "AssignmentPattern" && R.type !== "CatchClause" && F.properties.some((V) => V.value && (V.value.type === "ObjectPattern" || V.value.type === "ArrayPattern")) || F.type !== "ObjectPattern" && O && C(y.originalText, A(F), A(O)), P = M ? ";" : F.type === "TSInterfaceBody" || F.type === "TSTypeLiteral" ? a(x, ";") : ",", G = F.type === "RecordExpression" ? "#{" : F.exact ? "{|" : "{", re = F.exact ? "|}" : "}", $ = [];
              for (let V of _)
                d.each((oe) => {
                  let K = oe.getValue();
                  $.push({ node: K, printed: o(), loc: A(K) });
                }, V);
              _.length > 1 && $.sort((V, oe) => V.loc - oe.loc);
              let W = [], ee = $.map((V) => {
                let oe = [...W, r(V.printed)];
                return W = [P, s], (V.node.type === "TSPropertySignature" || V.node.type === "TSMethodSignature" || V.node.type === "TSConstructSignatureDeclaration") && f(V.node, N.PrettierIgnore) && W.shift(), T(V.node, y) && W.push(c), oe;
              });
              if (F.inexact) {
                let V;
                if (f(F, N.Dangling)) {
                  let oe = f(F, N.Line);
                  V = [t(d, y, true), oe || m(y.originalText, b(l(h(F)))) ? c : s, "..."];
                } else
                  V = ["..."];
                ee.push([...W, ...V]);
              }
              let U = l(F[S]), ne = !(F.inexact || U && U.type === "RestElement" || U && (U.type === "TSPropertySignature" || U.type === "TSCallSignatureDeclaration" || U.type === "TSMethodSignature" || U.type === "TSConstructSignatureDeclaration") && f(U, N.PrettierIgnore)), se;
              if (ee.length === 0) {
                if (!f(F, N.Dangling))
                  return [G, re, B(d, y, o)];
                se = r([G, t(d, y), i, re, v(d), B(d, y, o)]);
              } else
                se = [M && g(F.properties) ? E(R) : "", G, u([y.bracketSpacing ? s : i, ...ee]), a(ne && (P !== "," || p(y)) ? P : ""), y.bracketSpacing ? s : i, re, v(d), B(d, y, o)];
              return d.match((V) => V.type === "ObjectPattern" && !V.decorators, (V, oe, K) => w(V) && (oe === "params" || oe === "parameters" || oe === "this" || oe === "rest") && K === 0) || d.match(I, (V, oe) => oe === "typeAnnotation", (V, oe) => oe === "typeAnnotation", (V, oe, K) => w(V) && (oe === "params" || oe === "parameters" || oe === "this" || oe === "rest") && K === 0) || !H && d.match((V) => V.type === "ObjectPattern", (V) => V.type === "AssignmentExpression" || V.type === "VariableDeclarator") ? se : r(se, { shouldBreak: H });
            }
            n.exports = { printObject: D };
          } }), wm = Z({ "src/language-js/print/flow.js"(e, n) {
            "use strict";
            ae();
            var t = Ut(), { printDanglingComments: s } = Qe(), { printString: i, printNumber: r } = Ge(), { builders: { hardline: u, softline: a, group: c, indent: l } } = Le(), { getParentExportDeclaration: C, isFunctionNotation: m, isGetterOrSetter: g, rawText: p, shouldPrintComma: f } = Xe(), { locStart: h, locEnd: N } = nt(), { printClass: T } = Yt(), { printOpaqueType: A, printTypeAlias: b, printIntersectionType: v, printUnionType: B, printFunctionType: w, printTupleType: I, printIndexedAccessType: E } = _r(), { printInterface: D } = ao(), { printTypeParameter: d, printTypeParameters: y } = Pr(), { printExportDeclaration: o, printExportAllDeclaration: x } = io(), { printArrayItems: F } = zt(), { printObject: S } = zn(), { printPropertyKey: k } = Kt(), { printOptionalToken: _, printTypeAnnotation: O, printRestSpread: R } = ot();
            function M(P, G, re) {
              let $ = P.getValue(), W = G.semi ? ";" : "", ee = [];
              switch ($.type) {
                case "DeclareClass":
                  return H(P, T(P, G, re));
                case "DeclareFunction":
                  return H(P, ["function ", re("id"), $.predicate ? " " : "", re("predicate"), W]);
                case "DeclareModule":
                  return H(P, ["module ", re("id"), " ", re("body")]);
                case "DeclareModuleExports":
                  return H(P, ["module.exports", ": ", re("typeAnnotation"), W]);
                case "DeclareVariable":
                  return H(P, ["var ", re("id"), W]);
                case "DeclareOpaqueType":
                  return H(P, A(P, G, re));
                case "DeclareInterface":
                  return H(P, D(P, G, re));
                case "DeclareTypeAlias":
                  return H(P, b(P, G, re));
                case "DeclareExportDeclaration":
                  return H(P, o(P, G, re));
                case "DeclareExportAllDeclaration":
                  return H(P, x(P, G, re));
                case "OpaqueType":
                  return A(P, G, re);
                case "TypeAlias":
                  return b(P, G, re);
                case "IntersectionTypeAnnotation":
                  return v(P, G, re);
                case "UnionTypeAnnotation":
                  return B(P, G, re);
                case "FunctionTypeAnnotation":
                  return w(P, G, re);
                case "TupleTypeAnnotation":
                  return I(P, G, re);
                case "GenericTypeAnnotation":
                  return [re("id"), y(P, G, re, "typeParameters")];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                  return E(P, G, re);
                case "TypeAnnotation":
                  return re("typeAnnotation");
                case "TypeParameter":
                  return d(P, G, re);
                case "TypeofTypeAnnotation":
                  return ["typeof ", re("argument")];
                case "ExistsTypeAnnotation":
                  return "*";
                case "EmptyTypeAnnotation":
                  return "empty";
                case "MixedTypeAnnotation":
                  return "mixed";
                case "ArrayTypeAnnotation":
                  return [re("elementType"), "[]"];
                case "BooleanLiteralTypeAnnotation":
                  return String($.value);
                case "EnumDeclaration":
                  return ["enum ", re("id"), " ", re("body")];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if ($.type === "EnumSymbolBody" || $.explicitType) {
                    let U = null;
                    switch ($.type) {
                      case "EnumBooleanBody":
                        U = "boolean";
                        break;
                      case "EnumNumberBody":
                        U = "number";
                        break;
                      case "EnumStringBody":
                        U = "string";
                        break;
                      case "EnumSymbolBody":
                        U = "symbol";
                        break;
                    }
                    ee.push("of ", U, " ");
                  }
                  if ($.members.length === 0 && !$.hasUnknownMembers)
                    ee.push(c(["{", s(P, G), a, "}"]));
                  else {
                    let U = $.members.length > 0 ? [u, F(P, G, "members", re), $.hasUnknownMembers || f(G) ? "," : ""] : [];
                    ee.push(c(["{", l([...U, ...$.hasUnknownMembers ? [u, "..."] : []]), s(P, G, true), u, "}"]));
                  }
                  return ee;
                }
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return [re("id"), " = ", typeof $.init == "object" ? re("init") : String($.init)];
                case "EnumDefaultedMember":
                  return re("id");
                case "FunctionTypeParam": {
                  let U = $.name ? re("name") : P.getParentNode().this === $ ? "this" : "";
                  return [U, _(P), U ? ": " : "", re("typeAnnotation")];
                }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                  return D(P, G, re);
                case "ClassImplements":
                case "InterfaceExtends":
                  return [re("id"), re("typeParameters")];
                case "NullableTypeAnnotation":
                  return ["?", re("typeAnnotation")];
                case "Variance": {
                  let { kind: U } = $;
                  return t.ok(U === "plus" || U === "minus"), U === "plus" ? "+" : "-";
                }
                case "ObjectTypeCallProperty":
                  return $.static && ee.push("static "), ee.push(re("value")), ee;
                case "ObjectTypeIndexer":
                  return [$.static ? "static " : "", $.variance ? re("variance") : "", "[", re("id"), $.id ? ": " : "", re("key"), "]: ", re("value")];
                case "ObjectTypeProperty": {
                  let U = "";
                  return $.proto ? U = "proto " : $.static && (U = "static "), [U, g($) ? $.kind + " " : "", $.variance ? re("variance") : "", k(P, G, re), _(P), m($) ? "" : ": ", re("value")];
                }
                case "ObjectTypeAnnotation":
                  return S(P, G, re);
                case "ObjectTypeInternalSlot":
                  return [$.static ? "static " : "", "[[", re("id"), "]]", _(P), $.method ? "" : ": ", re("value")];
                case "ObjectTypeSpreadProperty":
                  return R(P, G, re);
                case "QualifiedTypeofIdentifier":
                case "QualifiedTypeIdentifier":
                  return [re("qualification"), ".", re("id")];
                case "StringLiteralTypeAnnotation":
                  return i(p($), G);
                case "NumberLiteralTypeAnnotation":
                  t.strictEqual(typeof $.value, "number");
                case "BigIntLiteralTypeAnnotation":
                  return $.extra ? r($.extra.raw) : r($.raw);
                case "TypeCastExpression":
                  return ["(", re("expression"), O(P, G, re), ")"];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation": {
                  let U = y(P, G, re, "params");
                  if (G.parser === "flow") {
                    let ne = h($), se = N($), V = G.originalText.lastIndexOf("/*", ne), oe = G.originalText.indexOf("*/", se);
                    if (V !== -1 && oe !== -1) {
                      let K = G.originalText.slice(V + 2, oe).trim();
                      if (K.startsWith("::") && !K.includes("/*") && !K.includes("*/"))
                        return ["/*:: ", U, " */"];
                    }
                  }
                  return U;
                }
                case "InferredPredicate":
                  return "%checks";
                case "DeclaredPredicate":
                  return ["%checks(", re("value"), ")"];
                case "AnyTypeAnnotation":
                  return "any";
                case "BooleanTypeAnnotation":
                  return "boolean";
                case "BigIntTypeAnnotation":
                  return "bigint";
                case "NullLiteralTypeAnnotation":
                  return "null";
                case "NumberTypeAnnotation":
                  return "number";
                case "SymbolTypeAnnotation":
                  return "symbol";
                case "StringTypeAnnotation":
                  return "string";
                case "VoidTypeAnnotation":
                  return "void";
                case "ThisTypeAnnotation":
                  return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                  throw new Error("unprintable type: " + JSON.stringify($.type));
              }
            }
            function H(P, G) {
              let re = C(P);
              return re ? (t.strictEqual(re.type, "DeclareExportDeclaration"), G) : ["declare ", G];
            }
            n.exports = { printFlow: M };
          } }), _m = Z({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
            "use strict";
            ae();
            function t(s) {
              let { type: i } = s;
              return i.startsWith("TS") && i.endsWith("Keyword");
            }
            n.exports = t;
          } }), oo = Z({ "src/language-js/print/ternary.js"(e, n) {
            "use strict";
            ae();
            var { hasNewlineInRange: t } = Ge(), { isJsxNode: s, getComments: i, isCallExpression: r, isMemberExpression: u } = Xe(), { locStart: a, locEnd: c } = nt(), l = Pt(), { builders: { line: C, softline: m, group: g, indent: p, align: f, ifBreak: h, dedent: N, breakParent: T } } = Le();
            function A(I) {
              let E = [I];
              for (let D = 0; D < E.length; D++) {
                let d = E[D];
                for (let y of ["test", "consequent", "alternate"]) {
                  let o = d[y];
                  if (s(o))
                    return true;
                  o.type === "ConditionalExpression" && E.push(o);
                }
              }
              return false;
            }
            function b(I, E, D) {
              let d = I.getValue(), y = d.type === "ConditionalExpression", o = y ? "alternate" : "falseType", x = I.getParentNode(), F = y ? D("test") : [D("checkType"), " ", "extends", " ", D("extendsType")];
              return x.type === d.type && x[o] === d ? f(2, F) : F;
            }
            var v = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
            function B(I) {
              let E = I.getValue();
              if (E.type !== "ConditionalExpression")
                return false;
              let D, d = E;
              for (let y = 0; !D; y++) {
                let o = I.getParentNode(y);
                if (r(o) && o.callee === d || u(o) && o.object === d || o.type === "TSNonNullExpression" && o.expression === d) {
                  d = o;
                  continue;
                }
                o.type === "NewExpression" && o.callee === d || o.type === "TSAsExpression" && o.expression === d ? (D = I.getParentNode(y + 1), d = o) : D = o;
              }
              return d === E ? false : D[v.get(D.type)] === d;
            }
            function w(I, E, D) {
              let d = I.getValue(), y = d.type === "ConditionalExpression", o = y ? "consequent" : "trueType", x = y ? "alternate" : "falseType", F = y ? ["test"] : ["checkType", "extendsType"], S = d[o], k = d[x], _ = [], O = false, R = I.getParentNode(), M = R.type === d.type && F.some((K) => R[K] === d), H = R.type === d.type && !M, P, G, re = 0;
              do
                G = P || d, P = I.getParentNode(re), re++;
              while (P && P.type === d.type && F.every((K) => P[K] !== G));
              let $ = P || R, W = G;
              if (y && (s(d[F[0]]) || s(S) || s(k) || A(W))) {
                O = true, H = true;
                let K = (q) => [h("("), p([m, q]), m, h(")")], Ee = (q) => q.type === "NullLiteral" || q.type === "Literal" && q.value === null || q.type === "Identifier" && q.name === "undefined";
                _.push(" ? ", Ee(S) ? D(o) : K(D(o)), " : ", k.type === d.type || Ee(k) ? D(x) : K(D(x)));
              } else {
                let K = [C, "? ", S.type === d.type ? h("", "(") : "", f(2, D(o)), S.type === d.type ? h("", ")") : "", C, ": ", k.type === d.type ? D(x) : f(2, D(x))];
                _.push(R.type !== d.type || R[x] === d || M ? K : E.useTabs ? N(p(K)) : f(Math.max(0, E.tabWidth - 2), K));
              }
              let U = [...F.map((K) => i(d[K])), i(S), i(k)].flat().some((K) => l(K) && t(E.originalText, a(K), c(K))), ne = (K) => R === $ ? g(K, { shouldBreak: U }) : U ? [K, T] : K, se = !O && (u(R) || R.type === "NGPipeExpression" && R.left === d) && !R.computed, V = B(I), oe = ne([b(I, E, D), H ? _ : p(_), y && se && !V ? m : ""]);
              return M || V ? g([p([m, oe]), m]) : oe;
            }
            n.exports = { printTernary: w };
          } }), co = Z({ "src/language-js/print/statement.js"(e, n) {
            "use strict";
            ae();
            var { builders: { hardline: t } } = Le(), s = kt(), { getLeftSidePathName: i, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: a, hasComment: c, CommentCheckFlags: l, isNextLineEmpty: C } = Xe(), { shouldPrintParamsWithoutParens: m } = Ir();
            function g(v, B, w, I) {
              let E = v.getValue(), D = [], d = E.type === "ClassBody", y = p(E[I]);
              return v.each((o, x, F) => {
                let S = o.getValue();
                if (S.type === "EmptyStatement")
                  return;
                let k = w();
                !B.semi && !d && !a(B, o) && f(o, B) ? c(S, l.Leading) ? D.push(w([], { needsSemi: true })) : D.push(";", k) : D.push(k), !B.semi && d && A(S) && b(S, F[x + 1]) && D.push(";"), S !== y && (D.push(t), C(S, B) && D.push(t));
              }, I), D;
            }
            function p(v) {
              for (let B = v.length - 1; B >= 0; B--) {
                let w = v[B];
                if (w.type !== "EmptyStatement")
                  return w;
              }
            }
            function f(v, B) {
              return v.getNode().type !== "ExpressionStatement" ? false : v.call((I) => h(I, B), "expression");
            }
            function h(v, B) {
              let w = v.getValue();
              switch (w.type) {
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                case "ArrayExpression":
                case "ArrayPattern":
                case "TemplateLiteral":
                case "TemplateElement":
                case "RegExpLiteral":
                  return true;
                case "ArrowFunctionExpression": {
                  if (!m(v, B))
                    return true;
                  break;
                }
                case "UnaryExpression": {
                  let { prefix: I, operator: E } = w;
                  if (I && (E === "+" || E === "-"))
                    return true;
                  break;
                }
                case "BindExpression": {
                  if (!w.object)
                    return true;
                  break;
                }
                case "Literal": {
                  if (w.regex)
                    return true;
                  break;
                }
                default:
                  if (u(w))
                    return true;
              }
              return s(v, B) ? true : r(w) ? v.call((I) => h(I, B), ...i(v, w)) : false;
            }
            function N(v, B, w) {
              return g(v, B, w, "body");
            }
            function T(v, B, w) {
              return g(v, B, w, "consequent");
            }
            var A = (v) => {
              let { type: B } = v;
              return B === "ClassProperty" || B === "PropertyDefinition" || B === "ClassPrivateProperty" || B === "ClassAccessorProperty";
            };
            function b(v, B) {
              let w = v.key && v.key.name;
              if ((w === "static" || w === "get" || w === "set") && !v.value && !v.typeAnnotation)
                return true;
              if (!B || B.static || B.accessibility)
                return false;
              if (!B.computed) {
                let I = B.key && B.key.name;
                if (I === "in" || I === "instanceof")
                  return true;
              }
              if (A(B) && B.variance && !B.static && !B.declare)
                return true;
              switch (B.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return B.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((B.value ? B.value.async : B.async) || B.kind === "get" || B.kind === "set")
                    return false;
                  let E = B.value ? B.value.generator : B.generator;
                  return !!(B.computed || E);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }
            n.exports = { printBody: N, printSwitchCaseConsequent: T };
          } }), lo = Z({ "src/language-js/print/block.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { isNonEmptyArray: s } = Ge(), { builders: { hardline: i, indent: r } } = Le(), { hasComment: u, CommentCheckFlags: a, isNextLineEmpty: c } = Xe(), { printHardlineAfterHeritage: l } = Yt(), { printBody: C } = co();
            function m(p, f, h) {
              let N = p.getValue(), T = [];
              if (N.type === "StaticBlock" && T.push("static "), N.type === "ClassBody" && s(N.body)) {
                let b = p.getParentNode();
                T.push(l(b));
              }
              T.push("{");
              let A = g(p, f, h);
              if (A)
                T.push(r([i, A]), i);
              else {
                let b = p.getParentNode(), v = p.getParentNode(1);
                b.type === "ArrowFunctionExpression" || b.type === "FunctionExpression" || b.type === "FunctionDeclaration" || b.type === "ObjectMethod" || b.type === "ClassMethod" || b.type === "ClassPrivateMethod" || b.type === "ForStatement" || b.type === "WhileStatement" || b.type === "DoWhileStatement" || b.type === "DoExpression" || b.type === "CatchClause" && !v.finalizer || b.type === "TSModuleDeclaration" || b.type === "TSDeclareFunction" || N.type === "StaticBlock" || N.type === "ClassBody" || T.push(i);
              }
              return T.push("}"), T;
            }
            function g(p, f, h) {
              let N = p.getValue(), T = s(N.directives), A = N.body.some((B) => B.type !== "EmptyStatement"), b = u(N, a.Dangling);
              if (!T && !A && !b)
                return "";
              let v = [];
              if (T && p.each((B, w, I) => {
                v.push(h()), (w < I.length - 1 || A || b) && (v.push(i), c(B.getValue(), f) && v.push(i));
              }, "directives"), A && v.push(C(p, f, h)), b && v.push(t(p, f, true)), N.type === "Program") {
                let B = p.getParentNode();
                (!B || B.type !== "ModuleExpression") && v.push(i);
              }
              return v;
            }
            n.exports = { printBlock: m, printBlockBody: g };
          } }), Pm = Z({ "src/language-js/print/typescript.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { hasNewlineInRange: s } = Ge(), { builders: { join: i, line: r, hardline: u, softline: a, group: c, indent: l, conditionalGroup: C, ifBreak: m } } = Le(), { isLiteral: g, getTypeScriptMappedTypeModifier: p, shouldPrintComma: f, isCallExpression: h, isMemberExpression: N } = Xe(), T = _m(), { locStart: A, locEnd: b } = nt(), { printOptionalToken: v, printTypeScriptModifiers: B } = ot(), { printTernary: w } = oo(), { printFunctionParameters: I, shouldGroupFunctionParameters: E } = wr(), { printTemplateLiteral: D } = It(), { printArrayItems: d } = zt(), { printObject: y } = zn(), { printClassProperty: o, printClassMethod: x } = Yt(), { printTypeParameter: F, printTypeParameters: S } = Pr(), { printPropertyKey: k } = Kt(), { printFunction: _, printMethodInternal: O } = Ir(), { printInterface: R } = ao(), { printBlock: M } = lo(), { printTypeAlias: H, printIntersectionType: P, printUnionType: G, printFunctionType: re, printTupleType: $, printIndexedAccessType: W } = _r();
            function ee(U, ne, se) {
              let V = U.getValue();
              if (!V.type.startsWith("TS"))
                return;
              if (T(V))
                return V.type.slice(2, -7).toLowerCase();
              let oe = ne.semi ? ";" : "", K = [];
              switch (V.type) {
                case "TSThisType":
                  return "this";
                case "TSTypeAssertion": {
                  let Ee = !(V.expression.type === "ArrayExpression" || V.expression.type === "ObjectExpression"), q = c(["<", l([a, se("typeAnnotation")]), a, ">"]), le = [m("("), l([a, se("expression")]), a, m(")")];
                  return Ee ? C([[q, se("expression")], [q, c(le, { shouldBreak: true })], [q, se("expression")]]) : c([q, se("expression")]);
                }
                case "TSDeclareFunction":
                  return _(U, se, ne);
                case "TSExportAssignment":
                  return ["export = ", se("expression"), oe];
                case "TSModuleBlock":
                  return M(U, ne, se);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                  return y(U, ne, se);
                case "TSTypeAliasDeclaration":
                  return H(U, ne, se);
                case "TSQualifiedName":
                  return i(".", [se("left"), se("right")]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                  return x(U, ne, se);
                case "TSAbstractPropertyDefinition":
                  return o(U, ne, se);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                  return K.push(se("expression")), V.typeParameters && K.push(se("typeParameters")), K;
                case "TSTemplateLiteralType":
                  return D(U, se, ne);
                case "TSNamedTupleMember":
                  return [se("label"), V.optional ? "?" : "", ": ", se("elementType")];
                case "TSRestType":
                  return ["...", se("typeAnnotation")];
                case "TSOptionalType":
                  return [se("typeAnnotation"), "?"];
                case "TSInterfaceDeclaration":
                  return R(U, ne, se);
                case "TSClassImplements":
                  return [se("expression"), se("typeParameters")];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return S(U, ne, se, "params");
                case "TSTypeParameter":
                  return F(U, ne, se);
                case "TSAsExpression": {
                  K.push(se("expression"), " as ", se("typeAnnotation"));
                  let Ee = U.getParentNode();
                  return h(Ee) && Ee.callee === V || N(Ee) && Ee.object === V ? c([l([a, ...K]), a]) : K;
                }
                case "TSArrayType":
                  return [se("elementType"), "[]"];
                case "TSPropertySignature":
                  return V.readonly && K.push("readonly "), K.push(k(U, ne, se), v(U)), V.typeAnnotation && K.push(": ", se("typeAnnotation")), V.initializer && K.push(" = ", se("initializer")), K;
                case "TSParameterProperty":
                  return V.accessibility && K.push(V.accessibility + " "), V.export && K.push("export "), V.static && K.push("static "), V.override && K.push("override "), V.readonly && K.push("readonly "), K.push(se("parameter")), K;
                case "TSTypeQuery":
                  return ["typeof ", se("exprName")];
                case "TSIndexSignature": {
                  let Ee = U.getParentNode(), q = V.parameters.length > 1 ? m(f(ne) ? "," : "") : "", le = c([l([a, i([", ", a], U.map(se, "parameters"))]), q, a]);
                  return [V.export ? "export " : "", V.accessibility ? [V.accessibility, " "] : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.declare ? "declare " : "", "[", V.parameters ? le : "", V.typeAnnotation ? "]: " : "]", V.typeAnnotation ? se("typeAnnotation") : "", Ee.type === "ClassBody" ? oe : ""];
                }
                case "TSTypePredicate":
                  return [V.asserts ? "asserts " : "", se("parameterName"), V.typeAnnotation ? [" is ", se("typeAnnotation")] : ""];
                case "TSNonNullExpression":
                  return [se("expression"), "!"];
                case "TSImportType":
                  return [V.isTypeOf ? "typeof " : "", "import(", se(V.parameter ? "parameter" : "argument"), ")", V.qualifier ? [".", se("qualifier")] : "", S(U, ne, se, "typeParameters")];
                case "TSLiteralType":
                  return se("literal");
                case "TSIndexedAccessType":
                  return W(U, ne, se);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType": {
                  if (V.type === "TSConstructorType" && V.abstract && K.push("abstract "), V.type !== "TSCallSignatureDeclaration" && K.push("new "), K.push(c(I(U, se, ne, false, true))), V.returnType || V.typeAnnotation) {
                    let Ee = V.type === "TSConstructorType";
                    K.push(Ee ? " => " : ": ", se("returnType"), se("typeAnnotation"));
                  }
                  return K;
                }
                case "TSTypeOperator":
                  return [V.operator, " ", se("typeAnnotation")];
                case "TSMappedType": {
                  let Ee = s(ne.originalText, A(V), b(V));
                  return c(["{", l([ne.bracketSpacing ? r : a, V.readonly ? [p(V.readonly, "readonly"), " "] : "", B(U, ne, se), se("typeParameter"), V.optional ? p(V.optional, "?") : "", V.typeAnnotation ? ": " : "", se("typeAnnotation"), m(oe)]), t(U, ne, true), ne.bracketSpacing ? r : a, "}"], { shouldBreak: Ee });
                }
                case "TSMethodSignature": {
                  let Ee = V.kind && V.kind !== "method" ? "".concat(V.kind, " ") : "";
                  K.push(V.accessibility ? [V.accessibility, " "] : "", Ee, V.export ? "export " : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.abstract ? "abstract " : "", V.declare ? "declare " : "", V.computed ? "[" : "", se("key"), V.computed ? "]" : "", v(U));
                  let q = I(U, se, ne, false, true), le = V.returnType ? "returnType" : "typeAnnotation", ue = V[le], Q = ue ? se(le) : "", de = E(V, Q);
                  return K.push(de ? c(q) : q), ue && K.push(": ", c(Q)), c(K);
                }
                case "TSNamespaceExportDeclaration":
                  return K.push("export as namespace ", se("id")), ne.semi && K.push(";"), c(K);
                case "TSEnumDeclaration":
                  return V.declare && K.push("declare "), V.modifiers && K.push(B(U, ne, se)), V.const && K.push("const "), K.push("enum ", se("id"), " "), V.members.length === 0 ? K.push(c(["{", t(U, ne), a, "}"])) : K.push(c(["{", l([u, d(U, ne, "members", se), f(ne, "es5") ? "," : ""]), t(U, ne, true), u, "}"])), K;
                case "TSEnumMember":
                  return K.push(se("id")), V.initializer && K.push(" = ", se("initializer")), K;
                case "TSImportEqualsDeclaration":
                  return V.isExport && K.push("export "), K.push("import "), V.importKind && V.importKind !== "value" && K.push(V.importKind, " "), K.push(se("id"), " = ", se("moduleReference")), ne.semi && K.push(";"), c(K);
                case "TSExternalModuleReference":
                  return ["require(", se("expression"), ")"];
                case "TSModuleDeclaration": {
                  let Ee = U.getParentNode(), q = g(V.id), le = Ee.type === "TSModuleDeclaration", ue = V.body && V.body.type === "TSModuleDeclaration";
                  if (le)
                    K.push(".");
                  else {
                    V.declare && K.push("declare "), K.push(B(U, ne, se));
                    let Q = ne.originalText.slice(A(V), A(V.id));
                    V.id.type === "Identifier" && V.id.name === "global" && !/namespace|module/.test(Q) || K.push(q || /(?:^|\s)module(?:\s|$)/.test(Q) ? "module " : "namespace ");
                  }
                  return K.push(se("id")), ue ? K.push(se("body")) : V.body ? K.push(" ", c(se("body"))) : K.push(oe), K;
                }
                case "TSConditionalType":
                  return w(U, ne, se);
                case "TSInferType":
                  return ["infer", " ", se("typeParameter")];
                case "TSIntersectionType":
                  return P(U, ne, se);
                case "TSUnionType":
                  return G(U, ne, se);
                case "TSFunctionType":
                  return re(U, ne, se);
                case "TSTupleType":
                  return $(U, ne, se);
                case "TSTypeReference":
                  return [se("typeName"), S(U, ne, se, "typeParameters")];
                case "TSTypeAnnotation":
                  return se("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                  return O(U, ne, se);
                case "TSJSDocAllType":
                  return "*";
                case "TSJSDocUnknownType":
                  return "?";
                case "TSJSDocNullableType":
                  return ["?", se("typeAnnotation")];
                case "TSJSDocNonNullableType":
                  return ["!", se("typeAnnotation")];
                default:
                  throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(V.type), "."));
              }
            }
            n.exports = { printTypescript: ee };
          } }), Im = Z({ "src/language-js/print/comment.js"(e, n) {
            "use strict";
            ae();
            var { hasNewline: t } = Ge(), { builders: { join: s, hardline: i }, utils: { replaceTextEndOfLine: r } } = Le(), { isLineComment: u } = Xe(), { locStart: a, locEnd: c } = nt(), l = Pt();
            function C(p, f) {
              let h = p.getValue();
              if (u(h))
                return f.originalText.slice(a(h), c(h)).trimEnd();
              if (l(h)) {
                if (m(h)) {
                  let A = g(h);
                  return h.trailing && !t(f.originalText, a(h), { backwards: true }) ? [i, A] : A;
                }
                let N = c(h), T = f.originalText.slice(N - 3, N) === "*-/";
                return ["/*", r(h.value), T ? "*-/" : "*/"];
              }
              throw new Error("Not a comment: " + JSON.stringify(h));
            }
            function m(p) {
              let f = "*".concat(p.value, "*").split(`
`);
              return f.length > 1 && f.every((h) => h.trim()[0] === "*");
            }
            function g(p) {
              let f = p.value.split(`
`);
              return ["/*", s(i, f.map((h, N) => N === 0 ? h.trimEnd() : " " + (N < f.length - 1 ? h.trim() : h.trimStart()))), "*/"];
            }
            n.exports = { printComment: C };
          } }), km = Z({ "src/language-js/print/literal.js"(e, n) {
            "use strict";
            ae();
            var { printString: t, printNumber: s } = Ge();
            function i(a, c) {
              let l = a.getNode();
              switch (l.type) {
                case "RegExpLiteral":
                  return u(l);
                case "BigIntLiteral":
                  return r(l.bigint || l.extra.raw);
                case "NumericLiteral":
                  return s(l.extra.raw);
                case "StringLiteral":
                  return t(l.extra.raw, c);
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return String(l.value);
                case "DecimalLiteral":
                  return s(l.value) + "m";
                case "Literal": {
                  if (l.regex)
                    return u(l.regex);
                  if (l.bigint)
                    return r(l.raw);
                  if (l.decimal)
                    return s(l.decimal) + "m";
                  let { value: C } = l;
                  return typeof C == "number" ? s(l.raw) : typeof C == "string" ? t(l.raw, c) : String(C);
                }
              }
            }
            function r(a) {
              return a.toLowerCase();
            }
            function u(a) {
              let { pattern: c, flags: l } = a;
              return l = [...l].sort().join(""), "/".concat(c, "/").concat(l);
            }
            n.exports = { printLiteral: i };
          } }), Lm = Z({ "src/language-js/printer-estree.js"(e, n) {
            "use strict";
            ae();
            var { printDanglingComments: t } = Qe(), { hasNewline: s } = Ge(), { builders: { join: i, line: r, hardline: u, softline: a, group: c, indent: l }, utils: { replaceTextEndOfLine: C } } = Le(), m = ym(), g = hm(), { insertPragma: p } = eo(), f = to(), h = kt(), N = ro(), { hasFlowShorthandAnnotationComment: T, hasComment: A, CommentCheckFlags: b, isTheOnlyJsxElementInMarkdown: v, isLineComment: B, isNextLineEmpty: w, needsHardlineAfterDanglingComment: I, rawText: E, hasIgnoreComment: D, isCallExpression: d, isMemberExpression: y, markerForIfWithoutBlockAndSameLineComment: o } = Xe(), { locStart: x, locEnd: F } = nt(), S = Pt(), { printHtmlBinding: k, isVueEventBindingExpression: _ } = bm(), { printAngular: O } = Tm(), { printJsx: R, hasJsxIgnoreComment: M } = Bm(), { printFlow: H } = wm(), { printTypescript: P } = Pm(), { printOptionalToken: G, printBindExpressionCallee: re, printTypeAnnotation: $, adjustClause: W, printRestSpread: ee, printDefiniteToken: U } = ot(), { printImportDeclaration: ne, printExportDeclaration: se, printExportAllDeclaration: V, printModuleSpecifier: oe } = io(), { printTernary: K } = oo(), { printTemplateLiteral: Ee } = It(), { printArray: q } = zt(), { printObject: le } = zn(), { printClass: ue, printClassMethod: Q, printClassProperty: de } = Yt(), { printProperty: ge } = Kt(), { printFunction: ve, printArrowFunction: xe, printMethod: we, printReturnStatement: fe, printThrowStatement: pe } = Ir(), { printCallExpression: me } = so(), { printVariableDeclarator: ce, printAssignmentExpression: he } = Xt(), { printBinaryishExpression: J } = Jn(), { printSwitchCaseConsequent: ye } = co(), { printMemberExpression: X } = uo(), { printBlock: Y, printBlockBody: te } = lo(), { printComment: z } = Im(), { printLiteral: j } = km(), { printDecorators: Ce } = Un();
            function Ne(Te, _e, Fe, Ke) {
              let Se = je(Te, _e, Fe, Ke);
              if (!Se)
                return "";
              let ze = Te.getValue(), { type: Be } = ze;
              if (Be === "ClassMethod" || Be === "ClassPrivateMethod" || Be === "ClassProperty" || Be === "ClassAccessorProperty" || Be === "PropertyDefinition" || Be === "TSAbstractPropertyDefinition" || Be === "ClassPrivateProperty" || Be === "MethodDefinition" || Be === "TSAbstractMethodDefinition" || Be === "TSDeclareMethod")
                return Se;
              let Ie = [Se], Ve = Ce(Te, _e, Fe), Ae = ze.type === "ClassExpression" && Ve;
              if (Ve && (Ie = [...Ve, Se], !Ae))
                return c(Ie);
              if (!h(Te, _e))
                return Ke && Ke.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === Se ? Se : Ie;
              if (Ae && (Ie = [l([r, ...Ie])]), Ie.unshift("("), Ke && Ke.needsSemi && Ie.unshift(";"), T(ze)) {
                let [Pe] = ze.trailingComments;
                Ie.push(" /*", Pe.value.trimStart(), "*/"), Pe.printed = true;
              }
              return Ae && Ie.push(r), Ie.push(")"), Ie;
            }
            function je(Te, _e, Fe, Ke) {
              let Se = Te.getValue(), ze = _e.semi ? ";" : "";
              if (!Se)
                return "";
              if (typeof Se == "string")
                return Se;
              for (let Ie of [j, k, O, R, H, P]) {
                let Ve = Ie(Te, _e, Fe);
                if (typeof Ve < "u")
                  return Ve;
              }
              let Be = [];
              switch (Se.type) {
                case "JsExpressionRoot":
                  return Fe("node");
                case "JsonRoot":
                  return [Fe("node"), u];
                case "File":
                  return Se.program && Se.program.interpreter && Be.push(Fe(["program", "interpreter"])), Be.push(Fe("program")), Be;
                case "Program":
                  return te(Te, _e, Fe);
                case "EmptyStatement":
                  return "";
                case "ExpressionStatement": {
                  if (Se.directive)
                    return [Ue(Se.expression, _e), ze];
                  if (_e.parser === "__vue_event_binding") {
                    let Ve = Te.getParentNode();
                    if (Ve.type === "Program" && Ve.body.length === 1 && Ve.body[0] === Se)
                      return [Fe("expression"), _(Se.expression) ? ";" : ""];
                  }
                  let Ie = t(Te, _e, true, (Ve) => {
                    let { marker: Ae } = Ve;
                    return Ae === o;
                  });
                  return [Fe("expression"), v(_e, Te) ? "" : ze, Ie ? [" ", Ie] : ""];
                }
                case "ParenthesizedExpression":
                  return !A(Se.expression) && (Se.expression.type === "ObjectExpression" || Se.expression.type === "ArrayExpression") ? ["(", Fe("expression"), ")"] : c(["(", l([a, Fe("expression")]), a, ")"]);
                case "AssignmentExpression":
                  return he(Te, _e, Fe);
                case "VariableDeclarator":
                  return ce(Te, _e, Fe);
                case "BinaryExpression":
                case "LogicalExpression":
                  return J(Te, _e, Fe);
                case "AssignmentPattern":
                  return [Fe("left"), " = ", Fe("right")];
                case "OptionalMemberExpression":
                case "MemberExpression":
                  return X(Te, _e, Fe);
                case "MetaProperty":
                  return [Fe("meta"), ".", Fe("property")];
                case "BindExpression":
                  return Se.object && Be.push(Fe("object")), Be.push(c(l([a, re(Te, _e, Fe)]))), Be;
                case "Identifier":
                  return [Se.name, G(Te), U(Te), $(Te, _e, Fe)];
                case "V8IntrinsicIdentifier":
                  return ["%", Se.name];
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                  return ee(Te, _e, Fe);
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return ve(Te, Fe, _e, Ke);
                case "ArrowFunctionExpression":
                  return xe(Te, _e, Fe, Ke);
                case "YieldExpression":
                  return Be.push("yield"), Se.delegate && Be.push("*"), Se.argument && Be.push(" ", Fe("argument")), Be;
                case "AwaitExpression": {
                  if (Be.push("await"), Se.argument) {
                    Be.push(" ", Fe("argument"));
                    let Ie = Te.getParentNode();
                    if (d(Ie) && Ie.callee === Se || y(Ie) && Ie.object === Se) {
                      Be = [l([a, ...Be]), a];
                      let Ve = Te.findAncestor((Ae) => Ae.type === "AwaitExpression" || Ae.type === "BlockStatement");
                      if (!Ve || Ve.type !== "AwaitExpression")
                        return c(Be);
                    }
                  }
                  return Be;
                }
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return se(Te, _e, Fe);
                case "ExportAllDeclaration":
                  return V(Te, _e, Fe);
                case "ImportDeclaration":
                  return ne(Te, _e, Fe);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                  return oe(Te, _e, Fe);
                case "ImportAttribute":
                  return [Fe("key"), ": ", Fe("value")];
                case "Import":
                  return "import";
                case "BlockStatement":
                case "StaticBlock":
                case "ClassBody":
                  return Y(Te, _e, Fe);
                case "ThrowStatement":
                  return pe(Te, _e, Fe);
                case "ReturnStatement":
                  return fe(Te, _e, Fe);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                  return me(Te, _e, Fe);
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  return le(Te, _e, Fe);
                case "ObjectProperty":
                case "Property":
                  return Se.method || Se.kind === "get" || Se.kind === "set" ? we(Te, _e, Fe) : ge(Te, _e, Fe);
                case "ObjectMethod":
                  return we(Te, _e, Fe);
                case "Decorator":
                  return ["@", Fe("expression")];
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  return q(Te, _e, Fe);
                case "SequenceExpression": {
                  let Ie = Te.getParentNode(0);
                  if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                    let Ve = [];
                    return Te.each((Ae, Oe) => {
                      Oe === 0 ? Ve.push(Fe()) : Ve.push(",", l([r, Fe()]));
                    }, "expressions"), c(Ve);
                  }
                  return c(i([",", r], Te.map(Fe, "expressions")));
                }
                case "ThisExpression":
                  return "this";
                case "Super":
                  return "super";
                case "Directive":
                  return [Fe("value"), ze];
                case "DirectiveLiteral":
                  return Ue(Se, _e);
                case "UnaryExpression":
                  return Be.push(Se.operator), /[a-z]$/.test(Se.operator) && Be.push(" "), A(Se.argument) ? Be.push(c(["(", l([a, Fe("argument")]), a, ")"])) : Be.push(Fe("argument")), Be;
                case "UpdateExpression":
                  return Be.push(Fe("argument"), Se.operator), Se.prefix && Be.reverse(), Be;
                case "ConditionalExpression":
                  return K(Te, _e, Fe);
                case "VariableDeclaration": {
                  let Ie = Te.map(Fe, "declarations"), Ve = Te.getParentNode(), Ae = Ve.type === "ForStatement" || Ve.type === "ForInStatement" || Ve.type === "ForOfStatement", Oe = Se.declarations.some((ie) => ie.init), Pe;
                  return Ie.length === 1 && !A(Se.declarations[0]) ? Pe = Ie[0] : Ie.length > 0 && (Pe = l(Ie[0])), Be = [Se.declare ? "declare " : "", Se.kind, Pe ? [" ", Pe] : "", l(Ie.slice(1).map((ie) => [",", Oe && !Ae ? u : r, ie]))], Ae && Ve.body !== Se || Be.push(ze), c(Be);
                }
                case "WithStatement":
                  return c(["with (", Fe("object"), ")", W(Se.body, Fe("body"))]);
                case "IfStatement": {
                  let Ie = W(Se.consequent, Fe("consequent")), Ve = c(["if (", c([l([a, Fe("test")]), a]), ")", Ie]);
                  if (Be.push(Ve), Se.alternate) {
                    let Ae = A(Se.consequent, b.Trailing | b.Line) || I(Se), Oe = Se.consequent.type === "BlockStatement" && !Ae;
                    Be.push(Oe ? " " : u), A(Se, b.Dangling) && Be.push(t(Te, _e, true), Ae ? u : " "), Be.push("else", c(W(Se.alternate, Fe("alternate"), Se.alternate.type === "IfStatement")));
                  }
                  return Be;
                }
                case "ForStatement": {
                  let Ie = W(Se.body, Fe("body")), Ve = t(Te, _e, true), Ae = Ve ? [Ve, a] : "";
                  return !Se.init && !Se.test && !Se.update ? [Ae, c(["for (;;)", Ie])] : [Ae, c(["for (", c([l([a, Fe("init"), ";", r, Fe("test"), ";", r, Fe("update")]), a]), ")", Ie])];
                }
                case "WhileStatement":
                  return c(["while (", c([l([a, Fe("test")]), a]), ")", W(Se.body, Fe("body"))]);
                case "ForInStatement":
                  return c(["for (", Fe("left"), " in ", Fe("right"), ")", W(Se.body, Fe("body"))]);
                case "ForOfStatement":
                  return c(["for", Se.await ? " await" : "", " (", Fe("left"), " of ", Fe("right"), ")", W(Se.body, Fe("body"))]);
                case "DoWhileStatement": {
                  let Ie = W(Se.body, Fe("body"));
                  return Be = [c(["do", Ie])], Se.body.type === "BlockStatement" ? Be.push(" ") : Be.push(u), Be.push("while (", c([l([a, Fe("test")]), a]), ")", ze), Be;
                }
                case "DoExpression":
                  return [Se.async ? "async " : "", "do ", Fe("body")];
                case "BreakStatement":
                  return Be.push("break"), Se.label && Be.push(" ", Fe("label")), Be.push(ze), Be;
                case "ContinueStatement":
                  return Be.push("continue"), Se.label && Be.push(" ", Fe("label")), Be.push(ze), Be;
                case "LabeledStatement":
                  return Se.body.type === "EmptyStatement" ? [Fe("label"), ":;"] : [Fe("label"), ": ", Fe("body")];
                case "TryStatement":
                  return ["try ", Fe("block"), Se.handler ? [" ", Fe("handler")] : "", Se.finalizer ? [" finally ", Fe("finalizer")] : ""];
                case "CatchClause":
                  if (Se.param) {
                    let Ie = A(Se.param, (Ae) => !S(Ae) || Ae.leading && s(_e.originalText, F(Ae)) || Ae.trailing && s(_e.originalText, x(Ae), { backwards: true })), Ve = Fe("param");
                    return ["catch ", Ie ? ["(", l([a, Ve]), a, ") "] : ["(", Ve, ") "], Fe("body")];
                  }
                  return ["catch ", Fe("body")];
                case "SwitchStatement":
                  return [c(["switch (", l([a, Fe("discriminant")]), a, ")"]), " {", Se.cases.length > 0 ? l([u, i(u, Te.map((Ie, Ve, Ae) => {
                    let Oe = Ie.getValue();
                    return [Fe(), Ve !== Ae.length - 1 && w(Oe, _e) ? u : ""];
                  }, "cases"))]) : "", u, "}"];
                case "SwitchCase": {
                  Se.test ? Be.push("case ", Fe("test"), ":") : Be.push("default:"), A(Se, b.Dangling) && Be.push(" ", t(Te, _e, true));
                  let Ie = Se.consequent.filter((Ve) => Ve.type !== "EmptyStatement");
                  if (Ie.length > 0) {
                    let Ve = ye(Te, _e, Fe);
                    Be.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Ve] : l([u, Ve]));
                  }
                  return Be;
                }
                case "DebuggerStatement":
                  return ["debugger", ze];
                case "ClassDeclaration":
                case "ClassExpression":
                  return ue(Te, _e, Fe);
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                  return Q(Te, _e, Fe);
                case "ClassProperty":
                case "PropertyDefinition":
                case "ClassPrivateProperty":
                case "ClassAccessorProperty":
                  return de(Te, _e, Fe);
                case "TemplateElement":
                  return C(Se.value.raw);
                case "TemplateLiteral":
                  return Ee(Te, Fe, _e);
                case "TaggedTemplateExpression":
                  return [Fe("tag"), Fe("typeParameters"), Fe("quasi")];
                case "PrivateIdentifier":
                  return ["#", Fe("name")];
                case "PrivateName":
                  return ["#", Fe("id")];
                case "InterpreterDirective":
                  return Be.push("#!", Se.value, u), w(Se, _e) && Be.push(u), Be;
                case "TopicReference":
                  return "%";
                case "ArgumentPlaceholder":
                  return "?";
                case "ModuleExpression": {
                  Be.push("module {");
                  let Ie = Fe("body");
                  return Ie && Be.push(l([u, Ie]), u), Be.push("}"), Be;
                }
                default:
                  throw new Error("unknown type: " + JSON.stringify(Se.type));
              }
            }
            function Ue(Te, _e) {
              let Fe = E(Te), Ke = Fe.slice(1, -1);
              if (Ke.includes('"') || Ke.includes("'"))
                return Fe;
              let Se = _e.singleQuote ? "'" : '"';
              return Se + Ke + Se;
            }
            function tt(Te) {
              return Te.type && !S(Te) && !B(Te) && Te.type !== "EmptyStatement" && Te.type !== "TemplateElement" && Te.type !== "Import" && Te.type !== "TSEmptyBodyFunctionExpression";
            }
            n.exports = { preprocess: N, print: Ne, embed: m, insertPragma: p, massageAstNode: g, hasPrettierIgnore(Te) {
              return D(Te) || M(Te);
            }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: tt, printComment: z, isBlockComment: S, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
          } }), Om = Z({ "src/language-js/printer-estree-json.js"(e, n) {
            "use strict";
            ae();
            var { builders: { hardline: t, indent: s, join: i } } = Le(), r = ro();
            function u(l, C, m) {
              let g = l.getValue();
              switch (g.type) {
                case "JsonRoot":
                  return [m("node"), t];
                case "ArrayExpression": {
                  if (g.elements.length === 0)
                    return "[]";
                  let p = l.map(() => l.getValue() === null ? "null" : m(), "elements");
                  return ["[", s([t, i([",", t], p)]), t, "]"];
                }
                case "ObjectExpression":
                  return g.properties.length === 0 ? "{}" : ["{", s([t, i([",", t], l.map(m, "properties"))]), t, "}"];
                case "ObjectProperty":
                  return [m("key"), ": ", m("value")];
                case "UnaryExpression":
                  return [g.operator === "+" ? "" : g.operator, m("argument")];
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return g.value ? "true" : "false";
                case "StringLiteral":
                case "NumericLiteral":
                  return JSON.stringify(g.value);
                case "Identifier": {
                  let p = l.getParentNode();
                  return p && p.type === "ObjectProperty" && p.key === g ? JSON.stringify(g.name) : g.name;
                }
                case "TemplateLiteral":
                  return m(["quasis", 0]);
                case "TemplateElement":
                  return JSON.stringify(g.value.cooked);
                default:
                  throw new Error("unknown type: " + JSON.stringify(g.type));
              }
            }
            var a = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
            function c(l, C) {
              let { type: m } = l;
              if (m === "ObjectProperty" && l.key.type === "Identifier") {
                C.key = { type: "StringLiteral", value: l.key.name };
                return;
              }
              if (m === "UnaryExpression" && l.operator === "+")
                return C.argument;
              if (m === "ArrayExpression") {
                for (let [g, p] of l.elements.entries())
                  p === null && C.elements.splice(g, 0, { type: "NullLiteral" });
                return;
              }
              if (m === "TemplateLiteral")
                return { type: "StringLiteral", value: l.quasis[0].value.cooked };
            }
            c.ignoredProperties = a, n.exports = { preprocess: r, print: u, massageAstNode: c };
          } }), Lt = Z({ "src/common/common-options.js"(e, n) {
            "use strict";
            ae();
            var t = "Common";
            n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
          } }), jm = Z({ "src/language-js/options.js"(e, n) {
            "use strict";
            ae();
            var t = Lt(), s = "JavaScript";
            n.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
          } }), qm = Z({ "src/language-js/parse/parsers.js"() {
            ae();
          } }), Fn = Z({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
            n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
          } }), Mm = Z({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
            n.exports = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
          } }), Rm = Z({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
            n.exports = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
          } }), mi = Z({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
            n.exports = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
          } }), Vm = Z({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
            n.exports = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
          } }), Wm = Z({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
            n.exports = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
          } }), $m = Z({ "src/language-js/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = Lm(), i = Om(), r = jm(), u = qm(), a = [t(Fn(), (l) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...l.interpreters, "zx"], extensions: [...l.extensions.filter((C) => C !== ".jsx"), ".wxs"] })), t(Fn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Fn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Mm(), (l) => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"], extensions: [...l.extensions, ".mts", ".cts"] })), t(Rm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(mi(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(mi(), (l) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: l.extensions.filter((C) => C !== ".jsonl") })), t(Vm(), (l) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...l.filenames, ".eslintrc", ".swcrc"] })), t(Wm(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], c = { estree: s, "estree-json": i };
            n.exports = { languages: a, options: r, printers: c, parsers: u };
          } }), Hm = Z({ "src/language-css/clean.js"(e, n) {
            "use strict";
            ae();
            var { isFrontMatterNode: t } = Ge(), s = st(), i = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
            function r(a, c, l) {
              if (t(a) && a.lang === "yaml" && delete c.value, a.type === "css-comment" && l.type === "css-root" && l.nodes.length > 0 && ((l.nodes[0] === a || t(l.nodes[0]) && l.nodes[1] === a) && (delete c.text, /^\*\s*@(?:format|prettier)\s*$/.test(a.text)) || l.type === "css-root" && s(l.nodes) === a))
                return null;
              if (a.type === "value-root" && delete c.text, (a.type === "media-query" || a.type === "media-query-list" || a.type === "media-feature-expression") && delete c.value, a.type === "css-rule" && delete c.params, a.type === "selector-combinator" && (c.value = c.value.replace(/\s+/g, " ")), a.type === "media-feature" && (c.value = c.value.replace(/ /g, "")), (a.type === "value-word" && (a.isColor && a.isHex || ["initial", "inherit", "unset", "revert"].includes(c.value.replace().toLowerCase())) || a.type === "media-feature" || a.type === "selector-root-invalid" || a.type === "selector-pseudo") && (c.value = c.value.toLowerCase()), a.type === "css-decl" && (c.prop = c.prop.toLowerCase()), (a.type === "css-atrule" || a.type === "css-import") && (c.name = c.name.toLowerCase()), a.type === "value-number" && (c.unit = c.unit.toLowerCase()), (a.type === "media-feature" || a.type === "media-keyword" || a.type === "media-type" || a.type === "media-unknown" || a.type === "media-url" || a.type === "media-value" || a.type === "selector-attribute" || a.type === "selector-string" || a.type === "selector-class" || a.type === "selector-combinator" || a.type === "value-string") && c.value && (c.value = u(c.value)), a.type === "selector-attribute" && (c.attribute = c.attribute.trim(), c.namespace && typeof c.namespace == "string" && (c.namespace = c.namespace.trim(), c.namespace.length === 0 && (c.namespace = true)), c.value && (c.value = c.value.trim().replace(/^["']|["']$/g, ""), delete c.quoted)), (a.type === "media-value" || a.type === "media-type" || a.type === "value-number" || a.type === "selector-root-invalid" || a.type === "selector-class" || a.type === "selector-combinator" || a.type === "selector-tag") && c.value && (c.value = c.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (C, m, g) => {
                let p = Number(m);
                return Number.isNaN(p) ? C : p + g.toLowerCase();
              })), a.type === "selector-tag") {
                let C = a.value.toLowerCase();
                ["from", "to"].includes(C) && (c.value = C);
              }
              if (a.type === "css-atrule" && a.name.toLowerCase() === "supports" && delete c.value, a.type === "selector-unknown" && delete c.value, a.type === "value-comma_group") {
                let C = a.groups.findIndex((m) => m.type === "value-number" && m.unit === "...");
                C !== -1 && (c.groups[C].unit = "", c.groups.splice(C + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
              }
            }
            r.ignoredProperties = i;
            function u(a) {
              return a.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
            }
            n.exports = r;
          } }), Xn = Z({ "src/utils/front-matter/print.js"(e, n) {
            "use strict";
            ae();
            var { builders: { hardline: t, markAsRoot: s } } = Le();
            function i(r, u) {
              if (r.lang === "yaml") {
                let a = r.value.trim(), c = a ? u(a, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
                return s([r.startDelimiter, t, c, c ? t : "", r.endDelimiter]);
              }
            }
            n.exports = i;
          } }), Gm = Z({ "src/language-css/embed.js"(e, n) {
            "use strict";
            ae();
            var { builders: { hardline: t } } = Le(), s = Xn();
            function i(r, u, a) {
              let c = r.getValue();
              if (c.type === "front-matter") {
                let l = s(c, a);
                return l ? [l, t] : "";
              }
            }
            n.exports = i;
          } }), po = Z({ "src/utils/front-matter/parse.js"(e, n) {
            "use strict";
            ae();
            var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(i) {
              let r = i.match(t);
              if (!r)
                return { content: i };
              let { startDelimiter: u, language: a, value: c = "", endDelimiter: l } = r.groups, C = a.trim() || "yaml";
              if (u === "+++" && (C = "toml"), C !== "yaml" && u !== l)
                return { content: i };
              let [m] = r;
              return { frontMatter: { type: "front-matter", lang: C, value: c, startDelimiter: u, endDelimiter: l, raw: m.replace(/\n$/, "") }, content: m.replace(/[^\n]/g, " ") + i.slice(m.length) };
            }
            n.exports = s;
          } }), Jm = Z({ "src/language-css/pragma.js"(e, n) {
            "use strict";
            ae();
            var t = eo(), s = po();
            function i(u) {
              return t.hasPragma(s(u).content);
            }
            function r(u) {
              let { frontMatter: a, content: c } = s(u);
              return (a ? a.raw + `

` : "") + t.insertPragma(c);
            }
            n.exports = { hasPragma: i, insertPragma: r };
          } }), Um = Z({ "src/language-css/utils/index.js"(e, n) {
            "use strict";
            ae();
            var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
            function s(q, le) {
              let ue = Array.isArray(le) ? le : [le], Q = -1, de;
              for (; de = q.getParentNode(++Q); )
                if (ue.includes(de.type))
                  return Q;
              return -1;
            }
            function i(q, le) {
              let ue = s(q, le);
              return ue === -1 ? null : q.getParentNode(ue);
            }
            function r(q) {
              let le = i(q, "css-decl");
              return le && le.prop && le.prop.toLowerCase();
            }
            function u(q) {
              return ["initial", "inherit", "unset", "revert"].includes(q.toLowerCase());
            }
            function a(q, le) {
              let ue = i(q, "css-atrule");
              return ue && ue.name && ue.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(le.toLowerCase());
            }
            function c(q) {
              return q.includes("$") || q.includes("@") || q.includes("#") || q.startsWith("%") || q.startsWith("--") || q.startsWith(":--") || q.includes("(") && q.includes(")") ? q : q.toLowerCase();
            }
            function l(q, le) {
              let ue = i(q, "value-func");
              return ue && ue.value && ue.value.toLowerCase() === le;
            }
            function C(q) {
              let le = i(q, "css-rule");
              return le && le.raws && le.raws.selector && (le.raws.selector.startsWith(":import") || le.raws.selector.startsWith(":export"));
            }
            function m(q, le) {
              let ue = Array.isArray(le) ? le : [le], Q = i(q, "css-atrule");
              return Q && ue.includes(Q.name.toLowerCase());
            }
            function g(q) {
              let le = q.getValue(), ue = i(q, "css-atrule");
              return ue && ue.name === "import" && le.groups[0].value === "url" && le.groups.length === 2;
            }
            function p(q) {
              return q.type === "value-func" && q.value.toLowerCase() === "url";
            }
            function f(q, le) {
              let ue = q.getParentNode();
              if (!ue)
                return false;
              let { nodes: Q } = ue;
              return Q && Q.indexOf(le) === Q.length - 1;
            }
            function h(q) {
              return q.selector ? typeof q.selector == "string" && /^@.+:.*$/.test(q.selector) || q.selector.value && /^@.+:.*$/.test(q.selector.value) : false;
            }
            function N(q) {
              return q.type === "value-word" && ["from", "through", "end"].includes(q.value);
            }
            function T(q) {
              return q.type === "value-word" && ["and", "or", "not"].includes(q.value);
            }
            function A(q) {
              return q.type === "value-word" && q.value === "in";
            }
            function b(q) {
              return q.type === "value-operator" && q.value === "*";
            }
            function v(q) {
              return q.type === "value-operator" && q.value === "/";
            }
            function B(q) {
              return q.type === "value-operator" && q.value === "+";
            }
            function w(q) {
              return q.type === "value-operator" && q.value === "-";
            }
            function I(q) {
              return q.type === "value-operator" && q.value === "%";
            }
            function E(q) {
              return b(q) || v(q) || B(q) || w(q) || I(q);
            }
            function D(q) {
              return q.type === "value-word" && ["==", "!="].includes(q.value);
            }
            function d(q) {
              return q.type === "value-word" && ["<", ">", "<=", ">="].includes(q.value);
            }
            function y(q) {
              return q.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(q.name);
            }
            function o(q) {
              return q.raws && q.raws.params && /^\(\s*\)$/.test(q.raws.params);
            }
            function x(q) {
              return q.name.startsWith("prettier-placeholder");
            }
            function F(q) {
              return q.prop.startsWith("@prettier-placeholder");
            }
            function S(q, le) {
              return q.value === "$$" && q.type === "value-func" && le && le.type === "value-word" && !le.raws.before;
            }
            function k(q) {
              return q.value && q.value.type === "value-root" && q.value.group && q.value.group.type === "value-value" && q.prop.toLowerCase() === "composes";
            }
            function _(q) {
              return q.value && q.value.group && q.value.group.group && q.value.group.group.type === "value-paren_group" && q.value.group.group.open !== null && q.value.group.group.close !== null;
            }
            function O(q) {
              return q.raws && q.raws.before === "";
            }
            function R(q) {
              return q.type === "value-comma_group" && q.groups && q.groups[1] && q.groups[1].type === "value-colon";
            }
            function M(q) {
              return q.type === "value-paren_group" && q.groups && q.groups[0] && R(q.groups[0]);
            }
            function H(q) {
              let le = q.getValue();
              if (le.groups.length === 0)
                return false;
              let ue = q.getParentNode(1);
              if (!M(le) && !(ue && M(ue)))
                return false;
              let Q = i(q, "css-decl");
              return !!(Q && Q.prop && Q.prop.startsWith("$") || M(ue) || ue.type === "value-func");
            }
            function P(q) {
              return q.type === "value-comment" && q.inline;
            }
            function G(q) {
              return q.type === "value-word" && q.value === "#";
            }
            function re(q) {
              return q.type === "value-word" && q.value === "{";
            }
            function $(q) {
              return q.type === "value-word" && q.value === "}";
            }
            function W(q) {
              return ["value-word", "value-atword"].includes(q.type);
            }
            function ee(q) {
              return q && q.type === "value-colon";
            }
            function U(q, le) {
              if (!R(le))
                return false;
              let { groups: ue } = le, Q = ue.indexOf(q);
              return Q === -1 ? false : ee(ue[Q + 1]);
            }
            function ne(q) {
              return q.value && ["not", "and", "or"].includes(q.value.toLowerCase());
            }
            function se(q) {
              return q.type !== "value-func" ? false : t.has(q.value.toLowerCase());
            }
            function V(q) {
              return /\/\//.test(q.split(/[\n\r]/).pop());
            }
            function oe(q) {
              return q && q.type === "value-atword" && q.value.startsWith("prettier-placeholder-");
            }
            function K(q, le) {
              if (!q.open || q.open.value !== "(" || !q.close || q.close.value !== ")" || q.groups.some((ue) => ue.type !== "value-comma_group"))
                return false;
              if (le.type === "value-comma_group") {
                let ue = le.groups.indexOf(q) - 1, Q = le.groups[ue];
                if (Q && Q.type === "value-word" && Q.value === "with")
                  return true;
              }
              return false;
            }
            function Ee(q) {
              return q.type === "value-paren_group" && q.open && q.open.value === "(" && q.close && q.close.value === ")";
            }
            n.exports = { getAncestorCounter: s, getAncestorNode: i, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: l, insideICSSRuleNode: C, insideAtRuleNode: m, insideURLFunctionInImportAtRuleNode: g, isKeyframeAtRuleKeywords: a, isWideKeywords: u, isLastNode: f, isSCSSControlDirectiveNode: y, isDetachedRulesetDeclarationNode: h, isRelationalOperatorNode: d, isEqualityOperatorNode: D, isMultiplicationNode: b, isDivisionNode: v, isAdditionNode: B, isSubtractionNode: w, isModuloNode: I, isMathOperatorNode: E, isEachKeywordNode: A, isForKeywordNode: N, isURLFunctionNode: p, isIfElseKeywordNode: T, hasComposesNode: k, hasParensAroundNode: _, hasEmptyRawBefore: O, isDetachedRulesetCallNode: o, isTemplatePlaceholderNode: x, isTemplatePropNode: F, isPostcssSimpleVarNode: S, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: M, isKeyInValuePairNode: U, isSCSSMapItemNode: H, isInlineValueCommentNode: P, isHashNode: G, isLeftCurlyBraceNode: re, isRightCurlyBraceNode: $, isWordNode: W, isColonNode: ee, isMediaAndSupportsKeywords: ne, isColorAdjusterFuncNode: se, lastLineHasInlineComment: V, isAtWordPlaceholderNode: oe, isConfigurationNode: K, isParenGroupNode: Ee };
          } }), zm = Z({ "src/utils/line-column-to-index.js"(e, n) {
            "use strict";
            ae(), n.exports = function(t, s) {
              let i = 0;
              for (let r = 0; r < t.line - 1; ++r)
                i = s.indexOf(`
`, i) + 1;
              return i + t.column;
            };
          } }), Xm = Z({ "src/language-css/loc.js"(e, n) {
            "use strict";
            ae();
            var { skipEverythingButNewLine: t } = Tr(), s = st(), i = zm();
            function r(p, f) {
              return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? i(p.source.start, f) - 1 : null;
            }
            function u(p, f) {
              if (p.type === "css-comment" && p.inline)
                return t(f, p.source.startOffset);
              let h = p.nodes && s(p.nodes);
              return h && p.source && !p.source.end && (p = h), p.source && p.source.end ? i(p.source.end, f) : null;
            }
            function a(p, f) {
              p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));
              for (let h in p) {
                let N = p[h];
                h === "source" || !N || typeof N != "object" || (N.type === "value-root" || N.type === "value-unknown" ? c(N, l(p), N.text || N.value) : a(N, f));
              }
            }
            function c(p, f, h) {
              p.source && (p.source.startOffset = r(p, h) + f, p.source.endOffset = u(p, h) + f);
              for (let N in p) {
                let T = p[N];
                N === "source" || !T || typeof T != "object" || c(T, f, h);
              }
            }
            function l(p) {
              let f = p.source.startOffset;
              return typeof p.prop == "string" && (f += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (f += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (f += p.raws.between.length), f;
            }
            function C(p) {
              let f = "initial", h = "initial", N, T = false, A = [];
              for (let b = 0; b < p.length; b++) {
                let v = p[b];
                switch (f) {
                  case "initial":
                    if (v === "'") {
                      f = "single-quotes";
                      continue;
                    }
                    if (v === '"') {
                      f = "double-quotes";
                      continue;
                    }
                    if ((v === "u" || v === "U") && p.slice(b, b + 4).toLowerCase() === "url(") {
                      f = "url", b += 3;
                      continue;
                    }
                    if (v === "*" && p[b - 1] === "/") {
                      f = "comment-block";
                      continue;
                    }
                    if (v === "/" && p[b - 1] === "/") {
                      f = "comment-inline", N = b - 1;
                      continue;
                    }
                    continue;
                  case "single-quotes":
                    if (v === "'" && p[b - 1] !== "\\" && (f = h, h = "initial"), v === `
` || v === "\r")
                      return p;
                    continue;
                  case "double-quotes":
                    if (v === '"' && p[b - 1] !== "\\" && (f = h, h = "initial"), v === `
` || v === "\r")
                      return p;
                    continue;
                  case "url":
                    if (v === ")" && (f = "initial"), v === `
` || v === "\r")
                      return p;
                    if (v === "'") {
                      f = "single-quotes", h = "url";
                      continue;
                    }
                    if (v === '"') {
                      f = "double-quotes", h = "url";
                      continue;
                    }
                    continue;
                  case "comment-block":
                    v === "/" && p[b - 1] === "*" && (f = "initial");
                    continue;
                  case "comment-inline":
                    (v === '"' || v === "'" || v === "*") && (T = true), (v === `
` || v === "\r") && (T && A.push([N, b]), f = "initial", T = false);
                    continue;
                }
              }
              for (let [b, v] of A)
                p = p.slice(0, b) + p.slice(b, v).replace(/["'*]/g, " ") + p.slice(v);
              return p;
            }
            function m(p) {
              return p.source.startOffset;
            }
            function g(p) {
              return p.source.endOffset;
            }
            n.exports = { locStart: m, locEnd: g, calculateLoc: a, replaceQuotesInInlineComments: C };
          } }), Km = Z({ "src/language-css/utils/is-less-parser.js"(e, n) {
            "use strict";
            ae();
            function t(s) {
              return s.parser === "css" || s.parser === "less";
            }
            n.exports = t;
          } }), Ym = Z({ "src/language-css/utils/is-scss.js"(e, n) {
            "use strict";
            ae();
            function t(s, i) {
              return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(i);
            }
            n.exports = t;
          } }), Qm = Z({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
            n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", vh: "vh", vi: "vi", vb: "vb", vmin: "vmin", vmax: "vmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
          } }), Zm = Z({ "src/language-css/utils/print-unit.js"(e, n) {
            "use strict";
            ae();
            var t = Qm();
            function s(i) {
              let r = i.toLowerCase();
              return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : i;
            }
            n.exports = s;
          } }), ed = Z({ "src/language-css/printer-postcss.js"(e, n) {
            "use strict";
            ae();
            var t = st(), { printNumber: s, printString: i, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: a, isNonEmptyArray: c } = Ge(), { builders: { join: l, line: C, hardline: m, softline: g, group: p, fill: f, indent: h, dedent: N, ifBreak: T, breakParent: A }, utils: { removeLines: b, getDocParts: v } } = Le(), B = Hm(), w = Gm(), { insertPragma: I } = Jm(), { getAncestorNode: E, getPropOfDeclNode: D, maybeToLowerCase: d, insideValueFunctionNode: y, insideICSSRuleNode: o, insideAtRuleNode: x, insideURLFunctionInImportAtRuleNode: F, isKeyframeAtRuleKeywords: S, isWideKeywords: k, isLastNode: _, isSCSSControlDirectiveNode: O, isDetachedRulesetDeclarationNode: R, isRelationalOperatorNode: M, isEqualityOperatorNode: H, isMultiplicationNode: P, isDivisionNode: G, isAdditionNode: re, isSubtractionNode: $, isMathOperatorNode: W, isEachKeywordNode: ee, isForKeywordNode: U, isURLFunctionNode: ne, isIfElseKeywordNode: se, hasComposesNode: V, hasParensAroundNode: oe, hasEmptyRawBefore: K, isKeyValuePairNode: Ee, isKeyInValuePairNode: q, isDetachedRulesetCallNode: le, isTemplatePlaceholderNode: ue, isTemplatePropNode: Q, isPostcssSimpleVarNode: de, isSCSSMapItemNode: ge, isInlineValueCommentNode: ve, isHashNode: xe, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: fe, isWordNode: pe, isColonNode: me, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: he, lastLineHasInlineComment: J, isAtWordPlaceholderNode: ye, isConfigurationNode: X, isParenGroupNode: Y } = Um(), { locStart: te, locEnd: z } = Xm(), j = Km(), Ce = Ym(), Ne = Zm();
            function je(Ae) {
              return Ae.trailingComma === "es5" || Ae.trailingComma === "all";
            }
            function Ue(Ae, Oe, Pe) {
              let ie = Ae.getValue();
              if (!ie)
                return "";
              if (typeof ie == "string")
                return ie;
              switch (ie.type) {
                case "front-matter":
                  return [ie.raw, m];
                case "css-root": {
                  let Me = tt(Ae, Oe, Pe), qe = ie.raws.after.trim();
                  return [Me, qe ? " ".concat(qe) : "", v(Me).length > 0 ? m : ""];
                }
                case "css-comment": {
                  let Me = ie.inline || ie.raws.inline, qe = Oe.originalText.slice(te(ie), z(ie));
                  return Me ? qe.trimEnd() : qe;
                }
                case "css-rule":
                  return [Pe("selector"), ie.important ? " !important" : "", ie.nodes ? [ie.selector && ie.selector.type === "selector-unknown" && J(ie.selector.value) ? C : " ", "{", ie.nodes.length > 0 ? h([m, tt(Ae, Oe, Pe)]) : "", m, "}", R(ie) ? ";" : ""] : ";"];
                case "css-decl": {
                  let Me = Ae.getParentNode(), { between: qe } = ie.raws, Je = qe.trim(), rt = Je === ":", Ze = V(ie) ? b(Pe("value")) : Pe("value");
                  return !rt && J(Je) && (Ze = h([m, N(Ze)])), [ie.raws.before.replace(/[\s;]/g, ""), o(Ae) ? ie.prop : d(ie.prop), Je.startsWith("//") ? " " : "", Je, ie.extend ? "" : " ", j(Oe) && ie.extend && ie.selector ? ["extend(", Pe("selector"), ")"] : "", Ze, ie.raws.important ? ie.raws.important.replace(/\s*!\s*important/i, " !important") : ie.important ? " !important" : "", ie.raws.scssDefault ? ie.raws.scssDefault.replace(/\s*!default/i, " !default") : ie.scssDefault ? " !default" : "", ie.raws.scssGlobal ? ie.raws.scssGlobal.replace(/\s*!global/i, " !global") : ie.scssGlobal ? " !global" : "", ie.nodes ? [" {", h([g, tt(Ae, Oe, Pe)]), g, "}"] : Q(ie) && !Me.raws.semicolon && Oe.originalText[z(ie) - 1] !== ";" ? "" : Oe.__isHTMLStyleAttribute && _(Ae, ie) ? T(";") : ";"];
                }
                case "css-atrule": {
                  let Me = Ae.getParentNode(), qe = ue(ie) && !Me.raws.semicolon && Oe.originalText[z(ie) - 1] !== ";";
                  if (j(Oe)) {
                    if (ie.mixin)
                      return [Pe("selector"), ie.important ? " !important" : "", qe ? "" : ";"];
                    if (ie.function)
                      return [ie.name, Pe("params"), qe ? "" : ";"];
                    if (ie.variable)
                      return ["@", ie.name, ": ", ie.value ? Pe("value") : "", ie.raws.between.trim() ? ie.raws.between.trim() + " " : "", ie.nodes ? ["{", h([ie.nodes.length > 0 ? g : "", tt(Ae, Oe, Pe)]), g, "}"] : "", qe ? "" : ";"];
                  }
                  return ["@", le(ie) || ie.name.endsWith(":") ? ie.name : d(ie.name), ie.params ? [le(ie) ? "" : ue(ie) ? ie.raws.afterName === "" ? "" : ie.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ie.raws.afterName) ? [m, m] : /^\s*\n/.test(ie.raws.afterName) ? m : " " : " ", Pe("params")] : "", ie.selector ? h([" ", Pe("selector")]) : "", ie.value ? p([" ", Pe("value"), O(ie) ? oe(ie) ? " " : C : ""]) : ie.name === "else" ? " " : "", ie.nodes ? [O(ie) ? "" : ie.selector && !ie.selector.nodes && typeof ie.selector.value == "string" && J(ie.selector.value) || !ie.selector && typeof ie.params == "string" && J(ie.params) ? C : " ", "{", h([ie.nodes.length > 0 ? g : "", tt(Ae, Oe, Pe)]), g, "}"] : qe ? "" : ";"];
                }
                case "media-query-list": {
                  let Me = [];
                  return Ae.each((qe) => {
                    let Je = qe.getValue();
                    Je.type === "media-query" && Je.value === "" || Me.push(Pe());
                  }, "nodes"), p(h(l(C, Me)));
                }
                case "media-query":
                  return [l(" ", Ae.map(Pe, "nodes")), _(Ae, ie) ? "" : ","];
                case "media-type":
                  return Ie(ze(ie.value, Oe));
                case "media-feature-expression":
                  return ie.nodes ? ["(", ...Ae.map(Pe, "nodes"), ")"] : ie.value;
                case "media-feature":
                  return d(ze(ie.value.replace(/ +/g, " "), Oe));
                case "media-colon":
                  return [ie.value, " "];
                case "media-value":
                  return Ie(ze(ie.value, Oe));
                case "media-keyword":
                  return ze(ie.value, Oe);
                case "media-url":
                  return ze(ie.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Oe);
                case "media-unknown":
                  return ie.value;
                case "selector-root":
                  return p([x(Ae, "custom-selector") ? [E(Ae, "css-atrule").customSelector, C] : "", l([",", x(Ae, ["extend", "custom-selector", "nest"]) ? C : m], Ae.map(Pe, "nodes"))]);
                case "selector-selector":
                  return p(h(Ae.map(Pe, "nodes")));
                case "selector-comment":
                  return ie.value;
                case "selector-string":
                  return ze(ie.value, Oe);
                case "selector-tag": {
                  let Me = Ae.getParentNode(), qe = Me && Me.nodes.indexOf(ie), Je = qe && Me.nodes[qe - 1];
                  return [ie.namespace ? [ie.namespace === true ? "" : ie.namespace.trim(), "|"] : "", Je.type === "selector-nesting" ? ie.value : Ie(S(Ae, ie.value) ? ie.value.toLowerCase() : ie.value)];
                }
                case "selector-id":
                  return ["#", ie.value];
                case "selector-class":
                  return [".", Ie(ze(ie.value, Oe))];
                case "selector-attribute":
                  return ["[", ie.namespace ? [ie.namespace === true ? "" : ie.namespace.trim(), "|"] : "", ie.attribute.trim(), ie.operator ? ie.operator : "", ie.value ? Be(ze(ie.value.trim(), Oe), Oe) : "", ie.insensitive ? " i" : "", "]"];
                case "selector-combinator": {
                  if (ie.value === "+" || ie.value === ">" || ie.value === "~" || ie.value === ">>>") {
                    let Je = Ae.getParentNode();
                    return [Je.type === "selector-selector" && Je.nodes[0] === ie ? "" : C, ie.value, _(Ae, ie) ? "" : " "];
                  }
                  let Me = ie.value.trim().startsWith("(") ? C : "", qe = Ie(ze(ie.value.trim(), Oe)) || C;
                  return [Me, qe];
                }
                case "selector-universal":
                  return [ie.namespace ? [ie.namespace === true ? "" : ie.namespace.trim(), "|"] : "", ie.value];
                case "selector-pseudo":
                  return [d(ie.value), c(ie.nodes) ? ["(", l(", ", Ae.map(Pe, "nodes")), ")"] : ""];
                case "selector-nesting":
                  return ie.value;
                case "selector-unknown": {
                  let Me = E(Ae, "css-rule");
                  if (Me && Me.isSCSSNesterProperty)
                    return Ie(ze(d(ie.value), Oe));
                  let qe = Ae.getParentNode();
                  if (qe.raws && qe.raws.selector) {
                    let rt = te(qe), Ze = rt + qe.raws.selector.length;
                    return Oe.originalText.slice(rt, Ze).trim();
                  }
                  let Je = Ae.getParentNode(1);
                  if (qe.type === "value-paren_group" && Je && Je.type === "value-func" && Je.value === "selector") {
                    let rt = z(qe.open) + 1, Ze = te(qe.close), ct = Oe.originalText.slice(rt, Ze).trim();
                    return J(ct) ? [A, ct] : ct;
                  }
                  return ie.value;
                }
                case "value-value":
                case "value-root":
                  return Pe("group");
                case "value-comment":
                  return Oe.originalText.slice(te(ie), z(ie));
                case "value-comma_group": {
                  let Me = Ae.getParentNode(), qe = Ae.getParentNode(1), Je = D(Ae), rt = Je && Me.type === "value-value" && (Je === "grid" || Je.startsWith("grid-template")), Ze = E(Ae, "css-atrule"), ct = Ze && O(Ze), qt = ie.groups.some((ut) => ve(ut)), L = Ae.map(Pe, "groups"), De = [], ke = y(Ae, "url"), We = false, $e = false;
                  for (let ut = 0; ut < ie.groups.length; ++ut) {
                    De.push(L[ut]);
                    let et = ie.groups[ut - 1], Re = ie.groups[ut], He = ie.groups[ut + 1], Zt = ie.groups[ut + 2];
                    if (ke) {
                      (He && re(He) || re(Re)) && De.push(" ");
                      continue;
                    }
                    if (x(Ae, "forward") && Re.type === "value-word" && Re.value && et !== void 0 && et.type === "value-word" && et.value === "as" && He.type === "value-operator" && He.value === "*" || !He || Re.type === "value-word" && Re.value.endsWith("-") && ye(He))
                      continue;
                    let ho = Re.type === "value-string" && Re.value.startsWith("#{"), Co = We && He.type === "value-string" && He.value.endsWith("}");
                    if (ho || Co) {
                      We = !We;
                      continue;
                    }
                    if (We || me(Re) || me(He) || Re.type === "value-atword" && Re.value === "" || Re.value === "~" || Re.value && Re.value.includes("\\") && He && He.type !== "value-comment" || et && et.value && et.value.indexOf("\\") === et.value.length - 1 && Re.type === "value-operator" && Re.value === "/" || Re.value === "\\" || de(Re, He) || xe(Re) || we(Re) || fe(He) || we(He) && K(He) || fe(Re) && K(He) || Re.value === "--" && xe(He))
                      continue;
                    let Qn = W(Re), Zn = W(He);
                    if ((Qn && xe(He) || Zn && fe(Re)) && K(He) || !et && G(Re) || y(Ae, "calc") && (re(Re) || re(He) || $(Re) || $(He)) && K(He))
                      continue;
                    let Eo = (re(Re) || $(Re)) && ut === 0 && (He.type === "value-number" || He.isHex) && qe && he(qe) && !K(He), eu = Zt && Zt.type === "value-func" || Zt && pe(Zt) || Re.type === "value-func" || pe(Re), tu = He.type === "value-func" || pe(He) || et && et.type === "value-func" || et && pe(et);
                    if (!(!(P(He) || P(Re)) && !y(Ae, "calc") && !Eo && (G(He) && !eu || G(Re) && !tu || re(He) && !eu || re(Re) && !tu || $(He) || $(Re)) && (K(He) || Qn && (!et || et && W(et))))) {
                      if (ve(Re)) {
                        if (Me.type === "value-paren_group") {
                          De.push(N(m));
                          continue;
                        }
                        De.push(m);
                        continue;
                      }
                      if (ct && (H(He) || M(He) || se(He) || ee(Re) || U(Re))) {
                        De.push(" ");
                        continue;
                      }
                      if (Ze && Ze.name.toLowerCase() === "namespace") {
                        De.push(" ");
                        continue;
                      }
                      if (rt) {
                        Re.source && He.source && Re.source.start.line !== He.source.start.line ? (De.push(m), $e = true) : De.push(" ");
                        continue;
                      }
                      if (Zn) {
                        De.push(" ");
                        continue;
                      }
                      if (!(He && He.value === "...") && !(ye(Re) && ye(He) && z(Re) === te(He))) {
                        if (ye(Re) && Y(He) && z(Re) === te(He.open)) {
                          De.push(g);
                          continue;
                        }
                        if (Re.value === "with" && Y(He)) {
                          De.push(" ");
                          continue;
                        }
                        De.push(C);
                      }
                    }
                  }
                  return qt && De.push(A), $e && De.unshift(m), ct ? p(h(De)) : F(Ae) ? p(f(De)) : p(h(f(De)));
                }
                case "value-paren_group": {
                  let Me = Ae.getParentNode();
                  if (Me && ne(Me) && (ie.groups.length === 1 || ie.groups.length > 0 && ie.groups[0].type === "value-comma_group" && ie.groups[0].groups.length > 0 && ie.groups[0].groups[0].type === "value-word" && ie.groups[0].groups[0].value.startsWith("data:")))
                    return [ie.open ? Pe("open") : "", l(",", Ae.map(Pe, "groups")), ie.close ? Pe("close") : ""];
                  if (!ie.open) {
                    let ke = Ae.map(Pe, "groups"), We = [];
                    for (let $e = 0; $e < ke.length; $e++)
                      $e !== 0 && We.push([",", C]), We.push(ke[$e]);
                    return p(h(f(We)));
                  }
                  let qe = ge(Ae), Je = t(ie.groups), rt = Je && Je.type === "value-comment", Ze = q(ie, Me), ct = X(ie, Me), qt = ct || qe && !Ze, L = ct || Ze, De = p([ie.open ? Pe("open") : "", h([g, l([C], Ae.map((ke, We) => {
                    let $e = ke.getValue(), ut = We === ie.groups.length - 1, et = [Pe(), ut ? "" : ","];
                    if (Ee($e) && $e.type === "value-comma_group" && $e.groups && $e.groups[0].type !== "value-paren_group" && $e.groups[2] && $e.groups[2].type === "value-paren_group") {
                      let Re = v(et[0].contents.contents);
                      return Re[1] = p(Re[1]), p(N(et));
                    }
                    if (!ut && $e.type === "value-comma_group" && c($e.groups)) {
                      let Re = t($e.groups);
                      Re.source && a(Oe.originalText, Re, z) && et.push(m);
                    }
                    return et;
                  }, "groups"))]), T(!rt && Ce(Oe.parser, Oe.originalText) && qe && je(Oe) ? "," : ""), g, ie.close ? Pe("close") : ""], { shouldBreak: qt });
                  return L ? N(De) : De;
                }
                case "value-func":
                  return [ie.value, x(Ae, "supports") && ce(ie) ? " " : "", Pe("group")];
                case "value-paren":
                  return ie.value;
                case "value-number":
                  return [Ve(ie.value), Ne(ie.unit)];
                case "value-operator":
                  return ie.value;
                case "value-word":
                  return ie.isColor && ie.isHex || k(ie.value) ? ie.value.toLowerCase() : ie.value;
                case "value-colon": {
                  let Me = Ae.getParentNode(), qe = Me && Me.groups.indexOf(ie), Je = qe && Me.groups[qe - 1];
                  return [ie.value, Je && typeof Je.value == "string" && t(Je.value) === "\\" || y(Ae, "url") ? "" : C];
                }
                case "value-comma":
                  return [ie.value, " "];
                case "value-string":
                  return i(ie.raws.quote + ie.value + ie.raws.quote, Oe);
                case "value-atword":
                  return ["@", ie.value];
                case "value-unicode-range":
                  return ie.value;
                case "value-unknown":
                  return ie.value;
                default:
                  throw new Error("Unknown postcss type ".concat(JSON.stringify(ie.type)));
              }
            }
            function tt(Ae, Oe, Pe) {
              let ie = [];
              return Ae.each((Me, qe, Je) => {
                let rt = Je[qe - 1];
                if (rt && rt.type === "css-comment" && rt.text.trim() === "prettier-ignore") {
                  let Ze = Me.getValue();
                  ie.push(Oe.originalText.slice(te(Ze), z(Ze)));
                } else
                  ie.push(Pe());
                qe !== Je.length - 1 && (Je[qe + 1].type === "css-comment" && !r(Oe.originalText, te(Je[qe + 1]), { backwards: true }) && !u(Je[qe]) || Je[qe + 1].type === "css-atrule" && Je[qe + 1].name === "else" && Je[qe].type !== "css-comment" ? ie.push(" ") : (ie.push(Oe.__isHTMLStyleAttribute ? C : m), a(Oe.originalText, Me.getValue(), z) && !u(Je[qe]) && ie.push(m)));
              }, "nodes"), ie;
            }
            var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, _e = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Fe = /[A-Za-z]+/g, Ke = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Se = new RegExp(Te.source + "|(".concat(Ke.source, ")?(").concat(_e.source, ")(").concat(Fe.source, ")?"), "g");
            function ze(Ae, Oe) {
              return Ae.replace(Te, (Pe) => i(Pe, Oe));
            }
            function Be(Ae, Oe) {
              let Pe = Oe.singleQuote ? "'" : '"';
              return Ae.includes('"') || Ae.includes("'") ? Ae : Pe + Ae + Pe;
            }
            function Ie(Ae) {
              return Ae.replace(Se, (Oe, Pe, ie, Me, qe) => !ie && Me ? Ve(Me) + d(qe || "") : Oe);
            }
            function Ve(Ae) {
              return s(Ae).replace(/\.0(?=$|e)/, "");
            }
            n.exports = { print: Ue, embed: w, insertPragma: I, massageAstNode: B };
          } }), td = Z({ "src/language-css/options.js"(e, n) {
            "use strict";
            ae();
            var t = Lt();
            n.exports = { singleQuote: t.singleQuote };
          } }), rd = Z({ "src/language-css/parsers.js"() {
            ae();
          } }), nd = Z({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
            n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
          } }), ud = Z({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
            n.exports = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
          } }), sd = Z({ "node_modules/linguist-languages/data/Less.json"(e, n) {
            n.exports = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
          } }), ad = Z({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
            n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
          } }), id = Z({ "src/language-css/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = ed(), i = td(), r = rd(), u = [t(nd(), (c) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...c.extensions, ".wxss"] })), t(ud(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(sd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(ad(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], a = { postcss: s };
            n.exports = { languages: u, options: i, printers: a, parsers: r };
          } }), od = Z({ "src/language-handlebars/loc.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return i.loc.start.offset;
            }
            function s(i) {
              return i.loc.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), cd = Z({ "src/language-handlebars/clean.js"(e, n) {
            "use strict";
            ae();
            function t(s, i) {
              if (s.type === "TextNode") {
                let r = s.chars.trim();
                if (!r)
                  return null;
                i.chars = r.replace(/[\t\n\f\r ]+/g, " ");
              }
              s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete i.value;
            }
            t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
          } }), ld = Z({ "vendors/html-void-elements.json"(e, n) {
            n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
          } }), pd = Z({ "src/language-handlebars/utils.js"(e, n) {
            "use strict";
            ae();
            var { htmlVoidElements: t } = ld(), s = st();
            function i(b) {
              let v = b.getValue(), B = b.getParentNode(0);
              return !!(m(b, ["ElementNode"]) && s(B.children) === v || m(b, ["Block"]) && s(B.body) === v);
            }
            function r(b) {
              return b.toUpperCase() === b;
            }
            function u(b) {
              return C(b, ["ElementNode"]) && typeof b.tag == "string" && b.tag[0] !== ":" && (r(b.tag[0]) || b.tag.includes("."));
            }
            var a = new Set(t);
            function c(b) {
              return u(b) && b.children.every((v) => l(v)) || a.has(b.tag);
            }
            function l(b) {
              return C(b, ["TextNode"]) && !/\S/.test(b.chars);
            }
            function C(b, v) {
              return b && v.includes(b.type);
            }
            function m(b, v) {
              let B = b.getParentNode(0);
              return C(B, v);
            }
            function g(b, v) {
              let B = h(b);
              return C(B, v);
            }
            function p(b, v) {
              let B = N(b);
              return C(B, v);
            }
            function f(b, v) {
              let B = b.getValue(), w = b.getParentNode(0) || {}, I = w.children || w.body || w.parts || [], E = I.indexOf(B);
              return E !== -1 && I[E + v];
            }
            function h(b) {
              let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              return f(b, -v);
            }
            function N(b) {
              return f(b, 1);
            }
            function T(b) {
              return C(b, ["MustacheCommentStatement"]) && typeof b.value == "string" && b.value.trim() === "prettier-ignore";
            }
            function A(b) {
              let v = b.getValue(), B = h(b, 2);
              return T(v) || T(B);
            }
            n.exports = { getNextNode: N, getPreviousNode: h, hasPrettierIgnore: A, isLastNodeOfSiblings: i, isNextNodeOfSomeType: p, isNodeOfSomeType: C, isParentOfSomeType: m, isPreviousNodeOfSomeType: g, isVoid: c, isWhitespaceNode: l };
          } }), fd = Z({ "src/language-handlebars/printer-glimmer.js"(e, n) {
            "use strict";
            ae();
            var { builders: { dedent: t, fill: s, group: i, hardline: r, ifBreak: u, indent: a, join: c, line: l, softline: C }, utils: { getDocParts: m, replaceTextEndOfLine: g } } = Le(), { getPreferredQuote: p, isNonEmptyArray: f } = Ge(), { locStart: h, locEnd: N } = od(), T = cd(), { getNextNode: A, getPreviousNode: b, hasPrettierIgnore: v, isLastNodeOfSiblings: B, isNextNodeOfSomeType: w, isNodeOfSomeType: I, isParentOfSomeType: E, isPreviousNodeOfSomeType: D, isVoid: d, isWhitespaceNode: y } = pd(), o = 2;
            function x(J, ye, X) {
              let Y = J.getValue();
              if (!Y)
                return "";
              if (v(J))
                return ye.originalText.slice(h(Y), N(Y));
              let te = ye.singleQuote ? "'" : '"';
              switch (Y.type) {
                case "Block":
                case "Program":
                case "Template":
                  return i(J.map(X, "body"));
                case "ElementNode": {
                  let z = i(S(J, X)), j = ye.htmlWhitespaceSensitivity === "ignore" && w(J, ["ElementNode"]) ? C : "";
                  if (d(Y))
                    return [z, j];
                  let Ce = ["</", Y.tag, ">"];
                  return Y.children.length === 0 ? [z, a(Ce), j] : ye.htmlWhitespaceSensitivity === "ignore" ? [z, a(k(J, ye, X)), r, a(Ce), j] : [z, a(i(k(J, ye, X))), a(Ce), j];
                }
                case "BlockStatement": {
                  let z = J.getParentNode(1);
                  return z && z.inverse && z.inverse.body.length === 1 && z.inverse.body[0] === Y && z.inverse.body[0].path.parts[0] === "if" ? [U(J, X), K(J, X, ye), Ee(J, X, ye)] : [W(J, X), i([K(J, X, ye), Ee(J, X, ye), ne(J, X, ye)])];
                }
                case "ElementModifierStatement":
                  return i(["{{", pe(J, X), "}}"]);
                case "MustacheStatement":
                  return i([O(Y), pe(J, X), R(Y)]);
                case "SubExpression":
                  return i(["(", fe(J, X), C, ")"]);
                case "AttrNode": {
                  let z = Y.value.type === "TextNode";
                  if (z && Y.value.chars === "" && h(Y.value) === N(Y.value))
                    return Y.name;
                  let Ce = z ? p(Y.value.chars, te).quote : Y.value.type === "ConcatStatement" ? p(Y.value.parts.filter((je) => je.type === "TextNode").map((je) => je.chars).join(""), te).quote : "", Ne = X("value");
                  return [Y.name, "=", Ce, Y.name === "class" && Ce ? i(a(Ne)) : Ne, Ce];
                }
                case "ConcatStatement":
                  return J.map(X, "parts");
                case "Hash":
                  return c(l, J.map(X, "pairs"));
                case "HashPair":
                  return [Y.key, "=", X("value")];
                case "TextNode": {
                  let z = Y.chars.replace(/{{/g, "\\{{"), j = ue(J);
                  if (j) {
                    if (j === "class") {
                      let Se = z.trim().split(/\s+/).join(" "), ze = false, Be = false;
                      return E(J, ["ConcatStatement"]) && (D(J, ["MustacheStatement"]) && /^\s/.test(z) && (ze = true), w(J, ["MustacheStatement"]) && /\s$/.test(z) && Se !== "" && (Be = true)), [ze ? l : "", Se, Be ? l : ""];
                    }
                    return g(z);
                  }
                  let Ne = /^[\t\n\f\r ]*$/.test(z), je = !b(J), Ue = !A(J);
                  if (ye.htmlWhitespaceSensitivity !== "ignore") {
                    let Se = /^[\t\n\f\r ]*/, ze = /[\t\n\f\r ]*$/, Be = Ue && E(J, ["Template"]), Ie = je && E(J, ["Template"]);
                    if (Ne) {
                      if (Ie || Be)
                        return "";
                      let ie = [l], Me = Q(z);
                      return Me && (ie = ve(Me)), B(J) && (ie = ie.map((qe) => t(qe))), ie;
                    }
                    let [Ve] = z.match(Se), [Ae] = z.match(ze), Oe = [];
                    if (Ve) {
                      Oe = [l];
                      let ie = Q(Ve);
                      ie && (Oe = ve(ie)), z = z.replace(Se, "");
                    }
                    let Pe = [];
                    if (Ae) {
                      if (!Be) {
                        Pe = [l];
                        let ie = Q(Ae);
                        ie && (Pe = ve(ie)), B(J) && (Pe = Pe.map((Me) => t(Me)));
                      }
                      z = z.replace(ze, "");
                    }
                    return [...Oe, s(q(z)), ...Pe];
                  }
                  let tt = Q(z), Te = de(z), _e = ge(z);
                  if ((je || Ue) && Ne && E(J, ["Block", "ElementNode", "Template"]))
                    return "";
                  Ne && tt ? (Te = Math.min(tt, o), _e = 0) : (w(J, ["BlockStatement", "ElementNode"]) && (_e = Math.max(_e, 1)), D(J, ["BlockStatement", "ElementNode"]) && (Te = Math.max(Te, 1)));
                  let Fe = "", Ke = "";
                  return _e === 0 && w(J, ["MustacheStatement"]) && (Ke = " "), Te === 0 && D(J, ["MustacheStatement"]) && (Fe = " "), je && (Te = 0, Fe = ""), Ue && (_e = 0, Ke = ""), z = z.replace(/^[\t\n\f\r ]+/g, Fe).replace(/[\t\n\f\r ]+$/, Ke), [...ve(Te), s(q(z)), ...ve(_e)];
                }
                case "MustacheCommentStatement": {
                  let z = h(Y), j = N(Y), Ce = ye.originalText.charAt(z + 2) === "~", Ne = ye.originalText.charAt(j - 3) === "~", je = Y.value.includes("}}") ? "--" : "";
                  return ["{{", Ce ? "~" : "", "!", je, Y.value, je, Ne ? "~" : "", "}}"];
                }
                case "PathExpression":
                  return Y.original;
                case "BooleanLiteral":
                  return String(Y.value);
                case "CommentStatement":
                  return ["<!--", Y.value, "-->"];
                case "StringLiteral": {
                  if (we(J)) {
                    let z = ye.singleQuote ? '"' : "'";
                    return xe(Y.value, z);
                  }
                  return xe(Y.value, te);
                }
                case "NumberLiteral":
                  return String(Y.value);
                case "UndefinedLiteral":
                  return "undefined";
                case "NullLiteral":
                  return "null";
                default:
                  throw new Error("unknown glimmer type: " + JSON.stringify(Y.type));
              }
            }
            function F(J, ye) {
              return h(J) - h(ye);
            }
            function S(J, ye) {
              let X = J.getValue(), Y = ["attributes", "modifiers", "comments"].filter((z) => f(X[z])), te = Y.flatMap((z) => X[z]).sort(F);
              for (let z of Y)
                J.each((j) => {
                  let Ce = te.indexOf(j.getValue());
                  te.splice(Ce, 1, [l, ye()]);
                }, z);
              return f(X.blockParams) && te.push(l, he(X)), ["<", X.tag, a(te), _(X)];
            }
            function k(J, ye, X) {
              let te = J.getValue().children.every((z) => y(z));
              return ye.htmlWhitespaceSensitivity === "ignore" && te ? "" : J.map((z, j) => {
                let Ce = X();
                return j === 0 && ye.htmlWhitespaceSensitivity === "ignore" ? [C, Ce] : Ce;
              }, "children");
            }
            function _(J) {
              return d(J) ? u([C, "/>"], [" />", C]) : u([C, ">"], ">");
            }
            function O(J) {
              let ye = J.escaped === false ? "{{{" : "{{", X = J.strip && J.strip.open ? "~" : "";
              return [ye, X];
            }
            function R(J) {
              let ye = J.escaped === false ? "}}}" : "}}";
              return [J.strip && J.strip.close ? "~" : "", ye];
            }
            function M(J) {
              let ye = O(J), X = J.openStrip.open ? "~" : "";
              return [ye, X, "#"];
            }
            function H(J) {
              let ye = R(J);
              return [J.openStrip.close ? "~" : "", ye];
            }
            function P(J) {
              let ye = O(J), X = J.closeStrip.open ? "~" : "";
              return [ye, X, "/"];
            }
            function G(J) {
              let ye = R(J);
              return [J.closeStrip.close ? "~" : "", ye];
            }
            function re(J) {
              let ye = O(J), X = J.inverseStrip.open ? "~" : "";
              return [ye, X];
            }
            function $(J) {
              let ye = R(J);
              return [J.inverseStrip.close ? "~" : "", ye];
            }
            function W(J, ye) {
              let X = J.getValue(), Y = M(X), te = H(X), z = [me(J, ye)], j = ce(J, ye);
              if (j && z.push(l, j), f(X.program.blockParams)) {
                let Ce = he(X.program);
                z.push(l, Ce);
              }
              return i([Y, a(z), C, te]);
            }
            function ee(J, ye) {
              return [ye.htmlWhitespaceSensitivity === "ignore" ? r : "", re(J), "else", $(J)];
            }
            function U(J, ye) {
              let X = J.getParentNode(1);
              return [re(X), "else if ", ce(J, ye), $(X)];
            }
            function ne(J, ye, X) {
              let Y = J.getValue();
              return X.htmlWhitespaceSensitivity === "ignore" ? [se(Y) ? C : r, P(Y), ye("path"), G(Y)] : [P(Y), ye("path"), G(Y)];
            }
            function se(J) {
              return I(J, ["BlockStatement"]) && J.program.body.every((ye) => y(ye));
            }
            function V(J) {
              return oe(J) && J.inverse.body.length === 1 && I(J.inverse.body[0], ["BlockStatement"]) && J.inverse.body[0].path.parts[0] === "if";
            }
            function oe(J) {
              return I(J, ["BlockStatement"]) && J.inverse;
            }
            function K(J, ye, X) {
              let Y = J.getValue();
              if (se(Y))
                return "";
              let te = ye("program");
              return X.htmlWhitespaceSensitivity === "ignore" ? a([r, te]) : a(te);
            }
            function Ee(J, ye, X) {
              let Y = J.getValue(), te = ye("inverse"), z = X.htmlWhitespaceSensitivity === "ignore" ? [r, te] : te;
              return V(Y) ? z : oe(Y) ? [ee(Y, X), a(z)] : "";
            }
            function q(J) {
              return m(c(l, le(J)));
            }
            function le(J) {
              return J.split(/[\t\n\f\r ]+/);
            }
            function ue(J) {
              for (let ye = 0; ye < 2; ye++) {
                let X = J.getParentNode(ye);
                if (X && X.type === "AttrNode")
                  return X.name.toLowerCase();
              }
            }
            function Q(J) {
              return J = typeof J == "string" ? J : "", J.split(`
`).length - 1;
            }
            function de(J) {
              J = typeof J == "string" ? J : "";
              let ye = (J.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
              return Q(ye);
            }
            function ge(J) {
              J = typeof J == "string" ? J : "";
              let ye = (J.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
              return Q(ye);
            }
            function ve() {
              let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return Array.from({ length: Math.min(J, o) }).fill(r);
            }
            function xe(J, ye) {
              let { quote: X, regex: Y } = p(J, ye);
              return [X, J.replace(Y, "\\".concat(X)), X];
            }
            function we(J) {
              let ye = 0, X = J.getParentNode(ye);
              for (; X && I(X, ["SubExpression"]); )
                ye++, X = J.getParentNode(ye);
              return !!(X && I(J.getParentNode(ye + 1), ["ConcatStatement"]) && I(J.getParentNode(ye + 2), ["AttrNode"]));
            }
            function fe(J, ye) {
              let X = me(J, ye), Y = ce(J, ye);
              return Y ? a([X, l, i(Y)]) : X;
            }
            function pe(J, ye) {
              let X = me(J, ye), Y = ce(J, ye);
              return Y ? [a([X, l, Y]), C] : X;
            }
            function me(J, ye) {
              return ye("path");
            }
            function ce(J, ye) {
              let X = J.getValue(), Y = [];
              if (X.params.length > 0) {
                let te = J.map(ye, "params");
                Y.push(...te);
              }
              if (X.hash && X.hash.pairs.length > 0) {
                let te = ye("hash");
                Y.push(te);
              }
              return Y.length === 0 ? "" : c(l, Y);
            }
            function he(J) {
              return ["as |", J.blockParams.join(" "), "|"];
            }
            n.exports = { print: x, massageAstNode: T };
          } }), Dd = Z({ "src/language-handlebars/parsers.js"() {
            ae();
          } }), md = Z({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
            n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
          } }), dd = Z({ "src/language-handlebars/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = fd(), i = Dd(), r = [t(md(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
            n.exports = { languages: r, printers: u, parsers: i };
          } }), gd = Z({ "src/language-graphql/pragma.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(i);
            }
            function s(i) {
              return `# @format

` + i;
            }
            n.exports = { hasPragma: t, insertPragma: s };
          } }), yd = Z({ "src/language-graphql/loc.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return typeof i.start == "number" ? i.start : i.loc && i.loc.start;
            }
            function s(i) {
              return typeof i.end == "number" ? i.end : i.loc && i.loc.end;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), hd = Z({ "src/language-graphql/printer-graphql.js"(e, n) {
            "use strict";
            ae();
            var { builders: { join: t, hardline: s, line: i, softline: r, group: u, indent: a, ifBreak: c } } = Le(), { isNextLineEmpty: l, isNonEmptyArray: C } = Ge(), { insertPragma: m } = gd(), { locStart: g, locEnd: p } = yd();
            function f(w, I, E) {
              let D = w.getValue();
              if (!D)
                return "";
              if (typeof D == "string")
                return D;
              switch (D.kind) {
                case "Document": {
                  let d = [];
                  return w.each((y, o, x) => {
                    d.push(E()), o !== x.length - 1 && (d.push(s), l(I.originalText, y.getValue(), p) && d.push(s));
                  }, "definitions"), [...d, s];
                }
                case "OperationDefinition": {
                  let d = I.originalText[g(D)] !== "{", y = Boolean(D.name);
                  return [d ? D.operation : "", d && y ? [" ", E("name")] : "", d && !y && C(D.variableDefinitions) ? " " : "", C(D.variableDefinitions) ? u(["(", a([r, t([c("", ", "), r], w.map(E, "variableDefinitions"))]), r, ")"]) : "", h(w, E, D), D.selectionSet ? !d && !y ? "" : " " : "", E("selectionSet")];
                }
                case "FragmentDefinition":
                  return ["fragment ", E("name"), C(D.variableDefinitions) ? u(["(", a([r, t([c("", ", "), r], w.map(E, "variableDefinitions"))]), r, ")"]) : "", " on ", E("typeCondition"), h(w, E, D), " ", E("selectionSet")];
                case "SelectionSet":
                  return ["{", a([s, t(s, N(w, I, E, "selections"))]), s, "}"];
                case "Field":
                  return u([D.alias ? [E("alias"), ": "] : "", E("name"), D.arguments.length > 0 ? u(["(", a([r, t([c("", ", "), r], N(w, I, E, "arguments"))]), r, ")"]) : "", h(w, E, D), D.selectionSet ? " " : "", E("selectionSet")]);
                case "Name":
                  return D.value;
                case "StringValue":
                  return D.block ? ['"""', s, t(s, D.value.replace(/"""/g, "\\$&").split(`
`)), s, '"""'] : ['"', D.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                  return D.value;
                case "BooleanValue":
                  return D.value ? "true" : "false";
                case "NullValue":
                  return "null";
                case "Variable":
                  return ["$", E("name")];
                case "ListValue":
                  return u(["[", a([r, t([c("", ", "), r], w.map(E, "values"))]), r, "]"]);
                case "ObjectValue":
                  return u(["{", I.bracketSpacing && D.fields.length > 0 ? " " : "", a([r, t([c("", ", "), r], w.map(E, "fields"))]), r, c("", I.bracketSpacing && D.fields.length > 0 ? " " : ""), "}"]);
                case "ObjectField":
                case "Argument":
                  return [E("name"), ": ", E("value")];
                case "Directive":
                  return ["@", E("name"), D.arguments.length > 0 ? u(["(", a([r, t([c("", ", "), r], N(w, I, E, "arguments"))]), r, ")"]) : ""];
                case "NamedType":
                  return E("name");
                case "VariableDefinition":
                  return [E("variable"), ": ", E("type"), D.defaultValue ? [" = ", E("defaultValue")] : "", h(w, E, D)];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                  return [E("description"), D.description ? s : "", D.kind === "ObjectTypeExtension" ? "extend " : "", "type ", E("name"), D.interfaces.length > 0 ? [" implements ", ...b(w, I, E)] : "", h(w, E, D), D.fields.length > 0 ? [" {", a([s, t(s, N(w, I, E, "fields"))]), s, "}"] : ""];
                case "FieldDefinition":
                  return [E("description"), D.description ? s : "", E("name"), D.arguments.length > 0 ? u(["(", a([r, t([c("", ", "), r], N(w, I, E, "arguments"))]), r, ")"]) : "", ": ", E("type"), h(w, E, D)];
                case "DirectiveDefinition":
                  return [E("description"), D.description ? s : "", "directive ", "@", E("name"), D.arguments.length > 0 ? u(["(", a([r, t([c("", ", "), r], N(w, I, E, "arguments"))]), r, ")"]) : "", D.repeatable ? " repeatable" : "", " on ", t(" | ", w.map(E, "locations"))];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                  return [E("description"), D.description ? s : "", D.kind === "EnumTypeExtension" ? "extend " : "", "enum ", E("name"), h(w, E, D), D.values.length > 0 ? [" {", a([s, t(s, N(w, I, E, "values"))]), s, "}"] : ""];
                case "EnumValueDefinition":
                  return [E("description"), D.description ? s : "", E("name"), h(w, E, D)];
                case "InputValueDefinition":
                  return [E("description"), D.description ? D.description.block ? s : i : "", E("name"), ": ", E("type"), D.defaultValue ? [" = ", E("defaultValue")] : "", h(w, E, D)];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                  return [E("description"), D.description ? s : "", D.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", E("name"), h(w, E, D), D.fields.length > 0 ? [" {", a([s, t(s, N(w, I, E, "fields"))]), s, "}"] : ""];
                case "SchemaDefinition":
                  return [E("description"), D.description ? s : "", "schema", h(w, E, D), " {", D.operationTypes.length > 0 ? a([s, t(s, N(w, I, E, "operationTypes"))]) : "", s, "}"];
                case "OperationTypeDefinition":
                  return [E("operation"), ": ", E("type")];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                  return [E("description"), D.description ? s : "", D.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", E("name"), D.interfaces.length > 0 ? [" implements ", ...b(w, I, E)] : "", h(w, E, D), D.fields.length > 0 ? [" {", a([s, t(s, N(w, I, E, "fields"))]), s, "}"] : ""];
                case "FragmentSpread":
                  return ["...", E("name"), h(w, E, D)];
                case "InlineFragment":
                  return ["...", D.typeCondition ? [" on ", E("typeCondition")] : "", h(w, E, D), " ", E("selectionSet")];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                  return u([E("description"), D.description ? s : "", u([D.kind === "UnionTypeExtension" ? "extend " : "", "union ", E("name"), h(w, E, D), D.types.length > 0 ? [" =", c("", " "), a([c([i, "  "]), t([i, "| "], w.map(E, "types"))])] : ""])]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                  return [E("description"), D.description ? s : "", D.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", E("name"), h(w, E, D)];
                case "NonNullType":
                  return [E("type"), "!"];
                case "ListType":
                  return ["[", E("type"), "]"];
                default:
                  throw new Error("unknown graphql type: " + JSON.stringify(D.kind));
              }
            }
            function h(w, I, E) {
              if (E.directives.length === 0)
                return "";
              let D = t(i, w.map(I, "directives"));
              return E.kind === "FragmentDefinition" || E.kind === "OperationDefinition" ? u([i, D]) : [" ", u(a([r, D]))];
            }
            function N(w, I, E, D) {
              return w.map((d, y, o) => {
                let x = E();
                return y < o.length - 1 && l(I.originalText, d.getValue(), p) ? [x, s] : x;
              }, D);
            }
            function T(w) {
              return w.kind && w.kind !== "Comment";
            }
            function A(w) {
              let I = w.getValue();
              if (I.kind === "Comment")
                return "#" + I.value.trimEnd();
              throw new Error("Not a comment: " + JSON.stringify(I));
            }
            function b(w, I, E) {
              let D = w.getNode(), d = [], { interfaces: y } = D, o = w.map((x) => E(x), "interfaces");
              for (let x = 0; x < y.length; x++) {
                let F = y[x];
                d.push(o[x]);
                let S = y[x + 1];
                if (S) {
                  let k = I.originalText.slice(F.loc.end, S.loc.start), _ = k.includes("#"), O = k.replace(/#.*/g, "").trim();
                  d.push(O === "," ? "," : " &", _ ? i : " ");
                }
              }
              return d;
            }
            function v() {
            }
            v.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
            function B(w) {
              let I = w.getValue();
              return I && Array.isArray(I.comments) && I.comments.some((E) => E.value.trim() === "prettier-ignore");
            }
            n.exports = { print: f, massageAstNode: v, hasPrettierIgnore: B, insertPragma: m, printComment: A, canAttachComment: T };
          } }), Cd = Z({ "src/language-graphql/options.js"(e, n) {
            "use strict";
            ae();
            var t = Lt();
            n.exports = { bracketSpacing: t.bracketSpacing };
          } }), Ed = Z({ "src/language-graphql/parsers.js"() {
            ae();
          } }), vd = Z({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
            n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
          } }), Fd = Z({ "src/language-graphql/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = hd(), i = Cd(), r = Ed(), u = [t(vd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], a = { graphql: s };
            n.exports = { languages: u, options: i, printers: a, parsers: r };
          } }), fo = Z({ "src/language-markdown/loc.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return i.position.start.offset;
            }
            function s(i) {
              return i.position.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Ad = Z({ "src/language-markdown/constants.evaluate.js"(e, n) {
            n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
          } }), Kn = Z({ "src/language-markdown/utils.js"(e, n) {
            "use strict";
            ae();
            var { getLast: t } = Ge(), { locStart: s, locEnd: i } = fo(), { cjkPattern: r, kPattern: u, punctuationPattern: a } = Ad(), c = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], l = [...c, "tableCell", "paragraph", "heading"], C = new RegExp(u), m = new RegExp(a);
            function g(A, b) {
              let v = "non-cjk", B = "cj-letter", w = "k-letter", I = "cjk-punctuation", E = [], D = (b.proseWrap === "preserve" ? A : A.replace(new RegExp("(".concat(r, `)
(`).concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
              for (let [y, o] of D.entries()) {
                if (y % 2 === 1) {
                  E.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                  continue;
                }
                if ((y === 0 || y === D.length - 1) && o === "")
                  continue;
                let x = o.split(new RegExp("(".concat(r, ")")));
                for (let [F, S] of x.entries())
                  if (!((F === 0 || F === x.length - 1) && S === "")) {
                    if (F % 2 === 0) {
                      S !== "" && d({ type: "word", value: S, kind: v, hasLeadingPunctuation: m.test(S[0]), hasTrailingPunctuation: m.test(t(S)) });
                      continue;
                    }
                    d(m.test(S) ? { type: "word", value: S, kind: I, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: C.test(S) ? w : B, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                  }
              }
              return E;
              function d(y) {
                let o = t(E);
                o && o.type === "word" && (o.kind === v && y.kind === B && !o.hasTrailingPunctuation || o.kind === B && y.kind === v && !y.hasLeadingPunctuation ? E.push({ type: "whitespace", value: " " }) : !x(v, I) && ![o.value, y.value].some((F) => /\u3000/.test(F)) && E.push({ type: "whitespace", value: "" })), E.push(y);
                function x(F, S) {
                  return o.kind === F && y.kind === S || o.kind === S && y.kind === F;
                }
              }
            }
            function p(A, b) {
              let [, v, B, w] = b.slice(A.position.start.offset, A.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
              return { numberText: v, marker: B, leadingSpaces: w };
            }
            function f(A, b) {
              if (!A.ordered || A.children.length < 2)
                return false;
              let v = Number(p(A.children[0], b.originalText).numberText), B = Number(p(A.children[1], b.originalText).numberText);
              if (v === 0 && A.children.length > 2) {
                let w = Number(p(A.children[2], b.originalText).numberText);
                return B === 1 && w === 1;
              }
              return B === 1;
            }
            function h(A, b) {
              let { value: v } = A;
              return A.position.end.offset === b.length && v.endsWith(`
`) && b.endsWith(`
`) ? v.slice(0, -1) : v;
            }
            function N(A, b) {
              return function v(B, w, I) {
                let E = Object.assign({}, b(B, w, I));
                return E.children && (E.children = E.children.map((D, d) => v(D, d, [E, ...I]))), E;
              }(A, null, []);
            }
            function T(A) {
              if (!A || A.type !== "link" || A.children.length !== 1)
                return false;
              let b = A.children[0];
              return b && s(A) === s(b) && i(A) === i(b);
            }
            n.exports = { mapAst: N, splitText: g, punctuationPattern: a, getFencedCodeBlockValue: h, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: c, INLINE_NODE_WRAPPER_TYPES: l, isAutolink: T };
          } }), Sd = Z({ "src/language-markdown/embed.js"(e, n) {
            "use strict";
            ae();
            var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ge(), { builders: { hardline: i, markAsRoot: r }, utils: { replaceEndOfLine: u } } = Le(), a = Xn(), { getFencedCodeBlockValue: c } = Kn();
            function l(C, m, g, p) {
              let f = C.getValue();
              if (f.type === "code" && f.lang !== null) {
                let h = t(f.lang, p);
                if (h) {
                  let N = p.__inJsTemplate ? "~" : "`", T = N.repeat(Math.max(3, s(f.value, N) + 1)), A = { parser: h };
                  f.lang === "tsx" && (A.filepath = "dummy.tsx");
                  let b = g(c(f, p.originalText), A, { stripTrailingHardline: true });
                  return r([T, f.lang, f.meta ? " " + f.meta : "", i, u(b), i, T]);
                }
              }
              switch (f.type) {
                case "front-matter":
                  return a(f, g);
                case "importExport":
                  return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), i];
                case "jsx":
                  return g("<$>".concat(f.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
              }
              return null;
            }
            n.exports = l;
          } }), Do = Z({ "src/language-markdown/pragma.js"(e, n) {
            "use strict";
            ae();
            var t = po(), s = ["format", "prettier"];
            function i(r) {
              let u = "@(".concat(s.join("|"), ")"), a = new RegExp(["<!--\\s*".concat(u, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"), `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(u, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)].join("|"), "m"), c = r.match(a);
              return c && c.index === 0;
            }
            n.exports = { startWithPragma: i, hasPragma: (r) => i(t(r).content.trimStart()), insertPragma: (r) => {
              let u = t(r), a = "<!-- @".concat(s[0], " -->");
              return u.frontMatter ? "".concat(u.frontMatter.raw, `

`).concat(a, `

`).concat(u.content) : "".concat(a, `

`).concat(u.content);
            } };
          } }), xd = Z({ "src/language-markdown/print-preprocess.js"(e, n) {
            "use strict";
            ae();
            var t = st(), { getOrderedListItemInfo: s, mapAst: i, splitText: r } = Kn(), u = /^.$/su;
            function a(T, A) {
              return T = C(T, A), T = p(T), T = l(T), T = h(T, A), T = N(T, A), T = f(T, A), T = c(T), T = m(T), T;
            }
            function c(T) {
              return i(T, (A) => A.type !== "import" && A.type !== "export" ? A : Object.assign(Object.assign({}, A), {}, { type: "importExport" }));
            }
            function l(T) {
              return i(T, (A) => A.type !== "inlineCode" ? A : Object.assign(Object.assign({}, A), {}, { value: A.value.replace(/\s+/g, " ") }));
            }
            function C(T, A) {
              return i(T, (b) => b.type !== "text" || b.value === "*" || b.value === "_" || !u.test(b.value) || b.position.end.offset - b.position.start.offset === b.value.length ? b : Object.assign(Object.assign({}, b), {}, { value: A.originalText.slice(b.position.start.offset, b.position.end.offset) }));
            }
            function m(T) {
              return g(T, (A, b) => A.type === "importExport" && b.type === "importExport", (A, b) => ({ type: "importExport", value: A.value + `

` + b.value, position: { start: A.position.start, end: b.position.end } }));
            }
            function g(T, A, b) {
              return i(T, (v) => {
                if (!v.children)
                  return v;
                let B = v.children.reduce((w, I) => {
                  let E = t(w);
                  return E && A(E, I) ? w.splice(-1, 1, b(E, I)) : w.push(I), w;
                }, []);
                return Object.assign(Object.assign({}, v), {}, { children: B });
              });
            }
            function p(T) {
              return g(T, (A, b) => A.type === "text" && b.type === "text", (A, b) => ({ type: "text", value: A.value + b.value, position: { start: A.position.start, end: b.position.end } }));
            }
            function f(T, A) {
              return i(T, (b, v, B) => {
                let [w] = B;
                if (b.type !== "text")
                  return b;
                let { value: I } = b;
                return w.type === "paragraph" && (v === 0 && (I = I.trimStart()), v === w.children.length - 1 && (I = I.trimEnd())), { type: "sentence", position: b.position, children: r(I, A) };
              });
            }
            function h(T, A) {
              return i(T, (b, v, B) => {
                if (b.type === "code") {
                  let w = /^\n?(?: {4,}|\t)/.test(A.originalText.slice(b.position.start.offset, b.position.end.offset));
                  if (b.isIndented = w, w)
                    for (let I = 0; I < B.length; I++) {
                      let E = B[I];
                      if (E.hasIndentedCodeblock)
                        break;
                      E.type === "list" && (E.hasIndentedCodeblock = true);
                    }
                }
                return b;
              });
            }
            function N(T, A) {
              return i(T, (B, w, I) => {
                if (B.type === "list" && B.children.length > 0) {
                  for (let E = 0; E < I.length; E++) {
                    let D = I[E];
                    if (D.type === "list" && !D.isAligned)
                      return B.isAligned = false, B;
                  }
                  B.isAligned = v(B);
                }
                return B;
              });
              function b(B) {
                return B.children.length === 0 ? -1 : B.children[0].position.start.column - 1;
              }
              function v(B) {
                if (!B.ordered)
                  return true;
                let [w, I] = B.children;
                if (s(w, A.originalText).leadingSpaces.length > 1)
                  return true;
                let D = b(w);
                if (D === -1)
                  return false;
                if (B.children.length === 1)
                  return D % A.tabWidth === 0;
                let d = b(I);
                return D !== d ? false : D % A.tabWidth === 0 ? true : s(I, A.originalText).leadingSpaces.length > 1;
              }
            }
            n.exports = a;
          } }), bd = Z({ "src/language-markdown/clean.js"(e, n) {
            "use strict";
            ae();
            var { isFrontMatterNode: t } = Ge(), { startWithPragma: s } = Do(), i = /* @__PURE__ */ new Set(["position", "raw"]);
            function r(u, a, c) {
              if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete a.value, u.type === "list" && delete a.isAligned, (u.type === "list" || u.type === "listItem") && (delete a.spread, delete a.loose), u.type === "text" || (u.type === "inlineCode" && (a.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (a.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (a.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (a.title = u.title.replace(/\\(["')])/g, "$1")), c && c.type === "root" && c.children.length > 0 && (c.children[0] === u || t(c.children[0]) && c.children[1] === u) && u.type === "html" && s(u.value)))
                return null;
            }
            r.ignoredProperties = i, n.exports = r;
          } }), Td = Z({ "src/language-markdown/printer-markdown.js"(e, n) {
            "use strict";
            ae();
            var { getLast: t, getMinNotPresentContinuousCount: s, getMaxContinuousCount: i, getStringWidth: r, isNonEmptyArray: u } = Ge(), { builders: { breakParent: a, join: c, line: l, literalline: C, markAsRoot: m, hardline: g, softline: p, ifBreak: f, fill: h, align: N, indent: T, group: A, hardlineWithoutBreakParent: b }, utils: { normalizeDoc: v, replaceTextEndOfLine: B }, printer: { printDocToString: w } } = Le(), I = Sd(), { insertPragma: E } = Do(), { locStart: D, locEnd: d } = fo(), y = xd(), o = bd(), { getFencedCodeBlockValue: x, hasGitDiffFriendlyOrderedList: F, splitText: S, punctuationPattern: k, INLINE_NODE_TYPES: _, INLINE_NODE_WRAPPER_TYPES: O, isAutolink: R } = Kn(), M = /* @__PURE__ */ new Set(["importExport"]), H = ["heading", "tableCell", "link", "wikiLink"], P = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
            function G(fe, pe, me) {
              let ce = fe.getValue();
              if (de(fe))
                return S(pe.originalText.slice(ce.position.start.offset, ce.position.end.offset), pe).map((he) => he.type === "word" ? he.value : he.value === "" ? "" : se(fe, he.value, pe));
              switch (ce.type) {
                case "front-matter":
                  return pe.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                case "root":
                  return ce.children.length === 0 ? "" : [v(oe(fe, pe, me)), M.has(Ee(ce).type) ? "" : g];
                case "paragraph":
                  return K(fe, pe, me, { postprocessor: h });
                case "sentence":
                  return K(fe, pe, me);
                case "word": {
                  let he = ce.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(k, ")(_+)"), "(_+)(".concat(k, "|$)")].join("|"), "g"), (X, Y, te, z, j) => (te ? "".concat(Y).concat(te) : "".concat(z).concat(j)).replace(/_/g, "\\_")), J = (X, Y, te) => X.type === "sentence" && te === 0, ye = (X, Y, te) => R(X.children[te - 1]);
                  return he !== ce.value && (fe.match(void 0, J, ye) || fe.match(void 0, J, (X, Y, te) => X.type === "emphasis" && te === 0, ye)) && (he = he.replace(/^(\\?[*_])+/, (X) => X.replace(/\\/g, ""))), he;
                }
                case "whitespace": {
                  let he = fe.getParentNode(), J = he.children.indexOf(ce), ye = he.children[J + 1], X = ye && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(ye.value) ? "never" : pe.proseWrap;
                  return se(fe, ce.value, { proseWrap: X });
                }
                case "emphasis": {
                  let he;
                  if (R(ce.children[0]))
                    he = pe.originalText[ce.position.start.offset];
                  else {
                    let J = fe.getParentNode(), ye = J.children.indexOf(ce), X = J.children[ye - 1], Y = J.children[ye + 1];
                    he = X && X.type === "sentence" && X.children.length > 0 && t(X.children).type === "word" && !t(X.children).hasTrailingPunctuation || Y && Y.type === "sentence" && Y.children.length > 0 && Y.children[0].type === "word" && !Y.children[0].hasLeadingPunctuation || ne(fe, "emphasis") ? "*" : "_";
                  }
                  return [he, K(fe, pe, me), he];
                }
                case "strong":
                  return ["**", K(fe, pe, me), "**"];
                case "delete":
                  return ["~~", K(fe, pe, me), "~~"];
                case "inlineCode": {
                  let he = s(ce.value, "`"), J = "`".repeat(he || 1), ye = he && !/^\s/.test(ce.value) ? " " : "";
                  return [J, ye, ce.value, ye, J];
                }
                case "wikiLink": {
                  let he = "";
                  return pe.proseWrap === "preserve" ? he = ce.value : he = ce.value.replace(/[\t\n]+/g, " "), ["[[", he, "]]"];
                }
                case "link":
                  switch (pe.originalText[ce.position.start.offset]) {
                    case "<": {
                      let he = "mailto:", J = ce.url.startsWith(he) && pe.originalText.slice(ce.position.start.offset + 1, ce.position.start.offset + 1 + he.length) !== he ? ce.url.slice(he.length) : ce.url;
                      return ["<", J, ">"];
                    }
                    case "[":
                      return ["[", K(fe, pe, me), "](", ge(ce.url, ")"), ve(ce.title, pe), ")"];
                    default:
                      return pe.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                  }
                case "image":
                  return ["![", ce.alt || "", "](", ge(ce.url, ")"), ve(ce.title, pe), ")"];
                case "blockquote":
                  return ["> ", N("> ", K(fe, pe, me))];
                case "heading":
                  return ["#".repeat(ce.depth) + " ", K(fe, pe, me)];
                case "code": {
                  if (ce.isIndented) {
                    let ye = " ".repeat(4);
                    return N(ye, [ye, ...B(ce.value, g)]);
                  }
                  let he = pe.__inJsTemplate ? "~" : "`", J = he.repeat(Math.max(3, i(ce.value, he) + 1));
                  return [J, ce.lang || "", ce.meta ? " " + ce.meta : "", g, ...B(x(ce, pe.originalText), g), g, J];
                }
                case "html": {
                  let he = fe.getParentNode(), J = he.type === "root" && t(he.children) === ce ? ce.value.trimEnd() : ce.value, ye = /^<!--.*-->$/s.test(J);
                  return B(J, ye ? g : m(C));
                }
                case "list": {
                  let he = W(ce, fe.getParentNode()), J = F(ce, pe);
                  return K(fe, pe, me, { processor: (ye, X) => {
                    let Y = z(), te = ye.getValue();
                    if (te.children.length === 2 && te.children[1].type === "html" && te.children[0].position.start.column !== te.children[1].position.start.column)
                      return [Y, re(ye, pe, me, Y)];
                    return [Y, N(" ".repeat(Y.length), re(ye, pe, me, Y))];
                    function z() {
                      let j = ce.ordered ? (X === 0 ? ce.start : J ? 1 : ce.start + X) + (he % 2 === 0 ? ". " : ") ") : he % 2 === 0 ? "- " : "* ";
                      return ce.isAligned || ce.hasIndentedCodeblock ? $(j, pe) : j;
                    }
                  } });
                }
                case "thematicBreak": {
                  let he = U(fe, "list");
                  return he === -1 ? "---" : W(fe.getParentNode(he), fe.getParentNode(he + 1)) % 2 === 0 ? "***" : "---";
                }
                case "linkReference":
                  return ["[", K(fe, pe, me), "]", ce.referenceType === "full" ? ["[", ce.identifier, "]"] : ce.referenceType === "collapsed" ? "[]" : ""];
                case "imageReference":
                  switch (ce.referenceType) {
                    case "full":
                      return ["![", ce.alt || "", "][", ce.identifier, "]"];
                    default:
                      return ["![", ce.alt, "]", ce.referenceType === "collapsed" ? "[]" : ""];
                  }
                case "definition": {
                  let he = pe.proseWrap === "always" ? l : " ";
                  return A(["[", ce.identifier, "]:", T([he, ge(ce.url), ce.title === null ? "" : [he, ve(ce.title, pe, false)]])]);
                }
                case "footnote":
                  return ["[^", K(fe, pe, me), "]"];
                case "footnoteReference":
                  return ["[^", ce.identifier, "]"];
                case "footnoteDefinition": {
                  let he = fe.getParentNode().children[fe.getName() + 1], J = ce.children.length === 1 && ce.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ce.children[0].position.start.line === ce.children[0].position.end.line);
                  return ["[^", ce.identifier, "]: ", J ? K(fe, pe, me) : A([N(" ".repeat(4), K(fe, pe, me, { processor: (ye, X) => X === 0 ? A([p, me()]) : me() })), he && he.type === "footnoteDefinition" ? p : ""])];
                }
                case "table":
                  return V(fe, pe, me);
                case "tableCell":
                  return K(fe, pe, me);
                case "break":
                  return /\s/.test(pe.originalText[ce.position.start.offset]) ? ["  ", m(C)] : ["\\", g];
                case "liquidNode":
                  return B(ce.value, g);
                case "importExport":
                  return [ce.value, g];
                case "esComment":
                  return ["{/* ", ce.value, " */}"];
                case "jsx":
                  return ce.value;
                case "math":
                  return ["$$", g, ce.value ? [...B(ce.value, g), g] : "", "$$"];
                case "inlineMath":
                  return pe.originalText.slice(D(ce), d(ce));
                case "tableRow":
                case "listItem":
                default:
                  throw new Error("Unknown markdown type ".concat(JSON.stringify(ce.type)));
              }
            }
            function re(fe, pe, me, ce) {
              let he = fe.getValue(), J = he.checked === null ? "" : he.checked ? "[x] " : "[ ] ";
              return [J, K(fe, pe, me, { processor: (ye, X) => {
                if (X === 0 && ye.getValue().type !== "list")
                  return N(" ".repeat(J.length), me());
                let Y = " ".repeat(xe(pe.tabWidth - ce.length, 0, 3));
                return [Y, N(Y, me())];
              } })];
            }
            function $(fe, pe) {
              let me = ce();
              return fe + " ".repeat(me >= 4 ? 0 : me);
              function ce() {
                let he = fe.length % pe.tabWidth;
                return he === 0 ? 0 : pe.tabWidth - he;
              }
            }
            function W(fe, pe) {
              return ee(fe, pe, (me) => me.ordered === fe.ordered);
            }
            function ee(fe, pe, me) {
              let ce = -1;
              for (let he of pe.children)
                if (he.type === fe.type && me(he) ? ce++ : ce = -1, he === fe)
                  return ce;
            }
            function U(fe, pe) {
              let me = Array.isArray(pe) ? pe : [pe], ce = -1, he;
              for (; he = fe.getParentNode(++ce); )
                if (me.includes(he.type))
                  return ce;
              return -1;
            }
            function ne(fe, pe) {
              let me = U(fe, pe);
              return me === -1 ? null : fe.getParentNode(me);
            }
            function se(fe, pe, me) {
              if (me.proseWrap === "preserve" && pe === `
`)
                return g;
              let ce = me.proseWrap === "always" && !ne(fe, H);
              return pe !== "" ? ce ? l : " " : ce ? p : "";
            }
            function V(fe, pe, me) {
              let ce = fe.getValue(), he = [], J = fe.map((j) => j.map((Ce, Ne) => {
                let je = w(me(), pe).formatted, Ue = r(je);
                return he[Ne] = Math.max(he[Ne] || 3, Ue), { text: je, width: Ue };
              }, "children"), "children"), ye = Y(false);
              if (pe.proseWrap !== "never")
                return [a, ye];
              let X = Y(true);
              return [a, A(f(X, ye))];
              function Y(j) {
                let Ce = [z(J[0], j), te(j)];
                return J.length > 1 && Ce.push(c(b, J.slice(1).map((Ne) => z(Ne, j)))), c(b, Ce);
              }
              function te(j) {
                let Ce = he.map((Ne, je) => {
                  let Ue = ce.align[je], tt = Ue === "center" || Ue === "left" ? ":" : "-", Te = Ue === "center" || Ue === "right" ? ":" : "-", _e = j ? "-" : "-".repeat(Ne - 2);
                  return "".concat(tt).concat(_e).concat(Te);
                });
                return "| ".concat(Ce.join(" | "), " |");
              }
              function z(j, Ce) {
                let Ne = j.map((je, Ue) => {
                  let { text: tt, width: Te } = je;
                  if (Ce)
                    return tt;
                  let _e = he[Ue] - Te, Fe = ce.align[Ue], Ke = 0;
                  Fe === "right" ? Ke = _e : Fe === "center" && (Ke = Math.floor(_e / 2));
                  let Se = _e - Ke;
                  return "".concat(" ".repeat(Ke)).concat(tt).concat(" ".repeat(Se));
                });
                return "| ".concat(Ne.join(" | "), " |");
              }
            }
            function oe(fe, pe, me) {
              let ce = [], he = null, { children: J } = fe.getValue();
              for (let [ye, X] of J.entries())
                switch (q(X)) {
                  case "start":
                    he === null && (he = { index: ye, offset: X.position.end.offset });
                    break;
                  case "end":
                    he !== null && (ce.push({ start: he, end: { index: ye, offset: X.position.start.offset } }), he = null);
                    break;
                  default:
                    break;
                }
              return K(fe, pe, me, { processor: (ye, X) => {
                if (ce.length > 0) {
                  let Y = ce[0];
                  if (X === Y.start.index)
                    return [J[Y.start.index].value, pe.originalText.slice(Y.start.offset, Y.end.offset), J[Y.end.index].value];
                  if (Y.start.index < X && X < Y.end.index)
                    return false;
                  if (X === Y.end.index)
                    return ce.shift(), false;
                }
                return me();
              } });
            }
            function K(fe, pe, me) {
              let ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: he } = ce, J = ce.processor || (() => me()), ye = fe.getValue(), X = [], Y;
              return fe.each((te, z) => {
                let j = te.getValue(), Ce = J(te, z);
                if (Ce !== false) {
                  let Ne = { parts: X, prevNode: Y, parentNode: ye, options: pe };
                  le(j, Ne) && (X.push(g), Y && M.has(Y.type) || (ue(j, Ne) || Q(j, Ne)) && X.push(g), Q(j, Ne) && X.push(g)), X.push(Ce), Y = j;
                }
              }, "children"), he ? he(X) : X;
            }
            function Ee(fe) {
              let pe = fe;
              for (; u(pe.children); )
                pe = t(pe.children);
              return pe;
            }
            function q(fe) {
              let pe;
              if (fe.type === "html")
                pe = fe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
              else {
                let me;
                fe.type === "esComment" ? me = fe : fe.type === "paragraph" && fe.children.length === 1 && fe.children[0].type === "esComment" && (me = fe.children[0]), me && (pe = me.value.match(/^prettier-ignore(?:-(start|end))?$/));
              }
              return pe ? pe[1] ? pe[1] : "next" : false;
            }
            function le(fe, pe) {
              let me = pe.parts.length === 0, ce = _.includes(fe.type), he = fe.type === "html" && O.includes(pe.parentNode.type);
              return !me && !ce && !he;
            }
            function ue(fe, pe) {
              let ce = (pe.prevNode && pe.prevNode.type) === fe.type && P.has(fe.type), he = pe.parentNode.type === "listItem" && !pe.parentNode.loose, J = pe.prevNode && pe.prevNode.type === "listItem" && pe.prevNode.loose, ye = q(pe.prevNode) === "next", X = fe.type === "html" && pe.prevNode && pe.prevNode.type === "html" && pe.prevNode.position.end.line + 1 === fe.position.start.line, Y = fe.type === "html" && pe.parentNode.type === "listItem" && pe.prevNode && pe.prevNode.type === "paragraph" && pe.prevNode.position.end.line + 1 === fe.position.start.line;
              return J || !(ce || he || ye || X || Y);
            }
            function Q(fe, pe) {
              let me = pe.prevNode && pe.prevNode.type === "list", ce = fe.type === "code" && fe.isIndented;
              return me && ce;
            }
            function de(fe) {
              let pe = ne(fe, ["linkReference", "imageReference"]);
              return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
            }
            function ge(fe) {
              let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], me = [" ", ...Array.isArray(pe) ? pe : [pe]];
              return new RegExp(me.map((ce) => "\\".concat(ce)).join("|")).test(fe) ? "<".concat(fe, ">") : fe;
            }
            function ve(fe, pe) {
              let me = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!fe)
                return "";
              if (me)
                return " " + ve(fe, pe, false);
              if (fe = fe.replace(/\\(["')])/g, "$1"), fe.includes('"') && fe.includes("'") && !fe.includes(")"))
                return "(".concat(fe, ")");
              let ce = fe.split("'").length - 1, he = fe.split('"').length - 1, J = ce > he ? '"' : he > ce || pe.singleQuote ? "'" : '"';
              return fe = fe.replace(/\\/, "\\\\"), fe = fe.replace(new RegExp("(".concat(J, ")"), "g"), "\\$1"), "".concat(J).concat(fe).concat(J);
            }
            function xe(fe, pe, me) {
              return fe < pe ? pe : fe > me ? me : fe;
            }
            function we(fe) {
              let pe = Number(fe.getName());
              if (pe === 0)
                return false;
              let me = fe.getParentNode().children[pe - 1];
              return q(me) === "next";
            }
            n.exports = { preprocess: y, print: G, embed: I, massageAstNode: o, hasPrettierIgnore: we, insertPragma: E };
          } }), Bd = Z({ "src/language-markdown/options.js"(e, n) {
            "use strict";
            ae();
            var t = Lt();
            n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
          } }), Nd = Z({ "src/language-markdown/parsers.js"() {
            ae();
          } }), di = Z({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
            n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
          } }), wd = Z({ "src/language-markdown/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = Td(), i = Bd(), r = Nd(), u = [t(di(), (c) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...c.filenames, "README"], extensions: c.extensions.filter((l) => l !== ".mdx") })), t(di(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], a = { mdast: s };
            n.exports = { languages: u, options: i, printers: a, parsers: r };
          } }), _d = Z({ "src/language-html/clean.js"(e, n) {
            "use strict";
            ae();
            var { isFrontMatterNode: t } = Ge(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "parent"]);
            function i(r, u) {
              if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
                return null;
              r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
            }
            i.ignoredProperties = s, n.exports = i;
          } }), Pd = Z({ "src/language-html/constants.evaluate.js"(e, n) {
            n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
          } }), Id = Z({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
            "use strict";
            ae();
            function t(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            n.exports = t;
          } }), Ot = Z({ "src/language-html/utils/index.js"(e, n) {
            "use strict";
            ae();
            var { inferParserByLanguage: t, isFrontMatterNode: s } = Ge(), { builders: { line: i, hardline: r, join: u }, utils: { getDocParts: a, replaceTextEndOfLine: c } } = Le(), { CSS_DISPLAY_TAGS: l, CSS_DISPLAY_DEFAULT: C, CSS_WHITE_SPACE_TAGS: m, CSS_WHITE_SPACE_DEFAULT: g } = Pd(), p = Id(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), h = (j) => j.replace(/^[\t\n\f\r ]+/, ""), N = (j) => j.replace(/[\t\n\f\r ]+$/, ""), T = (j) => h(N(j)), A = (j) => j.replace(/^[\t\f\r ]*\n/g, ""), b = (j) => A(N(j)), v = (j) => j.split(/[\t\n\f\r ]+/), B = (j) => j.match(/^[\t\n\f\r ]*/)[0], w = (j) => {
              let [, Ce, Ne, je] = j.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
              return { leadingWhitespace: Ce, trailingWhitespace: je, text: Ne };
            }, I = (j) => /[\t\n\f\r ]/.test(j);
            function E(j, Ce) {
              return !!(j.type === "ieConditionalComment" && j.lastChild && !j.lastChild.isSelfClosing && !j.lastChild.endSourceSpan || j.type === "ieConditionalComment" && !j.complete || de(j) && j.children.some((Ne) => Ne.type !== "text" && Ne.type !== "interpolation") || X(j, Ce) && !o(j) && j.type !== "interpolation");
            }
            function D(j) {
              return j.type === "attribute" || !j.parent || !j.prev ? false : d(j.prev);
            }
            function d(j) {
              return j.type === "comment" && j.value.trim() === "prettier-ignore";
            }
            function y(j) {
              return j.type === "text" || j.type === "comment";
            }
            function o(j) {
              return j.type === "element" && (j.fullName === "script" || j.fullName === "style" || j.fullName === "svg:style" || p(j) && (j.name === "script" || j.name === "style"));
            }
            function x(j) {
              return j.children && !o(j);
            }
            function F(j) {
              return o(j) || j.type === "interpolation" || S(j);
            }
            function S(j) {
              return we(j).startsWith("pre");
            }
            function k(j, Ce) {
              let Ne = je();
              if (Ne && !j.prev && j.parent && j.parent.tagDefinition && j.parent.tagDefinition.ignoreFirstLf)
                return j.type === "interpolation";
              return Ne;
              function je() {
                return s(j) ? false : (j.type === "text" || j.type === "interpolation") && j.prev && (j.prev.type === "text" || j.prev.type === "interpolation") ? true : !j.parent || j.parent.cssDisplay === "none" ? false : de(j.parent) ? true : !(!j.prev && (j.parent.type === "root" || de(j) && j.parent || o(j.parent) || J(j.parent, Ce) || !Ee(j.parent.cssDisplay)) || j.prev && !ue(j.prev.cssDisplay));
              }
            }
            function _(j, Ce) {
              return s(j) ? false : (j.type === "text" || j.type === "interpolation") && j.next && (j.next.type === "text" || j.next.type === "interpolation") ? true : !j.parent || j.parent.cssDisplay === "none" ? false : de(j.parent) ? true : !(!j.next && (j.parent.type === "root" || de(j) && j.parent || o(j.parent) || J(j.parent, Ce) || !q(j.parent.cssDisplay)) || j.next && !le(j.next.cssDisplay));
            }
            function O(j) {
              return Q(j.cssDisplay) && !o(j);
            }
            function R(j) {
              return s(j) || j.next && j.sourceSpan.end && j.sourceSpan.end.line + 1 < j.next.sourceSpan.start.line;
            }
            function M(j) {
              return H(j) || j.type === "element" && j.children.length > 0 && (["body", "script", "style"].includes(j.name) || j.children.some((Ce) => ne(Ce))) || j.firstChild && j.firstChild === j.lastChild && j.firstChild.type !== "text" && $(j.firstChild) && (!j.lastChild.isTrailingSpaceSensitive || W(j.lastChild));
            }
            function H(j) {
              return j.type === "element" && j.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(j.name) || j.cssDisplay.startsWith("table") && j.cssDisplay !== "table-cell");
            }
            function P(j) {
              return ee(j) || j.prev && G(j.prev) || re(j);
            }
            function G(j) {
              return ee(j) || j.type === "element" && j.fullName === "br" || re(j);
            }
            function re(j) {
              return $(j) && W(j);
            }
            function $(j) {
              return j.hasLeadingSpaces && (j.prev ? j.prev.sourceSpan.end.line < j.sourceSpan.start.line : j.parent.type === "root" || j.parent.startSourceSpan.end.line < j.sourceSpan.start.line);
            }
            function W(j) {
              return j.hasTrailingSpaces && (j.next ? j.next.sourceSpan.start.line > j.sourceSpan.end.line : j.parent.type === "root" || j.parent.endSourceSpan && j.parent.endSourceSpan.start.line > j.sourceSpan.end.line);
            }
            function ee(j) {
              switch (j.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive":
                  return true;
                case "element":
                  return ["script", "select"].includes(j.name);
              }
              return false;
            }
            function U(j) {
              return j.lastChild ? U(j.lastChild) : j;
            }
            function ne(j) {
              return j.children && j.children.some((Ce) => Ce.type !== "text");
            }
            function se(j) {
              let { type: Ce, lang: Ne } = j.attrMap;
              if (Ce === "module" || Ce === "text/javascript" || Ce === "text/babel" || Ce === "application/javascript" || Ne === "jsx")
                return "babel";
              if (Ce === "application/x-typescript" || Ne === "ts" || Ne === "tsx")
                return "typescript";
              if (Ce === "text/markdown")
                return "markdown";
              if (Ce === "text/html")
                return "html";
              if (Ce && (Ce.endsWith("json") || Ce.endsWith("importmap")))
                return "json";
              if (Ce === "text/x-handlebars-template")
                return "glimmer";
            }
            function V(j) {
              let { lang: Ce } = j.attrMap;
              if (!Ce || Ce === "postcss" || Ce === "css")
                return "css";
              if (Ce === "scss")
                return "scss";
              if (Ce === "less")
                return "less";
            }
            function oe(j, Ce) {
              if (j.name === "script" && !j.attrMap.src)
                return !j.attrMap.lang && !j.attrMap.type ? "babel" : se(j);
              if (j.name === "style")
                return V(j);
              if (Ce && X(j, Ce))
                return se(j) || !("src" in j.attrMap) && t(j.attrMap.lang, Ce);
            }
            function K(j) {
              return j === "block" || j === "list-item" || j.startsWith("table");
            }
            function Ee(j) {
              return !K(j) && j !== "inline-block";
            }
            function q(j) {
              return !K(j) && j !== "inline-block";
            }
            function le(j) {
              return !K(j);
            }
            function ue(j) {
              return !K(j);
            }
            function Q(j) {
              return !K(j) && j !== "inline-block";
            }
            function de(j) {
              return we(j).startsWith("pre");
            }
            function ge(j, Ce) {
              let Ne = 0;
              for (let je = j.stack.length - 1; je >= 0; je--) {
                let Ue = j.stack[je];
                Ue && typeof Ue == "object" && !Array.isArray(Ue) && Ce(Ue) && Ne++;
              }
              return Ne;
            }
            function ve(j, Ce) {
              let Ne = j;
              for (; Ne; ) {
                if (Ce(Ne))
                  return true;
                Ne = Ne.parent;
              }
              return false;
            }
            function xe(j, Ce) {
              if (j.prev && j.prev.type === "comment") {
                let je = j.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (je)
                  return je[1];
              }
              let Ne = false;
              if (j.type === "element" && j.namespace === "svg")
                if (ve(j, (je) => je.fullName === "svg:foreignObject"))
                  Ne = true;
                else
                  return j.name === "svg" ? "inline-block" : "block";
              switch (Ce.htmlWhitespaceSensitivity) {
                case "strict":
                  return "inline";
                case "ignore":
                  return "block";
                default:
                  return Ce.parser === "vue" && j.parent && j.parent.type === "root" ? "block" : j.type === "element" && (!j.namespace || Ne || p(j)) && l[j.name] || C;
              }
            }
            function we(j) {
              return j.type === "element" && (!j.namespace || p(j)) && m[j.name] || g;
            }
            function fe(j) {
              let Ce = Number.POSITIVE_INFINITY;
              for (let Ne of j.split(`
`)) {
                if (Ne.length === 0)
                  continue;
                if (!f.has(Ne[0]))
                  return 0;
                let je = B(Ne).length;
                Ne.length !== je && je < Ce && (Ce = je);
              }
              return Ce === Number.POSITIVE_INFINITY ? 0 : Ce;
            }
            function pe(j) {
              let Ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fe(j);
              return Ce === 0 ? j : j.split(`
`).map((Ne) => Ne.slice(Ce)).join(`
`);
            }
            function me(j, Ce) {
              let Ne = 0;
              for (let je = 0; je < j.length; je++)
                j[je] === Ce && Ne++;
              return Ne;
            }
            function ce(j) {
              return j.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            }
            var he = /* @__PURE__ */ new Set(["template", "style", "script"]);
            function J(j, Ce) {
              return ye(j, Ce) && !he.has(j.fullName);
            }
            function ye(j, Ce) {
              return Ce.parser === "vue" && j.type === "element" && j.parent.type === "root" && j.fullName.toLowerCase() !== "html";
            }
            function X(j, Ce) {
              return ye(j, Ce) && (J(j, Ce) || j.attrMap.lang && j.attrMap.lang !== "html");
            }
            function Y(j) {
              let Ce = j.fullName;
              return Ce.charAt(0) === "#" || Ce === "slot-scope" || Ce === "v-slot" || Ce.startsWith("v-slot:");
            }
            function te(j, Ce) {
              let Ne = j.parent;
              if (!ye(Ne, Ce))
                return false;
              let je = Ne.fullName, Ue = j.fullName;
              return je === "script" && Ue === "setup" || je === "style" && Ue === "vars";
            }
            function z(j) {
              let Ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : j.value;
              return j.parent.isWhitespaceSensitive ? j.parent.isIndentationSensitive ? c(Ce) : c(pe(b(Ce)), r) : a(u(i, v(Ce)));
            }
            n.exports = { htmlTrim: T, htmlTrimPreserveIndentation: b, hasHtmlWhitespace: I, getLeadingAndTrailingHtmlWhitespace: w, canHaveInterpolation: x, countChars: me, countParents: ge, dedentString: pe, forceBreakChildren: H, forceBreakContent: M, forceNextEmptyLine: R, getLastDescendant: U, getNodeCssStyleDisplay: xe, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: D, inferScriptParser: oe, isVueCustomBlock: J, isVueNonHtmlBlock: X, isVueSlotAttribute: Y, isVueSfcBindingsAttribute: te, isDanglingSpaceSensitiveNode: O, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: k, isPreLikeNode: de, isScriptLikeTag: o, isTextLikeNode: y, isTrailingSpaceSensitiveNode: _, isWhitespaceSensitiveNode: F, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: P, preferHardlineAsTrailingSpaces: G, shouldPreserveContent: E, unescapeQuoteEntities: ce, getTextValueParts: z };
          } }), kd = Z({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function n(a) {
              return a >= e.$TAB && a <= e.$SPACE || a == e.$NBSP;
            }
            e.isWhitespace = n;
            function t(a) {
              return e.$0 <= a && a <= e.$9;
            }
            e.isDigit = t;
            function s(a) {
              return a >= e.$a && a <= e.$z || a >= e.$A && a <= e.$Z;
            }
            e.isAsciiLetter = s;
            function i(a) {
              return a >= e.$a && a <= e.$f || a >= e.$A && a <= e.$F || t(a);
            }
            e.isAsciiHexDigit = i;
            function r(a) {
              return a === e.$LF || a === e.$CR;
            }
            e.isNewLine = r;
            function u(a) {
              return e.$0 <= a && a <= e.$7;
            }
            e.isOctalDigit = u;
          } }), Ld = Z({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = class {
              constructor(s, i, r) {
                this.filePath = s, this.name = i, this.members = r;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
              }
            };
            e.StaticSymbol = n;
            var t = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, i, r) {
                r = r || [];
                let u = r.length ? ".".concat(r.join(".")) : "", a = '"'.concat(s, '".').concat(i).concat(u), c = this.cache.get(a);
                return c || (c = new n(s, i, r), this.cache.set(a, c)), c;
              }
            };
            e.StaticSymbolCache = t;
          } }), Od = Z({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = /-+([a-z0-9])/g;
            function t(o) {
              return o.replace(n, function() {
                for (var x = arguments.length, F = new Array(x), S = 0; S < x; S++)
                  F[S] = arguments[S];
                return F[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = t;
            function s(o, x) {
              return r(o, ":", x);
            }
            e.splitAtColon = s;
            function i(o, x) {
              return r(o, ".", x);
            }
            e.splitAtPeriod = i;
            function r(o, x, F) {
              let S = o.indexOf(x);
              return S == -1 ? F : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
            }
            function u(o, x, F) {
              return Array.isArray(o) ? x.visitArray(o, F) : A(o) ? x.visitStringMap(o, F) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? x.visitPrimitive(o, F) : x.visitOther(o, F);
            }
            e.visitValue = u;
            function a(o) {
              return o != null;
            }
            e.isDefined = a;
            function c(o) {
              return o === void 0 ? null : o;
            }
            e.noUndefined = c;
            var l = class {
              visitArray(o, x) {
                return o.map((F) => u(F, this, x));
              }
              visitStringMap(o, x) {
                let F = {};
                return Object.keys(o).forEach((S) => {
                  F[S] = u(o[S], this, x);
                }), F;
              }
              visitPrimitive(o, x) {
                return o;
              }
              visitOther(o, x) {
                return o;
              }
            };
            e.ValueTransformer = l, e.SyncAsync = { assertSync: (o) => {
              if (w(o))
                throw new Error("Illegal state: value cannot be a promise");
              return o;
            }, then: (o, x) => w(o) ? o.then(x) : x(o), all: (o) => o.some(w) ? Promise.all(o) : o };
            function C(o) {
              throw new Error("Internal Error: ".concat(o));
            }
            e.error = C;
            function m(o, x) {
              let F = Error(o);
              return F[g] = true, x && (F[p] = x), F;
            }
            e.syntaxError = m;
            var g = "ngSyntaxError", p = "ngParseErrors";
            function f(o) {
              return o[g];
            }
            e.isSyntaxError = f;
            function h(o) {
              return o[p] || [];
            }
            e.getParseErrors = h;
            function N(o) {
              return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = N;
            var T = Object.getPrototypeOf({});
            function A(o) {
              return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === T;
            }
            function b(o) {
              let x = "";
              for (let F = 0; F < o.length; F++) {
                let S = o.charCodeAt(F);
                if (S >= 55296 && S <= 56319 && o.length > F + 1) {
                  let k = o.charCodeAt(F + 1);
                  k >= 56320 && k <= 57343 && (F++, S = (S - 55296 << 10) + k - 56320 + 65536);
                }
                S <= 127 ? x += String.fromCharCode(S) : S <= 2047 ? x += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? x += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (x += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
              }
              return x;
            }
            e.utf8Encode = b;
            function v(o) {
              if (typeof o == "string")
                return o;
              if (o instanceof Array)
                return "[" + o.map(v).join(", ") + "]";
              if (o == null)
                return "" + o;
              if (o.overriddenName)
                return "".concat(o.overriddenName);
              if (o.name)
                return "".concat(o.name);
              if (!o.toString)
                return "object";
              let x = o.toString();
              if (x == null)
                return "" + x;
              let F = x.indexOf(`
`);
              return F === -1 ? x : x.substring(0, F);
            }
            e.stringify = v;
            function B(o) {
              return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
            }
            e.resolveForwardRef = B;
            function w(o) {
              return !!o && typeof o.then == "function";
            }
            e.isPromise = w;
            var I = class {
              constructor(o) {
                this.full = o;
                let x = o.split(".");
                this.major = x[0], this.minor = x[1], this.patch = x.slice(2).join(".");
              }
            };
            e.Version = I;
            var E = typeof window < "u" && window, D = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, d = typeof globalThis < "u" && globalThis, y = d || E || D;
            e.global = y;
          } }), jd = Z({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Ld(), t = Od(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function i(F) {
              return F.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = i;
            var r = 0;
            function u(F) {
              if (!F || !F.reference)
                return null;
              let S = F.reference;
              if (S instanceof n.StaticSymbol)
                return S.name;
              if (S.__anonymousType)
                return S.__anonymousType;
              let k = t.stringify(S);
              return k.indexOf("(") >= 0 ? (k = "anonymous_".concat(r++), S.__anonymousType = k) : k = i(k), k;
            }
            e.identifierName = u;
            function a(F) {
              let S = F.reference;
              return S instanceof n.StaticSymbol ? S.filePath : "./".concat(t.stringify(S));
            }
            e.identifierModuleUrl = a;
            function c(F, S) {
              return "View_".concat(u({ reference: F }), "_").concat(S);
            }
            e.viewClassName = c;
            function l(F) {
              return "RenderType_".concat(u({ reference: F }));
            }
            e.rendererTypeName = l;
            function C(F) {
              return "HostView_".concat(u({ reference: F }));
            }
            e.hostViewClassName = C;
            function m(F) {
              return "".concat(u({ reference: F }), "NgFactory");
            }
            e.componentFactoryName = m;
            var g;
            (function(F) {
              F[F.Pipe = 0] = "Pipe", F[F.Directive = 1] = "Directive", F[F.NgModule = 2] = "NgModule", F[F.Injectable = 3] = "Injectable";
            })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function p(F) {
              return F.value != null ? i(F.value) : u(F.identifier);
            }
            e.tokenName = p;
            function f(F) {
              return F.identifier != null ? F.identifier.reference : F.value;
            }
            e.tokenReference = f;
            var h = class {
              constructor() {
                let { moduleUrl: F, styles: S, styleUrls: k } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = F || null, this.styles = w(S), this.styleUrls = w(k);
              }
            };
            e.CompileStylesheetMetadata = h;
            var N = class {
              constructor(F) {
                let { encapsulation: S, template: k, templateUrl: _, htmlAst: O, styles: R, styleUrls: M, externalStylesheets: H, animations: P, ngContentSelectors: G, interpolation: re, isInline: $, preserveWhitespaces: W } = F;
                if (this.encapsulation = S, this.template = k, this.templateUrl = _, this.htmlAst = O, this.styles = w(R), this.styleUrls = w(M), this.externalStylesheets = w(H), this.animations = P ? E(P) : [], this.ngContentSelectors = G || [], re && re.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = re, this.isInline = $, this.preserveWhitespaces = W;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = N;
            var T = class {
              static create(F) {
                let { isHost: S, type: k, isComponent: _, selector: O, exportAs: R, changeDetection: M, inputs: H, outputs: P, host: G, providers: re, viewProviders: $, queries: W, guards: ee, viewQueries: U, entryComponents: ne, template: se, componentViewType: V, rendererType: oe, componentFactory: K } = F, Ee = {}, q = {}, le = {};
                G != null && Object.keys(G).forEach((de) => {
                  let ge = G[de], ve = de.match(s);
                  ve === null ? le[de] = ge : ve[1] != null ? q[ve[1]] = ge : ve[2] != null && (Ee[ve[2]] = ge);
                });
                let ue = {};
                H != null && H.forEach((de) => {
                  let ge = t.splitAtColon(de, [de, de]);
                  ue[ge[0]] = ge[1];
                });
                let Q = {};
                return P != null && P.forEach((de) => {
                  let ge = t.splitAtColon(de, [de, de]);
                  Q[ge[0]] = ge[1];
                }), new T({ isHost: S, type: k, isComponent: !!_, selector: O, exportAs: R, changeDetection: M, inputs: ue, outputs: Q, hostListeners: Ee, hostProperties: q, hostAttributes: le, providers: re, viewProviders: $, queries: W, guards: ee, viewQueries: U, entryComponents: ne, template: se, componentViewType: V, rendererType: oe, componentFactory: K });
              }
              constructor(F) {
                let { isHost: S, type: k, isComponent: _, selector: O, exportAs: R, changeDetection: M, inputs: H, outputs: P, hostListeners: G, hostProperties: re, hostAttributes: $, providers: W, viewProviders: ee, queries: U, guards: ne, viewQueries: se, entryComponents: V, template: oe, componentViewType: K, rendererType: Ee, componentFactory: q } = F;
                this.isHost = !!S, this.type = k, this.isComponent = _, this.selector = O, this.exportAs = R, this.changeDetection = M, this.inputs = H, this.outputs = P, this.hostListeners = G, this.hostProperties = re, this.hostAttributes = $, this.providers = w(W), this.viewProviders = w(ee), this.queries = w(U), this.guards = ne, this.viewQueries = w(se), this.entryComponents = w(V), this.template = oe, this.componentViewType = K, this.rendererType = Ee, this.componentFactory = q;
              }
              toSummary() {
                return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = T;
            var A = class {
              constructor(F) {
                let { type: S, name: k, pure: _ } = F;
                this.type = S, this.name = k, this.pure = !!_;
              }
              toSummary() {
                return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = A;
            var b = class {
            };
            e.CompileShallowModuleMetadata = b;
            var v = class {
              constructor(F) {
                let { type: S, providers: k, declaredDirectives: _, exportedDirectives: O, declaredPipes: R, exportedPipes: M, entryComponents: H, bootstrapComponents: P, importedModules: G, exportedModules: re, schemas: $, transitiveModule: W, id: ee } = F;
                this.type = S || null, this.declaredDirectives = w(_), this.exportedDirectives = w(O), this.declaredPipes = w(R), this.exportedPipes = w(M), this.providers = w(k), this.entryComponents = w(H), this.bootstrapComponents = w(P), this.importedModules = w(G), this.exportedModules = w(re), this.schemas = w($), this.id = ee || null, this.transitiveModule = W || null;
              }
              toSummary() {
                let F = this.transitiveModule;
                return { summaryKind: g.NgModule, type: this.type, entryComponents: F.entryComponents, providers: F.providers, modules: F.modules, exportedDirectives: F.exportedDirectives, exportedPipes: F.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = v;
            var B = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(F, S) {
                this.providers.push({ provider: F, module: S });
              }
              addDirective(F) {
                this.directivesSet.has(F.reference) || (this.directivesSet.add(F.reference), this.directives.push(F));
              }
              addExportedDirective(F) {
                this.exportedDirectivesSet.has(F.reference) || (this.exportedDirectivesSet.add(F.reference), this.exportedDirectives.push(F));
              }
              addPipe(F) {
                this.pipesSet.has(F.reference) || (this.pipesSet.add(F.reference), this.pipes.push(F));
              }
              addExportedPipe(F) {
                this.exportedPipesSet.has(F.reference) || (this.exportedPipesSet.add(F.reference), this.exportedPipes.push(F));
              }
              addModule(F) {
                this.modulesSet.has(F.reference) || (this.modulesSet.add(F.reference), this.modules.push(F));
              }
              addEntryComponent(F) {
                this.entryComponentsSet.has(F.componentType) || (this.entryComponentsSet.add(F.componentType), this.entryComponents.push(F));
              }
            };
            e.TransitiveCompileNgModuleMetadata = B;
            function w(F) {
              return F || [];
            }
            var I = class {
              constructor(F, S) {
                let { useClass: k, useValue: _, useExisting: O, useFactory: R, deps: M, multi: H } = S;
                this.token = F, this.useClass = k || null, this.useValue = _, this.useExisting = O, this.useFactory = R || null, this.dependencies = M || null, this.multi = !!H;
              }
            };
            e.ProviderMeta = I;
            function E(F) {
              return F.reduce((S, k) => {
                let _ = Array.isArray(k) ? E(k) : k;
                return S.concat(_);
              }, []);
            }
            e.flatten = E;
            function D(F) {
              return F.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function d(F, S, k) {
              let _;
              return k.isInline ? S.type.reference instanceof n.StaticSymbol ? _ = "".concat(S.type.reference.filePath, ".").concat(S.type.reference.name, ".html") : _ = "".concat(u(F), "/").concat(u(S.type), ".html") : _ = k.templateUrl, S.type.reference instanceof n.StaticSymbol ? _ : D(_);
            }
            e.templateSourceUrl = d;
            function y(F, S) {
              let k = F.moduleUrl.split(/\/\\/g), _ = k[k.length - 1];
              return D("css/".concat(S).concat(_, ".ngstyle.js"));
            }
            e.sharedStylesheetJitUrl = y;
            function o(F) {
              return D("".concat(u(F.type), "/module.ngfactory.js"));
            }
            e.ngModuleJitUrl = o;
            function x(F, S) {
              return D("".concat(u(F), "/").concat(u(S.type), ".ngfactory.js"));
            }
            e.templateJitUrl = x;
          } }), qd = Z({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            ae(), Object.defineProperty(e, "__esModule", { value: true });
            var n = kd(), t = jd(), s = class {
              constructor(C, m, g, p) {
                this.file = C, this.offset = m, this.line = g, this.col = p;
              }
              toString() {
                return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
              }
              moveBy(C) {
                let m = this.file.content, g = m.length, p = this.offset, f = this.line, h = this.col;
                for (; p > 0 && C < 0; )
                  if (p--, C++, m.charCodeAt(p) == n.$LF) {
                    f--;
                    let T = m.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                    h = T > 0 ? p - T : p;
                  } else
                    h--;
                for (; p < g && C > 0; ) {
                  let N = m.charCodeAt(p);
                  p++, C--, N == n.$LF ? (f++, h = 0) : h++;
                }
                return new s(this.file, p, f, h);
              }
              getContext(C, m) {
                let g = this.file.content, p = this.offset;
                if (p != null) {
                  p > g.length - 1 && (p = g.length - 1);
                  let f = p, h = 0, N = 0;
                  for (; h < C && p > 0 && (p--, h++, !(g[p] == `
` && ++N == m)); )
                    ;
                  for (h = 0, N = 0; h < C && f < g.length - 1 && (f++, h++, !(g[f] == `
` && ++N == m)); )
                    ;
                  return { before: g.substring(p, this.offset), after: g.substring(this.offset, f + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var i = class {
              constructor(C, m) {
                this.content = C, this.url = m;
              }
            };
            e.ParseSourceFile = i;
            var r = class {
              constructor(C, m) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = C, this.end = m, this.details = g;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new i("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var u;
            (function(C) {
              C[C.WARNING = 0] = "WARNING", C[C.ERROR = 1] = "ERROR";
            })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var a = class {
              constructor(C, m) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                this.span = C, this.msg = m, this.level = g;
              }
              contextualMessage() {
                let C = this.span.start.getContext(100, 3);
                return C ? "".concat(this.msg, ' ("').concat(C.before, "[").concat(u[this.level], " ->]").concat(C.after, '")') : this.msg;
              }
              toString() {
                let C = this.span.details ? ", ".concat(this.span.details) : "";
                return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(C);
              }
            };
            e.ParseError = a;
            function c(C, m) {
              let g = t.identifierModuleUrl(m), p = g != null ? "in ".concat(C, " ").concat(t.identifierName(m), " in ").concat(g) : "in ".concat(C, " ").concat(t.identifierName(m)), f = new i("", p);
              return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.typeSourceSpan = c;
            function l(C, m, g) {
              let p = "in ".concat(C, " ").concat(m, " in ").concat(g), f = new i("", p);
              return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = l;
          } }), Md = Z({ "src/language-html/print-preprocess.js"(e, n) {
            "use strict";
            ae();
            var { ParseSourceSpan: t } = qd(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: i, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: a, isDanglingSpaceSensitiveNode: c, isIndentationSensitiveNode: l, isLeadingSpaceSensitiveNode: C, isTrailingSpaceSensitiveNode: m, isWhitespaceSensitiveNode: g } = Ot(), p = [h, N, A, v, B, E, w, I, D, b];
            function f(d, y) {
              for (let o of p)
                o(d, y);
              return d;
            }
            function h(d) {
              d.walk((y) => {
                if (y.type === "element" && y.tagDefinition.ignoreFirstLf && y.children.length > 0 && y.children[0].type === "text" && y.children[0].value[0] === `
`) {
                  let o = y.children[0];
                  o.value.length === 1 ? y.removeChild(o) : o.value = o.value.slice(1);
                }
              });
            }
            function N(d) {
              let y = (o) => o.type === "element" && o.prev && o.prev.type === "ieConditionalStartComment" && o.prev.sourceSpan.end.offset === o.startSourceSpan.start.offset && o.firstChild && o.firstChild.type === "ieConditionalEndComment" && o.firstChild.sourceSpan.start.offset === o.startSourceSpan.end.offset;
              d.walk((o) => {
                if (o.children)
                  for (let x = 0; x < o.children.length; x++) {
                    let F = o.children[x];
                    if (!y(F))
                      continue;
                    let S = F.prev, k = F.firstChild;
                    o.removeChild(S), x--;
                    let _ = new t(S.sourceSpan.start, k.sourceSpan.end), O = new t(_.start, F.sourceSpan.end);
                    F.condition = S.condition, F.sourceSpan = O, F.startSourceSpan = _, F.removeChild(k);
                  }
              });
            }
            function T(d, y, o) {
              d.walk((x) => {
                if (x.children)
                  for (let F = 0; F < x.children.length; F++) {
                    let S = x.children[F];
                    if (S.type !== "text" && !y(S))
                      continue;
                    S.type !== "text" && (S.type = "text", S.value = o(S));
                    let k = S.prev;
                    !k || k.type !== "text" || (k.value += S.value, k.sourceSpan = new t(k.sourceSpan.start, S.sourceSpan.end), x.removeChild(S), F--);
                  }
              });
            }
            function A(d) {
              return T(d, (y) => y.type === "cdata", (y) => "<![CDATA[".concat(y.value, "]]>"));
            }
            function b(d) {
              let y = (o) => o.type === "element" && o.attrs.length === 0 && o.children.length === 1 && o.firstChild.type === "text" && !r(o.children[0].value) && !o.firstChild.hasLeadingSpaces && !o.firstChild.hasTrailingSpaces && o.isLeadingSpaceSensitive && !o.hasLeadingSpaces && o.isTrailingSpaceSensitive && !o.hasTrailingSpaces && o.prev && o.prev.type === "text" && o.next && o.next.type === "text";
              d.walk((o) => {
                if (o.children)
                  for (let x = 0; x < o.children.length; x++) {
                    let F = o.children[x];
                    if (!y(F))
                      continue;
                    let S = F.prev, k = F.next;
                    S.value += "<".concat(F.rawName, ">") + F.firstChild.value + "</".concat(F.rawName, ">") + k.value, S.sourceSpan = new t(S.sourceSpan.start, k.sourceSpan.end), S.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, S.hasTrailingSpaces = k.hasTrailingSpaces, o.removeChild(F), x--, o.removeChild(k);
                  }
              });
            }
            function v(d, y) {
              if (y.parser === "html")
                return;
              let o = /{{(.+?)}}/s;
              d.walk((x) => {
                if (!!u(x))
                  for (let F of x.children) {
                    if (F.type !== "text")
                      continue;
                    let S = F.sourceSpan.start, k = null, _ = F.value.split(o);
                    for (let O = 0; O < _.length; O++, S = k) {
                      let R = _[O];
                      if (O % 2 === 0) {
                        k = S.moveBy(R.length), R.length > 0 && x.insertChildBefore(F, { type: "text", value: R, sourceSpan: new t(S, k) });
                        continue;
                      }
                      k = S.moveBy(R.length + 4), x.insertChildBefore(F, { type: "interpolation", sourceSpan: new t(S, k), children: R.length === 0 ? [] : [{ type: "text", value: R, sourceSpan: new t(S.moveBy(2), k.moveBy(-2)) }] });
                    }
                    x.removeChild(F);
                  }
              });
            }
            function B(d) {
              d.walk((y) => {
                if (!y.children)
                  return;
                if (y.children.length === 0 || y.children.length === 1 && y.children[0].type === "text" && s(y.children[0].value).length === 0) {
                  y.hasDanglingSpaces = y.children.length > 0, y.children = [];
                  return;
                }
                let o = g(y), x = l(y);
                if (!o)
                  for (let F = 0; F < y.children.length; F++) {
                    let S = y.children[F];
                    if (S.type !== "text")
                      continue;
                    let { leadingWhitespace: k, text: _, trailingWhitespace: O } = i(S.value), R = S.prev, M = S.next;
                    _ ? (S.value = _, S.sourceSpan = new t(S.sourceSpan.start.moveBy(k.length), S.sourceSpan.end.moveBy(-O.length)), k && (R && (R.hasTrailingSpaces = true), S.hasLeadingSpaces = true), O && (S.hasTrailingSpaces = true, M && (M.hasLeadingSpaces = true))) : (y.removeChild(S), F--, (k || O) && (R && (R.hasTrailingSpaces = true), M && (M.hasLeadingSpaces = true)));
                  }
                y.isWhitespaceSensitive = o, y.isIndentationSensitive = x;
              });
            }
            function w(d) {
              d.walk((y) => {
                y.isSelfClosing = !y.children || y.type === "element" && (y.tagDefinition.isVoid || y.startSourceSpan === y.endSourceSpan);
              });
            }
            function I(d, y) {
              d.walk((o) => {
                o.type === "element" && (o.hasHtmComponentClosingTag = o.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(y.originalText.slice(o.endSourceSpan.start.offset, o.endSourceSpan.end.offset)));
              });
            }
            function E(d, y) {
              d.walk((o) => {
                o.cssDisplay = a(o, y);
              });
            }
            function D(d, y) {
              d.walk((o) => {
                let { children: x } = o;
                if (!!x) {
                  if (x.length === 0) {
                    o.isDanglingSpaceSensitive = c(o);
                    return;
                  }
                  for (let F of x)
                    F.isLeadingSpaceSensitive = C(F, y), F.isTrailingSpaceSensitive = m(F, y);
                  for (let F = 0; F < x.length; F++) {
                    let S = x[F];
                    S.isLeadingSpaceSensitive = (F === 0 || S.prev.isTrailingSpaceSensitive) && S.isLeadingSpaceSensitive, S.isTrailingSpaceSensitive = (F === x.length - 1 || S.next.isLeadingSpaceSensitive) && S.isTrailingSpaceSensitive;
                  }
                }
              });
            }
            n.exports = f;
          } }), Rd = Z({ "src/language-html/pragma.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(i);
            }
            function s(i) {
              return `<!-- @format -->

` + i.replace(/^\s*\n/, "");
            }
            n.exports = { hasPragma: t, insertPragma: s };
          } }), Yn = Z({ "src/language-html/loc.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return i.sourceSpan.start.offset;
            }
            function s(i) {
              return i.sourceSpan.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Qt = Z({ "src/language-html/print/tag.js"(e, n) {
            "use strict";
            ae();
            var t = Ut(), { isNonEmptyArray: s } = Ge(), { builders: { indent: i, join: r, line: u, softline: a, hardline: c }, utils: { replaceTextEndOfLine: l } } = Le(), { locStart: C, locEnd: m } = Yn(), { isTextLikeNode: g, getLastDescendant: p, isPreLikeNode: f, hasPrettierIgnore: h, shouldPreserveContent: N } = Ot();
            function T(P, G) {
              return [P.isSelfClosing ? "" : A(P, G), b(P, G)];
            }
            function A(P, G) {
              return P.lastChild && y(P.lastChild) ? "" : [v(P, G), w(P, G)];
            }
            function b(P, G) {
              return (P.next ? D(P.next) : d(P.parent)) ? "" : [I(P, G), B(P, G)];
            }
            function v(P, G) {
              return d(P) ? I(P.lastChild, G) : "";
            }
            function B(P, G) {
              return y(P) ? w(P.parent, G) : o(P) ? M(P.next) : "";
            }
            function w(P, G) {
              if (t(!P.isSelfClosing), E(P, G))
                return "";
              switch (P.type) {
                case "ieConditionalComment":
                  return "<!";
                case "element":
                  if (P.hasHtmComponentClosingTag)
                    return "<//";
                default:
                  return "</".concat(P.rawName);
              }
            }
            function I(P, G) {
              if (E(P, G))
                return "";
              switch (P.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment":
                  return "[endif]-->";
                case "ieConditionalStartComment":
                  return "]><!-->";
                case "interpolation":
                  return "}}";
                case "element":
                  if (P.isSelfClosing)
                    return "/>";
                default:
                  return ">";
              }
            }
            function E(P, G) {
              return !P.isSelfClosing && !P.endSourceSpan && (h(P) || N(P.parent, G));
            }
            function D(P) {
              return P.prev && P.prev.type !== "docType" && !g(P.prev) && P.isLeadingSpaceSensitive && !P.hasLeadingSpaces;
            }
            function d(P) {
              return P.lastChild && P.lastChild.isTrailingSpaceSensitive && !P.lastChild.hasTrailingSpaces && !g(p(P.lastChild)) && !f(P);
            }
            function y(P) {
              return !P.next && !P.hasTrailingSpaces && P.isTrailingSpaceSensitive && g(p(P));
            }
            function o(P) {
              return P.next && !g(P.next) && g(P) && P.isTrailingSpaceSensitive && !P.hasTrailingSpaces;
            }
            function x(P) {
              let G = P.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
              return G ? G[1] ? G[1].split(/\s+/) : true : false;
            }
            function F(P) {
              return !P.prev && P.isLeadingSpaceSensitive && !P.hasLeadingSpaces;
            }
            function S(P, G, re) {
              let $ = P.getValue();
              if (!s($.attrs))
                return $.isSelfClosing ? " " : "";
              let W = $.prev && $.prev.type === "comment" && x($.prev.value), ee = typeof W == "boolean" ? () => W : Array.isArray(W) ? (oe) => W.includes(oe.rawName) : () => false, U = P.map((oe) => {
                let K = oe.getValue();
                return ee(K) ? l(G.originalText.slice(C(K), m(K))) : re();
              }, "attrs"), ne = $.type === "element" && $.fullName === "script" && $.attrs.length === 1 && $.attrs[0].fullName === "src" && $.children.length === 0, se = G.singleAttributePerLine && $.attrs.length > 1 ? c : u, V = [i([ne ? " " : u, r(se, U)])];
              return $.firstChild && F($.firstChild) || $.isSelfClosing && d($.parent) || ne ? V.push($.isSelfClosing ? " " : "") : V.push(G.bracketSameLine ? $.isSelfClosing ? " " : "" : $.isSelfClosing ? u : a), V;
            }
            function k(P) {
              return P.firstChild && F(P.firstChild) ? "" : H(P);
            }
            function _(P, G, re) {
              let $ = P.getValue();
              return [O($, G), S(P, G, re), $.isSelfClosing ? "" : k($)];
            }
            function O(P, G) {
              return P.prev && o(P.prev) ? "" : [R(P, G), M(P)];
            }
            function R(P, G) {
              return F(P) ? H(P.parent) : D(P) ? I(P.prev, G) : "";
            }
            function M(P) {
              switch (P.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment":
                  return "<!--[if ".concat(P.condition);
                case "ieConditionalEndComment":
                  return "<!--<!";
                case "interpolation":
                  return "{{";
                case "docType":
                  return "<!DOCTYPE";
                case "element":
                  if (P.condition)
                    return "<!--[if ".concat(P.condition, "]><!--><").concat(P.rawName);
                default:
                  return "<".concat(P.rawName);
              }
            }
            function H(P) {
              switch (t(!P.isSelfClosing), P.type) {
                case "ieConditionalComment":
                  return "]>";
                case "element":
                  if (P.condition)
                    return "><!--<![endif]-->";
                default:
                  return ">";
              }
            }
            n.exports = { printClosingTag: T, printClosingTagStart: A, printClosingTagStartMarker: w, printClosingTagEndMarker: I, printClosingTagSuffix: B, printClosingTagEnd: b, needsToBorrowLastChildClosingTagEndMarker: d, needsToBorrowParentClosingTagStartMarker: y, needsToBorrowPrevClosingTagEndMarker: D, printOpeningTag: _, printOpeningTagStart: O, printOpeningTagPrefix: R, printOpeningTagStartMarker: M, printOpeningTagEndMarker: H, needsToBorrowNextOpeningTagStartMarker: o, needsToBorrowParentOpeningTagEndMarker: F };
          } }), Vd = Z({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
            ae(), function(t, s) {
              typeof define == "function" && define.amd ? define([], s) : typeof n == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
            }(e, function() {
              return function(t, s) {
                var i = s && s.logger || console;
                function r(I) {
                  return I === " " || I === "	" || I === `
` || I === "\f" || I === "\r";
                }
                function u(I) {
                  var E, D = I.exec(t.substring(b));
                  if (D)
                    return E = D[0], b += E.length, E;
                }
                for (var a = t.length, c = /^[ \t\n\r\u000c]+/, l = /^[, \t\n\r\u000c]+/, C = /^[^ \t\n\r\u000c]+/, m = /[,]+$/, g = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h, N, T, A, b = 0, v = []; ; ) {
                  if (u(l), b >= a)
                    return v;
                  f = u(C), h = [], f.slice(-1) === "," ? (f = f.replace(m, ""), w()) : B();
                }
                function B() {
                  for (u(c), N = "", T = "in descriptor"; ; ) {
                    if (A = t.charAt(b), T === "in descriptor")
                      if (r(A))
                        N && (h.push(N), N = "", T = "after descriptor");
                      else if (A === ",") {
                        b += 1, N && h.push(N), w();
                        return;
                      } else if (A === "(")
                        N = N + A, T = "in parens";
                      else if (A === "") {
                        N && h.push(N), w();
                        return;
                      } else
                        N = N + A;
                    else if (T === "in parens")
                      if (A === ")")
                        N = N + A, T = "in descriptor";
                      else if (A === "") {
                        h.push(N), w();
                        return;
                      } else
                        N = N + A;
                    else if (T === "after descriptor" && !r(A))
                      if (A === "") {
                        w();
                        return;
                      } else
                        T = "in descriptor", b -= 1;
                    b += 1;
                  }
                }
                function w() {
                  var I = false, E, D, d, y, o = {}, x, F, S, k, _;
                  for (y = 0; y < h.length; y++)
                    x = h[y], F = x[x.length - 1], S = x.substring(0, x.length - 1), k = parseInt(S, 10), _ = parseFloat(S), g.test(S) && F === "w" ? ((E || D) && (I = true), k === 0 ? I = true : E = k) : p.test(S) && F === "x" ? ((E || D || d) && (I = true), _ < 0 ? I = true : D = _) : g.test(S) && F === "h" ? ((d || D) && (I = true), k === 0 ? I = true : d = k) : I = true;
                  I ? i && i.error && i.error("Invalid srcset descriptor found in '" + t + "' at '" + x + "'.") : (o.url = f, E && (o.w = E), D && (o.d = D), d && (o.h = d), v.push(o));
                }
              };
            });
          } }), Wd = Z({ "src/language-html/syntax-attribute.js"(e, n) {
            "use strict";
            ae();
            var t = Vd(), { builders: { ifBreak: s, join: i, line: r } } = Le();
            function u(c) {
              let l = t(c, { logger: { error(B) {
                throw new Error(B);
              } } }), C = l.some((B) => {
                let { w } = B;
                return w;
              }), m = l.some((B) => {
                let { h: w } = B;
                return w;
              }), g = l.some((B) => {
                let { d: w } = B;
                return w;
              });
              if (C + m + g > 1)
                throw new Error("Mixed descriptor in srcset is not supported");
              let p = C ? "w" : m ? "h" : "d", f = C ? "w" : m ? "h" : "x", h = (B) => Math.max(...B), N = l.map((B) => B.url), T = h(N.map((B) => B.length)), A = l.map((B) => B[p]).map((B) => B ? B.toString() : ""), b = A.map((B) => {
                let w = B.indexOf(".");
                return w === -1 ? B.length : w;
              }), v = h(b);
              return i([",", r], N.map((B, w) => {
                let I = [B], E = A[w];
                if (E) {
                  let D = T - B.length + 1, d = v - b[w], y = " ".repeat(D + d);
                  I.push(s(y, " "), E + f);
                }
                return I;
              }));
            }
            function a(c) {
              return c.trim().split(/\s+/).join(" ");
            }
            n.exports = { printImgSrcset: u, printClassNames: a };
          } }), $d = Z({ "src/language-html/syntax-vue.js"(e, n) {
            "use strict";
            ae();
            var { builders: { group: t } } = Le();
            function s(a, c) {
              let { left: l, operator: C, right: m } = i(a);
              return [t(c("function _(".concat(l, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", C, " ", c(m, { parser: "__js_expression" }, { stripTrailingHardline: true })];
            }
            function i(a) {
              let c = /(.*?)\s+(in|of)\s+(.*)/s, l = /,([^,\]}]*)(?:,([^,\]}]*))?$/, C = /^\(|\)$/g, m = a.match(c);
              if (!m)
                return;
              let g = {};
              if (g.for = m[3].trim(), !g.for)
                return;
              let p = m[1].trim().replace(C, ""), f = p.match(l);
              f ? (g.alias = p.replace(l, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = p;
              let h = [g.alias, g.iterator1, g.iterator2];
              if (!h.some((N, T) => !N && (T === 0 || h.slice(T + 1).some(Boolean))))
                return { left: h.filter(Boolean).join(","), operator: m[2], right: g.for };
            }
            function r(a, c) {
              return c("function _(".concat(a, ") {}"), { parser: "babel", __isVueBindings: true });
            }
            function u(a) {
              let c = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, l = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, C = a.trim();
              return c.test(C) || l.test(C);
            }
            n.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: r };
          } }), mo = Z({ "src/language-html/get-node-content.js"(e, n) {
            "use strict";
            ae();
            var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: i, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: a } = Qt();
            function c(l, C) {
              let m = l.startSourceSpan.end.offset;
              l.firstChild && u(l.firstChild) && (m -= a(l).length);
              let g = l.endSourceSpan.start.offset;
              return l.lastChild && t(l.lastChild) ? g += s(l, C).length : i(l) && (g -= r(l.lastChild, C).length), C.originalText.slice(m, g);
            }
            n.exports = c;
          } }), Hd = Z({ "src/language-html/embed.js"(e, n) {
            "use strict";
            ae();
            var { builders: { breakParent: t, group: s, hardline: i, indent: r, line: u, fill: a, softline: c }, utils: { mapDoc: l, replaceTextEndOfLine: C } } = Le(), m = Xn(), { printClosingTag: g, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: h, printOpeningTag: N } = Qt(), { printImgSrcset: T, printClassNames: A } = Wd(), { printVueFor: b, printVueBindings: v, isVueEventBindingExpression: B } = $d(), { isScriptLikeTag: w, isVueNonHtmlBlock: I, inferScriptParser: E, htmlTrimPreserveIndentation: D, dedentString: d, unescapeQuoteEntities: y, isVueSlotAttribute: o, isVueSfcBindingsAttribute: x, getTextValueParts: F } = Ot(), S = mo();
            function k(O, R, M) {
              let H = (ne) => new RegExp(ne.join("|")).test(O.fullName), P = () => y(O.value), G = false, re = (ne, se) => {
                let V = ne.type === "NGRoot" ? ne.node.type === "NGMicrosyntax" && ne.node.body.length === 1 && ne.node.body[0].type === "NGMicrosyntaxExpression" ? ne.node.body[0].expression : ne.node : ne.type === "JsExpressionRoot" ? ne.node : ne;
                V && (V.type === "ObjectExpression" || V.type === "ArrayExpression" || se.parser === "__vue_expression" && (V.type === "TemplateLiteral" || V.type === "StringLiteral")) && (G = true);
              }, $ = (ne) => s(ne), W = function(ne) {
                let se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return s([r([c, ne]), se ? c : ""]);
              }, ee = (ne) => G ? $(ne) : W(ne), U = (ne, se) => R(ne, Object.assign({ __onHtmlBindingRoot: re, __embeddedInHtml: true }, se));
              if (O.fullName === "srcset" && (O.parent.fullName === "img" || O.parent.fullName === "source"))
                return W(T(P()));
              if (O.fullName === "class" && !M.parentParser) {
                let ne = P();
                if (!ne.includes("{{"))
                  return A(ne);
              }
              if (O.fullName === "style" && !M.parentParser) {
                let ne = P();
                if (!ne.includes("{{"))
                  return W(U(ne, { parser: "css", __isHTMLStyleAttribute: true }));
              }
              if (M.parser === "vue") {
                if (O.fullName === "v-for")
                  return b(P(), U);
                if (o(O) || x(O, M))
                  return v(P(), U);
                let ne = ["^@", "^v-on:"], se = ["^:", "^v-bind:"], V = ["^v-"];
                if (H(ne)) {
                  let oe = P();
                  return ee(U(oe, { parser: B(oe) ? "__js_expression" : "__vue_event_binding" }));
                }
                if (H(se))
                  return ee(U(P(), { parser: "__vue_expression" }));
                if (H(V))
                  return ee(U(P(), { parser: "__js_expression" }));
              }
              if (M.parser === "angular") {
                let ne = (le, ue) => U(le, Object.assign(Object.assign({}, ue), {}, { trailingComma: "none" })), se = ["^\\*"], V = ["^\\(.+\\)$", "^on-"], oe = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], K = ["^i18n(-.+)?$"];
                if (H(V))
                  return ee(ne(P(), { parser: "__ng_action" }));
                if (H(oe))
                  return ee(ne(P(), { parser: "__ng_binding" }));
                if (H(K)) {
                  let le = P().trim();
                  return W(a(F(O, le)), !le.includes("@@"));
                }
                if (H(se))
                  return ee(ne(P(), { parser: "__ng_directive" }));
                let Ee = /{{(.+?)}}/s, q = P();
                if (Ee.test(q)) {
                  let le = [];
                  for (let [ue, Q] of q.split(Ee).entries())
                    if (ue % 2 === 0)
                      le.push(C(Q));
                    else
                      try {
                        le.push(s(["{{", r([u, ne(Q, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                      } catch {
                        le.push("{{", C(Q), "}}");
                      }
                  return s(le);
                }
              }
              return null;
            }
            function _(O, R, M, H) {
              let P = O.getValue();
              switch (P.type) {
                case "element": {
                  if (w(P) || P.type === "interpolation")
                    return;
                  if (!P.isSelfClosing && I(P, H)) {
                    let G = E(P, H);
                    if (!G)
                      return;
                    let re = S(P, H), $ = /^\s*$/.test(re), W = "";
                    return $ || (W = M(D(re), { parser: G, __embeddedInHtml: true }, { stripTrailingHardline: true }), $ = W === ""), [h(P, H), s(N(O, H, R)), $ ? "" : i, W, $ ? "" : i, g(P, H), p(P, H)];
                  }
                  break;
                }
                case "text": {
                  if (w(P.parent)) {
                    let G = E(P.parent);
                    if (G) {
                      let re = G === "markdown" ? d(P.value.replace(/^[^\S\n]*\n/, "")) : P.value, $ = { parser: G, __embeddedInHtml: true };
                      if (H.parser === "html" && G === "babel") {
                        let W = "script", { attrMap: ee } = P.parent;
                        ee && (ee.type === "module" || ee.type === "text/babel" && ee["data-type"] === "module") && (W = "module"), $.__babelSourceType = W;
                      }
                      return [t, h(P, H), M(re, $, { stripTrailingHardline: true }), p(P, H)];
                    }
                  } else if (P.parent.type === "interpolation") {
                    let G = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                    return H.parser === "angular" ? (G.parser = "__ng_interpolation", G.trailingComma = "none") : H.parser === "vue" ? G.parser = "__vue_expression" : G.parser = "__js_expression", [r([u, M(P.value, G, { stripTrailingHardline: true })]), P.parent.next && f(P.parent.next) ? " " : u];
                  }
                  break;
                }
                case "attribute": {
                  if (!P.value)
                    break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(H.originalText.slice(P.valueSpan.start.offset, P.valueSpan.end.offset)))
                    return [P.rawName, "=", P.value];
                  if (H.parser === "lwc" && /^{.*}$/s.test(H.originalText.slice(P.valueSpan.start.offset, P.valueSpan.end.offset)))
                    return [P.rawName, "=", P.value];
                  let G = k(P, (re, $) => M(re, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, $), { stripTrailingHardline: true }), H);
                  if (G)
                    return [P.rawName, '="', s(l(G, (re) => typeof re == "string" ? re.replace(/"/g, "&quot;") : re)), '"'];
                  break;
                }
                case "front-matter":
                  return m(P, M);
              }
            }
            n.exports = _;
          } }), go = Z({ "src/language-html/print/children.js"(e, n) {
            "use strict";
            ae();
            var { builders: { breakParent: t, group: s, ifBreak: i, line: r, softline: u, hardline: a }, utils: { replaceTextEndOfLine: c } } = Le(), { locStart: l, locEnd: C } = Yn(), { forceBreakChildren: m, forceNextEmptyLine: g, isTextLikeNode: p, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: h } = Ot(), { printOpeningTagPrefix: N, needsToBorrowNextOpeningTagStartMarker: T, printOpeningTagStartMarker: A, needsToBorrowPrevClosingTagEndMarker: b, printClosingTagEndMarker: v, printClosingTagSuffix: B, needsToBorrowParentClosingTagStartMarker: w } = Qt();
            function I(d, y, o) {
              let x = d.getValue();
              return f(x) ? [N(x, y), ...c(y.originalText.slice(l(x) + (x.prev && T(x.prev) ? A(x).length : 0), C(x) - (x.next && b(x.next) ? v(x, y).length : 0))), B(x, y)] : o();
            }
            function E(d, y) {
              return p(d) && p(y) ? d.isTrailingSpaceSensitive ? d.hasTrailingSpaces ? h(y) ? a : r : "" : h(y) ? a : u : T(d) && (f(y) || y.firstChild || y.isSelfClosing || y.type === "element" && y.attrs.length > 0) || d.type === "element" && d.isSelfClosing && b(y) ? "" : !y.isLeadingSpaceSensitive || h(y) || b(y) && d.lastChild && w(d.lastChild) && d.lastChild.lastChild && w(d.lastChild.lastChild) ? a : y.hasLeadingSpaces ? r : u;
            }
            function D(d, y, o) {
              let x = d.getValue();
              if (m(x))
                return [t, ...d.map((S) => {
                  let k = S.getValue(), _ = k.prev ? E(k.prev, k) : "";
                  return [_ ? [_, g(k.prev) ? a : ""] : "", I(S, y, o)];
                }, "children")];
              let F = x.children.map(() => Symbol(""));
              return d.map((S, k) => {
                let _ = S.getValue();
                if (p(_)) {
                  if (_.prev && p(_.prev)) {
                    let re = E(_.prev, _);
                    if (re)
                      return g(_.prev) ? [a, a, I(S, y, o)] : [re, I(S, y, o)];
                  }
                  return I(S, y, o);
                }
                let O = [], R = [], M = [], H = [], P = _.prev ? E(_.prev, _) : "", G = _.next ? E(_, _.next) : "";
                return P && (g(_.prev) ? O.push(a, a) : P === a ? O.push(a) : p(_.prev) ? R.push(P) : R.push(i("", u, { groupId: F[k - 1] }))), G && (g(_) ? p(_.next) && H.push(a, a) : G === a ? p(_.next) && H.push(a) : M.push(G)), [...O, s([...R, s([I(S, y, o), ...M], { id: F[k] })]), ...H];
              }, "children");
            }
            n.exports = { printChildren: D };
          } }), Gd = Z({ "src/language-html/print/element.js"(e, n) {
            "use strict";
            ae();
            var { builders: { breakParent: t, dedentToRoot: s, group: i, ifBreak: r, indentIfBreak: u, indent: a, line: c, softline: l }, utils: { replaceTextEndOfLine: C } } = Le(), m = mo(), { shouldPreserveContent: g, isScriptLikeTag: p, isVueCustomBlock: f, countParents: h, forceBreakContent: N } = Ot(), { printOpeningTagPrefix: T, printOpeningTag: A, printClosingTagSuffix: b, printClosingTag: v, needsToBorrowPrevClosingTagEndMarker: B, needsToBorrowLastChildClosingTagEndMarker: w } = Qt(), { printChildren: I } = go();
            function E(D, d, y) {
              let o = D.getValue();
              if (g(o, d))
                return [T(o, d), i(A(D, d, y)), ...C(m(o, d)), ...v(o, d), b(o, d)];
              let x = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, F = Symbol("element-attr-group-id"), S = (R) => i([i(A(D, d, y), { id: F }), R, v(o, d)]), k = (R) => x ? u(R, { groupId: F }) : (p(o) || f(o, d)) && o.parent.type === "root" && d.parser === "vue" && !d.vueIndentScriptAndStyle ? R : a(R), _ = () => x ? r(l, "", { groupId: F }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? c : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(l) : l, O = () => (o.next ? B(o.next) : w(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : x ? r(l, "", { groupId: F }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? c : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(d.tabWidth * h(D, (M) => M.parent && M.parent.type !== "root"), "}$")).test(o.lastChild.value) ? "" : l;
              return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? c : "") : S([N(o) ? t : "", k([_(), I(D, d, y)]), O()]);
            }
            n.exports = { printElement: E };
          } }), Jd = Z({ "src/language-html/printer-html.js"(e, n) {
            "use strict";
            ae();
            var { builders: { fill: t, group: s, hardline: i, literalline: r }, utils: { cleanDoc: u, getDocParts: a, isConcat: c, replaceTextEndOfLine: l } } = Le(), C = _d(), { countChars: m, unescapeQuoteEntities: g, getTextValueParts: p } = Ot(), f = Md(), { insertPragma: h } = Rd(), { locStart: N, locEnd: T } = Yn(), A = Hd(), { printClosingTagSuffix: b, printClosingTagEnd: v, printOpeningTagPrefix: B, printOpeningTagStart: w } = Qt(), { printElement: I } = Gd(), { printChildren: E } = go();
            function D(d, y, o) {
              let x = d.getValue();
              switch (x.type) {
                case "front-matter":
                  return l(x.raw);
                case "root":
                  return y.__onHtmlRoot && y.__onHtmlRoot(x), [s(E(d, y, o)), i];
                case "element":
                case "ieConditionalComment":
                  return I(d, y, o);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                  return [w(x), v(x)];
                case "interpolation":
                  return [w(x, y), ...d.map(o, "children"), v(x, y)];
                case "text": {
                  if (x.parent.type === "interpolation") {
                    let S = /\n[^\S\n]*$/, k = S.test(x.value), _ = k ? x.value.replace(S, "") : x.value;
                    return [...l(_), k ? i : ""];
                  }
                  let F = u([B(x, y), ...p(x), b(x, y)]);
                  return c(F) || F.type === "fill" ? t(a(F)) : F;
                }
                case "docType":
                  return [s([w(x, y), " ", x.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), v(x, y)];
                case "comment":
                  return [B(x, y), ...l(y.originalText.slice(N(x), T(x)), r), b(x, y)];
                case "attribute": {
                  if (x.value === null)
                    return x.rawName;
                  let F = g(x.value), S = m(F, "'"), k = m(F, '"'), _ = S < k ? "'" : '"';
                  return [x.rawName, "=", _, ...l(_ === '"' ? F.replace(/"/g, "&quot;") : F.replace(/'/g, "&apos;")), _];
                }
                default:
                  throw new Error("Unexpected node type ".concat(x.type));
              }
            }
            n.exports = { preprocess: f, print: D, insertPragma: h, massageAstNode: C, embed: A };
          } }), Ud = Z({ "src/language-html/options.js"(e, n) {
            "use strict";
            ae();
            var t = Lt(), s = "HTML";
            n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
          } }), zd = Z({ "src/language-html/parsers.js"() {
            ae();
          } }), An = Z({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
            n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
          } }), Xd = Z({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
            n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
          } }), Kd = Z({ "src/language-html/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = Jd(), i = Ud(), r = zd(), u = [t(An(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(An(), (c) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...c.extensions, ".mjml"] })), t(An(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(Xd(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], a = { html: s };
            n.exports = { languages: u, printers: a, options: i, parsers: r };
          } }), Yd = Z({ "src/language-yaml/pragma.js"(e, n) {
            "use strict";
            ae();
            function t(r) {
              return /^\s*@(?:prettier|format)\s*$/.test(r);
            }
            function s(r) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
            }
            function i(r) {
              return `# @format

`.concat(r);
            }
            n.exports = { isPragma: t, hasPragma: s, insertPragma: i };
          } }), Qd = Z({ "src/language-yaml/loc.js"(e, n) {
            "use strict";
            ae();
            function t(i) {
              return i.position.start.offset;
            }
            function s(i) {
              return i.position.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Zd = Z({ "src/language-yaml/embed.js"(e, n) {
            "use strict";
            ae();
            function t(s, i, r, u) {
              if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath))
                return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
            }
            n.exports = t;
          } }), jt = Z({ "src/language-yaml/utils.js"(e, n) {
            "use strict";
            ae();
            var { getLast: t, isNonEmptyArray: s } = Ge();
            function i(E, D) {
              let d = 0, y = E.stack.length - 1;
              for (let o = 0; o < y; o++) {
                let x = E.stack[o];
                r(x) && D(x) && d++;
              }
              return d;
            }
            function r(E, D) {
              return E && typeof E.type == "string" && (!D || D.includes(E.type));
            }
            function u(E, D, d) {
              return D("children" in E ? Object.assign(Object.assign({}, E), {}, { children: E.children.map((y) => u(y, D, E)) }) : E, d);
            }
            function a(E, D, d) {
              Object.defineProperty(E, D, { get: d, enumerable: false });
            }
            function c(E, D) {
              let d = 0, y = D.length;
              for (let o = E.position.end.offset - 1; o < y; o++) {
                let x = D[o];
                if (x === `
` && d++, d === 1 && /\S/.test(x))
                  return false;
                if (d === 2)
                  return true;
              }
              return false;
            }
            function l(E) {
              switch (E.getValue().type) {
                case "tag":
                case "anchor":
                case "comment":
                  return false;
              }
              let d = E.stack.length;
              for (let y = 1; y < d; y++) {
                let o = E.stack[y], x = E.stack[y - 1];
                if (Array.isArray(x) && typeof o == "number" && o !== x.length - 1)
                  return false;
              }
              return true;
            }
            function C(E) {
              return s(E.children) ? C(t(E.children)) : E;
            }
            function m(E) {
              return E.value.trim() === "prettier-ignore";
            }
            function g(E) {
              let D = E.getValue();
              if (D.type === "documentBody") {
                let d = E.getParentNode();
                return b(d.head) && m(t(d.head.endComments));
              }
              return h(D) && m(t(D.leadingComments));
            }
            function p(E) {
              return !s(E.children) && !f(E);
            }
            function f(E) {
              return h(E) || N(E) || T(E) || A(E) || b(E);
            }
            function h(E) {
              return E && s(E.leadingComments);
            }
            function N(E) {
              return E && s(E.middleComments);
            }
            function T(E) {
              return E && E.indicatorComment;
            }
            function A(E) {
              return E && E.trailingComment;
            }
            function b(E) {
              return E && s(E.endComments);
            }
            function v(E) {
              let D = [], d;
              for (let y of E.split(/( +)/))
                y !== " " ? d === " " ? D.push(y) : D.push((D.pop() || "") + y) : d === void 0 && D.unshift(""), d = y;
              return d === " " && D.push((D.pop() || "") + " "), D[0] === "" && (D.shift(), D.unshift(" " + (D.shift() || ""))), D;
            }
            function B(E, D, d) {
              let y = D.split(`
`).map((o, x, F) => x === 0 && x === F.length - 1 ? o : x !== 0 && x !== F.length - 1 ? o.trim() : x === 0 ? o.trimEnd() : o.trimStart());
              return d.proseWrap === "preserve" ? y.map((o) => o.length === 0 ? [] : [o]) : y.map((o) => o.length === 0 ? [] : v(o)).reduce((o, x, F) => F !== 0 && y[F - 1].length > 0 && x.length > 0 && !(E === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...x]] : [...o, x], []).map((o) => d.proseWrap === "never" ? [o.join(" ")] : o);
            }
            function w(E, D) {
              let { parentIndent: d, isLastDescendant: y, options: o } = D, x = E.position.start.line === E.position.end.line ? "" : o.originalText.slice(E.position.start.offset, E.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], F;
              if (E.indent === null) {
                let _ = x.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                F = _ ? _.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
              } else
                F = E.indent - 1 + d;
              let S = x.split(`
`).map((_) => _.slice(F));
              if (o.proseWrap === "preserve" || E.type === "blockLiteral")
                return k(S.map((_) => _.length === 0 ? [] : [_]));
              return k(S.map((_) => _.length === 0 ? [] : v(_)).reduce((_, O, R) => R !== 0 && S[R - 1].length > 0 && O.length > 0 && !/^\s/.test(O[0]) && !/^\s|\s$/.test(t(_)) ? [..._.slice(0, -1), [...t(_), ...O]] : [..._, O], []).map((_) => _.reduce((O, R) => O.length > 0 && /\s$/.test(t(O)) ? [...O.slice(0, -1), t(O) + " " + R] : [...O, R], [])).map((_) => o.proseWrap === "never" ? [_.join(" ")] : _));
              function k(_) {
                if (E.chomping === "keep")
                  return t(_).length === 0 ? _.slice(0, -1) : _;
                let O = 0;
                for (let R = _.length - 1; R >= 0 && _[R].length === 0; R--)
                  O++;
                return O === 0 ? _ : O >= 2 && !y ? _.slice(0, -(O - 1)) : _.slice(0, -O);
              }
            }
            function I(E) {
              if (!E)
                return true;
              switch (E.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = { getLast: t, getAncestorCount: i, isNode: r, isEmptyNode: p, isInlineNode: I, mapNode: u, defineShortcut: a, isNextLineEmpty: c, isLastDescendantNode: l, getBlockValueLineContents: w, getFlowScalarLineContents: B, getLastDescendantNode: C, hasPrettierIgnore: g, hasLeadingComments: h, hasMiddleComments: N, hasIndicatorComment: T, hasTrailingComment: A, hasEndComments: b };
          } }), eg = Z({ "src/language-yaml/print-preprocess.js"(e, n) {
            "use strict";
            ae();
            var { defineShortcut: t, mapNode: s } = jt();
            function i(u) {
              return s(u, r);
            }
            function r(u) {
              switch (u.type) {
                case "document":
                  t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                  break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                  t(u, "content", () => u.children[0]);
                  break;
                case "mappingItem":
                case "flowMappingItem":
                  t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                  break;
              }
              return u;
            }
            n.exports = i;
          } }), kr = Z({ "src/language-yaml/print/misc.js"(e, n) {
            "use strict";
            ae();
            var { builders: { softline: t, align: s } } = Le(), { hasEndComments: i, isNextLineEmpty: r, isNode: u } = jt(), a = /* @__PURE__ */ new WeakMap();
            function c(m, g) {
              let p = m.getValue(), f = m.stack[0], h;
              return a.has(f) ? h = a.get(f) : (h = /* @__PURE__ */ new Set(), a.set(f, h)), !h.has(p.position.end.line) && (h.add(p.position.end.line), r(p, g) && !l(m.getParentNode())) ? t : "";
            }
            function l(m) {
              return i(m) && !u(m, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
            }
            function C(m, g) {
              return s(" ".repeat(m), g);
            }
            n.exports = { alignWithSpaces: C, shouldPrintEndComments: l, printNextEmptyLine: c };
          } }), tg = Z({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
            "use strict";
            ae();
            var { builders: { ifBreak: t, line: s, softline: i, hardline: r, join: u } } = Le(), { isEmptyNode: a, getLast: c, hasEndComments: l } = jt(), { printNextEmptyLine: C, alignWithSpaces: m } = kr();
            function g(f, h, N) {
              let T = f.getValue(), A = T.type === "flowMapping", b = A ? "{" : "[", v = A ? "}" : "]", B = i;
              A && T.children.length > 0 && N.bracketSpacing && (B = s);
              let w = c(T.children), I = w && w.type === "flowMappingItem" && a(w.key) && a(w.value);
              return [b, m(N.tabWidth, [B, p(f, h, N), N.trailingComma === "none" ? "" : t(","), l(T) ? [r, u(r, f.map(h, "endComments"))] : ""]), I ? "" : B, v];
            }
            function p(f, h, N) {
              let T = f.getValue();
              return f.map((b, v) => [h(), v === T.children.length - 1 ? "" : [",", s, T.children[v].position.start.line !== T.children[v + 1].position.start.line ? C(b, N.originalText) : ""]], "children");
            }
            n.exports = { printFlowMapping: g, printFlowSequence: g };
          } }), rg = Z({ "src/language-yaml/print/mapping-item.js"(e, n) {
            "use strict";
            ae();
            var { builders: { conditionalGroup: t, group: s, hardline: i, ifBreak: r, join: u, line: a } } = Le(), { hasLeadingComments: c, hasMiddleComments: l, hasTrailingComment: C, hasEndComments: m, isNode: g, isEmptyNode: p, isInlineNode: f } = jt(), { alignWithSpaces: h } = kr();
            function N(v, B, w, I, E) {
              let { key: D, value: d } = v, y = p(D), o = p(d);
              if (y && o)
                return ": ";
              let x = I("key"), F = A(v) ? " " : "";
              if (o)
                return v.type === "flowMappingItem" && B.type === "flowMapping" ? x : v.type === "mappingItem" && T(D.content, E) && !C(D.content) && (!B.tag || B.tag.value !== "tag:yaml.org,2002:set") ? [x, F, ":"] : ["? ", h(2, x)];
              let S = I("value");
              if (y)
                return [": ", h(2, S)];
              if (c(d) || !f(D.content))
                return ["? ", h(2, x), i, u("", w.map(I, "value", "leadingComments").map((H) => [H, i])), ": ", h(2, S)];
              if (b(D.content) && !c(D.content) && !l(D.content) && !C(D.content) && !m(D) && !c(d.content) && !l(d.content) && !m(d) && T(d.content, E))
                return [x, F, ": ", S];
              let k = Symbol("mappingKey"), _ = s([r("? "), s(h(2, x), { id: k })]), O = [i, ": ", h(2, S)], R = [F, ":"];
              c(d.content) || m(d) && d.content && !g(d.content, ["mapping", "sequence"]) || B.type === "mapping" && C(D.content) && f(d.content) || g(d.content, ["mapping", "sequence"]) && d.content.tag === null && d.content.anchor === null ? R.push(i) : d.content && R.push(a), R.push(S);
              let M = h(E.tabWidth, R);
              return T(D.content, E) && !c(D.content) && !l(D.content) && !m(D) ? t([[x, M]]) : t([[_, r(O, M, { groupId: k })]]);
            }
            function T(v, B) {
              if (!v)
                return true;
              switch (v.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble":
                  break;
                case "alias":
                  return true;
                default:
                  return false;
              }
              if (B.proseWrap === "preserve")
                return v.position.start.line === v.position.end.line;
              if (/\\$/m.test(B.originalText.slice(v.position.start.offset, v.position.end.offset)))
                return false;
              switch (B.proseWrap) {
                case "never":
                  return !v.value.includes(`
`);
                case "always":
                  return !/[\n ]/.test(v.value);
                default:
                  return false;
              }
            }
            function A(v) {
              return v.key.content && v.key.content.type === "alias";
            }
            function b(v) {
              if (!v)
                return true;
              switch (v.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return v.position.start.line === v.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = N;
          } }), ng = Z({ "src/language-yaml/print/block.js"(e, n) {
            "use strict";
            ae();
            var { builders: { dedent: t, dedentToRoot: s, fill: i, hardline: r, join: u, line: a, literalline: c, markAsRoot: l }, utils: { getDocParts: C } } = Le(), { getAncestorCount: m, getBlockValueLineContents: g, hasIndicatorComment: p, isLastDescendantNode: f, isNode: h } = jt(), { alignWithSpaces: N } = kr();
            function T(A, b, v) {
              let B = A.getValue(), w = m(A, (y) => h(y, ["sequence", "mapping"])), I = f(A), E = [B.type === "blockFolded" ? ">" : "|"];
              B.indent !== null && E.push(B.indent.toString()), B.chomping !== "clip" && E.push(B.chomping === "keep" ? "+" : "-"), p(B) && E.push(" ", b("indicatorComment"));
              let D = g(B, { parentIndent: w, isLastDescendant: I, options: v }), d = [];
              for (let [y, o] of D.entries())
                y === 0 && d.push(r), d.push(i(C(u(a, o)))), y !== D.length - 1 ? d.push(o.length === 0 ? r : l(c)) : B.chomping === "keep" && I && d.push(s(o.length === 0 ? r : c));
              return B.indent === null ? E.push(t(N(v.tabWidth, d))) : E.push(s(N(B.indent - 1 + w, d))), E;
            }
            n.exports = T;
          } }), ug = Z({ "src/language-yaml/printer-yaml.js"(e, n) {
            "use strict";
            ae();
            var { builders: { breakParent: t, fill: s, group: i, hardline: r, join: u, line: a, lineSuffix: c, literalline: l }, utils: { getDocParts: C, replaceTextEndOfLine: m } } = Le(), { isPreviousLineEmpty: g } = Ge(), { insertPragma: p, isPragma: f } = Yd(), { locStart: h } = Qd(), N = Zd(), { getFlowScalarLineContents: T, getLastDescendantNode: A, hasLeadingComments: b, hasMiddleComments: v, hasTrailingComment: B, hasEndComments: w, hasPrettierIgnore: I, isLastDescendantNode: E, isNode: D, isInlineNode: d } = jt(), y = eg(), { alignWithSpaces: o, printNextEmptyLine: x, shouldPrintEndComments: F } = kr(), { printFlowMapping: S, printFlowSequence: k } = tg(), _ = rg(), O = ng();
            function R(W, ee, U) {
              let ne = W.getValue(), se = [];
              ne.type !== "mappingValue" && b(ne) && se.push([u(r, W.map(U, "leadingComments")), r]);
              let { tag: V, anchor: oe } = ne;
              V && se.push(U("tag")), V && oe && se.push(" "), oe && se.push(U("anchor"));
              let K = "";
              D(ne, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !E(W) && (K = x(W, ee.originalText)), (V || oe) && (D(ne, ["sequence", "mapping"]) && !v(ne) ? se.push(r) : se.push(" ")), v(ne) && se.push([ne.middleComments.length === 1 ? "" : r, u(r, W.map(U, "middleComments")), r]);
              let Ee = W.getParentNode();
              return I(W) ? se.push(m(ee.originalText.slice(ne.position.start.offset, ne.position.end.offset).trimEnd(), l)) : se.push(i(M(ne, Ee, W, ee, U))), B(ne) && !D(ne, ["document", "documentHead"]) && se.push(c([ne.type === "mappingValue" && !ne.content ? "" : " ", Ee.type === "mappingKey" && W.getParentNode(2).type === "mapping" && d(ne) ? "" : t, U("trailingComment")])), F(ne) && se.push(o(ne.type === "sequenceItem" ? 2 : 0, [r, u(r, W.map((q) => [g(ee.originalText, q.getValue(), h) ? r : "", U()], "endComments"))])), se.push(K), se;
            }
            function M(W, ee, U, ne, se) {
              switch (W.type) {
                case "root": {
                  let { children: V } = W, oe = [];
                  U.each((Ee, q) => {
                    let le = V[q], ue = V[q + 1];
                    q !== 0 && oe.push(r), oe.push(se()), P(le, ue) ? (oe.push(r, "..."), B(le) && oe.push(" ", se("trailingComment"))) : ue && !B(ue.head) && oe.push(r, "---");
                  }, "children");
                  let K = A(W);
                  return (!D(K, ["blockLiteral", "blockFolded"]) || K.chomping !== "keep") && oe.push(r), oe;
                }
                case "document": {
                  let V = ee.children[U.getName() + 1], oe = [];
                  return G(W, V, ee, ne) === "head" && ((W.head.children.length > 0 || W.head.endComments.length > 0) && oe.push(se("head")), B(W.head) ? oe.push(["---", " ", se(["head", "trailingComment"])]) : oe.push("---")), H(W) && oe.push(se("body")), u(r, oe);
                }
                case "documentHead":
                  return u(r, [...U.map(se, "children"), ...U.map(se, "endComments")]);
                case "documentBody": {
                  let { children: V, endComments: oe } = W, K = "";
                  if (V.length > 0 && oe.length > 0) {
                    let Ee = A(W);
                    D(Ee, ["blockFolded", "blockLiteral"]) ? Ee.chomping !== "keep" && (K = [r, r]) : K = r;
                  }
                  return [u(r, U.map(se, "children")), K, u(r, U.map(se, "endComments"))];
                }
                case "directive":
                  return ["%", u(" ", [W.name, ...W.parameters])];
                case "comment":
                  return ["#", W.value];
                case "alias":
                  return ["*", W.value];
                case "tag":
                  return ne.originalText.slice(W.position.start.offset, W.position.end.offset);
                case "anchor":
                  return ["&", W.value];
                case "plain":
                  return re(W.type, ne.originalText.slice(W.position.start.offset, W.position.end.offset), ne);
                case "quoteDouble":
                case "quoteSingle": {
                  let V = "'", oe = '"', K = ne.originalText.slice(W.position.start.offset + 1, W.position.end.offset - 1);
                  if (W.type === "quoteSingle" && K.includes("\\") || W.type === "quoteDouble" && /\\[^"]/.test(K)) {
                    let q = W.type === "quoteDouble" ? oe : V;
                    return [q, re(W.type, K, ne), q];
                  }
                  if (K.includes(oe))
                    return [V, re(W.type, W.type === "quoteDouble" ? K.replace(/\\"/g, oe).replace(/'/g, V.repeat(2)) : K, ne), V];
                  if (K.includes(V))
                    return [oe, re(W.type, W.type === "quoteSingle" ? K.replace(/''/g, V) : K, ne), oe];
                  let Ee = ne.singleQuote ? V : oe;
                  return [Ee, re(W.type, K, ne), Ee];
                }
                case "blockFolded":
                case "blockLiteral":
                  return O(U, se, ne);
                case "mapping":
                case "sequence":
                  return u(r, U.map(se, "children"));
                case "sequenceItem":
                  return ["- ", o(2, W.content ? se("content") : "")];
                case "mappingKey":
                case "mappingValue":
                  return W.content ? se("content") : "";
                case "mappingItem":
                case "flowMappingItem":
                  return _(W, ee, U, se, ne);
                case "flowMapping":
                  return S(U, se, ne);
                case "flowSequence":
                  return k(U, se, ne);
                case "flowSequenceItem":
                  return se("content");
                default:
                  throw new Error("Unexpected node type ".concat(W.type));
              }
            }
            function H(W) {
              return W.body.children.length > 0 || w(W.body);
            }
            function P(W, ee) {
              return B(W) || ee && (ee.head.children.length > 0 || w(ee.head));
            }
            function G(W, ee, U, ne) {
              return U.children[0] === W && /---(?:\s|$)/.test(ne.originalText.slice(h(W), h(W) + 4)) || W.head.children.length > 0 || w(W.head) || B(W.head) ? "head" : P(W, ee) ? false : ee ? "root" : false;
            }
            function re(W, ee, U) {
              let ne = T(W, ee, U);
              return u(r, ne.map((se) => s(C(u(a, se)))));
            }
            function $(W, ee) {
              if (D(ee))
                switch (delete ee.position, ee.type) {
                  case "comment":
                    if (f(ee.value))
                      return null;
                    break;
                  case "quoteDouble":
                  case "quoteSingle":
                    ee.type = "quote";
                    break;
                }
            }
            n.exports = { preprocess: y, embed: N, print: R, massageAstNode: $, insertPragma: p };
          } }), sg = Z({ "src/language-yaml/options.js"(e, n) {
            "use strict";
            ae();
            var t = Lt();
            n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
          } }), ag = Z({ "src/language-yaml/parsers.js"() {
            ae();
          } }), ig = Z({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
            n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
          } }), og = Z({ "src/language-yaml/index.js"(e, n) {
            "use strict";
            ae();
            var t = bt(), s = ug(), i = sg(), r = ag(), u = [t(ig(), (a) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...a.filenames.filter((c) => c !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
            n.exports = { languages: u, printers: { yaml: s }, options: i, parsers: r };
          } }), cg = Z({ "src/languages.js"(e, n) {
            "use strict";
            ae(), n.exports = [$m(), id(), dd(), Fd(), wd(), Kd(), og()];
          } });
          ae();
          var { version: lg } = gi(), _t = om(), { getSupportInfo: pg } = Mn(), fg = cm(), Dg = cg(), mg = Le();
          function St(e) {
            let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
              for (var t = arguments.length, s = new Array(t), i = 0; i < t; i++)
                s[i] = arguments[i];
              let r = s[n] || {}, u = r.plugins || [];
              return s[n] = Object.assign(Object.assign({}, r), {}, { plugins: [...Dg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
            };
          }
          var Sn = St(_t.formatWithCursor);
          yo.exports = { formatWithCursor: Sn, format(e, n) {
            return Sn(e, n).formatted;
          }, check(e, n) {
            let { formatted: t } = Sn(e, n);
            return t === e;
          }, doc: mg, getSupportInfo: St(pg, 0), version: lg, util: fg, __debug: { parse: St(_t.parse), formatAST: St(_t.formatAST), formatDoc: St(_t.formatDoc), printToDoc: St(_t.printToDoc), printDocToString: St(_t.printDocToString) } };
        });
        "use strict";
        return dg();
      });
    }
  });

  // ../../node_modules/.pnpm/prettier@2.6.2/node_modules/prettier/parser-graphql.js
  var require_parser_graphql = __commonJS({
    "../../node_modules/.pnpm/prettier@2.6.2/node_modules/prettier/parser-graphql.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.graphql = e();
        }
      })(function() {
        "use strict";
        var oe = (a, d) => () => (d || a((d = { exports: {} }).exports, d), d.exports);
        var be = oe((Ce, ae) => {
          var H = Object.getOwnPropertyNames, se = (a, d) => function() {
            return a && (d = (0, a[H(a)[0]])(a = 0)), d;
          }, L = (a, d) => function() {
            return d || (0, a[H(a)[0]])((d = { exports: {} }).exports, d), d.exports;
          }, K = se({ "<define:process>"() {
          } }), ce = L({ "src/common/parser-create-error.js"(a, d) {
            "use strict";
            K();
            function i(c, r) {
              let _ = new SyntaxError(c + " (" + r.start.line + ":" + r.start.column + ")");
              return _.loc = r, _;
            }
            d.exports = i;
          } }), ue = L({ "src/utils/try-combinations.js"(a, d) {
            "use strict";
            K();
            function i() {
              let c;
              for (var r = arguments.length, _ = new Array(r), E = 0; E < r; E++)
                _[E] = arguments[E];
              for (let [k, O] of _.entries())
                try {
                  return { result: O() };
                } catch (A) {
                  k === 0 && (c = A);
                }
              return { error: c };
            }
            d.exports = i;
          } }), le = L({ "src/language-graphql/pragma.js"(a, d) {
            "use strict";
            K();
            function i(r) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(r);
            }
            function c(r) {
              return `# @format

` + r;
            }
            d.exports = { hasPragma: i, insertPragma: c };
          } }), pe = L({ "src/language-graphql/loc.js"(a, d) {
            "use strict";
            K();
            function i(r) {
              return typeof r.start == "number" ? r.start : r.loc && r.loc.start;
            }
            function c(r) {
              return typeof r.end == "number" ? r.end : r.loc && r.loc.end;
            }
            d.exports = { locStart: i, locEnd: c };
          } }), fe = L({ "node_modules/graphql/jsutils/isObjectLike.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = i;
            function d(c) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(_) {
                return typeof _;
              } : d = function(_) {
                return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
              }, d(c);
            }
            function i(c) {
              return d(c) == "object" && c !== null;
            }
          } }), z = L({ "node_modules/graphql/polyfills/symbols.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.SYMBOL_TO_STRING_TAG = a.SYMBOL_ASYNC_ITERATOR = a.SYMBOL_ITERATOR = void 0;
            var d = typeof Symbol == "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
            a.SYMBOL_ITERATOR = d;
            var i = typeof Symbol == "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
            a.SYMBOL_ASYNC_ITERATOR = i;
            var c = typeof Symbol == "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
            a.SYMBOL_TO_STRING_TAG = c;
          } }), $ = L({ "node_modules/graphql/language/location.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.getLocation = d;
            function d(i, c) {
              for (var r = /\r\n|[\n\r]/g, _ = 1, E = c + 1, k; (k = r.exec(i.body)) && k.index < c; )
                _ += 1, E = c + 1 - (k.index + k[0].length);
              return { line: _, column: E };
            }
          } }), de = L({ "node_modules/graphql/language/printLocation.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.printLocation = i, a.printSourceLocation = c;
            var d = $();
            function i(k) {
              return c(k.source, (0, d.getLocation)(k.source, k.start));
            }
            function c(k, O) {
              var A = k.locationOffset.column - 1, N = _(A) + k.body, g = O.line - 1, D = k.locationOffset.line - 1, v = O.line + D, I = O.line === 1 ? A : 0, s = O.column + I, p = "".concat(k.name, ":").concat(v, ":").concat(s, `
`), e = N.split(/\r\n|[\n\r]/g), n = e[g];
              if (n.length > 120) {
                for (var t = Math.floor(s / 80), u = s % 80, y = [], f = 0; f < n.length; f += 80)
                  y.push(n.slice(f, f + 80));
                return p + r([["".concat(v), y[0]]].concat(y.slice(1, t + 1).map(function(m) {
                  return ["", m];
                }), [[" ", _(u - 1) + "^"], ["", y[t + 1]]]));
              }
              return p + r([["".concat(v - 1), e[g - 1]], ["".concat(v), n], ["", _(s - 1) + "^"], ["".concat(v + 1), e[g + 1]]]);
            }
            function r(k) {
              var O = k.filter(function(N) {
                var g = N[0], D = N[1];
                return D !== void 0;
              }), A = Math.max.apply(Math, O.map(function(N) {
                var g = N[0];
                return g.length;
              }));
              return O.map(function(N) {
                var g = N[0], D = N[1];
                return E(A, g) + (D ? " | " + D : " |");
              }).join(`
`);
            }
            function _(k) {
              return Array(k + 1).join(" ");
            }
            function E(k, O) {
              return _(k - O.length) + O;
            }
          } }), W = L({ "node_modules/graphql/error/GraphQLError.js"(a) {
            "use strict";
            K();
            function d(f) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(o) {
                return typeof o;
              } : d = function(o) {
                return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
              }, d(f);
            }
            Object.defineProperty(a, "__esModule", { value: true }), a.printError = y, a.GraphQLError = void 0;
            var i = E(fe()), c = z(), r = $(), _ = de();
            function E(f) {
              return f && f.__esModule ? f : { default: f };
            }
            function k(f, m) {
              if (!(f instanceof m))
                throw new TypeError("Cannot call a class as a function");
            }
            function O(f, m) {
              for (var o = 0; o < m.length; o++) {
                var h = m[o];
                h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(f, h.key, h);
              }
            }
            function A(f, m, o) {
              return m && O(f.prototype, m), o && O(f, o), f;
            }
            function N(f, m) {
              if (typeof m != "function" && m !== null)
                throw new TypeError("Super expression must either be null or a function");
              f.prototype = Object.create(m && m.prototype, { constructor: { value: f, writable: true, configurable: true } }), m && n(f, m);
            }
            function g(f) {
              var m = p();
              return function() {
                var h = t(f), l;
                if (m) {
                  var T = t(this).constructor;
                  l = Reflect.construct(h, arguments, T);
                } else
                  l = h.apply(this, arguments);
                return D(this, l);
              };
            }
            function D(f, m) {
              return m && (d(m) === "object" || typeof m == "function") ? m : v(f);
            }
            function v(f) {
              if (f === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return f;
            }
            function I(f) {
              var m = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
              return I = function(h) {
                if (h === null || !e(h))
                  return h;
                if (typeof h != "function")
                  throw new TypeError("Super expression must either be null or a function");
                if (typeof m < "u") {
                  if (m.has(h))
                    return m.get(h);
                  m.set(h, l);
                }
                function l() {
                  return s(h, arguments, t(this).constructor);
                }
                return l.prototype = Object.create(h.prototype, { constructor: { value: l, enumerable: false, writable: true, configurable: true } }), n(l, h);
              }, I(f);
            }
            function s(f, m, o) {
              return p() ? s = Reflect.construct : s = function(l, T, S) {
                var x = [null];
                x.push.apply(x, T);
                var b = Function.bind.apply(l, x), M = new b();
                return S && n(M, S.prototype), M;
              }, s.apply(null, arguments);
            }
            function p() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch {
                return false;
              }
            }
            function e(f) {
              return Function.toString.call(f).indexOf("[native code]") !== -1;
            }
            function n(f, m) {
              return n = Object.setPrototypeOf || function(h, l) {
                return h.__proto__ = l, h;
              }, n(f, m);
            }
            function t(f) {
              return t = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
              }, t(f);
            }
            var u = function(f) {
              N(o, f);
              var m = g(o);
              function o(h, l, T, S, x, b, M) {
                var U, V, q, G, C;
                k(this, o), C = m.call(this, h);
                var R = Array.isArray(l) ? l.length !== 0 ? l : void 0 : l ? [l] : void 0, Y = T;
                if (!Y && R) {
                  var J;
                  Y = (J = R[0].loc) === null || J === void 0 ? void 0 : J.source;
                }
                var F = S;
                !F && R && (F = R.reduce(function(w, P) {
                  return P.loc && w.push(P.loc.start), w;
                }, [])), F && F.length === 0 && (F = void 0);
                var B;
                S && T ? B = S.map(function(w) {
                  return (0, r.getLocation)(T, w);
                }) : R && (B = R.reduce(function(w, P) {
                  return P.loc && w.push((0, r.getLocation)(P.loc.source, P.loc.start)), w;
                }, []));
                var j = M;
                if (j == null && b != null) {
                  var Q = b.extensions;
                  (0, i.default)(Q) && (j = Q);
                }
                return Object.defineProperties(v(C), { name: { value: "GraphQLError" }, message: { value: h, enumerable: true, writable: true }, locations: { value: (U = B) !== null && U !== void 0 ? U : void 0, enumerable: B != null }, path: { value: x != null ? x : void 0, enumerable: x != null }, nodes: { value: R != null ? R : void 0 }, source: { value: (V = Y) !== null && V !== void 0 ? V : void 0 }, positions: { value: (q = F) !== null && q !== void 0 ? q : void 0 }, originalError: { value: b }, extensions: { value: (G = j) !== null && G !== void 0 ? G : void 0, enumerable: j != null } }), b != null && b.stack ? (Object.defineProperty(v(C), "stack", { value: b.stack, writable: true, configurable: true }), D(C)) : (Error.captureStackTrace ? Error.captureStackTrace(v(C), o) : Object.defineProperty(v(C), "stack", { value: Error().stack, writable: true, configurable: true }), C);
              }
              return A(o, [{ key: "toString", value: function() {
                return y(this);
              } }, { key: c.SYMBOL_TO_STRING_TAG, get: function() {
                return "Object";
              } }]), o;
            }(I(Error));
            a.GraphQLError = u;
            function y(f) {
              var m = f.message;
              if (f.nodes)
                for (var o = 0, h = f.nodes; o < h.length; o++) {
                  var l = h[o];
                  l.loc && (m += `

` + (0, _.printLocation)(l.loc));
                }
              else if (f.source && f.locations)
                for (var T = 0, S = f.locations; T < S.length; T++) {
                  var x = S[T];
                  m += `

` + (0, _.printSourceLocation)(f.source, x);
                }
              return m;
            }
          } }), Z = L({ "node_modules/graphql/error/syntaxError.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.syntaxError = i;
            var d = W();
            function i(c, r, _) {
              return new d.GraphQLError("Syntax Error: ".concat(_), void 0, c, [r]);
            }
          } }), he = L({ "node_modules/graphql/language/kinds.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.Kind = void 0;
            var d = Object.freeze({ NAME: "Name", DOCUMENT: "Document", OPERATION_DEFINITION: "OperationDefinition", VARIABLE_DEFINITION: "VariableDefinition", SELECTION_SET: "SelectionSet", FIELD: "Field", ARGUMENT: "Argument", FRAGMENT_SPREAD: "FragmentSpread", INLINE_FRAGMENT: "InlineFragment", FRAGMENT_DEFINITION: "FragmentDefinition", VARIABLE: "Variable", INT: "IntValue", FLOAT: "FloatValue", STRING: "StringValue", BOOLEAN: "BooleanValue", NULL: "NullValue", ENUM: "EnumValue", LIST: "ListValue", OBJECT: "ObjectValue", OBJECT_FIELD: "ObjectField", DIRECTIVE: "Directive", NAMED_TYPE: "NamedType", LIST_TYPE: "ListType", NON_NULL_TYPE: "NonNullType", SCHEMA_DEFINITION: "SchemaDefinition", OPERATION_TYPE_DEFINITION: "OperationTypeDefinition", SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition", OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition", FIELD_DEFINITION: "FieldDefinition", INPUT_VALUE_DEFINITION: "InputValueDefinition", INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition", UNION_TYPE_DEFINITION: "UnionTypeDefinition", ENUM_TYPE_DEFINITION: "EnumTypeDefinition", ENUM_VALUE_DEFINITION: "EnumValueDefinition", INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition", DIRECTIVE_DEFINITION: "DirectiveDefinition", SCHEMA_EXTENSION: "SchemaExtension", SCALAR_TYPE_EXTENSION: "ScalarTypeExtension", OBJECT_TYPE_EXTENSION: "ObjectTypeExtension", INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension", UNION_TYPE_EXTENSION: "UnionTypeExtension", ENUM_TYPE_EXTENSION: "EnumTypeExtension", INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension" });
            a.Kind = d;
          } }), ve = L({ "node_modules/graphql/jsutils/invariant.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = d;
            function d(i, c) {
              var r = Boolean(i);
              if (!r)
                throw new Error(c != null ? c : "Unexpected invariant triggered.");
            }
          } }), ee = L({ "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = void 0;
            var d = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0, i = d;
            a.default = i;
          } }), Te = L({ "node_modules/graphql/jsutils/defineInspect.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = r;
            var d = c(ve()), i = c(ee());
            function c(_) {
              return _ && _.__esModule ? _ : { default: _ };
            }
            function r(_) {
              var E = _.prototype.toJSON;
              typeof E == "function" || (0, d.default)(0), _.prototype.inspect = E, i.default && (_.prototype[i.default] = E);
            }
          } }), te = L({ "node_modules/graphql/language/ast.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isNode = _, a.Token = a.Location = void 0;
            var d = i(Te());
            function i(E) {
              return E && E.__esModule ? E : { default: E };
            }
            var c = function() {
              function E(O, A, N) {
                this.start = O.start, this.end = A.end, this.startToken = O, this.endToken = A, this.source = N;
              }
              var k = E.prototype;
              return k.toJSON = function() {
                return { start: this.start, end: this.end };
              }, E;
            }();
            a.Location = c, (0, d.default)(c);
            var r = function() {
              function E(O, A, N, g, D, v, I) {
                this.kind = O, this.start = A, this.end = N, this.line = g, this.column = D, this.value = I, this.prev = v, this.next = null;
              }
              var k = E.prototype;
              return k.toJSON = function() {
                return { kind: this.kind, value: this.value, line: this.line, column: this.column };
              }, E;
            }();
            a.Token = r, (0, d.default)(r);
            function _(E) {
              return E != null && typeof E.kind == "string";
            }
          } }), ne = L({ "node_modules/graphql/language/tokenKind.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.TokenKind = void 0;
            var d = Object.freeze({ SOF: "<SOF>", EOF: "<EOF>", BANG: "!", DOLLAR: "$", AMP: "&", PAREN_L: "(", PAREN_R: ")", SPREAD: "...", COLON: ":", EQUALS: "=", AT: "@", BRACKET_L: "[", BRACKET_R: "]", BRACE_L: "{", PIPE: "|", BRACE_R: "}", NAME: "Name", INT: "Int", FLOAT: "Float", STRING: "String", BLOCK_STRING: "BlockString", COMMENT: "Comment" });
            a.TokenKind = d;
          } }), re = L({ "node_modules/graphql/jsutils/inspect.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = E;
            var d = i(ee());
            function i(v) {
              return v && v.__esModule ? v : { default: v };
            }
            function c(v) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(s) {
                return typeof s;
              } : c = function(s) {
                return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
              }, c(v);
            }
            var r = 10, _ = 2;
            function E(v) {
              return k(v, []);
            }
            function k(v, I) {
              switch (c(v)) {
                case "string":
                  return JSON.stringify(v);
                case "function":
                  return v.name ? "[function ".concat(v.name, "]") : "[function]";
                case "object":
                  return v === null ? "null" : O(v, I);
                default:
                  return String(v);
              }
            }
            function O(v, I) {
              if (I.indexOf(v) !== -1)
                return "[Circular]";
              var s = [].concat(I, [v]), p = g(v);
              if (p !== void 0) {
                var e = p.call(v);
                if (e !== v)
                  return typeof e == "string" ? e : k(e, s);
              } else if (Array.isArray(v))
                return N(v, s);
              return A(v, s);
            }
            function A(v, I) {
              var s = Object.keys(v);
              if (s.length === 0)
                return "{}";
              if (I.length > _)
                return "[" + D(v) + "]";
              var p = s.map(function(e) {
                var n = k(v[e], I);
                return e + ": " + n;
              });
              return "{ " + p.join(", ") + " }";
            }
            function N(v, I) {
              if (v.length === 0)
                return "[]";
              if (I.length > _)
                return "[Array]";
              for (var s = Math.min(r, v.length), p = v.length - s, e = [], n = 0; n < s; ++n)
                e.push(k(v[n], I));
              return p === 1 ? e.push("... 1 more item") : p > 1 && e.push("... ".concat(p, " more items")), "[" + e.join(", ") + "]";
            }
            function g(v) {
              var I = v[String(d.default)];
              if (typeof I == "function")
                return I;
              if (typeof v.inspect == "function")
                return v.inspect;
            }
            function D(v) {
              var I = Object.prototype.toString.call(v).replace(/^\[object /, "").replace(/]$/, "");
              if (I === "Object" && typeof v.constructor == "function") {
                var s = v.constructor.name;
                if (typeof s == "string" && s !== "")
                  return s;
              }
              return I;
            }
          } }), _e = L({ "node_modules/graphql/jsutils/devAssert.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = d;
            function d(i, c) {
              var r = Boolean(i);
              if (!r)
                throw new Error(c);
            }
          } }), Ee = L({ "node_modules/graphql/jsutils/instanceOf.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = void 0;
            var d = i(re());
            function i(r) {
              return r && r.__esModule ? r : { default: r };
            }
            var c = function(_, E) {
              return _ instanceof E;
            };
            a.default = c;
          } }), me = L({ "node_modules/graphql/language/source.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isSource = A, a.Source = void 0;
            var d = z(), i = _(re()), c = _(_e()), r = _(Ee());
            function _(N) {
              return N && N.__esModule ? N : { default: N };
            }
            function E(N, g) {
              for (var D = 0; D < g.length; D++) {
                var v = g[D];
                v.enumerable = v.enumerable || false, v.configurable = true, "value" in v && (v.writable = true), Object.defineProperty(N, v.key, v);
              }
            }
            function k(N, g, D) {
              return g && E(N.prototype, g), D && E(N, D), N;
            }
            var O = function() {
              function N(g) {
                var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request", v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { line: 1, column: 1 };
                typeof g == "string" || (0, c.default)(0, "Body must be a string. Received: ".concat((0, i.default)(g), ".")), this.body = g, this.name = D, this.locationOffset = v, this.locationOffset.line > 0 || (0, c.default)(0, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || (0, c.default)(0, "column in locationOffset is 1-indexed and must be positive.");
              }
              return k(N, [{ key: d.SYMBOL_TO_STRING_TAG, get: function() {
                return "Source";
              } }]), N;
            }();
            a.Source = O;
            function A(N) {
              return (0, r.default)(N, O);
            }
          } }), ye = L({ "node_modules/graphql/language/directiveLocation.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.DirectiveLocation = void 0;
            var d = Object.freeze({ QUERY: "QUERY", MUTATION: "MUTATION", SUBSCRIPTION: "SUBSCRIPTION", FIELD: "FIELD", FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION", FRAGMENT_SPREAD: "FRAGMENT_SPREAD", INLINE_FRAGMENT: "INLINE_FRAGMENT", VARIABLE_DEFINITION: "VARIABLE_DEFINITION", SCHEMA: "SCHEMA", SCALAR: "SCALAR", OBJECT: "OBJECT", FIELD_DEFINITION: "FIELD_DEFINITION", ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION", INTERFACE: "INTERFACE", UNION: "UNION", ENUM: "ENUM", ENUM_VALUE: "ENUM_VALUE", INPUT_OBJECT: "INPUT_OBJECT", INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION" });
            a.DirectiveLocation = d;
          } }), ke = L({ "node_modules/graphql/language/blockString.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.dedentBlockStringValue = d, a.getBlockStringIndentation = c, a.printBlockString = r;
            function d(_) {
              var E = _.split(/\r\n|[\n\r]/g), k = c(_);
              if (k !== 0)
                for (var O = 1; O < E.length; O++)
                  E[O] = E[O].slice(k);
              for (var A = 0; A < E.length && i(E[A]); )
                ++A;
              for (var N = E.length; N > A && i(E[N - 1]); )
                --N;
              return E.slice(A, N).join(`
`);
            }
            function i(_) {
              for (var E = 0; E < _.length; ++E)
                if (_[E] !== " " && _[E] !== "	")
                  return false;
              return true;
            }
            function c(_) {
              for (var E, k = true, O = true, A = 0, N = null, g = 0; g < _.length; ++g)
                switch (_.charCodeAt(g)) {
                  case 13:
                    _.charCodeAt(g + 1) === 10 && ++g;
                  case 10:
                    k = false, O = true, A = 0;
                    break;
                  case 9:
                  case 32:
                    ++A;
                    break;
                  default:
                    O && !k && (N === null || A < N) && (N = A), O = false;
                }
              return (E = N) !== null && E !== void 0 ? E : 0;
            }
            function r(_) {
              var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", k = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, O = _.indexOf(`
`) === -1, A = _[0] === " " || _[0] === "	", N = _[_.length - 1] === '"', g = _[_.length - 1] === "\\", D = !O || N || g || k, v = "";
              return D && !(O && A) && (v += `
` + E), v += E ? _.replace(/\n/g, `
` + E) : _, D && (v += `
`), '"""' + v.replace(/"""/g, '\\"""') + '"""';
            }
          } }), Ne = L({ "node_modules/graphql/language/lexer.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isPunctuatorTokenKind = E, a.Lexer = void 0;
            var d = Z(), i = te(), c = ne(), r = ke(), _ = function() {
              function t(y) {
                var f = new i.Token(c.TokenKind.SOF, 0, 0, 0, 0, null);
                this.source = y, this.lastToken = f, this.token = f, this.line = 1, this.lineStart = 0;
              }
              var u = t.prototype;
              return u.advance = function() {
                this.lastToken = this.token;
                var f = this.token = this.lookahead();
                return f;
              }, u.lookahead = function() {
                var f = this.token;
                if (f.kind !== c.TokenKind.EOF)
                  do {
                    var m;
                    f = (m = f.next) !== null && m !== void 0 ? m : f.next = O(this, f);
                  } while (f.kind === c.TokenKind.COMMENT);
                return f;
              }, t;
            }();
            a.Lexer = _;
            function E(t) {
              return t === c.TokenKind.BANG || t === c.TokenKind.DOLLAR || t === c.TokenKind.AMP || t === c.TokenKind.PAREN_L || t === c.TokenKind.PAREN_R || t === c.TokenKind.SPREAD || t === c.TokenKind.COLON || t === c.TokenKind.EQUALS || t === c.TokenKind.AT || t === c.TokenKind.BRACKET_L || t === c.TokenKind.BRACKET_R || t === c.TokenKind.BRACE_L || t === c.TokenKind.PIPE || t === c.TokenKind.BRACE_R;
            }
            function k(t) {
              return isNaN(t) ? c.TokenKind.EOF : t < 127 ? JSON.stringify(String.fromCharCode(t)) : '"\\u'.concat(("00" + t.toString(16).toUpperCase()).slice(-4), '"');
            }
            function O(t, u) {
              for (var y = t.source, f = y.body, m = f.length, o = u.end; o < m; ) {
                var h = f.charCodeAt(o), l = t.line, T = 1 + o - t.lineStart;
                switch (h) {
                  case 65279:
                  case 9:
                  case 32:
                  case 44:
                    ++o;
                    continue;
                  case 10:
                    ++o, ++t.line, t.lineStart = o;
                    continue;
                  case 13:
                    f.charCodeAt(o + 1) === 10 ? o += 2 : ++o, ++t.line, t.lineStart = o;
                    continue;
                  case 33:
                    return new i.Token(c.TokenKind.BANG, o, o + 1, l, T, u);
                  case 35:
                    return N(y, o, l, T, u);
                  case 36:
                    return new i.Token(c.TokenKind.DOLLAR, o, o + 1, l, T, u);
                  case 38:
                    return new i.Token(c.TokenKind.AMP, o, o + 1, l, T, u);
                  case 40:
                    return new i.Token(c.TokenKind.PAREN_L, o, o + 1, l, T, u);
                  case 41:
                    return new i.Token(c.TokenKind.PAREN_R, o, o + 1, l, T, u);
                  case 46:
                    if (f.charCodeAt(o + 1) === 46 && f.charCodeAt(o + 2) === 46)
                      return new i.Token(c.TokenKind.SPREAD, o, o + 3, l, T, u);
                    break;
                  case 58:
                    return new i.Token(c.TokenKind.COLON, o, o + 1, l, T, u);
                  case 61:
                    return new i.Token(c.TokenKind.EQUALS, o, o + 1, l, T, u);
                  case 64:
                    return new i.Token(c.TokenKind.AT, o, o + 1, l, T, u);
                  case 91:
                    return new i.Token(c.TokenKind.BRACKET_L, o, o + 1, l, T, u);
                  case 93:
                    return new i.Token(c.TokenKind.BRACKET_R, o, o + 1, l, T, u);
                  case 123:
                    return new i.Token(c.TokenKind.BRACE_L, o, o + 1, l, T, u);
                  case 124:
                    return new i.Token(c.TokenKind.PIPE, o, o + 1, l, T, u);
                  case 125:
                    return new i.Token(c.TokenKind.BRACE_R, o, o + 1, l, T, u);
                  case 34:
                    return f.charCodeAt(o + 1) === 34 && f.charCodeAt(o + 2) === 34 ? I(y, o, l, T, u, t) : v(y, o, l, T, u);
                  case 45:
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return g(y, o, h, l, T, u);
                  case 65:
                  case 66:
                  case 67:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                  case 78:
                  case 79:
                  case 80:
                  case 81:
                  case 82:
                  case 83:
                  case 84:
                  case 85:
                  case 86:
                  case 87:
                  case 88:
                  case 89:
                  case 90:
                  case 95:
                  case 97:
                  case 98:
                  case 99:
                  case 100:
                  case 101:
                  case 102:
                  case 103:
                  case 104:
                  case 105:
                  case 106:
                  case 107:
                  case 108:
                  case 109:
                  case 110:
                  case 111:
                  case 112:
                  case 113:
                  case 114:
                  case 115:
                  case 116:
                  case 117:
                  case 118:
                  case 119:
                  case 120:
                  case 121:
                  case 122:
                    return e(y, o, l, T, u);
                }
                throw (0, d.syntaxError)(y, o, A(h));
              }
              var S = t.line, x = 1 + o - t.lineStart;
              return new i.Token(c.TokenKind.EOF, m, m, S, x, u);
            }
            function A(t) {
              return t < 32 && t !== 9 && t !== 10 && t !== 13 ? "Cannot contain the invalid character ".concat(k(t), ".") : t === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : "Cannot parse the unexpected character ".concat(k(t), ".");
            }
            function N(t, u, y, f, m) {
              var o = t.body, h, l = u;
              do
                h = o.charCodeAt(++l);
              while (!isNaN(h) && (h > 31 || h === 9));
              return new i.Token(c.TokenKind.COMMENT, u, l, y, f, m, o.slice(u + 1, l));
            }
            function g(t, u, y, f, m, o) {
              var h = t.body, l = y, T = u, S = false;
              if (l === 45 && (l = h.charCodeAt(++T)), l === 48) {
                if (l = h.charCodeAt(++T), l >= 48 && l <= 57)
                  throw (0, d.syntaxError)(t, T, "Invalid number, unexpected digit after 0: ".concat(k(l), "."));
              } else
                T = D(t, T, l), l = h.charCodeAt(T);
              if (l === 46 && (S = true, l = h.charCodeAt(++T), T = D(t, T, l), l = h.charCodeAt(T)), (l === 69 || l === 101) && (S = true, l = h.charCodeAt(++T), (l === 43 || l === 45) && (l = h.charCodeAt(++T)), T = D(t, T, l), l = h.charCodeAt(T)), l === 46 || n(l))
                throw (0, d.syntaxError)(t, T, "Invalid number, expected digit but got: ".concat(k(l), "."));
              return new i.Token(S ? c.TokenKind.FLOAT : c.TokenKind.INT, u, T, f, m, o, h.slice(u, T));
            }
            function D(t, u, y) {
              var f = t.body, m = u, o = y;
              if (o >= 48 && o <= 57) {
                do
                  o = f.charCodeAt(++m);
                while (o >= 48 && o <= 57);
                return m;
              }
              throw (0, d.syntaxError)(t, m, "Invalid number, expected digit but got: ".concat(k(o), "."));
            }
            function v(t, u, y, f, m) {
              for (var o = t.body, h = u + 1, l = h, T = 0, S = ""; h < o.length && !isNaN(T = o.charCodeAt(h)) && T !== 10 && T !== 13; ) {
                if (T === 34)
                  return S += o.slice(l, h), new i.Token(c.TokenKind.STRING, u, h + 1, y, f, m, S);
                if (T < 32 && T !== 9)
                  throw (0, d.syntaxError)(t, h, "Invalid character within String: ".concat(k(T), "."));
                if (++h, T === 92) {
                  switch (S += o.slice(l, h - 1), T = o.charCodeAt(h), T) {
                    case 34:
                      S += '"';
                      break;
                    case 47:
                      S += "/";
                      break;
                    case 92:
                      S += "\\";
                      break;
                    case 98:
                      S += "\b";
                      break;
                    case 102:
                      S += "\f";
                      break;
                    case 110:
                      S += `
`;
                      break;
                    case 114:
                      S += "\r";
                      break;
                    case 116:
                      S += "	";
                      break;
                    case 117: {
                      var x = s(o.charCodeAt(h + 1), o.charCodeAt(h + 2), o.charCodeAt(h + 3), o.charCodeAt(h + 4));
                      if (x < 0) {
                        var b = o.slice(h + 1, h + 5);
                        throw (0, d.syntaxError)(t, h, "Invalid character escape sequence: \\u".concat(b, "."));
                      }
                      S += String.fromCharCode(x), h += 4;
                      break;
                    }
                    default:
                      throw (0, d.syntaxError)(t, h, "Invalid character escape sequence: \\".concat(String.fromCharCode(T), "."));
                  }
                  ++h, l = h;
                }
              }
              throw (0, d.syntaxError)(t, h, "Unterminated string.");
            }
            function I(t, u, y, f, m, o) {
              for (var h = t.body, l = u + 3, T = l, S = 0, x = ""; l < h.length && !isNaN(S = h.charCodeAt(l)); ) {
                if (S === 34 && h.charCodeAt(l + 1) === 34 && h.charCodeAt(l + 2) === 34)
                  return x += h.slice(T, l), new i.Token(c.TokenKind.BLOCK_STRING, u, l + 3, y, f, m, (0, r.dedentBlockStringValue)(x));
                if (S < 32 && S !== 9 && S !== 10 && S !== 13)
                  throw (0, d.syntaxError)(t, l, "Invalid character within String: ".concat(k(S), "."));
                S === 10 ? (++l, ++o.line, o.lineStart = l) : S === 13 ? (h.charCodeAt(l + 1) === 10 ? l += 2 : ++l, ++o.line, o.lineStart = l) : S === 92 && h.charCodeAt(l + 1) === 34 && h.charCodeAt(l + 2) === 34 && h.charCodeAt(l + 3) === 34 ? (x += h.slice(T, l) + '"""', l += 4, T = l) : ++l;
              }
              throw (0, d.syntaxError)(t, l, "Unterminated string.");
            }
            function s(t, u, y, f) {
              return p(t) << 12 | p(u) << 8 | p(y) << 4 | p(f);
            }
            function p(t) {
              return t >= 48 && t <= 57 ? t - 48 : t >= 65 && t <= 70 ? t - 55 : t >= 97 && t <= 102 ? t - 87 : -1;
            }
            function e(t, u, y, f, m) {
              for (var o = t.body, h = o.length, l = u + 1, T = 0; l !== h && !isNaN(T = o.charCodeAt(l)) && (T === 95 || T >= 48 && T <= 57 || T >= 65 && T <= 90 || T >= 97 && T <= 122); )
                ++l;
              return new i.Token(c.TokenKind.NAME, u, l, y, f, m, o.slice(u, l));
            }
            function n(t) {
              return t === 95 || t >= 65 && t <= 90 || t >= 97 && t <= 122;
            }
          } }), Oe = L({ "node_modules/graphql/language/parser.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.parse = O, a.parseValue = A, a.parseType = N, a.Parser = void 0;
            var d = Z(), i = he(), c = te(), r = ne(), _ = me(), E = ye(), k = Ne();
            function O(I, s) {
              var p = new g(I, s);
              return p.parseDocument();
            }
            function A(I, s) {
              var p = new g(I, s);
              p.expectToken(r.TokenKind.SOF);
              var e = p.parseValueLiteral(false);
              return p.expectToken(r.TokenKind.EOF), e;
            }
            function N(I, s) {
              var p = new g(I, s);
              p.expectToken(r.TokenKind.SOF);
              var e = p.parseTypeReference();
              return p.expectToken(r.TokenKind.EOF), e;
            }
            var g = function() {
              function I(p, e) {
                var n = (0, _.isSource)(p) ? p : new _.Source(p);
                this._lexer = new k.Lexer(n), this._options = e;
              }
              var s = I.prototype;
              return s.parseName = function() {
                var e = this.expectToken(r.TokenKind.NAME);
                return { kind: i.Kind.NAME, value: e.value, loc: this.loc(e) };
              }, s.parseDocument = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.DOCUMENT, definitions: this.many(r.TokenKind.SOF, this.parseDefinition, r.TokenKind.EOF), loc: this.loc(e) };
              }, s.parseDefinition = function() {
                if (this.peek(r.TokenKind.NAME))
                  switch (this._lexer.token.value) {
                    case "query":
                    case "mutation":
                    case "subscription":
                      return this.parseOperationDefinition();
                    case "fragment":
                      return this.parseFragmentDefinition();
                    case "schema":
                    case "scalar":
                    case "type":
                    case "interface":
                    case "union":
                    case "enum":
                    case "input":
                    case "directive":
                      return this.parseTypeSystemDefinition();
                    case "extend":
                      return this.parseTypeSystemExtension();
                  }
                else {
                  if (this.peek(r.TokenKind.BRACE_L))
                    return this.parseOperationDefinition();
                  if (this.peekDescription())
                    return this.parseTypeSystemDefinition();
                }
                throw this.unexpected();
              }, s.parseOperationDefinition = function() {
                var e = this._lexer.token;
                if (this.peek(r.TokenKind.BRACE_L))
                  return { kind: i.Kind.OPERATION_DEFINITION, operation: "query", name: void 0, variableDefinitions: [], directives: [], selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
                var n = this.parseOperationType(), t;
                return this.peek(r.TokenKind.NAME) && (t = this.parseName()), { kind: i.Kind.OPERATION_DEFINITION, operation: n, name: t, variableDefinitions: this.parseVariableDefinitions(), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
              }, s.parseOperationType = function() {
                var e = this.expectToken(r.TokenKind.NAME);
                switch (e.value) {
                  case "query":
                    return "query";
                  case "mutation":
                    return "mutation";
                  case "subscription":
                    return "subscription";
                }
                throw this.unexpected(e);
              }, s.parseVariableDefinitions = function() {
                return this.optionalMany(r.TokenKind.PAREN_L, this.parseVariableDefinition, r.TokenKind.PAREN_R);
              }, s.parseVariableDefinition = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.VARIABLE_DEFINITION, variable: this.parseVariable(), type: (this.expectToken(r.TokenKind.COLON), this.parseTypeReference()), defaultValue: this.expectOptionalToken(r.TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0, directives: this.parseDirectives(true), loc: this.loc(e) };
              }, s.parseVariable = function() {
                var e = this._lexer.token;
                return this.expectToken(r.TokenKind.DOLLAR), { kind: i.Kind.VARIABLE, name: this.parseName(), loc: this.loc(e) };
              }, s.parseSelectionSet = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.SELECTION_SET, selections: this.many(r.TokenKind.BRACE_L, this.parseSelection, r.TokenKind.BRACE_R), loc: this.loc(e) };
              }, s.parseSelection = function() {
                return this.peek(r.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
              }, s.parseField = function() {
                var e = this._lexer.token, n = this.parseName(), t, u;
                return this.expectOptionalToken(r.TokenKind.COLON) ? (t = n, u = this.parseName()) : u = n, { kind: i.Kind.FIELD, alias: t, name: u, arguments: this.parseArguments(false), directives: this.parseDirectives(false), selectionSet: this.peek(r.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0, loc: this.loc(e) };
              }, s.parseArguments = function(e) {
                var n = e ? this.parseConstArgument : this.parseArgument;
                return this.optionalMany(r.TokenKind.PAREN_L, n, r.TokenKind.PAREN_R);
              }, s.parseArgument = function() {
                var e = this._lexer.token, n = this.parseName();
                return this.expectToken(r.TokenKind.COLON), { kind: i.Kind.ARGUMENT, name: n, value: this.parseValueLiteral(false), loc: this.loc(e) };
              }, s.parseConstArgument = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.ARGUMENT, name: this.parseName(), value: (this.expectToken(r.TokenKind.COLON), this.parseValueLiteral(true)), loc: this.loc(e) };
              }, s.parseFragment = function() {
                var e = this._lexer.token;
                this.expectToken(r.TokenKind.SPREAD);
                var n = this.expectOptionalKeyword("on");
                return !n && this.peek(r.TokenKind.NAME) ? { kind: i.Kind.FRAGMENT_SPREAD, name: this.parseFragmentName(), directives: this.parseDirectives(false), loc: this.loc(e) } : { kind: i.Kind.INLINE_FRAGMENT, typeCondition: n ? this.parseNamedType() : void 0, directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
              }, s.parseFragmentDefinition = function() {
                var e, n = this._lexer.token;
                return this.expectKeyword("fragment"), ((e = this._options) === null || e === void 0 ? void 0 : e.experimentalFragmentVariables) === true ? { kind: i.Kind.FRAGMENT_DEFINITION, name: this.parseFragmentName(), variableDefinitions: this.parseVariableDefinitions(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(n) } : { kind: i.Kind.FRAGMENT_DEFINITION, name: this.parseFragmentName(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(n) };
              }, s.parseFragmentName = function() {
                if (this._lexer.token.value === "on")
                  throw this.unexpected();
                return this.parseName();
              }, s.parseValueLiteral = function(e) {
                var n = this._lexer.token;
                switch (n.kind) {
                  case r.TokenKind.BRACKET_L:
                    return this.parseList(e);
                  case r.TokenKind.BRACE_L:
                    return this.parseObject(e);
                  case r.TokenKind.INT:
                    return this._lexer.advance(), { kind: i.Kind.INT, value: n.value, loc: this.loc(n) };
                  case r.TokenKind.FLOAT:
                    return this._lexer.advance(), { kind: i.Kind.FLOAT, value: n.value, loc: this.loc(n) };
                  case r.TokenKind.STRING:
                  case r.TokenKind.BLOCK_STRING:
                    return this.parseStringLiteral();
                  case r.TokenKind.NAME:
                    switch (this._lexer.advance(), n.value) {
                      case "true":
                        return { kind: i.Kind.BOOLEAN, value: true, loc: this.loc(n) };
                      case "false":
                        return { kind: i.Kind.BOOLEAN, value: false, loc: this.loc(n) };
                      case "null":
                        return { kind: i.Kind.NULL, loc: this.loc(n) };
                      default:
                        return { kind: i.Kind.ENUM, value: n.value, loc: this.loc(n) };
                    }
                  case r.TokenKind.DOLLAR:
                    if (!e)
                      return this.parseVariable();
                    break;
                }
                throw this.unexpected();
              }, s.parseStringLiteral = function() {
                var e = this._lexer.token;
                return this._lexer.advance(), { kind: i.Kind.STRING, value: e.value, block: e.kind === r.TokenKind.BLOCK_STRING, loc: this.loc(e) };
              }, s.parseList = function(e) {
                var n = this, t = this._lexer.token, u = function() {
                  return n.parseValueLiteral(e);
                };
                return { kind: i.Kind.LIST, values: this.any(r.TokenKind.BRACKET_L, u, r.TokenKind.BRACKET_R), loc: this.loc(t) };
              }, s.parseObject = function(e) {
                var n = this, t = this._lexer.token, u = function() {
                  return n.parseObjectField(e);
                };
                return { kind: i.Kind.OBJECT, fields: this.any(r.TokenKind.BRACE_L, u, r.TokenKind.BRACE_R), loc: this.loc(t) };
              }, s.parseObjectField = function(e) {
                var n = this._lexer.token, t = this.parseName();
                return this.expectToken(r.TokenKind.COLON), { kind: i.Kind.OBJECT_FIELD, name: t, value: this.parseValueLiteral(e), loc: this.loc(n) };
              }, s.parseDirectives = function(e) {
                for (var n = []; this.peek(r.TokenKind.AT); )
                  n.push(this.parseDirective(e));
                return n;
              }, s.parseDirective = function(e) {
                var n = this._lexer.token;
                return this.expectToken(r.TokenKind.AT), { kind: i.Kind.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(e), loc: this.loc(n) };
              }, s.parseTypeReference = function() {
                var e = this._lexer.token, n;
                return this.expectOptionalToken(r.TokenKind.BRACKET_L) ? (n = this.parseTypeReference(), this.expectToken(r.TokenKind.BRACKET_R), n = { kind: i.Kind.LIST_TYPE, type: n, loc: this.loc(e) }) : n = this.parseNamedType(), this.expectOptionalToken(r.TokenKind.BANG) ? { kind: i.Kind.NON_NULL_TYPE, type: n, loc: this.loc(e) } : n;
              }, s.parseNamedType = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.NAMED_TYPE, name: this.parseName(), loc: this.loc(e) };
              }, s.parseTypeSystemDefinition = function() {
                var e = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
                if (e.kind === r.TokenKind.NAME)
                  switch (e.value) {
                    case "schema":
                      return this.parseSchemaDefinition();
                    case "scalar":
                      return this.parseScalarTypeDefinition();
                    case "type":
                      return this.parseObjectTypeDefinition();
                    case "interface":
                      return this.parseInterfaceTypeDefinition();
                    case "union":
                      return this.parseUnionTypeDefinition();
                    case "enum":
                      return this.parseEnumTypeDefinition();
                    case "input":
                      return this.parseInputObjectTypeDefinition();
                    case "directive":
                      return this.parseDirectiveDefinition();
                  }
                throw this.unexpected(e);
              }, s.peekDescription = function() {
                return this.peek(r.TokenKind.STRING) || this.peek(r.TokenKind.BLOCK_STRING);
              }, s.parseDescription = function() {
                if (this.peekDescription())
                  return this.parseStringLiteral();
              }, s.parseSchemaDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("schema");
                var t = this.parseDirectives(true), u = this.many(r.TokenKind.BRACE_L, this.parseOperationTypeDefinition, r.TokenKind.BRACE_R);
                return { kind: i.Kind.SCHEMA_DEFINITION, description: n, directives: t, operationTypes: u, loc: this.loc(e) };
              }, s.parseOperationTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseOperationType();
                this.expectToken(r.TokenKind.COLON);
                var t = this.parseNamedType();
                return { kind: i.Kind.OPERATION_TYPE_DEFINITION, operation: n, type: t, loc: this.loc(e) };
              }, s.parseScalarTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("scalar");
                var t = this.parseName(), u = this.parseDirectives(true);
                return { kind: i.Kind.SCALAR_TYPE_DEFINITION, description: n, name: t, directives: u, loc: this.loc(e) };
              }, s.parseObjectTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("type");
                var t = this.parseName(), u = this.parseImplementsInterfaces(), y = this.parseDirectives(true), f = this.parseFieldsDefinition();
                return { kind: i.Kind.OBJECT_TYPE_DEFINITION, description: n, name: t, interfaces: u, directives: y, fields: f, loc: this.loc(e) };
              }, s.parseImplementsInterfaces = function() {
                var e;
                if (!this.expectOptionalKeyword("implements"))
                  return [];
                if (((e = this._options) === null || e === void 0 ? void 0 : e.allowLegacySDLImplementsInterfaces) === true) {
                  var n = [];
                  this.expectOptionalToken(r.TokenKind.AMP);
                  do
                    n.push(this.parseNamedType());
                  while (this.expectOptionalToken(r.TokenKind.AMP) || this.peek(r.TokenKind.NAME));
                  return n;
                }
                return this.delimitedMany(r.TokenKind.AMP, this.parseNamedType);
              }, s.parseFieldsDefinition = function() {
                var e;
                return ((e = this._options) === null || e === void 0 ? void 0 : e.allowLegacySDLEmptyFields) === true && this.peek(r.TokenKind.BRACE_L) && this._lexer.lookahead().kind === r.TokenKind.BRACE_R ? (this._lexer.advance(), this._lexer.advance(), []) : this.optionalMany(r.TokenKind.BRACE_L, this.parseFieldDefinition, r.TokenKind.BRACE_R);
              }, s.parseFieldDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName(), u = this.parseArgumentDefs();
                this.expectToken(r.TokenKind.COLON);
                var y = this.parseTypeReference(), f = this.parseDirectives(true);
                return { kind: i.Kind.FIELD_DEFINITION, description: n, name: t, arguments: u, type: y, directives: f, loc: this.loc(e) };
              }, s.parseArgumentDefs = function() {
                return this.optionalMany(r.TokenKind.PAREN_L, this.parseInputValueDef, r.TokenKind.PAREN_R);
              }, s.parseInputValueDef = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName();
                this.expectToken(r.TokenKind.COLON);
                var u = this.parseTypeReference(), y;
                this.expectOptionalToken(r.TokenKind.EQUALS) && (y = this.parseValueLiteral(true));
                var f = this.parseDirectives(true);
                return { kind: i.Kind.INPUT_VALUE_DEFINITION, description: n, name: t, type: u, defaultValue: y, directives: f, loc: this.loc(e) };
              }, s.parseInterfaceTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("interface");
                var t = this.parseName(), u = this.parseImplementsInterfaces(), y = this.parseDirectives(true), f = this.parseFieldsDefinition();
                return { kind: i.Kind.INTERFACE_TYPE_DEFINITION, description: n, name: t, interfaces: u, directives: y, fields: f, loc: this.loc(e) };
              }, s.parseUnionTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("union");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseUnionMemberTypes();
                return { kind: i.Kind.UNION_TYPE_DEFINITION, description: n, name: t, directives: u, types: y, loc: this.loc(e) };
              }, s.parseUnionMemberTypes = function() {
                return this.expectOptionalToken(r.TokenKind.EQUALS) ? this.delimitedMany(r.TokenKind.PIPE, this.parseNamedType) : [];
              }, s.parseEnumTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("enum");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseEnumValuesDefinition();
                return { kind: i.Kind.ENUM_TYPE_DEFINITION, description: n, name: t, directives: u, values: y, loc: this.loc(e) };
              }, s.parseEnumValuesDefinition = function() {
                return this.optionalMany(r.TokenKind.BRACE_L, this.parseEnumValueDefinition, r.TokenKind.BRACE_R);
              }, s.parseEnumValueDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName(), u = this.parseDirectives(true);
                return { kind: i.Kind.ENUM_VALUE_DEFINITION, description: n, name: t, directives: u, loc: this.loc(e) };
              }, s.parseInputObjectTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("input");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseInputFieldsDefinition();
                return { kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION, description: n, name: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseInputFieldsDefinition = function() {
                return this.optionalMany(r.TokenKind.BRACE_L, this.parseInputValueDef, r.TokenKind.BRACE_R);
              }, s.parseTypeSystemExtension = function() {
                var e = this._lexer.lookahead();
                if (e.kind === r.TokenKind.NAME)
                  switch (e.value) {
                    case "schema":
                      return this.parseSchemaExtension();
                    case "scalar":
                      return this.parseScalarTypeExtension();
                    case "type":
                      return this.parseObjectTypeExtension();
                    case "interface":
                      return this.parseInterfaceTypeExtension();
                    case "union":
                      return this.parseUnionTypeExtension();
                    case "enum":
                      return this.parseEnumTypeExtension();
                    case "input":
                      return this.parseInputObjectTypeExtension();
                  }
                throw this.unexpected(e);
              }, s.parseSchemaExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("schema");
                var n = this.parseDirectives(true), t = this.optionalMany(r.TokenKind.BRACE_L, this.parseOperationTypeDefinition, r.TokenKind.BRACE_R);
                if (n.length === 0 && t.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.SCHEMA_EXTENSION, directives: n, operationTypes: t, loc: this.loc(e) };
              }, s.parseScalarTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("scalar");
                var n = this.parseName(), t = this.parseDirectives(true);
                if (t.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.SCALAR_TYPE_EXTENSION, name: n, directives: t, loc: this.loc(e) };
              }, s.parseObjectTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("type");
                var n = this.parseName(), t = this.parseImplementsInterfaces(), u = this.parseDirectives(true), y = this.parseFieldsDefinition();
                if (t.length === 0 && u.length === 0 && y.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.OBJECT_TYPE_EXTENSION, name: n, interfaces: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseInterfaceTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("interface");
                var n = this.parseName(), t = this.parseImplementsInterfaces(), u = this.parseDirectives(true), y = this.parseFieldsDefinition();
                if (t.length === 0 && u.length === 0 && y.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.INTERFACE_TYPE_EXTENSION, name: n, interfaces: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseUnionTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("union");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseUnionMemberTypes();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.UNION_TYPE_EXTENSION, name: n, directives: t, types: u, loc: this.loc(e) };
              }, s.parseEnumTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("enum");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseEnumValuesDefinition();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.ENUM_TYPE_EXTENSION, name: n, directives: t, values: u, loc: this.loc(e) };
              }, s.parseInputObjectTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("input");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseInputFieldsDefinition();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION, name: n, directives: t, fields: u, loc: this.loc(e) };
              }, s.parseDirectiveDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("directive"), this.expectToken(r.TokenKind.AT);
                var t = this.parseName(), u = this.parseArgumentDefs(), y = this.expectOptionalKeyword("repeatable");
                this.expectKeyword("on");
                var f = this.parseDirectiveLocations();
                return { kind: i.Kind.DIRECTIVE_DEFINITION, description: n, name: t, arguments: u, repeatable: y, locations: f, loc: this.loc(e) };
              }, s.parseDirectiveLocations = function() {
                return this.delimitedMany(r.TokenKind.PIPE, this.parseDirectiveLocation);
              }, s.parseDirectiveLocation = function() {
                var e = this._lexer.token, n = this.parseName();
                if (E.DirectiveLocation[n.value] !== void 0)
                  return n;
                throw this.unexpected(e);
              }, s.loc = function(e) {
                var n;
                if (((n = this._options) === null || n === void 0 ? void 0 : n.noLocation) !== true)
                  return new c.Location(e, this._lexer.lastToken, this._lexer.source);
              }, s.peek = function(e) {
                return this._lexer.token.kind === e;
              }, s.expectToken = function(e) {
                var n = this._lexer.token;
                if (n.kind === e)
                  return this._lexer.advance(), n;
                throw (0, d.syntaxError)(this._lexer.source, n.start, "Expected ".concat(v(e), ", found ").concat(D(n), "."));
              }, s.expectOptionalToken = function(e) {
                var n = this._lexer.token;
                if (n.kind === e)
                  return this._lexer.advance(), n;
              }, s.expectKeyword = function(e) {
                var n = this._lexer.token;
                if (n.kind === r.TokenKind.NAME && n.value === e)
                  this._lexer.advance();
                else
                  throw (0, d.syntaxError)(this._lexer.source, n.start, 'Expected "'.concat(e, '", found ').concat(D(n), "."));
              }, s.expectOptionalKeyword = function(e) {
                var n = this._lexer.token;
                return n.kind === r.TokenKind.NAME && n.value === e ? (this._lexer.advance(), true) : false;
              }, s.unexpected = function(e) {
                var n = e != null ? e : this._lexer.token;
                return (0, d.syntaxError)(this._lexer.source, n.start, "Unexpected ".concat(D(n), "."));
              }, s.any = function(e, n, t) {
                this.expectToken(e);
                for (var u = []; !this.expectOptionalToken(t); )
                  u.push(n.call(this));
                return u;
              }, s.optionalMany = function(e, n, t) {
                if (this.expectOptionalToken(e)) {
                  var u = [];
                  do
                    u.push(n.call(this));
                  while (!this.expectOptionalToken(t));
                  return u;
                }
                return [];
              }, s.many = function(e, n, t) {
                this.expectToken(e);
                var u = [];
                do
                  u.push(n.call(this));
                while (!this.expectOptionalToken(t));
                return u;
              }, s.delimitedMany = function(e, n) {
                this.expectOptionalToken(e);
                var t = [];
                do
                  t.push(n.call(this));
                while (this.expectOptionalToken(e));
                return t;
              }, I;
            }();
            a.Parser = g;
            function D(I) {
              var s = I.value;
              return v(I.kind) + (s != null ? ' "'.concat(s, '"') : "");
            }
            function v(I) {
              return (0, k.isPunctuatorTokenKind)(I) ? '"'.concat(I, '"') : I;
            }
          } });
          K();
          var Ie = ce(), ge = ue(), { hasPragma: Se } = le(), { locStart: Ae, locEnd: De } = pe();
          function Ke(a) {
            let d = [], { startToken: i } = a.loc, { next: c } = i;
            for (; c.kind !== "<EOF>"; )
              c.kind === "Comment" && (Object.assign(c, { column: c.column - 1 }), d.push(c)), c = c.next;
            return d;
          }
          function ie(a) {
            if (a && typeof a == "object") {
              delete a.startToken, delete a.endToken, delete a.prev, delete a.next;
              for (let d in a)
                ie(a[d]);
            }
            return a;
          }
          var X = { allowLegacySDLImplementsInterfaces: false, experimentalFragmentVariables: true };
          function Le(a) {
            let { GraphQLError: d } = W();
            if (a instanceof d) {
              let { message: i, locations: [c] } = a;
              return Ie(i, { start: c });
            }
            return a;
          }
          function xe(a) {
            let { parse: d } = Oe(), { result: i, error: c } = ge(() => d(a, Object.assign({}, X)), () => d(a, Object.assign(Object.assign({}, X), {}, { allowLegacySDLImplementsInterfaces: true })));
            if (!i)
              throw Le(c);
            return i.comments = Ke(i), ie(i), i;
          }
          ae.exports = { parsers: { graphql: { parse: xe, astFormat: "graphql", hasPragma: Se, locStart: Ae, locEnd: De } } };
        });
        "use strict";
        return be();
      });
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/GraphQLWorker.js
  var require_GraphQLWorker = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/GraphQLWorker.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.create = exports.GraphQLWorker = void 0;
      var graphql_language_service_1 = require_dist();
      var LanguageService_1 = require_LanguageService();
      var utils_1 = require_utils3();
      var GraphQLWorker = function() {
        function GraphQLWorker2(ctx, createData) {
          this._ctx = ctx;
          this._languageService = new LanguageService_1.LanguageService(createData.languageConfig);
          this._formattingOptions = createData.formattingOptions;
        }
        GraphQLWorker2.prototype.doValidation = function(uri) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_1, graphqlDiagnostics;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_1 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_1) {
                  return [2, []];
                }
                graphqlDiagnostics = this._languageService.getDiagnostics(uri, document_1);
                return [2, graphqlDiagnostics.map(utils_1.toMarkerData)];
              } catch (err) {
                console.error(err);
                return [2, []];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doComplete = function(uri, position) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_2, graphQLPosition, suggestions;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_2 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_2) {
                  return [2, []];
                }
                graphQLPosition = utils_1.toGraphQLPosition(position);
                suggestions = this._languageService.getCompletion(uri, document_2, graphQLPosition);
                return [2, suggestions.map(function(suggestion) {
                  return utils_1.toCompletion(suggestion);
                })];
              } catch (err) {
                console.error(err);
                return [2, []];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doHover = function(uri, position) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_3, graphQLPosition, hover;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_3 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_3) {
                  return [2, null];
                }
                graphQLPosition = utils_1.toGraphQLPosition(position);
                hover = this._languageService.getHover(uri, document_3, graphQLPosition);
                return [2, {
                  content: hover,
                  range: utils_1.toMonacoRange(graphql_language_service_1.getRange({
                    column: graphQLPosition.character,
                    line: graphQLPosition.line
                  }, document_3))
                }];
              } catch (err) {
                console.error(err);
                return [2, null];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doGetVariablesJSONSchema = function(uri) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document, jsonSchema;
            return __generator(this, function(_a3) {
              documentModel = this._getTextModel(uri);
              document = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
              if (!documentModel || !document) {
                return [2, null];
              }
              jsonSchema = this._languageService.getVariablesJSONSchema(uri, document, { useMarkdownDescription: true });
              if (jsonSchema) {
                jsonSchema.$id = "monaco://variables-schema.json";
                jsonSchema.title = "GraphQL Variables";
                return [2, jsonSchema];
              }
              return [2, null];
            });
          });
        };
        GraphQLWorker2.prototype.doFormat = function(uri) {
          var _a3;
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document, prettierStandalone, prettierGraphqlParser;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  documentModel = this._getTextModel(uri);
                  document = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                  if (!documentModel || !document) {
                    return [2, null];
                  }
                  return [4, Promise.resolve().then(function() {
                    return __importStar(require_standalone());
                  })];
                case 1:
                  prettierStandalone = _b.sent();
                  return [4, Promise.resolve().then(function() {
                    return __importStar(require_parser_graphql());
                  })];
                case 2:
                  prettierGraphqlParser = _b.sent();
                  return [2, prettierStandalone.format(document, __assign({ parser: "graphql", plugins: [prettierGraphqlParser] }, (_a3 = this._formattingOptions) === null || _a3 === void 0 ? void 0 : _a3.prettierConfig))];
              }
            });
          });
        };
        GraphQLWorker2.prototype._getTextModel = function(uri) {
          var e_1, _a3;
          var models = this._ctx.getMirrorModels();
          try {
            for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
              var model = models_1_1.value;
              if (model.uri.toString() === uri) {
                return model;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (models_1_1 && !models_1_1.done && (_a3 = models_1.return))
                _a3.call(models_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return null;
        };
        GraphQLWorker2.prototype.doUpdateSchema = function(schema) {
          return this._languageService.updateSchema(schema);
        };
        GraphQLWorker2.prototype.doUpdateSchemas = function(schemas) {
          return this._languageService.updateSchemas(schemas);
        };
        return GraphQLWorker2;
      }();
      exports.GraphQLWorker = GraphQLWorker;
      exports.default = {
        GraphQLWorker
      };
      function create(ctx, createData) {
        return new GraphQLWorker(ctx, createData);
      }
      exports.create = create;
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/graphql.worker.js
  var require_graphql_worker = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.0_a7bnabqs6qaueskeewpycdc2jy/node_modules/monaco-graphql/dist/graphql.worker.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      var editor_worker_1 = (init_editor_worker(), __toCommonJS(editor_worker_exports));
      var GraphQLWorker_1 = require_GraphQLWorker();
      self.onmessage = function() {
        try {
          editor_worker_1.initialize(function(ctx, createData) {
            return new GraphQLWorker_1.GraphQLWorker(ctx, createData);
          });
        } catch (err) {
          throw err;
        }
      };
    }
  });
  require_graphql_worker();
})();
