"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      let { name, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name,
        message,
        stack
      };
    }
    return error;
  }
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var ErrorHandler, errorHandler, canceledName, CancellationError;
  var init_errors = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js"() {
      ErrorHandler = class {
        constructor() {
          this.listeners = [];
          this.unexpectedErrorHandler = function(e) {
            setTimeout(() => {
              if (e.stack) {
                throw new Error(e.message + "\n\n" + e.stack);
              }
              throw e;
            }, 0);
          };
        }
        emit(e) {
          this.listeners.forEach((listener) => {
            listener(e);
          });
        }
        onUnexpectedError(e) {
          this.unexpectedErrorHandler(e);
          this.emit(e);
        }
        onUnexpectedExternalError(e) {
          this.unexpectedErrorHandler(e);
        }
      };
      errorHandler = new ErrorHandler();
      canceledName = "Canceled";
      CancellationError = class extends Error {
        constructor() {
          super(canceledName);
          this.name = this.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js
  function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      result = fn.apply(_this, arguments);
      return result;
    };
  }
  var init_functional = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  var init_iterator = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js"() {
      (function(Iterable2) {
        function is(thing) {
          return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
        }
        Iterable2.is = is;
        const _empty2 = Object.freeze([]);
        function empty() {
          return _empty2;
        }
        Iterable2.empty = empty;
        function* single(element) {
          yield element;
        }
        Iterable2.single = single;
        function from(iterable) {
          return iterable || _empty2;
        }
        Iterable2.from = from;
        function isEmpty(iterable) {
          return !iterable || iterable[Symbol.iterator]().next().done === true;
        }
        Iterable2.isEmpty = isEmpty;
        function first(iterable) {
          return iterable[Symbol.iterator]().next().value;
        }
        Iterable2.first = first;
        function some(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return true;
            }
          }
          return false;
        }
        Iterable2.some = some;
        function find(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return element;
            }
          }
          return void 0;
        }
        Iterable2.find = find;
        function* filter(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              yield element;
            }
          }
        }
        Iterable2.filter = filter;
        function* map(iterable, fn) {
          let index = 0;
          for (const element of iterable) {
            yield fn(element, index++);
          }
        }
        Iterable2.map = map;
        function* concat(...iterables) {
          for (const iterable of iterables) {
            for (const element of iterable) {
              yield element;
            }
          }
        }
        Iterable2.concat = concat;
        function* concatNested(iterables) {
          for (const iterable of iterables) {
            for (const element of iterable) {
              yield element;
            }
          }
        }
        Iterable2.concatNested = concatNested;
        function reduce(iterable, reducer, initialValue) {
          let value = initialValue;
          for (const element of iterable) {
            value = reducer(value, element);
          }
          return value;
        }
        Iterable2.reduce = reduce;
        function* slice(arr, from2, to = arr.length) {
          if (from2 < 0) {
            from2 += arr.length;
          }
          if (to < 0) {
            to += arr.length;
          } else if (to > arr.length) {
            to = arr.length;
          }
          for (; from2 < to; from2++) {
            yield arr[from2];
          }
        }
        Iterable2.slice = slice;
        function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
          const consumed = [];
          if (atMost === 0) {
            return [consumed, iterable];
          }
          const iterator = iterable[Symbol.iterator]();
          for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
              return [consumed, Iterable2.empty()];
            }
            consumed.push(next.value);
          }
          return [consumed, { [Symbol.iterator]() {
            return iterator;
          } }];
        }
        Iterable2.consume = consume;
        function equals2(a, b, comparator = (at, bt) => at === bt) {
          const ai = a[Symbol.iterator]();
          const bi = b[Symbol.iterator]();
          while (true) {
            const an = ai.next();
            const bn = bi.next();
            if (an.done !== bn.done) {
              return false;
            } else if (an.done) {
              return true;
            } else if (!comparator(an.value, bn.value)) {
              return false;
            }
          }
        }
        Iterable2.equals = equals2;
      })(Iterable || (Iterable = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      let errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new MultiDisposeError(errors);
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: once(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var TRACK_DISPOSABLES, disposableTracker, MultiDisposeError, DisposableStore, Disposable, SafeDisposable;
  var init_lifecycle = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"() {
      init_functional();
      init_iterator();
      TRACK_DISPOSABLES = false;
      disposableTracker = null;
      if (TRACK_DISPOSABLES) {
        const __is_disposable_tracked__ = "__is_disposable_tracked__";
        setDisposableTracker(new class {
          trackDisposable(x) {
            const stack = new Error("Potentially leaked disposable").stack;
            setTimeout(() => {
              if (!x[__is_disposable_tracked__]) {
                console.log(stack);
              }
            }, 3e3);
          }
          setParent(child, parent) {
            if (child && child !== Disposable.None) {
              try {
                child[__is_disposable_tracked__] = true;
              } catch (_a3) {
              }
            }
          }
          markAsDisposed(disposable) {
            if (disposable && disposable !== Disposable.None) {
              try {
                disposable[__is_disposable_tracked__] = true;
              } catch (_a3) {
              }
            }
          }
          markAsSingleton(disposable) {
          }
        }());
      }
      MultiDisposeError = class extends Error {
        constructor(errors) {
          super(`Encountered errors while disposing of store. Errors: [${errors.join(", ")}]`);
          this.errors = errors;
        }
      };
      DisposableStore = class {
        constructor() {
          this._toDispose = /* @__PURE__ */ new Set();
          this._isDisposed = false;
          trackDisposable(this);
        }
        dispose() {
          if (this._isDisposed) {
            return;
          }
          markAsDisposed(this);
          this._isDisposed = true;
          this.clear();
        }
        get isDisposed() {
          return this._isDisposed;
        }
        clear() {
          try {
            dispose(this._toDispose.values());
          } finally {
            this._toDispose.clear();
          }
        }
        add(o) {
          if (!o) {
            return o;
          }
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          setParentOfDisposable(o, this);
          if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
              console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
            }
          } else {
            this._toDispose.add(o);
          }
          return o;
        }
      };
      DisposableStore.DISABLE_DISPOSED_WARNING = false;
      Disposable = class {
        constructor() {
          this._store = new DisposableStore();
          trackDisposable(this);
          setParentOfDisposable(this._store, this);
        }
        dispose() {
          markAsDisposed(this);
          this._store.dispose();
        }
        _register(o) {
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          return this._store.add(o);
        }
      };
      Disposable.None = Object.freeze({ dispose() {
      } });
      SafeDisposable = class {
        constructor() {
          this.dispose = () => {
          };
          this.unset = () => {
          };
          this.isset = () => false;
          trackDisposable(this);
        }
        set(fn) {
          let callback = fn;
          this.unset = () => callback = void 0;
          this.isset = () => callback !== void 0;
          this.dispose = () => {
            if (callback) {
              callback();
              callback = void 0;
              markAsDisposed(this);
            }
          };
          return this;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node, LinkedList;
  var init_linkedList = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js"() {
      Node = class {
        constructor(element) {
          this.element = element;
          this.next = Node.Undefined;
          this.prev = Node.Undefined;
        }
      };
      Node.Undefined = new Node(void 0);
      LinkedList = class {
        constructor() {
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        get size() {
          return this._size;
        }
        isEmpty() {
          return this._first === Node.Undefined;
        }
        clear() {
          let node = this._first;
          while (node !== Node.Undefined) {
            const next = node.next;
            node.prev = Node.Undefined;
            node.next = Node.Undefined;
            node = next;
          }
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        unshift(element) {
          return this._insert(element, false);
        }
        push(element) {
          return this._insert(element, true);
        }
        _insert(element, atTheEnd) {
          const newNode = new Node(element);
          if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
          } else if (atTheEnd) {
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
          } else {
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
          }
          this._size += 1;
          let didRemove = false;
          return () => {
            if (!didRemove) {
              didRemove = true;
              this._remove(newNode);
            }
          };
        }
        shift() {
          if (this._first === Node.Undefined) {
            return void 0;
          } else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
          }
        }
        pop() {
          if (this._last === Node.Undefined) {
            return void 0;
          } else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
          }
        }
        _remove(node) {
          if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
          } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            this._first = Node.Undefined;
            this._last = Node.Undefined;
          } else if (node.next === Node.Undefined) {
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
          } else if (node.prev === Node.Undefined) {
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
          }
          this._size -= 1;
        }
        *[Symbol.iterator]() {
          let node = this._first;
          while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a, LANGUAGE_DEFAULT, _isWindows, _isMacintosh, _isLinux, _isLinuxSnap, _isNative, _isWeb, _isElectron, _isIOS, _isCI, _locale, _language, _translationsConfigFile, _userAgent, globals, nodeProcess, isElectronProcess, isElectronRenderer, _platform, isWindows, isMacintosh, isWebWorker, userAgent, setTimeout0, isChrome, isFirefox, isSafari, isEdge, isAndroid;
  var init_platform = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js"() {
      LANGUAGE_DEFAULT = "en";
      _isWindows = false;
      _isMacintosh = false;
      _isLinux = false;
      _isLinuxSnap = false;
      _isNative = false;
      _isWeb = false;
      _isElectron = false;
      _isIOS = false;
      _isCI = false;
      _locale = void 0;
      _language = LANGUAGE_DEFAULT;
      _translationsConfigFile = void 0;
      _userAgent = void 0;
      globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
      nodeProcess = void 0;
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        nodeProcess = globals.vscode.process;
      } else if (typeof process !== "undefined") {
        nodeProcess = process;
      }
      isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
      isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
      if (typeof navigator === "object" && !isElectronRenderer) {
        _userAgent = navigator.userAgent;
        _isWindows = _userAgent.indexOf("Windows") >= 0;
        _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
        _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
        _isLinux = _userAgent.indexOf("Linux") >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
      } else if (typeof nodeProcess === "object") {
        _isWindows = nodeProcess.platform === "win32";
        _isMacintosh = nodeProcess.platform === "darwin";
        _isLinux = nodeProcess.platform === "linux";
        _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
        _isElectron = isElectronProcess;
        _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
        _locale = LANGUAGE_DEFAULT;
        _language = LANGUAGE_DEFAULT;
        const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
        if (rawNlsConfig) {
          try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages["*"];
            _locale = nlsConfig.locale;
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
          } catch (e) {
          }
        }
        _isNative = true;
      } else {
        console.error("Unable to resolve platform.");
      }
      _platform = 0;
      if (_isMacintosh) {
        _platform = 1;
      } else if (_isWindows) {
        _platform = 3;
      } else if (_isLinux) {
        _platform = 2;
      }
      isWindows = _isWindows;
      isMacintosh = _isMacintosh;
      isWebWorker = _isWeb && typeof globals.importScripts === "function";
      userAgent = _userAgent;
      setTimeout0 = (() => {
        if (typeof globals.postMessage === "function" && !globals.importScripts) {
          let pending = [];
          globals.addEventListener("message", (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
              for (let i = 0, len = pending.length; i < len; i++) {
                const candidate = pending[i];
                if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                  pending.splice(i, 1);
                  candidate.callback();
                  return;
                }
              }
            }
          });
          let lastId = 0;
          return (callback) => {
            const myId = ++lastId;
            pending.push({
              id: myId,
              callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
          };
        }
        return (callback) => setTimeout(callback);
      })();
      isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
      isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
      isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
      isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
      isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow, StopWatch;
  var init_stopwatch = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js"() {
      init_platform();
      hasPerformanceNow = globals.performance && typeof globals.performance.now === "function";
      StopWatch = class {
        constructor(highResolution) {
          this._highResolution = hasPerformanceNow && highResolution;
          this._startTime = this._now();
          this._stopTime = -1;
        }
        static create(highResolution = true) {
          return new StopWatch(highResolution);
        }
        stop() {
          this._stopTime = this._now();
        }
        elapsed() {
          if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
          }
          return this._now() - this._startTime;
        }
        _now() {
          return this._highResolution ? globals.performance.now() : Date.now();
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableDisposeWithListenerWarning, _enableSnapshotPotentialLeakWarning, Event, EventProfiling, _globalLeakWarningThreshold, LeakageMonitor, Stacktrace, Listener, Emitter;
  var init_event = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js"() {
      init_errors();
      init_lifecycle();
      init_linkedList();
      init_stopwatch();
      _enableDisposeWithListenerWarning = false;
      _enableSnapshotPotentialLeakWarning = false;
      (function(Event2) {
        Event2.None = () => Disposable.None;
        function _addLeakageTraceLogic(options) {
          if (_enableSnapshotPotentialLeakWarning) {
            const { onListenerDidAdd: origListenerDidAdd } = options;
            const stack = Stacktrace.create();
            let count = 0;
            options.onListenerDidAdd = () => {
              if (++count === 2) {
                console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
                stack.print();
              }
              origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
            };
          }
        }
        function once3(event) {
          return (listener, thisArgs = null, disposables) => {
            let didFire = false;
            let result;
            result = event((e) => {
              if (didFire) {
                return;
              } else if (result) {
                result.dispose();
              } else {
                didFire = true;
              }
              return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
              result.dispose();
            }
            return result;
          };
        }
        Event2.once = once3;
        function map(event, map2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
        }
        Event2.map = map;
        function forEach(event, each, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => {
            each(i);
            listener.call(thisArgs, i);
          }, null, disposables), disposable);
        }
        Event2.forEach = forEach;
        function filter(event, filter2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
        }
        Event2.filter = filter;
        function signal(event) {
          return event;
        }
        Event2.signal = signal;
        function any(...events) {
          return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
        }
        Event2.any = any;
        function reduce(event, merge, initial, disposable) {
          let output = initial;
          return map(event, (e) => {
            output = merge(output, e);
            return output;
          }, disposable);
        }
        Event2.reduce = reduce;
        function snapshot(event, disposable) {
          let listener;
          const options = {
            onFirstListenerAdd() {
              listener = event(emitter.fire, emitter);
            },
            onLastListenerRemove() {
              listener.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          if (disposable) {
            disposable.add(emitter);
          }
          return emitter.event;
        }
        function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {
          let subscription;
          let output = void 0;
          let handle = void 0;
          let numDebouncedCalls = 0;
          const options = {
            leakWarningThreshold,
            onFirstListenerAdd() {
              subscription = event((cur) => {
                numDebouncedCalls++;
                output = merge(output, cur);
                if (leading && !handle) {
                  emitter.fire(output);
                  output = void 0;
                }
                clearTimeout(handle);
                handle = setTimeout(() => {
                  const _output = output;
                  output = void 0;
                  handle = void 0;
                  if (!leading || numDebouncedCalls > 1) {
                    emitter.fire(_output);
                  }
                  numDebouncedCalls = 0;
                }, delay);
              });
            },
            onLastListenerRemove() {
              subscription.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          if (disposable) {
            disposable.add(emitter);
          }
          return emitter.event;
        }
        Event2.debounce = debounce;
        function latch(event, equals2 = (a, b) => a === b, disposable) {
          let firstCall = true;
          let cache;
          return filter(event, (value) => {
            const shouldEmit = firstCall || !equals2(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit;
          }, disposable);
        }
        Event2.latch = latch;
        function split(event, isT, disposable) {
          return [
            Event2.filter(event, isT, disposable),
            Event2.filter(event, (e) => !isT(e), disposable)
          ];
        }
        Event2.split = split;
        function buffer(event, flushAfterTimeout = false, _buffer = []) {
          let buffer2 = _buffer.slice();
          let listener = event((e) => {
            if (buffer2) {
              buffer2.push(e);
            } else {
              emitter.fire(e);
            }
          });
          const flush = () => {
            if (buffer2) {
              buffer2.forEach((e) => emitter.fire(e));
            }
            buffer2 = null;
          };
          const emitter = new Emitter({
            onFirstListenerAdd() {
              if (!listener) {
                listener = event((e) => emitter.fire(e));
              }
            },
            onFirstListenerDidAdd() {
              if (buffer2) {
                if (flushAfterTimeout) {
                  setTimeout(flush);
                } else {
                  flush();
                }
              }
            },
            onLastListenerRemove() {
              if (listener) {
                listener.dispose();
              }
              listener = null;
            }
          });
          return emitter.event;
        }
        Event2.buffer = buffer;
        class ChainableEvent {
          constructor(event) {
            this.event = event;
          }
          map(fn) {
            return new ChainableEvent(map(this.event, fn));
          }
          forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn));
          }
          filter(fn) {
            return new ChainableEvent(filter(this.event, fn));
          }
          reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial));
          }
          latch() {
            return new ChainableEvent(latch(this.event));
          }
          debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
          }
          on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
          }
          once(listener, thisArgs, disposables) {
            return once3(this.event)(listener, thisArgs, disposables);
          }
        }
        function chain(event) {
          return new ChainableEvent(event);
        }
        Event2.chain = chain;
        function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.on(eventName, fn);
          const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
          const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
          return result.event;
        }
        Event2.fromNodeEventEmitter = fromNodeEventEmitter;
        function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
          const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
          const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
          return result.event;
        }
        Event2.fromDOMEventEmitter = fromDOMEventEmitter;
        function toPromise(event) {
          return new Promise((resolve2) => once3(event)(resolve2));
        }
        Event2.toPromise = toPromise;
        function runAndSubscribe(event, handler) {
          handler(void 0);
          return event((e) => handler(e));
        }
        Event2.runAndSubscribe = runAndSubscribe;
        function runAndSubscribeWithStore(event, handler) {
          let store = null;
          function run(e) {
            store === null || store === void 0 ? void 0 : store.dispose();
            store = new DisposableStore();
            handler(e, store);
          }
          run(void 0);
          const disposable = event((e) => run(e));
          return toDisposable(() => {
            disposable.dispose();
            store === null || store === void 0 ? void 0 : store.dispose();
          });
        }
        Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
      })(Event || (Event = {}));
      EventProfiling = class {
        constructor(name) {
          this._listenerCount = 0;
          this._invocationCount = 0;
          this._elapsedOverall = 0;
          this._name = `${name}_${EventProfiling._idPool++}`;
        }
        start(listenerCount) {
          this._stopWatch = new StopWatch(true);
          this._listenerCount = listenerCount;
        }
        stop() {
          if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this._elapsedOverall += elapsed;
            this._invocationCount += 1;
            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);
            this._stopWatch = void 0;
          }
        }
      };
      EventProfiling._idPool = 0;
      _globalLeakWarningThreshold = -1;
      LeakageMonitor = class {
        constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
          this.customThreshold = customThreshold;
          this.name = name;
          this._warnCountdown = 0;
        }
        dispose() {
          if (this._stacks) {
            this._stacks.clear();
          }
        }
        check(stack, listenerCount) {
          let threshold = _globalLeakWarningThreshold;
          if (typeof this.customThreshold === "number") {
            threshold = this.customThreshold;
          }
          if (threshold <= 0 || listenerCount < threshold) {
            return void 0;
          }
          if (!this._stacks) {
            this._stacks = /* @__PURE__ */ new Map();
          }
          const count = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count + 1);
          this._warnCountdown -= 1;
          if (this._warnCountdown <= 0) {
            this._warnCountdown = threshold * 0.5;
            let topStack;
            let topCount = 0;
            for (const [stack2, count2] of this._stacks) {
              if (!topStack || topCount < count2) {
                topStack = stack2;
                topCount = count2;
              }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
          }
          return () => {
            const count2 = this._stacks.get(stack.value) || 0;
            this._stacks.set(stack.value, count2 - 1);
          };
        }
      };
      Stacktrace = class {
        constructor(value) {
          this.value = value;
        }
        static create() {
          var _a3;
          return new Stacktrace((_a3 = new Error().stack) !== null && _a3 !== void 0 ? _a3 : "");
        }
        print() {
          console.warn(this.value.split("\n").slice(2).join("\n"));
        }
      };
      Listener = class {
        constructor(callback, callbackThis, stack) {
          this.callback = callback;
          this.callbackThis = callbackThis;
          this.stack = stack;
          this.subscription = new SafeDisposable();
        }
        invoke(e) {
          this.callback.call(this.callbackThis, e);
        }
      };
      Emitter = class {
        constructor(options) {
          var _a3;
          this._disposed = false;
          this._options = options;
          this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : void 0;
          this._perfMon = ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3._profName) ? new EventProfiling(this._options._profName) : void 0;
        }
        dispose() {
          var _a3, _b, _c, _d;
          if (!this._disposed) {
            this._disposed = true;
            if (this._listeners) {
              if (_enableDisposeWithListenerWarning) {
                const listeners = Array.from(this._listeners);
                queueMicrotask(() => {
                  var _a4;
                  for (const listener of listeners) {
                    if (listener.subscription.isset()) {
                      listener.subscription.unset();
                      (_a4 = listener.stack) === null || _a4 === void 0 ? void 0 : _a4.print();
                    }
                  }
                });
              }
              this._listeners.clear();
            }
            (_a3 = this._deliveryQueue) === null || _a3 === void 0 ? void 0 : _a3.clear();
            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);
            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
          }
        }
        get event() {
          if (!this._event) {
            this._event = (callback, thisArgs, disposables) => {
              var _a3, _b, _c;
              if (!this._listeners) {
                this._listeners = new LinkedList();
              }
              const firstListener = this._listeners.isEmpty();
              if (firstListener && ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.onFirstListenerAdd)) {
                this._options.onFirstListenerAdd(this);
              }
              let removeMonitor;
              let stack;
              if (this._leakageMon && this._listeners.size >= 30) {
                stack = Stacktrace.create();
                removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
              }
              if (_enableDisposeWithListenerWarning) {
                stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
              }
              const listener = new Listener(callback, thisArgs, stack);
              const removeListener = this._listeners.push(listener);
              if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {
                this._options.onFirstListenerDidAdd(this);
              }
              if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {
                this._options.onListenerDidAdd(this, callback, thisArgs);
              }
              const result = listener.subscription.set(() => {
                if (removeMonitor) {
                  removeMonitor();
                }
                if (!this._disposed) {
                  removeListener();
                  if (this._options && this._options.onLastListenerRemove) {
                    const hasListeners = this._listeners && !this._listeners.isEmpty();
                    if (!hasListeners) {
                      this._options.onLastListenerRemove(this);
                    }
                  }
                }
              });
              if (disposables instanceof DisposableStore) {
                disposables.add(result);
              } else if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        fire(event) {
          var _a3, _b;
          if (this._listeners) {
            if (!this._deliveryQueue) {
              this._deliveryQueue = new LinkedList();
            }
            for (let listener of this._listeners) {
              this._deliveryQueue.push([listener, event]);
            }
            (_a3 = this._perfMon) === null || _a3 === void 0 ? void 0 : _a3.start(this._deliveryQueue.size);
            while (this._deliveryQueue.size > 0) {
              const [listener, event2] = this._deliveryQueue.shift();
              try {
                listener.invoke(event2);
              } catch (e) {
                onUnexpectedError(e);
              }
            }
            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js
  function getAllPropertyNames(obj) {
    let res = [];
    let proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
      res = res.concat(Object.getOwnPropertyNames(proto));
      proto = Object.getPrototypeOf(proto);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    let result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  function assertNever(value, message = "Unreachable") {
    throw new Error(message);
  }
  var init_types = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js
  var LRUCachedComputed;
  var init_cache = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js"() {
      LRUCachedComputed = class {
        constructor(computeFn) {
          this.computeFn = computeFn;
          this.lastCache = void 0;
          this.lastArgKey = void 0;
        }
        get(arg) {
          const key = JSON.stringify(arg);
          if (this.lastArgKey !== key) {
            this.lastArgKey = key;
            this.lastCache = this.computeFn(arg);
          }
          return this.lastCache;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy;
  var init_lazy = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js"() {
      Lazy = class {
        constructor(executor) {
          this.executor = executor;
          this._didRun = false;
        }
        getValue() {
          if (!this._didRun) {
            try {
              this._value = this.executor();
            } catch (err) {
              this._error = err;
            } finally {
              this._didRun = true;
            }
          }
          if (this._error) {
            throw this._error;
          }
          return this._value;
        }
        get rawValue() {
          return this._value;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var _a2, IS_BASIC_ASCII, UTF8_BOM_CHARACTER, GraphemeBreakTree, AmbiguousCharacters, InvisibleCharacters;
  var init_strings = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js"() {
      init_cache();
      init_lazy();
      IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
      UTF8_BOM_CHARACTER = String.fromCharCode(65279);
      GraphemeBreakTree = class {
        constructor() {
          this._data = getGraphemeBreakRawData();
        }
        static getInstance() {
          if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
          }
          return GraphemeBreakTree._INSTANCE;
        }
        getGraphemeBreakType(codePoint) {
          if (codePoint < 32) {
            if (codePoint === 10) {
              return 3;
            }
            if (codePoint === 13) {
              return 2;
            }
            return 4;
          }
          if (codePoint < 127) {
            return 0;
          }
          const data = this._data;
          const nodeCount = data.length / 3;
          let nodeIndex = 1;
          while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
              nodeIndex = 2 * nodeIndex;
            } else if (codePoint > data[3 * nodeIndex + 1]) {
              nodeIndex = 2 * nodeIndex + 1;
            } else {
              return data[3 * nodeIndex + 2];
            }
          }
          return 0;
        }
      };
      GraphemeBreakTree._INSTANCE = null;
      AmbiguousCharacters = class {
        constructor(confusableDictionary) {
          this.confusableDictionary = confusableDictionary;
        }
        static getInstance(locales) {
          return AmbiguousCharacters.cache.get(Array.from(locales));
        }
        static getLocales() {
          return AmbiguousCharacters._locales.getValue();
        }
        isAmbiguous(codePoint) {
          return this.confusableDictionary.has(codePoint);
        }
        getPrimaryConfusable(codePoint) {
          return this.confusableDictionary.get(codePoint);
        }
        getConfusableCodePoints() {
          return new Set(this.confusableDictionary.keys());
        }
      };
      _a2 = AmbiguousCharacters;
      AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
        return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
      });
      AmbiguousCharacters.cache = new LRUCachedComputed((locales) => {
        function arrayToMap(arr) {
          const result = /* @__PURE__ */ new Map();
          for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
          }
          return result;
        }
        function mergeMaps(map1, map2) {
          const result = new Map(map1);
          for (const [key, value] of map2) {
            result.set(key, value);
          }
          return result;
        }
        function intersectMaps(map1, map2) {
          if (!map1) {
            return map2;
          }
          const result = /* @__PURE__ */ new Map();
          for (const [key, value] of map1) {
            if (map2.has(key)) {
              result.set(key, value);
            }
          }
          return result;
        }
        const data = _a2.ambiguousCharacterData.getValue();
        let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
        if (filteredLocales.length === 0) {
          filteredLocales = ["_default"];
        }
        let languageSpecificMap = void 0;
        for (const locale of filteredLocales) {
          const map2 = arrayToMap(data[locale]);
          languageSpecificMap = intersectMaps(languageSpecificMap, map2);
        }
        const commonMap = arrayToMap(data["_common"]);
        const map = mergeMaps(commonMap, languageSpecificMap);
        return new AmbiguousCharacters(map);
      });
      AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter((k) => !k.startsWith("_")));
      InvisibleCharacters = class {
        static getRawData() {
          return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
        }
        static getData() {
          if (!this._data) {
            this._data = new Set(InvisibleCharacters.getRawData());
          }
          return this._data;
        }
        static isInvisibleCharacter(codePoint) {
          return InvisibleCharacters.getData().has(codePoint);
        }
        static get codePoints() {
          return InvisibleCharacters.getData();
        }
      };
      InvisibleCharacters._data = void 0;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    let result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var INITIALIZE, RequestMessage, ReplyMessage, SubscribeEventMessage, EventMessage, UnsubscribeEventMessage, SimpleWorkerProtocol, SimpleWorkerServer;
  var init_simpleWorker = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js"() {
      init_errors();
      init_event();
      init_lifecycle();
      init_platform();
      init_types();
      init_strings();
      INITIALIZE = "$initialize";
      RequestMessage = class {
        constructor(vsWorker, req, method, args) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.method = method;
          this.args = args;
          this.type = 0;
        }
      };
      ReplyMessage = class {
        constructor(vsWorker, seq, res, err) {
          this.vsWorker = vsWorker;
          this.seq = seq;
          this.res = res;
          this.err = err;
          this.type = 1;
        }
      };
      SubscribeEventMessage = class {
        constructor(vsWorker, req, eventName, arg) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.eventName = eventName;
          this.arg = arg;
          this.type = 2;
        }
      };
      EventMessage = class {
        constructor(vsWorker, req, event) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.event = event;
          this.type = 3;
        }
      };
      UnsubscribeEventMessage = class {
        constructor(vsWorker, req) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.type = 4;
        }
      };
      SimpleWorkerProtocol = class {
        constructor(handler) {
          this._workerId = -1;
          this._handler = handler;
          this._lastSentReq = 0;
          this._pendingReplies = /* @__PURE__ */ Object.create(null);
          this._pendingEmitters = /* @__PURE__ */ new Map();
          this._pendingEvents = /* @__PURE__ */ new Map();
        }
        setWorkerId(workerId) {
          this._workerId = workerId;
        }
        sendMessage(method, args) {
          const req = String(++this._lastSentReq);
          return new Promise((resolve2, reject) => {
            this._pendingReplies[req] = {
              resolve: resolve2,
              reject
            };
            this._send(new RequestMessage(this._workerId, req, method, args));
          });
        }
        listen(eventName, arg) {
          let req = null;
          const emitter = new Emitter({
            onFirstListenerAdd: () => {
              req = String(++this._lastSentReq);
              this._pendingEmitters.set(req, emitter);
              this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
            },
            onLastListenerRemove: () => {
              this._pendingEmitters.delete(req);
              this._send(new UnsubscribeEventMessage(this._workerId, req));
              req = null;
            }
          });
          return emitter.event;
        }
        handleMessage(message) {
          if (!message || !message.vsWorker) {
            return;
          }
          if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
          }
          this._handleMessage(message);
        }
        _handleMessage(msg) {
          switch (msg.type) {
            case 1:
              return this._handleReplyMessage(msg);
            case 0:
              return this._handleRequestMessage(msg);
            case 2:
              return this._handleSubscribeEventMessage(msg);
            case 3:
              return this._handleEventMessage(msg);
            case 4:
              return this._handleUnsubscribeEventMessage(msg);
          }
        }
        _handleReplyMessage(replyMessage) {
          if (!this._pendingReplies[replyMessage.seq]) {
            console.warn("Got reply to unknown seq");
            return;
          }
          let reply = this._pendingReplies[replyMessage.seq];
          delete this._pendingReplies[replyMessage.seq];
          if (replyMessage.err) {
            let err = replyMessage.err;
            if (replyMessage.err.$isError) {
              err = new Error();
              err.name = replyMessage.err.name;
              err.message = replyMessage.err.message;
              err.stack = replyMessage.err.stack;
            }
            reply.reject(err);
            return;
          }
          reply.resolve(replyMessage.res);
        }
        _handleRequestMessage(requestMessage) {
          let req = requestMessage.req;
          let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
          result.then((r) => {
            this._send(new ReplyMessage(this._workerId, req, r, void 0));
          }, (e) => {
            if (e.detail instanceof Error) {
              e.detail = transformErrorForSerialization(e.detail);
            }
            this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
          });
        }
        _handleSubscribeEventMessage(msg) {
          const req = msg.req;
          const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
            this._send(new EventMessage(this._workerId, req, event));
          });
          this._pendingEvents.set(req, disposable);
        }
        _handleEventMessage(msg) {
          if (!this._pendingEmitters.has(msg.req)) {
            console.warn("Got event for unknown req");
            return;
          }
          this._pendingEmitters.get(msg.req).fire(msg.event);
        }
        _handleUnsubscribeEventMessage(msg) {
          if (!this._pendingEvents.has(msg.req)) {
            console.warn("Got unsubscribe for unknown req");
            return;
          }
          this._pendingEvents.get(msg.req).dispose();
          this._pendingEvents.delete(msg.req);
        }
        _send(msg) {
          let transfer = [];
          if (msg.type === 0) {
            for (let i = 0; i < msg.args.length; i++) {
              if (msg.args[i] instanceof ArrayBuffer) {
                transfer.push(msg.args[i]);
              }
            }
          } else if (msg.type === 1) {
            if (msg.res instanceof ArrayBuffer) {
              transfer.push(msg.res);
            }
          }
          this._handler.sendMessage(msg, transfer);
        }
      };
      SimpleWorkerServer = class {
        constructor(postMessage, requestHandlerFactory) {
          this._requestHandlerFactory = requestHandlerFactory;
          this._requestHandler = null;
          this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
              postMessage(msg, transfer);
            },
            handleMessage: (method, args) => this._handleMessage(method, args),
            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
          });
        }
        onmessage(msg) {
          this._protocol.handleMessage(msg);
        }
        _handleMessage(method, args) {
          if (method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2], args[3]);
          }
          if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
            return Promise.reject(new Error("Missing requestHandler or method: " + method));
          }
          try {
            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
          } catch (e) {
            return Promise.reject(e);
          }
        }
        _handleEvent(eventName, arg) {
          if (!this._requestHandler) {
            throw new Error(`Missing requestHandler`);
          }
          if (propertyIsDynamicEvent(eventName)) {
            const event = this._requestHandler[eventName].call(this._requestHandler, arg);
            if (typeof event !== "function") {
              throw new Error(`Missing dynamic event ${eventName} on request handler.`);
            }
            return event;
          }
          if (propertyIsEvent(eventName)) {
            const event = this._requestHandler[eventName];
            if (typeof event !== "function") {
              throw new Error(`Missing event ${eventName} on request handler.`);
            }
            return event;
          }
          throw new Error(`Malformed event name ${eventName}`);
        }
        initialize(workerId, loaderConfig, moduleId, hostMethods) {
          this._protocol.setWorkerId(workerId);
          const proxyMethodRequest = (method, args) => {
            return this._protocol.sendMessage(method, args);
          };
          const proxyListen = (eventName, arg) => {
            return this._protocol.listen(eventName, arg);
          };
          const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
          if (this._requestHandlerFactory) {
            this._requestHandler = this._requestHandlerFactory(hostProxy);
            return Promise.resolve(getAllMethodNames(this._requestHandler));
          }
          if (loaderConfig) {
            if (typeof loaderConfig.baseUrl !== "undefined") {
              delete loaderConfig["baseUrl"];
            }
            if (typeof loaderConfig.paths !== "undefined") {
              if (typeof loaderConfig.paths.vs !== "undefined") {
                delete loaderConfig.paths["vs"];
              }
            }
            if (typeof loaderConfig.trustedTypesPolicy !== void 0) {
              delete loaderConfig["trustedTypesPolicy"];
            }
            loaderConfig.catchError = true;
            globals.require.config(loaderConfig);
          }
          return new Promise((resolve2, reject) => {
            const req = globals.require;
            req([moduleId], (module) => {
              this._requestHandler = module.create(hostProxy);
              if (!this._requestHandler) {
                reject(new Error(`No RequestHandler!`));
                return;
              }
              resolve2(getAllMethodNames(this._requestHandler));
            }, reject);
          });
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange;
  var init_diffChange = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js"() {
      DiffChange = class {
        constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
          this.originalStart = originalStart;
          this.originalLength = originalLength;
          this.modifiedStart = modifiedStart;
          this.modifiedLength = modifiedLength;
        }
        getOriginalEnd() {
          return this.originalStart + this.originalLength;
        }
        getModifiedEnd() {
          return this.modifiedStart + this.modifiedLength;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1;
  var init_hash = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js"() {
      init_strings();
      StringSHA1 = class {
        constructor() {
          this._h0 = 1732584193;
          this._h1 = 4023233417;
          this._h2 = 2562383102;
          this._h3 = 271733878;
          this._h4 = 3285377520;
          this._buff = new Uint8Array(64 + 3);
          this._buffDV = new DataView(this._buff.buffer);
          this._buffLen = 0;
          this._totalLen = 0;
          this._leftoverHighSurrogate = 0;
          this._finished = false;
        }
        update(str) {
          const strLen = str.length;
          if (strLen === 0) {
            return;
          }
          const buff = this._buff;
          let buffLen = this._buffLen;
          let leftoverHighSurrogate = this._leftoverHighSurrogate;
          let charCode;
          let offset;
          if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
          } else {
            charCode = str.charCodeAt(0);
            offset = 0;
          }
          while (true) {
            let codePoint = charCode;
            if (isHighSurrogate(charCode)) {
              if (offset + 1 < strLen) {
                const nextCharCode = str.charCodeAt(offset + 1);
                if (isLowSurrogate(nextCharCode)) {
                  offset++;
                  codePoint = computeCodePoint(charCode, nextCharCode);
                } else {
                  codePoint = 65533;
                }
              } else {
                leftoverHighSurrogate = charCode;
                break;
              }
            } else if (isLowSurrogate(charCode)) {
              codePoint = 65533;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
              charCode = str.charCodeAt(offset);
            } else {
              break;
            }
          }
          this._buffLen = buffLen;
          this._leftoverHighSurrogate = leftoverHighSurrogate;
        }
        _push(buff, buffLen, codePoint) {
          if (codePoint < 128) {
            buff[buffLen++] = codePoint;
          } else if (codePoint < 2048) {
            buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else if (codePoint < 65536) {
            buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else {
            buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
            buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          }
          if (buffLen >= 64) {
            this._step();
            buffLen -= 64;
            this._totalLen += 64;
            buff[0] = buff[64 + 0];
            buff[1] = buff[64 + 1];
            buff[2] = buff[64 + 2];
          }
          return buffLen;
        }
        digest() {
          if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
              this._leftoverHighSurrogate = 0;
              this._buffLen = this._push(this._buff, this._buffLen, 65533);
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
          }
          return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
        }
        _wrapUp() {
          this._buff[this._buffLen++] = 128;
          fill(this._buff, this._buffLen);
          if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
          }
          const ml = 8 * this._totalLen;
          this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
          this._buffDV.setUint32(60, ml % 4294967296, false);
          this._step();
        }
        _step() {
          const bigBlock32 = StringSHA1._bigBlock32;
          const data = this._buffDV;
          for (let j = 0; j < 64; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
          }
          for (let j = 64; j < 320; j += 4) {
            bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
          }
          let a = this._h0;
          let b = this._h1;
          let c = this._h2;
          let d = this._h3;
          let e = this._h4;
          let f, k;
          let temp;
          for (let j = 0; j < 80; j++) {
            if (j < 20) {
              f = b & c | ~b & d;
              k = 1518500249;
            } else if (j < 40) {
              f = b ^ c ^ d;
              k = 1859775393;
            } else if (j < 60) {
              f = b & c | b & d | c & d;
              k = 2400959708;
            } else {
              f = b ^ c ^ d;
              k = 3395469782;
            }
            temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
          }
          this._h0 = this._h0 + a & 4294967295;
          this._h1 = this._h1 + b & 4294967295;
          this._h2 = this._h2 + c & 4294967295;
          this._h3 = this._h3 + d & 4294967295;
          this._h4 = this._h4 + e & 4294967295;
        }
      };
      StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var StringDiffSequence, Debug, MyArray, DiffChangeHelper, LcsDiff;
  var init_diff = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"() {
      init_diffChange();
      init_hash();
      StringDiffSequence = class {
        constructor(source) {
          this.source = source;
        }
        getElements() {
          const source = this.source;
          const characters = new Int32Array(source.length);
          for (let i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
          }
          return characters;
        }
      };
      Debug = class {
        static Assert(condition, message) {
          if (!condition) {
            throw new Error(message);
          }
        }
      };
      MyArray = class {
        static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
          for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
          }
        }
        static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
          for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
          }
        }
      };
      DiffChangeHelper = class {
        constructor() {
          this.m_changes = [];
          this.m_originalStart = 1073741824;
          this.m_modifiedStart = 1073741824;
          this.m_originalCount = 0;
          this.m_modifiedCount = 0;
        }
        MarkNextChange() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
          }
          this.m_originalCount = 0;
          this.m_modifiedCount = 0;
          this.m_originalStart = 1073741824;
          this.m_modifiedStart = 1073741824;
        }
        AddOriginalElement(originalIndex, modifiedIndex) {
          this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
          this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
          this.m_originalCount++;
        }
        AddModifiedElement(originalIndex, modifiedIndex) {
          this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
          this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
          this.m_modifiedCount++;
        }
        getChanges() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.MarkNextChange();
          }
          return this.m_changes;
        }
        getReverseChanges() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.MarkNextChange();
          }
          this.m_changes.reverse();
          return this.m_changes;
        }
      };
      LcsDiff = class {
        constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
          this.ContinueProcessingPredicate = continueProcessingPredicate;
          this._originalSequence = originalSequence;
          this._modifiedSequence = modifiedSequence;
          const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
          const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
          this._hasStrings = originalHasStrings && modifiedHasStrings;
          this._originalStringElements = originalStringElements;
          this._originalElementsOrHash = originalElementsOrHash;
          this._modifiedStringElements = modifiedStringElements;
          this._modifiedElementsOrHash = modifiedElementsOrHash;
          this.m_forwardHistory = [];
          this.m_reverseHistory = [];
        }
        static _isStringArray(arr) {
          return arr.length > 0 && typeof arr[0] === "string";
        }
        static _getElements(sequence) {
          const elements = sequence.getElements();
          if (LcsDiff._isStringArray(elements)) {
            const hashes = new Int32Array(elements.length);
            for (let i = 0, len = elements.length; i < len; i++) {
              hashes[i] = stringHash(elements[i], 0);
            }
            return [elements, hashes, true];
          }
          if (elements instanceof Int32Array) {
            return [[], elements, false];
          }
          return [[], new Int32Array(elements), false];
        }
        ElementsAreEqual(originalIndex, newIndex) {
          if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
          }
          return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
        }
        ElementsAreStrictEqual(originalIndex, newIndex) {
          if (!this.ElementsAreEqual(originalIndex, newIndex)) {
            return false;
          }
          const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
          const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
          return originalElement === modifiedElement;
        }
        static _getStrictElement(sequence, index) {
          if (typeof sequence.getStrictElement === "function") {
            return sequence.getStrictElement(index);
          }
          return null;
        }
        OriginalElementsAreEqual(index1, index2) {
          if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
          }
          return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
        }
        ModifiedElementsAreEqual(index1, index2) {
          if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
          }
          return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
        }
        ComputeDiff(pretty) {
          return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
        }
        _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
          const quitEarlyArr = [false];
          let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
          if (pretty) {
            changes = this.PrettifyChanges(changes);
          }
          return {
            quitEarly: quitEarlyArr[0],
            changes
          };
        }
        ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
          quitEarlyArr[0] = false;
          while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
          }
          while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
          }
          if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            let changes;
            if (modifiedStart <= modifiedEnd) {
              Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
              changes = [
                new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
              ];
            } else if (originalStart <= originalEnd) {
              Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
              changes = [
                new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
              ];
            } else {
              Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
              Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
              changes = [];
            }
            return changes;
          }
          const midOriginalArr = [0];
          const midModifiedArr = [0];
          const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
          const midOriginal = midOriginalArr[0];
          const midModified = midModifiedArr[0];
          if (result !== null) {
            return result;
          } else if (!quitEarlyArr[0]) {
            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            let rightChanges = [];
            if (!quitEarlyArr[0]) {
              rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            } else {
              rightChanges = [
                new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
              ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
          }
          return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        }
        WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
          let forwardChanges = null;
          let reverseChanges = null;
          let changeHelper = new DiffChangeHelper();
          let diagonalMin = diagonalForwardStart;
          let diagonalMax = diagonalForwardEnd;
          let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
          let lastOriginalIndex = -1073741824;
          let historyIndex = this.m_forwardHistory.length - 1;
          do {
            const diagonal = diagonalRelative + diagonalForwardBase;
            if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
              originalIndex = forwardPoints[diagonal + 1];
              modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
              if (originalIndex < lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex;
              changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
              diagonalRelative = diagonal + 1 - diagonalForwardBase;
            } else {
              originalIndex = forwardPoints[diagonal - 1] + 1;
              modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
              if (originalIndex < lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex - 1;
              changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
              diagonalRelative = diagonal - 1 - diagonalForwardBase;
            }
            if (historyIndex >= 0) {
              forwardPoints = this.m_forwardHistory[historyIndex];
              diagonalForwardBase = forwardPoints[0];
              diagonalMin = 1;
              diagonalMax = forwardPoints.length - 1;
            }
          } while (--historyIndex >= -1);
          forwardChanges = changeHelper.getReverseChanges();
          if (quitEarlyArr[0]) {
            let originalStartPoint = midOriginalArr[0] + 1;
            let modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
              const lastForwardChange = forwardChanges[forwardChanges.length - 1];
              originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
              modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
              new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
          } else {
            changeHelper = new DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
            lastOriginalIndex = 1073741824;
            historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
              const diagonal = diagonalRelative + diagonalReverseBase;
              if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
                originalIndex = reversePoints[diagonal + 1] - 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                if (originalIndex > lastOriginalIndex) {
                  changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex + 1;
                changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                diagonalRelative = diagonal + 1 - diagonalReverseBase;
              } else {
                originalIndex = reversePoints[diagonal - 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                if (originalIndex > lastOriginalIndex) {
                  changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                diagonalRelative = diagonal - 1 - diagonalReverseBase;
              }
              if (historyIndex >= 0) {
                reversePoints = this.m_reverseHistory[historyIndex];
                diagonalReverseBase = reversePoints[0];
                diagonalMin = 1;
                diagonalMax = reversePoints.length - 1;
              }
            } while (--historyIndex >= -1);
            reverseChanges = changeHelper.getChanges();
          }
          return this.ConcatenateChanges(forwardChanges, reverseChanges);
        }
        ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
          let originalIndex = 0, modifiedIndex = 0;
          let diagonalForwardStart = 0, diagonalForwardEnd = 0;
          let diagonalReverseStart = 0, diagonalReverseEnd = 0;
          originalStart--;
          modifiedStart--;
          midOriginalArr[0] = 0;
          midModifiedArr[0] = 0;
          this.m_forwardHistory = [];
          this.m_reverseHistory = [];
          const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
          const numDiagonals = maxDifferences + 1;
          const forwardPoints = new Int32Array(numDiagonals);
          const reversePoints = new Int32Array(numDiagonals);
          const diagonalForwardBase = modifiedEnd - modifiedStart;
          const diagonalReverseBase = originalEnd - originalStart;
          const diagonalForwardOffset = originalStart - modifiedStart;
          const diagonalReverseOffset = originalEnd - modifiedEnd;
          const delta = diagonalReverseBase - diagonalForwardBase;
          const deltaIsEven = delta % 2 === 0;
          forwardPoints[diagonalForwardBase] = originalStart;
          reversePoints[diagonalReverseBase] = originalEnd;
          quitEarlyArr[0] = false;
          for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
            let furthestOriginalIndex = 0;
            let furthestModifiedIndex = 0;
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
              if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
                originalIndex = forwardPoints[diagonal + 1];
              } else {
                originalIndex = forwardPoints[diagonal - 1] + 1;
              }
              modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
              const tempOriginalIndex = originalIndex;
              while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                originalIndex++;
                modifiedIndex++;
              }
              forwardPoints[diagonal] = originalIndex;
              if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                furthestOriginalIndex = originalIndex;
                furthestModifiedIndex = modifiedIndex;
              }
              if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
                if (originalIndex >= reversePoints[diagonal]) {
                  midOriginalArr[0] = originalIndex;
                  midModifiedArr[0] = modifiedIndex;
                  if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                  } else {
                    return null;
                  }
                }
              }
            }
            const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
              quitEarlyArr[0] = true;
              midOriginalArr[0] = furthestOriginalIndex;
              midModifiedArr[0] = furthestModifiedIndex;
              if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                originalStart++;
                modifiedStart++;
                return [
                  new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
              }
            }
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
              if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
                originalIndex = reversePoints[diagonal + 1] - 1;
              } else {
                originalIndex = reversePoints[diagonal - 1];
              }
              modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
              const tempOriginalIndex = originalIndex;
              while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                originalIndex--;
                modifiedIndex--;
              }
              reversePoints[diagonal] = originalIndex;
              if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                if (originalIndex <= forwardPoints[diagonal]) {
                  midOriginalArr[0] = originalIndex;
                  midModifiedArr[0] = modifiedIndex;
                  if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                  } else {
                    return null;
                  }
                }
              }
            }
            if (numDifferences <= 1447) {
              let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
              temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
              MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
              this.m_forwardHistory.push(temp);
              temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
              temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
              MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
              this.m_reverseHistory.push(temp);
            }
          }
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        }
        PrettifyChanges(changes) {
          for (let i = 0; i < changes.length; i++) {
            const change = changes[i];
            const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
              const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
              const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
              if (endStrictEqual && !startStrictEqual) {
                break;
              }
              change.originalStart++;
              change.modifiedStart++;
            }
            let mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
              changes[i] = mergedChangeArr[0];
              changes.splice(i + 1, 1);
              i--;
              continue;
            }
          }
          for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            let originalStop = 0;
            let modifiedStop = 0;
            if (i > 0) {
              const prevChange = changes[i - 1];
              originalStop = prevChange.originalStart + prevChange.originalLength;
              modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
            }
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            let bestDelta = 0;
            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (let delta = 1; ; delta++) {
              const originalStart = change.originalStart - delta;
              const modifiedStart = change.modifiedStart - delta;
              if (originalStart < originalStop || modifiedStart < modifiedStop) {
                break;
              }
              if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                break;
              }
              if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                break;
              }
              const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
              const score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
              if (score > bestScore) {
                bestScore = score;
                bestDelta = delta;
              }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
            const mergedChangeArr = [null];
            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
              changes[i - 1] = mergedChangeArr[0];
              changes.splice(i, 1);
              i++;
              continue;
            }
          }
          if (this._hasStrings) {
            for (let i = 1, len = changes.length; i < len; i++) {
              const aChange = changes[i - 1];
              const bChange = changes[i];
              const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
              const aOriginalStart = aChange.originalStart;
              const bOriginalEnd = bChange.originalStart + bChange.originalLength;
              const abOriginalLength = bOriginalEnd - aOriginalStart;
              const aModifiedStart = aChange.modifiedStart;
              const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
              const abModifiedLength = bModifiedEnd - aModifiedStart;
              if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
                const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
                if (t) {
                  const [originalMatchStart, modifiedMatchStart] = t;
                  if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                    aChange.originalLength = originalMatchStart - aChange.originalStart;
                    aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                    bChange.originalStart = originalMatchStart + matchedLength;
                    bChange.modifiedStart = modifiedMatchStart + matchedLength;
                    bChange.originalLength = bOriginalEnd - bChange.originalStart;
                    bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                  }
                }
              }
            }
          }
          return changes;
        }
        _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
          if (originalLength < desiredLength || modifiedLength < desiredLength) {
            return null;
          }
          const originalMax = originalStart + originalLength - desiredLength + 1;
          const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
          let bestScore = 0;
          let bestOriginalStart = 0;
          let bestModifiedStart = 0;
          for (let i = originalStart; i < originalMax; i++) {
            for (let j = modifiedStart; j < modifiedMax; j++) {
              const score = this._contiguousSequenceScore(i, j, desiredLength);
              if (score > 0 && score > bestScore) {
                bestScore = score;
                bestOriginalStart = i;
                bestModifiedStart = j;
              }
            }
          }
          if (bestScore > 0) {
            return [bestOriginalStart, bestModifiedStart];
          }
          return null;
        }
        _contiguousSequenceScore(originalStart, modifiedStart, length) {
          let score = 0;
          for (let l = 0; l < length; l++) {
            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
              return 0;
            }
            score += this._originalStringElements[originalStart + l].length;
          }
          return score;
        }
        _OriginalIsBoundary(index) {
          if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
          }
          return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
        }
        _OriginalRegionIsBoundary(originalStart, originalLength) {
          if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
          }
          if (originalLength > 0) {
            const originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
              return true;
            }
          }
          return false;
        }
        _ModifiedIsBoundary(index) {
          if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
          }
          return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
        }
        _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
          if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
          }
          if (modifiedLength > 0) {
            const modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
              return true;
            }
          }
          return false;
        }
        _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
          const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
          const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
          return originalScore + modifiedScore;
        }
        ConcatenateChanges(left, right) {
          let mergedChangeArr = [];
          if (left.length === 0 || right.length === 0) {
            return right.length > 0 ? right : left;
          } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            const result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
          } else {
            const result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
          }
        }
        ChangesOverlap(left, right, mergedChangeArr) {
          Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
          Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
          if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            const originalStart = left.originalStart;
            let originalLength = left.originalLength;
            const modifiedStart = left.modifiedStart;
            let modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
              originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
              modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
          } else {
            mergedChangeArr[0] = null;
            return false;
          }
        }
        ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
          if (diagonal >= 0 && diagonal < numDiagonals) {
            return diagonal;
          }
          const diagonalsBelow = diagonalBaseIndex;
          const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
          const diffEven = numDifferences % 2 === 0;
          if (diagonal < 0) {
            const lowerBoundEven = diagonalsBelow % 2 === 0;
            return diffEven === lowerBoundEven ? 0 : 1;
          } else {
            const upperBoundEven = diagonalsAbove % 2 === 0;
            return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess, cwd, env, platform;
  var init_process = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js"() {
      init_platform();
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        const sandboxProcess = globals.vscode.process;
        safeProcess = {
          get platform() {
            return sandboxProcess.platform;
          },
          get arch() {
            return sandboxProcess.arch;
          },
          get env() {
            return sandboxProcess.env;
          },
          cwd() {
            return sandboxProcess.cwd();
          }
        };
      } else if (typeof process !== "undefined") {
        safeProcess = {
          get platform() {
            return process.platform;
          },
          get arch() {
            return process.arch;
          },
          get env() {
            return process.env;
          },
          cwd() {
            return process.env["VSCODE_CWD"] || process.cwd();
          }
        };
      } else {
        safeProcess = {
          get platform() {
            return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
          },
          get arch() {
            return void 0;
          },
          get env() {
            return {};
          },
          cwd() {
            return "/";
          }
        };
      }
      cwd = safeProcess.cwd;
      env = safeProcess.env;
      platform = safeProcess.platform;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js
  function validateString(value, name) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name, "string", value);
    }
  }
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType("pathObject", "Object", pathObject);
    }
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_COLON, CHAR_QUESTION_MARK, ErrorInvalidArgType, win32, posix, normalize, resolve, relative, dirname, basename, extname, sep;
  var init_path = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js"() {
      init_process();
      CHAR_UPPERCASE_A = 65;
      CHAR_LOWERCASE_A = 97;
      CHAR_UPPERCASE_Z = 90;
      CHAR_LOWERCASE_Z = 122;
      CHAR_DOT = 46;
      CHAR_FORWARD_SLASH = 47;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_COLON = 58;
      CHAR_QUESTION_MARK = 63;
      ErrorInvalidArgType = class extends Error {
        constructor(name, expected, actual) {
          let determiner;
          if (typeof expected === "string" && expected.indexOf("not ") === 0) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          const type = name.indexOf(".") !== -1 ? "property" : "argument";
          let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
          msg += `. Received type ${typeof actual}`;
          super(msg);
          this.code = "ERR_INVALID_ARG_TYPE";
        }
      };
      win32 = {
        resolve(...pathSegments) {
          let resolvedDevice = "";
          let resolvedTail = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
              path = pathSegments[i];
              validateString(path, "path");
              if (path.length === 0) {
                continue;
              }
            } else if (resolvedDevice.length === 0) {
              path = cwd();
            } else {
              path = env[`=${resolvedDevice}`] || cwd();
              if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
                path = `${resolvedDevice}\\`;
              }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len === 1) {
              if (isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
              }
            } else if (isPathSeparator(code)) {
              isAbsolute = true;
              if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  const firstPart = path.slice(last, j);
                  last = j;
                  while (j < len && isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j < len && j !== last) {
                    last = j;
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                      j++;
                    }
                    if (j === len || j !== last) {
                      device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                      rootEnd = j;
                    }
                  }
                }
              } else {
                rootEnd = 1;
              }
            } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
              device = path.slice(0, 2);
              rootEnd = 2;
              if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                isAbsolute = true;
                rootEnd = 3;
              }
            }
            if (device.length > 0) {
              if (resolvedDevice.length > 0) {
                if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                  continue;
                }
              } else {
                resolvedDevice = device;
              }
            }
            if (resolvedAbsolute) {
              if (resolvedDevice.length > 0) {
                break;
              }
            } else {
              resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
              resolvedAbsolute = isAbsolute;
              if (isAbsolute && resolvedDevice.length > 0) {
                break;
              }
            }
          }
          resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
          return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
        },
        normalize(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = 0;
          let device;
          let isAbsolute = false;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPosixPathSeparator(code) ? "\\" : path;
          }
          if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                const firstPart = path.slice(last, j);
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return `\\\\${firstPart}\\${path.slice(last)}\\`;
                  }
                  if (j !== last) {
                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                    rootEnd = j;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
              isAbsolute = true;
              rootEnd = 3;
            }
          }
          let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
          if (tail.length === 0 && !isAbsolute) {
            tail = ".";
          }
          if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
          }
          if (device === void 0) {
            return isAbsolute ? `\\${tail}` : tail;
          }
          return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
        },
        isAbsolute(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return false;
          }
          const code = path.charCodeAt(0);
          return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          let firstPart;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = firstPart = arg;
              } else {
                joined += `\\${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          let needsReplace = true;
          let slashCount = 0;
          if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
              ++slashCount;
              if (firstLen > 2) {
                if (isPathSeparator(firstPart.charCodeAt(2))) {
                  ++slashCount;
                } else {
                  needsReplace = false;
                }
              }
            }
          }
          if (needsReplace) {
            while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
              slashCount++;
            }
            if (slashCount >= 2) {
              joined = `\\${joined.slice(slashCount)}`;
            }
          }
          return win32.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          const fromOrig = win32.resolve(from);
          const toOrig = win32.resolve(to);
          if (fromOrig === toOrig) {
            return "";
          }
          from = fromOrig.toLowerCase();
          to = toOrig.toLowerCase();
          if (from === to) {
            return "";
          }
          let fromStart = 0;
          while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
          }
          let fromEnd = from.length;
          while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
          }
          const fromLen = fromEnd - fromStart;
          let toStart = 0;
          while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
          }
          let toEnd = to.length;
          while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
          }
          const toLen = toEnd - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_BACKWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i !== length) {
            if (lastCommonSep === -1) {
              return toOrig;
            }
          } else {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                return toOrig.slice(toStart + i + 1);
              }
              if (i === 2) {
                return toOrig.slice(toStart + i);
              }
            }
            if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 2) {
                lastCommonSep = 3;
              }
            }
            if (lastCommonSep === -1) {
              lastCommonSep = 0;
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
              out += out.length === 0 ? ".." : "\\..";
            }
          }
          toStart += lastCommonSep;
          if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
          }
          if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
          }
          return toOrig.slice(toStart, toEnd);
        },
        toNamespacedPath(path) {
          if (typeof path !== "string") {
            return path;
          }
          if (path.length === 0) {
            return "";
          }
          const resolvedPath = win32.resolve(path);
          if (resolvedPath.length <= 2) {
            return path;
          }
          if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
              const code = resolvedPath.charCodeAt(2);
              if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
              }
            }
          } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            return `\\\\?\\${resolvedPath}`;
          }
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = -1;
          let offset = 0;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPathSeparator(code) ? path : ".";
          }
          if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return path;
                  }
                  if (j !== last) {
                    rootEnd = offset = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
          }
          let end = -1;
          let matchedSlash = true;
          for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            if (rootEnd === -1) {
              return ".";
            }
            end = rootEnd;
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
          }
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
              const code = path.charCodeAt(i);
              if (isPathSeparator(code)) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let start = 0;
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
          }
          for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format.bind(null, "\\"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const len = path.length;
          let rootEnd = 0;
          let code = path.charCodeAt(0);
          if (len === 1) {
            if (isPathSeparator(code)) {
              ret.root = ret.dir = path;
              return ret;
            }
            ret.base = ret.name = path;
            return ret;
          }
          if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    rootEnd = j;
                  } else if (j !== last) {
                    rootEnd = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            if (len <= 2) {
              ret.root = ret.dir = path;
              return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
              if (len === 3) {
                ret.root = ret.dir = path;
                return ret;
              }
              rootEnd = 3;
            }
          }
          if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
          }
          let startDot = -1;
          let startPart = rootEnd;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(startPart, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
          } else {
            ret.dir = ret.root;
          }
          return ret;
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null
      };
      posix = {
        resolve(...pathSegments) {
          let resolvedPath = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : cwd();
            validateString(path, "path");
            if (path.length === 0) {
              continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          }
          resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
          if (resolvedAbsolute) {
            return `/${resolvedPath}`;
          }
          return resolvedPath.length > 0 ? resolvedPath : ".";
        },
        normalize(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
          path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
          if (path.length === 0) {
            if (isAbsolute) {
              return "/";
            }
            return trailingSeparator ? "./" : ".";
          }
          if (trailingSeparator) {
            path += "/";
          }
          return isAbsolute ? `/${path}` : path;
        },
        isAbsolute(path) {
          validateString(path, "path");
          return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = arg;
              } else {
                joined += `/${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return posix.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to) {
            return "";
          }
          const fromStart = 1;
          const fromEnd = from.length;
          const fromLen = fromEnd - fromStart;
          const toStart = 1;
          const toLen = to.length - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_FORWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                return to.slice(toStart + i + 1);
              }
              if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              out += out.length === 0 ? ".." : "/..";
            }
          }
          return `${out}${to.slice(toStart + lastCommonSep)}`;
        },
        toNamespacedPath(path) {
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let end = -1;
          let matchedSlash = true;
          for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            return hasRoot ? "/" : ".";
          }
          if (hasRoot && end === 1) {
            return "//";
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              const code = path.charCodeAt(i);
              if (code === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format.bind(null, "/"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
            if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(start2, end);
            } else {
              ret.name = path.slice(start2, startDot);
              ret.base = path.slice(start2, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
          } else if (isAbsolute) {
            ret.dir = "/";
          }
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.win32 = win32.win32 = win32;
      posix.posix = win32.posix = posix;
      normalize = platform === "win32" ? win32.normalize : posix.normalize;
      resolve = platform === "win32" ? win32.resolve : posix.resolve;
      relative = platform === "win32" ? win32.relative : posix.relative;
      dirname = platform === "win32" ? win32.dirname : posix.dirname;
      basename = platform === "win32" ? win32.basename : posix.basename;
      extname = platform === "win32" ? win32.extname : posix.extname;
      sep = platform === "win32" ? win32.sep : posix.sep;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  function encodeURIComponentFast(uriComponent, allowSlash) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.indexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.indexOf(":");
      if (idx === -1) {
        res += encoder(authority, false);
      } else {
        res += encoder(authority.substr(0, idx), false);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true);
    }
    if (query) {
      res += "?";
      res += encoder(query, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a3) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }
  var _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, Uri, encodeTable, _rEncodedAsHex;
  var init_uri = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js"() {
      init_path();
      init_platform();
      _schemePattern = /^\w[\w\d+.-]*$/;
      _singleSlashStart = /^\//;
      _doubleSlashStart = /^\/\//;
      _empty = "";
      _slash = "/";
      _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      URI = class {
        constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
          if (typeof schemeOrData === "object") {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
          } else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
          }
        }
        static isUri(thing) {
          if (thing instanceof URI) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
        }
        get fsPath() {
          return uriToFsPath(this, false);
        }
        with(change) {
          if (!change) {
            return this;
          }
          let { scheme, authority, path, query, fragment } = change;
          if (scheme === void 0) {
            scheme = this.scheme;
          } else if (scheme === null) {
            scheme = _empty;
          }
          if (authority === void 0) {
            authority = this.authority;
          } else if (authority === null) {
            authority = _empty;
          }
          if (path === void 0) {
            path = this.path;
          } else if (path === null) {
            path = _empty;
          }
          if (query === void 0) {
            query = this.query;
          } else if (query === null) {
            query = _empty;
          }
          if (fragment === void 0) {
            fragment = this.fragment;
          } else if (fragment === null) {
            fragment = _empty;
          }
          if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
            return this;
          }
          return new Uri(scheme, authority, path, query, fragment);
        }
        static parse(value, _strict = false) {
          const match = _regexp.exec(value);
          if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
          }
          return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
        }
        static file(path) {
          let authority = _empty;
          if (isWindows) {
            path = path.replace(/\\/g, _slash);
          }
          if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
              authority = path.substring(2);
              path = _slash;
            } else {
              authority = path.substring(2, idx);
              path = path.substring(idx) || _slash;
            }
          }
          return new Uri("file", authority, path, _empty, _empty);
        }
        static from(components) {
          const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
          _validateUri(result, true);
          return result;
        }
        static joinPath(uri, ...pathFragment) {
          if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPath on URI without path`);
          }
          let newPath;
          if (isWindows && uri.scheme === "file") {
            newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
          } else {
            newPath = posix.join(uri.path, ...pathFragment);
          }
          return uri.with({ path: newPath });
        }
        toString(skipEncoding = false) {
          return _asFormatted(this, skipEncoding);
        }
        toJSON() {
          return this;
        }
        static revive(data) {
          if (!data) {
            return data;
          } else if (data instanceof URI) {
            return data;
          } else {
            const result = new Uri(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
          }
        }
      };
      _pathSepMarker = isWindows ? 1 : void 0;
      Uri = class extends URI {
        constructor() {
          super(...arguments);
          this._formatted = null;
          this._fsPath = null;
        }
        get fsPath() {
          if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
          }
          return this._fsPath;
        }
        toString(skipEncoding = false) {
          if (!skipEncoding) {
            if (!this._formatted) {
              this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
          } else {
            return _asFormatted(this, true);
          }
        }
        toJSON() {
          const res = {
            $mid: 1
          };
          if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
          }
          if (this._formatted) {
            res.external = this._formatted;
          }
          if (this.path) {
            res.path = this.path;
          }
          if (this.scheme) {
            res.scheme = this.scheme;
          }
          if (this.authority) {
            res.authority = this.authority;
          }
          if (this.query) {
            res.query = this.query;
          }
          if (this.fragment) {
            res.fragment = this.fragment;
          }
          return res;
        }
      };
      encodeTable = {
        [58]: "%3A",
        [47]: "%2F",
        [63]: "%3F",
        [35]: "%23",
        [91]: "%5B",
        [93]: "%5D",
        [64]: "%40",
        [33]: "%21",
        [36]: "%24",
        [38]: "%26",
        [39]: "%27",
        [40]: "%28",
        [41]: "%29",
        [42]: "%2A",
        [43]: "%2B",
        [44]: "%2C",
        [59]: "%3B",
        [61]: "%3D",
        [32]: "%20"
      };
      _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position;
  var init_position = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js"() {
      Position = class {
        constructor(lineNumber, column) {
          this.lineNumber = lineNumber;
          this.column = column;
        }
        with(newLineNumber = this.lineNumber, newColumn = this.column) {
          if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
          } else {
            return new Position(newLineNumber, newColumn);
          }
        }
        delta(deltaLineNumber = 0, deltaColumn = 0) {
          return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
        }
        equals(other) {
          return Position.equals(this, other);
        }
        static equals(a, b) {
          if (!a && !b) {
            return true;
          }
          return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
        }
        isBefore(other) {
          return Position.isBefore(this, other);
        }
        static isBefore(a, b) {
          if (a.lineNumber < b.lineNumber) {
            return true;
          }
          if (b.lineNumber < a.lineNumber) {
            return false;
          }
          return a.column < b.column;
        }
        isBeforeOrEqual(other) {
          return Position.isBeforeOrEqual(this, other);
        }
        static isBeforeOrEqual(a, b) {
          if (a.lineNumber < b.lineNumber) {
            return true;
          }
          if (b.lineNumber < a.lineNumber) {
            return false;
          }
          return a.column <= b.column;
        }
        static compare(a, b) {
          const aLineNumber = a.lineNumber | 0;
          const bLineNumber = b.lineNumber | 0;
          if (aLineNumber === bLineNumber) {
            const aColumn = a.column | 0;
            const bColumn = b.column | 0;
            return aColumn - bColumn;
          }
          return aLineNumber - bLineNumber;
        }
        clone() {
          return new Position(this.lineNumber, this.column);
        }
        toString() {
          return "(" + this.lineNumber + "," + this.column + ")";
        }
        static lift(pos) {
          return new Position(pos.lineNumber, pos.column);
        }
        static isIPosition(obj) {
          return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range;
  var init_range = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"() {
      init_position();
      Range = class {
        constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
          if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
          } else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
          }
        }
        isEmpty() {
          return Range.isEmpty(this);
        }
        static isEmpty(range) {
          return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
        }
        containsPosition(position) {
          return Range.containsPosition(this, position);
        }
        static containsPosition(range, position) {
          if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
          }
          if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
          }
          if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
          }
          return true;
        }
        static strictContainsPosition(range, position) {
          if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
          }
          if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
            return false;
          }
          if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
            return false;
          }
          return true;
        }
        containsRange(range) {
          return Range.containsRange(this, range);
        }
        static containsRange(range, otherRange) {
          if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
          }
          if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
          }
          return true;
        }
        strictContainsRange(range) {
          return Range.strictContainsRange(this, range);
        }
        static strictContainsRange(range, otherRange) {
          if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
          }
          if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
          }
          return true;
        }
        plusRange(range) {
          return Range.plusRange(this, range);
        }
        static plusRange(a, b) {
          let startLineNumber;
          let startColumn;
          let endLineNumber;
          let endColumn;
          if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
          } else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
          } else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
          }
          if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
          } else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
          } else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
          }
          return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        intersectRanges(range) {
          return Range.intersectRanges(this, range);
        }
        static intersectRanges(a, b) {
          let resultStartLineNumber = a.startLineNumber;
          let resultStartColumn = a.startColumn;
          let resultEndLineNumber = a.endLineNumber;
          let resultEndColumn = a.endColumn;
          let otherStartLineNumber = b.startLineNumber;
          let otherStartColumn = b.startColumn;
          let otherEndLineNumber = b.endLineNumber;
          let otherEndColumn = b.endColumn;
          if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
          } else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
          }
          if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
          } else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
          }
          if (resultStartLineNumber > resultEndLineNumber) {
            return null;
          }
          if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
          }
          return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        }
        equalsRange(other) {
          return Range.equalsRange(this, other);
        }
        static equalsRange(a, b) {
          return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
        }
        getEndPosition() {
          return Range.getEndPosition(this);
        }
        static getEndPosition(range) {
          return new Position(range.endLineNumber, range.endColumn);
        }
        getStartPosition() {
          return Range.getStartPosition(this);
        }
        static getStartPosition(range) {
          return new Position(range.startLineNumber, range.startColumn);
        }
        toString() {
          return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
        }
        setEndPosition(endLineNumber, endColumn) {
          return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        setStartPosition(startLineNumber, startColumn) {
          return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        collapseToStart() {
          return Range.collapseToStart(this);
        }
        static collapseToStart(range) {
          return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        }
        static fromPositions(start, end = start) {
          return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        static lift(range) {
          if (!range) {
            return null;
          }
          return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        }
        static isIRange(obj) {
          return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
        }
        static areIntersectingOrTouching(a, b) {
          if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
            return false;
          }
          if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
            return false;
          }
          return true;
        }
        static areIntersecting(a, b) {
          if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
            return false;
          }
          if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
            return false;
          }
          return true;
        }
        static compareRangesUsingStarts(a, b) {
          if (a && b) {
            const aStartLineNumber = a.startLineNumber | 0;
            const bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
              const aStartColumn = a.startColumn | 0;
              const bStartColumn = b.startColumn | 0;
              if (aStartColumn === bStartColumn) {
                const aEndLineNumber = a.endLineNumber | 0;
                const bEndLineNumber = b.endLineNumber | 0;
                if (aEndLineNumber === bEndLineNumber) {
                  const aEndColumn = a.endColumn | 0;
                  const bEndColumn = b.endColumn | 0;
                  return aEndColumn - bEndColumn;
                }
                return aEndLineNumber - bEndLineNumber;
              }
              return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
          }
          const aExists = a ? 1 : 0;
          const bExists = b ? 1 : 0;
          return aExists - bExists;
        }
        static compareRangesUsingEnds(a, b) {
          if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
              if (a.startLineNumber === b.startLineNumber) {
                return a.startColumn - b.startColumn;
              }
              return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
          }
          return a.endLineNumber - b.endLineNumber;
        }
        static spansMultipleLines(range) {
          return range.endLineNumber > range.startLineNumber;
        }
        toJSON() {
          return this;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }
  var MINIMUM_MATCHING_CHARACTER_LENGTH, LineSequence, CharSequence, CharChange, LineChange, DiffComputer;
  var init_diffComputer = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js"() {
      init_diff();
      init_strings();
      MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
      LineSequence = class {
        constructor(lines) {
          const startColumns = [];
          const endColumns = [];
          for (let i = 0, length = lines.length; i < length; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
          }
          this.lines = lines;
          this._startColumns = startColumns;
          this._endColumns = endColumns;
        }
        getElements() {
          const elements = [];
          for (let i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
          }
          return elements;
        }
        getStrictElement(index) {
          return this.lines[index];
        }
        getStartLineNumber(i) {
          return i + 1;
        }
        getEndLineNumber(i) {
          return i + 1;
        }
        createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
          const charCodes = [];
          const lineNumbers = [];
          const columns = [];
          let len = 0;
          for (let index = startIndex; index <= endIndex; index++) {
            const lineContent = this.lines[index];
            const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
            const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
            for (let col = startColumn; col < endColumn; col++) {
              charCodes[len] = lineContent.charCodeAt(col - 1);
              lineNumbers[len] = index + 1;
              columns[len] = col;
              len++;
            }
          }
          return new CharSequence(charCodes, lineNumbers, columns);
        }
      };
      CharSequence = class {
        constructor(charCodes, lineNumbers, columns) {
          this._charCodes = charCodes;
          this._lineNumbers = lineNumbers;
          this._columns = columns;
        }
        getElements() {
          return this._charCodes;
        }
        getStartLineNumber(i) {
          return this._lineNumbers[i];
        }
        getStartColumn(i) {
          return this._columns[i];
        }
        getEndLineNumber(i) {
          return this._lineNumbers[i];
        }
        getEndColumn(i) {
          return this._columns[i] + 1;
        }
      };
      CharChange = class {
        constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
          this.originalStartLineNumber = originalStartLineNumber;
          this.originalStartColumn = originalStartColumn;
          this.originalEndLineNumber = originalEndLineNumber;
          this.originalEndColumn = originalEndColumn;
          this.modifiedStartLineNumber = modifiedStartLineNumber;
          this.modifiedStartColumn = modifiedStartColumn;
          this.modifiedEndLineNumber = modifiedEndLineNumber;
          this.modifiedEndColumn = modifiedEndColumn;
        }
        static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
          let originalStartLineNumber;
          let originalStartColumn;
          let originalEndLineNumber;
          let originalEndColumn;
          let modifiedStartLineNumber;
          let modifiedStartColumn;
          let modifiedEndLineNumber;
          let modifiedEndColumn;
          if (diffChange.originalLength === 0) {
            originalStartLineNumber = 0;
            originalStartColumn = 0;
            originalEndLineNumber = 0;
            originalEndColumn = 0;
          } else {
            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
          }
          if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = 0;
            modifiedStartColumn = 0;
            modifiedEndLineNumber = 0;
            modifiedEndColumn = 0;
          } else {
            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          }
          return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
        }
      };
      LineChange = class {
        constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
          this.originalStartLineNumber = originalStartLineNumber;
          this.originalEndLineNumber = originalEndLineNumber;
          this.modifiedStartLineNumber = modifiedStartLineNumber;
          this.modifiedEndLineNumber = modifiedEndLineNumber;
          this.charChanges = charChanges;
        }
        static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
          let originalStartLineNumber;
          let originalEndLineNumber;
          let modifiedStartLineNumber;
          let modifiedEndLineNumber;
          let charChanges = void 0;
          if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
          } else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
          }
          if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
          } else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          }
          if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
              rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
              charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
            }
          }
          return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
        }
      };
      DiffComputer = class {
        constructor(originalLines, modifiedLines, opts) {
          this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
          this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
          this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
          this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
          this.originalLines = originalLines;
          this.modifiedLines = modifiedLines;
          this.original = new LineSequence(originalLines);
          this.modified = new LineSequence(modifiedLines);
          this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
          this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
        }
        computeDiff() {
          if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
              return {
                quitEarly: false,
                changes: []
              };
            }
            return {
              quitEarly: false,
              changes: [{
                originalStartLineNumber: 1,
                originalEndLineNumber: 1,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: this.modified.lines.length,
                charChanges: [{
                  modifiedEndColumn: 0,
                  modifiedEndLineNumber: 0,
                  modifiedStartColumn: 0,
                  modifiedStartLineNumber: 0,
                  originalEndColumn: 0,
                  originalEndLineNumber: 0,
                  originalStartColumn: 0,
                  originalStartLineNumber: 0
                }]
              }]
            };
          }
          if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            return {
              quitEarly: false,
              changes: [{
                originalStartLineNumber: 1,
                originalEndLineNumber: this.original.lines.length,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: 1,
                charChanges: [{
                  modifiedEndColumn: 0,
                  modifiedEndLineNumber: 0,
                  modifiedStartColumn: 0,
                  modifiedStartLineNumber: 0,
                  originalEndColumn: 0,
                  originalEndLineNumber: 0,
                  originalStartColumn: 0,
                  originalStartLineNumber: 0
                }]
              }]
            };
          }
          const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
          const rawChanges = diffResult.changes;
          const quitEarly = diffResult.quitEarly;
          if (this.shouldIgnoreTrimWhitespace) {
            const lineChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
              lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
              quitEarly,
              changes: lineChanges
            };
          }
          const result = [];
          let originalLineIndex = 0;
          let modifiedLineIndex = 0;
          for (let i = -1, len = rawChanges.length; i < len; i++) {
            const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
            const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
            const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
              const originalLine = this.originalLines[originalLineIndex];
              const modifiedLine = this.modifiedLines[modifiedLineIndex];
              if (originalLine !== modifiedLine) {
                {
                  let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                  let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                  while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                    const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                    const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                    if (originalChar !== modifiedChar) {
                      break;
                    }
                    originalStartColumn--;
                    modifiedStartColumn--;
                  }
                  if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                    this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                  }
                }
                {
                  let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                  let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                  const originalMaxColumn = originalLine.length + 1;
                  const modifiedMaxColumn = modifiedLine.length + 1;
                  while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                    const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                    const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                    if (originalChar !== modifiedChar) {
                      break;
                    }
                    originalEndColumn++;
                    modifiedEndColumn++;
                  }
                  if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                    this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                  }
                }
              }
              originalLineIndex++;
              modifiedLineIndex++;
            }
            if (nextChange) {
              result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
              originalLineIndex += nextChange.originalLength;
              modifiedLineIndex += nextChange.modifiedLength;
            }
          }
          return {
            quitEarly,
            changes: result
          };
        }
        _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
          if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            return;
          }
          let charChanges = void 0;
          if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
          }
          result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
        }
        _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
          const len = result.length;
          if (len === 0) {
            return false;
          }
          const prevChange = result[len - 1];
          if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            return false;
          }
          if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
              prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
          }
          return false;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js
  var init_arrays = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 255) {
      return 255;
    }
    return v | 0;
  }
  function toUint32(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 4294967295) {
      return 4294967295;
    }
    return v | 0;
  }
  var init_uint = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js"() {
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer, PrefixSumIndexOfResult;
  var init_prefixSumComputer = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js"() {
      init_arrays();
      init_uint();
      PrefixSumComputer = class {
        constructor(values) {
          this.values = values;
          this.prefixSum = new Uint32Array(values.length);
          this.prefixSumValidIndex = new Int32Array(1);
          this.prefixSumValidIndex[0] = -1;
        }
        insertValues(insertIndex, insertValues) {
          insertIndex = toUint32(insertIndex);
          const oldValues = this.values;
          const oldPrefixSum = this.prefixSum;
          const insertValuesLen = insertValues.length;
          if (insertValuesLen === 0) {
            return false;
          }
          this.values = new Uint32Array(oldValues.length + insertValuesLen);
          this.values.set(oldValues.subarray(0, insertIndex), 0);
          this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
          this.values.set(insertValues, insertIndex);
          if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
          }
          this.prefixSum = new Uint32Array(this.values.length);
          if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
          }
          return true;
        }
        setValue(index, value) {
          index = toUint32(index);
          value = toUint32(value);
          if (this.values[index] === value) {
            return false;
          }
          this.values[index] = value;
          if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
          }
          return true;
        }
        removeValues(startIndex, count) {
          startIndex = toUint32(startIndex);
          count = toUint32(count);
          const oldValues = this.values;
          const oldPrefixSum = this.prefixSum;
          if (startIndex >= oldValues.length) {
            return false;
          }
          const maxCount = oldValues.length - startIndex;
          if (count >= maxCount) {
            count = maxCount;
          }
          if (count === 0) {
            return false;
          }
          this.values = new Uint32Array(oldValues.length - count);
          this.values.set(oldValues.subarray(0, startIndex), 0);
          this.values.set(oldValues.subarray(startIndex + count), startIndex);
          this.prefixSum = new Uint32Array(this.values.length);
          if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
          }
          if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
          }
          return true;
        }
        getTotalSum() {
          if (this.values.length === 0) {
            return 0;
          }
          return this._getPrefixSum(this.values.length - 1);
        }
        getPrefixSum(index) {
          if (index < 0) {
            return 0;
          }
          index = toUint32(index);
          return this._getPrefixSum(index);
        }
        _getPrefixSum(index) {
          if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
          }
          let startIndex = this.prefixSumValidIndex[0] + 1;
          if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
          }
          if (index >= this.values.length) {
            index = this.values.length - 1;
          }
          for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
          }
          this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
          return this.prefixSum[index];
        }
        getIndexOf(sum) {
          sum = Math.floor(sum);
          this.getTotalSum();
          let low = 0;
          let high = this.values.length - 1;
          let mid = 0;
          let midStop = 0;
          let midStart = 0;
          while (low <= high) {
            mid = low + (high - low) / 2 | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (sum < midStart) {
              high = mid - 1;
            } else if (sum >= midStop) {
              low = mid + 1;
            } else {
              break;
            }
          }
          return new PrefixSumIndexOfResult(mid, sum - midStart);
        }
      };
      PrefixSumIndexOfResult = class {
        constructor(index, remainder) {
          this.index = index;
          this.remainder = remainder;
          this._prefixSumIndexOfResultBrand = void 0;
          this.index = index;
          this.remainder = remainder;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel;
  var init_mirrorTextModel = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js"() {
      init_strings();
      init_position();
      init_prefixSumComputer();
      MirrorTextModel = class {
        constructor(uri, lines, eol, versionId) {
          this._uri = uri;
          this._lines = lines;
          this._eol = eol;
          this._versionId = versionId;
          this._lineStarts = null;
          this._cachedTextValue = null;
        }
        dispose() {
          this._lines.length = 0;
        }
        get version() {
          return this._versionId;
        }
        getText() {
          if (this._cachedTextValue === null) {
            this._cachedTextValue = this._lines.join(this._eol);
          }
          return this._cachedTextValue;
        }
        onEvents(e) {
          if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
          }
          const changes = e.changes;
          for (const change of changes) {
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
          }
          this._versionId = e.versionId;
          this._cachedTextValue = null;
        }
        _ensureLineStarts() {
          if (!this._lineStarts) {
            const eolLength = this._eol.length;
            const linesLength = this._lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
              lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new PrefixSumComputer(lineStartValues);
          }
        }
        _setLineText(lineIndex, newValue) {
          this._lines[lineIndex] = newValue;
          if (this._lineStarts) {
            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
          }
        }
        _acceptDeleteRange(range) {
          if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
              return;
            }
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
          }
          this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
          this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
          if (this._lineStarts) {
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
          }
        }
        _acceptInsertText(position, insertText) {
          if (insertText.length === 0) {
            return;
          }
          const insertLines = splitLines(insertText);
          if (insertLines.length === 1) {
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
          }
          insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
          this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
          const newLengths = new Uint32Array(insertLines.length - 1);
          for (let i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
          }
          if (this._lineStarts) {
            this._lineStarts.insertValues(position.lineNumber, newLengths);
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {
    if (text.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text = text.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }
  var USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, _defaultConfig;
  var init_wordHelper = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"() {
      USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
      DEFAULT_WORD_REGEXP = createWordRegExp();
      _defaultConfig = {
        maxLen: 1e3,
        windowSize: 15,
        timeBudget: 150
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier;
  var init_characterClassifier = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js"() {
      init_uint();
      CharacterClassifier = class {
        constructor(_defaultValue) {
          const defaultValue = toUint8(_defaultValue);
          this._defaultValue = defaultValue;
          this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
          this._map = /* @__PURE__ */ new Map();
        }
        static _createAsciiMap(defaultValue) {
          const asciiMap = new Uint8Array(256);
          for (let i = 0; i < 256; i++) {
            asciiMap[i] = defaultValue;
          }
          return asciiMap;
        }
        set(charCode, _value) {
          const value = toUint8(_value);
          if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
          } else {
            this._map.set(charCode, value);
          }
        }
        get(charCode) {
          if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
          } else {
            return this._map.get(charCode) || this._defaultValue;
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [1, 104, 2],
        [1, 72, 2],
        [1, 102, 6],
        [1, 70, 6],
        [2, 116, 3],
        [2, 84, 3],
        [3, 116, 4],
        [3, 84, 4],
        [4, 112, 5],
        [4, 80, 5],
        [5, 115, 9],
        [5, 83, 9],
        [5, 58, 10],
        [6, 105, 7],
        [6, 73, 7],
        [7, 108, 8],
        [7, 76, 8],
        [8, 101, 9],
        [8, 69, 9],
        [9, 58, 10],
        [10, 47, 11],
        [11, 47, 12]
      ]);
    }
    return _stateMachine;
  }
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(0);
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1);
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2);
      }
    }
    return _classifier;
  }
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }
  var Uint8Matrix, StateMachine, _stateMachine, _classifier, LinkComputer;
  var init_linkComputer = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js"() {
      init_characterClassifier();
      Uint8Matrix = class {
        constructor(rows, cols, defaultValue) {
          const data = new Uint8Array(rows * cols);
          for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
          }
          this._data = data;
          this.rows = rows;
          this.cols = cols;
        }
        get(row, col) {
          return this._data[row * this.cols + col];
        }
        set(row, col, value) {
          this._data[row * this.cols + col] = value;
        }
      };
      StateMachine = class {
        constructor(edges) {
          let maxCharCode = 0;
          let maxState = 0;
          for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
              maxCharCode = chCode;
            }
            if (from > maxState) {
              maxState = from;
            }
            if (to > maxState) {
              maxState = to;
            }
          }
          maxCharCode++;
          maxState++;
          const states = new Uint8Matrix(maxState, maxCharCode, 0);
          for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
          }
          this._states = states;
          this._maxCharCode = maxCharCode;
        }
        nextState(currentState, chCode) {
          if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0;
          }
          return this._states.get(currentState, chCode);
        }
      };
      _stateMachine = null;
      _classifier = null;
      LinkComputer = class {
        static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
          let lastIncludedCharIndex = linkEndIndex - 1;
          do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2) {
              break;
            }
            lastIncludedCharIndex--;
          } while (lastIncludedCharIndex > linkBeginIndex);
          if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
              lastIncludedCharIndex--;
            }
          }
          return {
            range: {
              startLineNumber: lineNumber,
              startColumn: linkBeginIndex + 1,
              endLineNumber: lineNumber,
              endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
          };
        }
        static computeLinks(model, stateMachine = getStateMachine()) {
          const classifier = getClassifier();
          const result = [];
          for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
              let resetStateMachine = false;
              const chCode = line.charCodeAt(j);
              if (state === 13) {
                let chClass;
                switch (chCode) {
                  case 40:
                    hasOpenParens = true;
                    chClass = 0;
                    break;
                  case 41:
                    chClass = hasOpenParens ? 0 : 1;
                    break;
                  case 91:
                    inSquareBrackets = true;
                    hasOpenSquareBracket = true;
                    chClass = 0;
                    break;
                  case 93:
                    inSquareBrackets = false;
                    chClass = hasOpenSquareBracket ? 0 : 1;
                    break;
                  case 123:
                    hasOpenCurlyBracket = true;
                    chClass = 0;
                    break;
                  case 125:
                    chClass = hasOpenCurlyBracket ? 0 : 1;
                    break;
                  case 39:
                    chClass = linkBeginChCode === 34 || linkBeginChCode === 96 ? 0 : 1;
                    break;
                  case 34:
                    chClass = linkBeginChCode === 39 || linkBeginChCode === 96 ? 0 : 1;
                    break;
                  case 96:
                    chClass = linkBeginChCode === 39 || linkBeginChCode === 34 ? 0 : 1;
                    break;
                  case 42:
                    chClass = linkBeginChCode === 42 ? 1 : 0;
                    break;
                  case 124:
                    chClass = linkBeginChCode === 124 ? 1 : 0;
                    break;
                  case 32:
                    chClass = inSquareBrackets ? 0 : 1;
                    break;
                  default:
                    chClass = classifier.get(chCode);
                }
                if (chClass === 1) {
                  result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                  resetStateMachine = true;
                }
              } else if (state === 12) {
                let chClass;
                if (chCode === 91) {
                  hasOpenSquareBracket = true;
                  chClass = 0;
                } else {
                  chClass = classifier.get(chCode);
                }
                if (chClass === 1) {
                  resetStateMachine = true;
                } else {
                  state = 13;
                }
              } else {
                state = stateMachine.nextState(state, chCode);
                if (state === 0) {
                  resetStateMachine = true;
                }
              }
              if (resetStateMachine) {
                state = 1;
                hasOpenParens = false;
                hasOpenSquareBracket = false;
                hasOpenCurlyBracket = false;
                linkBeginIndex = j + 1;
                linkBeginChCode = chCode;
              }
              j++;
            }
            if (state === 13) {
              result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
          }
          return result;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace;
  var init_inplaceReplaceSupport = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js"() {
      BasicInplaceReplace = class {
        constructor() {
          this._defaultValueSet = [
            ["true", "false"],
            ["True", "False"],
            ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
            ["public", "protected", "private"]
          ];
        }
        navigateValueSet(range1, text1, range2, text2, up) {
          if (range1 && text1) {
            const result = this.doNavigateValueSet(text1, up);
            if (result) {
              return {
                range: range1,
                value: result
              };
            }
          }
          if (range2 && text2) {
            const result = this.doNavigateValueSet(text2, up);
            if (result) {
              return {
                range: range2,
                value: result
              };
            }
          }
          return null;
        }
        doNavigateValueSet(text, up) {
          const numberResult = this.numberReplace(text, up);
          if (numberResult !== null) {
            return numberResult;
          }
          return this.textReplace(text, up);
        }
        numberReplace(value, up) {
          const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
          let n1 = Number(value);
          let n2 = parseFloat(value);
          if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
              return null;
            } else {
              n1 = Math.floor(n1 * precision);
              n1 += up ? precision : -precision;
              return String(n1 / precision);
            }
          }
          return null;
        }
        textReplace(value, up) {
          return this.valueSetsReplace(this._defaultValueSet, value, up);
        }
        valueSetsReplace(valueSets, value, up) {
          let result = null;
          for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
          }
          return result;
        }
        valueSetReplace(valueSet, value, up) {
          let idx = valueSet.indexOf(value);
          if (idx >= 0) {
            idx += up ? 1 : -1;
            if (idx < 0) {
              idx = valueSet.length - 1;
            } else {
              idx %= valueSet.length;
            }
            return valueSet[idx];
          }
          return null;
        }
      };
      BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent, CancellationToken, MutableToken, CancellationTokenSource;
  var init_cancellation = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js"() {
      init_event();
      shortcutEvent = Object.freeze(function(callback, context) {
        const handle = setTimeout(callback.bind(context), 0);
        return { dispose() {
          clearTimeout(handle);
        } };
      });
      (function(CancellationToken2) {
        function isCancellationToken(thing) {
          if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
            return true;
          }
          if (thing instanceof MutableToken) {
            return true;
          }
          if (!thing || typeof thing !== "object") {
            return false;
          }
          return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
        }
        CancellationToken2.isCancellationToken = isCancellationToken;
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: shortcutEvent
        });
      })(CancellationToken || (CancellationToken = {}));
      MutableToken = class {
        constructor() {
          this._isCancelled = false;
          this._emitter = null;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
          }
        }
      };
      CancellationTokenSource = class {
        constructor(parent) {
          this._token = void 0;
          this._parentListener = void 0;
          this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
        }
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else if (this._token instanceof MutableToken) {
            this._token.cancel();
          }
        }
        dispose(cancel = false) {
          if (cancel) {
            this.cancel();
          }
          if (this._parentListener) {
            this._parentListener.dispose();
          }
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }
  var KeyCodeStrMap, uiMap, userSettingsUSMap, userSettingsGeneralMap, EVENT_KEY_CODE_MAP, NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE, scanCodeIntToStr, scanCodeStrToInt, scanCodeLowerCaseStrToInt, IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, KeyCodeUtils;
  var init_keyCodes = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js"() {
      KeyCodeStrMap = class {
        constructor() {
          this._keyCodeToStr = [];
          this._strToKeyCode = /* @__PURE__ */ Object.create(null);
        }
        define(keyCode, str) {
          this._keyCodeToStr[keyCode] = str;
          this._strToKeyCode[str.toLowerCase()] = keyCode;
        }
        keyCodeToStr(keyCode) {
          return this._keyCodeToStr[keyCode];
        }
        strToKeyCode(str) {
          return this._strToKeyCode[str.toLowerCase()] || 0;
        }
      };
      uiMap = new KeyCodeStrMap();
      userSettingsUSMap = new KeyCodeStrMap();
      userSettingsGeneralMap = new KeyCodeStrMap();
      EVENT_KEY_CODE_MAP = new Array(230);
      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
      scanCodeIntToStr = [];
      scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
      scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
      IMMUTABLE_CODE_TO_KEY_CODE = [];
      IMMUTABLE_KEY_CODE_TO_CODE = [];
      for (let i = 0; i <= 193; i++) {
        IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
      }
      for (let i = 0; i <= 127; i++) {
        IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
      }
      (function() {
        const empty = "";
        const mappings = [
          [0, 1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
          [0, 1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
          [0, 1, 2, "Super", 0, empty, 0, empty, empty, empty],
          [0, 1, 3, "Fn", 0, empty, 0, empty, empty, empty],
          [0, 1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
          [0, 1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
          [0, 1, 6, "Resume", 0, empty, 0, empty, empty, empty],
          [0, 1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
          [0, 1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
          [0, 1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
          [31, 0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
          [32, 0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
          [33, 0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
          [34, 0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
          [35, 0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
          [36, 0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
          [37, 0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
          [38, 0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
          [39, 0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
          [40, 0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
          [41, 0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
          [42, 0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
          [43, 0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
          [44, 0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
          [45, 0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
          [46, 0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
          [47, 0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
          [48, 0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
          [49, 0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
          [50, 0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
          [51, 0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
          [52, 0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
          [53, 0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
          [54, 0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
          [55, 0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
          [56, 0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
          [22, 0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
          [23, 0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
          [24, 0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
          [25, 0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
          [26, 0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
          [27, 0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
          [28, 0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
          [29, 0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
          [30, 0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
          [21, 0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
          [3, 1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
          [9, 1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
          [1, 1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
          [2, 1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
          [10, 1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
          [83, 0, 51, "Minus", 83, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
          [81, 0, 52, "Equal", 81, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
          [87, 0, 53, "BracketLeft", 87, "[", 219, "VK_OEM_4", "[", "OEM_4"],
          [89, 0, 54, "BracketRight", 89, "]", 221, "VK_OEM_6", "]", "OEM_6"],
          [88, 0, 55, "Backslash", 88, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
          [0, 0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
          [80, 0, 57, "Semicolon", 80, ";", 186, "VK_OEM_1", ";", "OEM_1"],
          [90, 0, 58, "Quote", 90, "'", 222, "VK_OEM_7", "'", "OEM_7"],
          [86, 0, 59, "Backquote", 86, "`", 192, "VK_OEM_3", "`", "OEM_3"],
          [82, 0, 60, "Comma", 82, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
          [84, 0, 61, "Period", 84, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
          [85, 0, 62, "Slash", 85, "/", 191, "VK_OEM_2", "/", "OEM_2"],
          [8, 1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
          [59, 1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
          [60, 1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
          [61, 1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
          [62, 1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
          [63, 1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
          [64, 1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
          [65, 1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
          [66, 1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
          [67, 1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
          [68, 1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
          [69, 1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
          [70, 1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
          [0, 1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
          [79, 1, 77, "ScrollLock", 79, "ScrollLock", 145, "VK_SCROLL", empty, empty],
          [7, 1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
          [19, 1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
          [14, 1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
          [11, 1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
          [20, 1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
          [13, 1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
          [12, 1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
          [17, 1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
          [15, 1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
          [18, 1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
          [16, 1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
          [78, 1, 89, "NumLock", 78, "NumLock", 144, "VK_NUMLOCK", empty, empty],
          [108, 1, 90, "NumpadDivide", 108, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
          [103, 1, 91, "NumpadMultiply", 103, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
          [106, 1, 92, "NumpadSubtract", 106, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
          [104, 1, 93, "NumpadAdd", 104, "NumPad_Add", 107, "VK_ADD", empty, empty],
          [3, 1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
          [94, 1, 95, "Numpad1", 94, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
          [95, 1, 96, "Numpad2", 95, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
          [96, 1, 97, "Numpad3", 96, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
          [97, 1, 98, "Numpad4", 97, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
          [98, 1, 99, "Numpad5", 98, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
          [99, 1, 100, "Numpad6", 99, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
          [100, 1, 101, "Numpad7", 100, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
          [101, 1, 102, "Numpad8", 101, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
          [102, 1, 103, "Numpad9", 102, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
          [93, 1, 104, "Numpad0", 93, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
          [107, 1, 105, "NumpadDecimal", 107, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
          [92, 0, 106, "IntlBackslash", 92, "OEM_102", 226, "VK_OEM_102", empty, empty],
          [58, 1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
          [0, 1, 108, "Power", 0, empty, 0, empty, empty, empty],
          [0, 1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
          [71, 1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
          [72, 1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
          [73, 1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
          [74, 1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
          [75, 1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
          [76, 1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
          [77, 1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
          [0, 1, 117, "F20", 0, empty, 0, "VK_F20", empty, empty],
          [0, 1, 118, "F21", 0, empty, 0, "VK_F21", empty, empty],
          [0, 1, 119, "F22", 0, empty, 0, "VK_F22", empty, empty],
          [0, 1, 120, "F23", 0, empty, 0, "VK_F23", empty, empty],
          [0, 1, 121, "F24", 0, empty, 0, "VK_F24", empty, empty],
          [0, 1, 122, "Open", 0, empty, 0, empty, empty, empty],
          [0, 1, 123, "Help", 0, empty, 0, empty, empty, empty],
          [0, 1, 124, "Select", 0, empty, 0, empty, empty, empty],
          [0, 1, 125, "Again", 0, empty, 0, empty, empty, empty],
          [0, 1, 126, "Undo", 0, empty, 0, empty, empty, empty],
          [0, 1, 127, "Cut", 0, empty, 0, empty, empty, empty],
          [0, 1, 128, "Copy", 0, empty, 0, empty, empty, empty],
          [0, 1, 129, "Paste", 0, empty, 0, empty, empty, empty],
          [0, 1, 130, "Find", 0, empty, 0, empty, empty, empty],
          [0, 1, 131, "AudioVolumeMute", 112, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
          [0, 1, 132, "AudioVolumeUp", 113, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
          [0, 1, 133, "AudioVolumeDown", 114, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
          [105, 1, 134, "NumpadComma", 105, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
          [110, 0, 135, "IntlRo", 110, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
          [0, 1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
          [0, 0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
          [0, 1, 138, "Convert", 0, empty, 0, empty, empty, empty],
          [0, 1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
          [0, 1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
          [0, 1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
          [0, 1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
          [0, 1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
          [0, 1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
          [0, 1, 145, "Abort", 0, empty, 0, empty, empty, empty],
          [0, 1, 146, "Props", 0, empty, 0, empty, empty, empty],
          [0, 1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
          [0, 1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
          [0, 1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
          [0, 1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
          [0, 1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
          [0, 1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
          [0, 1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
          [0, 1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
          [0, 1, 155, "NumpadClear", 126, "Clear", 12, "VK_CLEAR", empty, empty],
          [0, 1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
          [5, 1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
          [4, 1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
          [6, 1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
          [57, 1, 0, empty, 57, "Meta", 0, "VK_COMMAND", empty, empty],
          [5, 1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
          [4, 1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
          [6, 1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
          [57, 1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
          [5, 1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
          [4, 1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
          [6, 1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
          [57, 1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
          [0, 1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
          [0, 1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
          [0, 1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
          [0, 1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
          [0, 1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
          [0, 1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
          [114, 1, 171, "MediaTrackNext", 119, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
          [115, 1, 172, "MediaTrackPrevious", 120, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
          [116, 1, 173, "MediaStop", 121, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
          [0, 1, 174, "Eject", 0, empty, 0, empty, empty, empty],
          [117, 1, 175, "MediaPlayPause", 122, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
          [0, 1, 176, "MediaSelect", 123, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
          [0, 1, 177, "LaunchMail", 124, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
          [0, 1, 178, "LaunchApp2", 125, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
          [0, 1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
          [0, 1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
          [0, 1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
          [0, 1, 182, "BrowserSearch", 115, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
          [0, 1, 183, "BrowserHome", 116, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
          [112, 1, 184, "BrowserBack", 117, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
          [113, 1, 185, "BrowserForward", 118, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
          [0, 1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
          [0, 1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
          [0, 1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
          [0, 1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
          [0, 1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
          [0, 1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
          [0, 1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
          [109, 1, 0, empty, 109, "KeyInComposition", 229, empty, empty, empty],
          [111, 1, 0, empty, 111, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
          [91, 1, 0, empty, 91, "OEM_8", 223, "VK_OEM_8", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
        ];
        let seenKeyCode = [];
        let seenScanCode = [];
        for (const mapping of mappings) {
          const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
          if (!seenScanCode[scanCode]) {
            seenScanCode[scanCode] = true;
            scanCodeIntToStr[scanCode] = scanCodeStr;
            scanCodeStrToInt[scanCodeStr] = scanCode;
            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
            if (immutable) {
              IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
              if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
                IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
              }
            }
          }
          if (!seenKeyCode[keyCode]) {
            seenKeyCode[keyCode] = true;
            if (!keyCodeStr) {
              throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
            }
            uiMap.define(keyCode, keyCodeStr);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
          }
          if (eventKeyCode) {
            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
          }
          if (vkey) {
            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
          }
        }
        IMMUTABLE_KEY_CODE_TO_CODE[3] = 46;
      })();
      (function(KeyCodeUtils2) {
        function toString(keyCode) {
          return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toString = toString;
        function fromString(key) {
          return uiMap.strToKeyCode(key);
        }
        KeyCodeUtils2.fromString = fromString;
        function toUserSettingsUS(keyCode) {
          return userSettingsUSMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
        function toUserSettingsGeneral(keyCode) {
          return userSettingsGeneralMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
        function fromUserSettings(key) {
          return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
        }
        KeyCodeUtils2.fromUserSettings = fromUserSettings;
        function toElectronAccelerator(keyCode) {
          if (keyCode >= 93 && keyCode <= 108) {
            return null;
          }
          switch (keyCode) {
            case 16:
              return "Up";
            case 18:
              return "Down";
            case 15:
              return "Left";
            case 17:
              return "Right";
          }
          return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
      })(KeyCodeUtils || (KeyCodeUtils = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection;
  var init_selection = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js"() {
      init_position();
      init_range();
      Selection = class extends Range {
        constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
          super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
          this.selectionStartLineNumber = selectionStartLineNumber;
          this.selectionStartColumn = selectionStartColumn;
          this.positionLineNumber = positionLineNumber;
          this.positionColumn = positionColumn;
        }
        toString() {
          return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
        }
        equalsSelection(other) {
          return Selection.selectionsEqual(this, other);
        }
        static selectionsEqual(a, b) {
          return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
        }
        getDirection() {
          if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0;
          }
          return 1;
        }
        setEndPosition(endLineNumber, endColumn) {
          if (this.getDirection() === 0) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
          }
          return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        }
        getPosition() {
          return new Position(this.positionLineNumber, this.positionColumn);
        }
        getSelectionStart() {
          return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
        }
        setStartPosition(startLineNumber, startColumn) {
          if (this.getDirection() === 0) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
          }
          return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        }
        static fromPositions(start, end = start) {
          return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        static fromRange(range, direction) {
          if (direction === 0) {
            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
          } else {
            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
          }
        }
        static liftSelection(sel) {
          return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        }
        static selectionsArrEqual(a, b) {
          if (a && !b || !a && b) {
            return false;
          }
          if (!a && !b) {
            return true;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
        static isISelection(obj) {
          return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
        }
        static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
          if (direction === 0) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
          }
          return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var __awaiter, TokenizationRegistry, TokenizationSupportFactoryData;
  var init_tokenizationRegistry = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js"() {
      init_event();
      init_lifecycle();
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      TokenizationRegistry = class {
        constructor() {
          this._map = /* @__PURE__ */ new Map();
          this._factories = /* @__PURE__ */ new Map();
          this._onDidChange = new Emitter();
          this.onDidChange = this._onDidChange.event;
          this._colorMap = null;
        }
        fire(languages) {
          this._onDidChange.fire({
            changedLanguages: languages,
            changedColorMap: false
          });
        }
        register(language, support) {
          this._map.set(language, support);
          this.fire([language]);
          return toDisposable(() => {
            if (this._map.get(language) !== support) {
              return;
            }
            this._map.delete(language);
            this.fire([language]);
          });
        }
        registerFactory(languageId, factory) {
          var _a3;
          (_a3 = this._factories.get(languageId)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
          const myData = new TokenizationSupportFactoryData(this, languageId, factory);
          this._factories.set(languageId, myData);
          return toDisposable(() => {
            const v = this._factories.get(languageId);
            if (!v || v !== myData) {
              return;
            }
            this._factories.delete(languageId);
            v.dispose();
          });
        }
        getOrCreate(languageId) {
          return __awaiter(this, void 0, void 0, function* () {
            const tokenizationSupport = this.get(languageId);
            if (tokenizationSupport) {
              return tokenizationSupport;
            }
            const factory = this._factories.get(languageId);
            if (!factory || factory.isResolved) {
              return null;
            }
            yield factory.resolve();
            return this.get(languageId);
          });
        }
        get(language) {
          return this._map.get(language) || null;
        }
        isResolved(languageId) {
          const tokenizationSupport = this.get(languageId);
          if (tokenizationSupport) {
            return true;
          }
          const factory = this._factories.get(languageId);
          if (!factory || factory.isResolved) {
            return true;
          }
          return false;
        }
        setColorMap(colorMap) {
          this._colorMap = colorMap;
          this._onDidChange.fire({
            changedLanguages: Array.from(this._map.keys()),
            changedColorMap: true
          });
        }
        getColorMap() {
          return this._colorMap;
        }
        getDefaultBackground() {
          if (this._colorMap && this._colorMap.length > 2) {
            return this._colorMap[2];
          }
          return null;
        }
      };
      TokenizationSupportFactoryData = class extends Disposable {
        constructor(_registry, _languageId, _factory) {
          super();
          this._registry = _registry;
          this._languageId = _languageId;
          this._factory = _factory;
          this._isDisposed = false;
          this._resolvePromise = null;
          this._isResolved = false;
        }
        get isResolved() {
          return this._isResolved;
        }
        dispose() {
          this._isDisposed = true;
          super.dispose();
        }
        resolve() {
          return __awaiter(this, void 0, void 0, function* () {
            if (!this._resolvePromise) {
              this._resolvePromise = this._create();
            }
            return this._resolvePromise;
          });
        }
        _create() {
          return __awaiter(this, void 0, void 0, function* () {
            const value = yield Promise.resolve(this._factory.createTokenizationSupport());
            this._isResolved = true;
            if (value && !this._isDisposed) {
              this._register(this._registry.register(this._languageId, value));
            }
          });
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js
  var Codicon, CSSIcon;
  var init_codicons = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js"() {
      Codicon = class {
        constructor(id, definition, description) {
          this.id = id;
          this.definition = definition;
          this.description = description;
          Codicon._allCodicons.push(this);
        }
        get classNames() {
          return "codicon codicon-" + this.id;
        }
        get classNamesArray() {
          return ["codicon", "codicon-" + this.id];
        }
        get cssSelector() {
          return ".codicon.codicon-" + this.id;
        }
        static getAll() {
          return Codicon._allCodicons;
        }
      };
      Codicon._allCodicons = [];
      Codicon.add = new Codicon("add", { fontCharacter: "\\ea60" });
      Codicon.plus = new Codicon("plus", Codicon.add.definition);
      Codicon.gistNew = new Codicon("gist-new", Codicon.add.definition);
      Codicon.repoCreate = new Codicon("repo-create", Codicon.add.definition);
      Codicon.lightbulb = new Codicon("lightbulb", { fontCharacter: "\\ea61" });
      Codicon.lightBulb = new Codicon("light-bulb", { fontCharacter: "\\ea61" });
      Codicon.repo = new Codicon("repo", { fontCharacter: "\\ea62" });
      Codicon.repoDelete = new Codicon("repo-delete", { fontCharacter: "\\ea62" });
      Codicon.gistFork = new Codicon("gist-fork", { fontCharacter: "\\ea63" });
      Codicon.repoForked = new Codicon("repo-forked", { fontCharacter: "\\ea63" });
      Codicon.gitPullRequest = new Codicon("git-pull-request", { fontCharacter: "\\ea64" });
      Codicon.gitPullRequestAbandoned = new Codicon("git-pull-request-abandoned", { fontCharacter: "\\ea64" });
      Codicon.recordKeys = new Codicon("record-keys", { fontCharacter: "\\ea65" });
      Codicon.keyboard = new Codicon("keyboard", { fontCharacter: "\\ea65" });
      Codicon.tag = new Codicon("tag", { fontCharacter: "\\ea66" });
      Codicon.tagAdd = new Codicon("tag-add", { fontCharacter: "\\ea66" });
      Codicon.tagRemove = new Codicon("tag-remove", { fontCharacter: "\\ea66" });
      Codicon.person = new Codicon("person", { fontCharacter: "\\ea67" });
      Codicon.personFollow = new Codicon("person-follow", { fontCharacter: "\\ea67" });
      Codicon.personOutline = new Codicon("person-outline", { fontCharacter: "\\ea67" });
      Codicon.personFilled = new Codicon("person-filled", { fontCharacter: "\\ea67" });
      Codicon.gitBranch = new Codicon("git-branch", { fontCharacter: "\\ea68" });
      Codicon.gitBranchCreate = new Codicon("git-branch-create", { fontCharacter: "\\ea68" });
      Codicon.gitBranchDelete = new Codicon("git-branch-delete", { fontCharacter: "\\ea68" });
      Codicon.sourceControl = new Codicon("source-control", { fontCharacter: "\\ea68" });
      Codicon.mirror = new Codicon("mirror", { fontCharacter: "\\ea69" });
      Codicon.mirrorPublic = new Codicon("mirror-public", { fontCharacter: "\\ea69" });
      Codicon.star = new Codicon("star", { fontCharacter: "\\ea6a" });
      Codicon.starAdd = new Codicon("star-add", { fontCharacter: "\\ea6a" });
      Codicon.starDelete = new Codicon("star-delete", { fontCharacter: "\\ea6a" });
      Codicon.starEmpty = new Codicon("star-empty", { fontCharacter: "\\ea6a" });
      Codicon.comment = new Codicon("comment", { fontCharacter: "\\ea6b" });
      Codicon.commentAdd = new Codicon("comment-add", { fontCharacter: "\\ea6b" });
      Codicon.alert = new Codicon("alert", { fontCharacter: "\\ea6c" });
      Codicon.warning = new Codicon("warning", { fontCharacter: "\\ea6c" });
      Codicon.search = new Codicon("search", { fontCharacter: "\\ea6d" });
      Codicon.searchSave = new Codicon("search-save", { fontCharacter: "\\ea6d" });
      Codicon.logOut = new Codicon("log-out", { fontCharacter: "\\ea6e" });
      Codicon.signOut = new Codicon("sign-out", { fontCharacter: "\\ea6e" });
      Codicon.logIn = new Codicon("log-in", { fontCharacter: "\\ea6f" });
      Codicon.signIn = new Codicon("sign-in", { fontCharacter: "\\ea6f" });
      Codicon.eye = new Codicon("eye", { fontCharacter: "\\ea70" });
      Codicon.eyeUnwatch = new Codicon("eye-unwatch", { fontCharacter: "\\ea70" });
      Codicon.eyeWatch = new Codicon("eye-watch", { fontCharacter: "\\ea70" });
      Codicon.circleFilled = new Codicon("circle-filled", { fontCharacter: "\\ea71" });
      Codicon.primitiveDot = new Codicon("primitive-dot", { fontCharacter: "\\ea71" });
      Codicon.closeDirty = new Codicon("close-dirty", { fontCharacter: "\\ea71" });
      Codicon.debugBreakpoint = new Codicon("debug-breakpoint", { fontCharacter: "\\ea71" });
      Codicon.debugBreakpointDisabled = new Codicon("debug-breakpoint-disabled", { fontCharacter: "\\ea71" });
      Codicon.debugHint = new Codicon("debug-hint", { fontCharacter: "\\ea71" });
      Codicon.primitiveSquare = new Codicon("primitive-square", { fontCharacter: "\\ea72" });
      Codicon.edit = new Codicon("edit", { fontCharacter: "\\ea73" });
      Codicon.pencil = new Codicon("pencil", { fontCharacter: "\\ea73" });
      Codicon.info = new Codicon("info", { fontCharacter: "\\ea74" });
      Codicon.issueOpened = new Codicon("issue-opened", { fontCharacter: "\\ea74" });
      Codicon.gistPrivate = new Codicon("gist-private", { fontCharacter: "\\ea75" });
      Codicon.gitForkPrivate = new Codicon("git-fork-private", { fontCharacter: "\\ea75" });
      Codicon.lock = new Codicon("lock", { fontCharacter: "\\ea75" });
      Codicon.mirrorPrivate = new Codicon("mirror-private", { fontCharacter: "\\ea75" });
      Codicon.close = new Codicon("close", { fontCharacter: "\\ea76" });
      Codicon.removeClose = new Codicon("remove-close", { fontCharacter: "\\ea76" });
      Codicon.x = new Codicon("x", { fontCharacter: "\\ea76" });
      Codicon.repoSync = new Codicon("repo-sync", { fontCharacter: "\\ea77" });
      Codicon.sync = new Codicon("sync", { fontCharacter: "\\ea77" });
      Codicon.clone = new Codicon("clone", { fontCharacter: "\\ea78" });
      Codicon.desktopDownload = new Codicon("desktop-download", { fontCharacter: "\\ea78" });
      Codicon.beaker = new Codicon("beaker", { fontCharacter: "\\ea79" });
      Codicon.microscope = new Codicon("microscope", { fontCharacter: "\\ea79" });
      Codicon.vm = new Codicon("vm", { fontCharacter: "\\ea7a" });
      Codicon.deviceDesktop = new Codicon("device-desktop", { fontCharacter: "\\ea7a" });
      Codicon.file = new Codicon("file", { fontCharacter: "\\ea7b" });
      Codicon.fileText = new Codicon("file-text", { fontCharacter: "\\ea7b" });
      Codicon.more = new Codicon("more", { fontCharacter: "\\ea7c" });
      Codicon.ellipsis = new Codicon("ellipsis", { fontCharacter: "\\ea7c" });
      Codicon.kebabHorizontal = new Codicon("kebab-horizontal", { fontCharacter: "\\ea7c" });
      Codicon.mailReply = new Codicon("mail-reply", { fontCharacter: "\\ea7d" });
      Codicon.reply = new Codicon("reply", { fontCharacter: "\\ea7d" });
      Codicon.organization = new Codicon("organization", { fontCharacter: "\\ea7e" });
      Codicon.organizationFilled = new Codicon("organization-filled", { fontCharacter: "\\ea7e" });
      Codicon.organizationOutline = new Codicon("organization-outline", { fontCharacter: "\\ea7e" });
      Codicon.newFile = new Codicon("new-file", { fontCharacter: "\\ea7f" });
      Codicon.fileAdd = new Codicon("file-add", { fontCharacter: "\\ea7f" });
      Codicon.newFolder = new Codicon("new-folder", { fontCharacter: "\\ea80" });
      Codicon.fileDirectoryCreate = new Codicon("file-directory-create", { fontCharacter: "\\ea80" });
      Codicon.trash = new Codicon("trash", { fontCharacter: "\\ea81" });
      Codicon.trashcan = new Codicon("trashcan", { fontCharacter: "\\ea81" });
      Codicon.history = new Codicon("history", { fontCharacter: "\\ea82" });
      Codicon.clock = new Codicon("clock", { fontCharacter: "\\ea82" });
      Codicon.folder = new Codicon("folder", { fontCharacter: "\\ea83" });
      Codicon.fileDirectory = new Codicon("file-directory", { fontCharacter: "\\ea83" });
      Codicon.symbolFolder = new Codicon("symbol-folder", { fontCharacter: "\\ea83" });
      Codicon.logoGithub = new Codicon("logo-github", { fontCharacter: "\\ea84" });
      Codicon.markGithub = new Codicon("mark-github", { fontCharacter: "\\ea84" });
      Codicon.github = new Codicon("github", { fontCharacter: "\\ea84" });
      Codicon.terminal = new Codicon("terminal", { fontCharacter: "\\ea85" });
      Codicon.console = new Codicon("console", { fontCharacter: "\\ea85" });
      Codicon.repl = new Codicon("repl", { fontCharacter: "\\ea85" });
      Codicon.zap = new Codicon("zap", { fontCharacter: "\\ea86" });
      Codicon.symbolEvent = new Codicon("symbol-event", { fontCharacter: "\\ea86" });
      Codicon.error = new Codicon("error", { fontCharacter: "\\ea87" });
      Codicon.stop = new Codicon("stop", { fontCharacter: "\\ea87" });
      Codicon.variable = new Codicon("variable", { fontCharacter: "\\ea88" });
      Codicon.symbolVariable = new Codicon("symbol-variable", { fontCharacter: "\\ea88" });
      Codicon.array = new Codicon("array", { fontCharacter: "\\ea8a" });
      Codicon.symbolArray = new Codicon("symbol-array", { fontCharacter: "\\ea8a" });
      Codicon.symbolModule = new Codicon("symbol-module", { fontCharacter: "\\ea8b" });
      Codicon.symbolPackage = new Codicon("symbol-package", { fontCharacter: "\\ea8b" });
      Codicon.symbolNamespace = new Codicon("symbol-namespace", { fontCharacter: "\\ea8b" });
      Codicon.symbolObject = new Codicon("symbol-object", { fontCharacter: "\\ea8b" });
      Codicon.symbolMethod = new Codicon("symbol-method", { fontCharacter: "\\ea8c" });
      Codicon.symbolFunction = new Codicon("symbol-function", { fontCharacter: "\\ea8c" });
      Codicon.symbolConstructor = new Codicon("symbol-constructor", { fontCharacter: "\\ea8c" });
      Codicon.symbolBoolean = new Codicon("symbol-boolean", { fontCharacter: "\\ea8f" });
      Codicon.symbolNull = new Codicon("symbol-null", { fontCharacter: "\\ea8f" });
      Codicon.symbolNumeric = new Codicon("symbol-numeric", { fontCharacter: "\\ea90" });
      Codicon.symbolNumber = new Codicon("symbol-number", { fontCharacter: "\\ea90" });
      Codicon.symbolStructure = new Codicon("symbol-structure", { fontCharacter: "\\ea91" });
      Codicon.symbolStruct = new Codicon("symbol-struct", { fontCharacter: "\\ea91" });
      Codicon.symbolParameter = new Codicon("symbol-parameter", { fontCharacter: "\\ea92" });
      Codicon.symbolTypeParameter = new Codicon("symbol-type-parameter", { fontCharacter: "\\ea92" });
      Codicon.symbolKey = new Codicon("symbol-key", { fontCharacter: "\\ea93" });
      Codicon.symbolText = new Codicon("symbol-text", { fontCharacter: "\\ea93" });
      Codicon.symbolReference = new Codicon("symbol-reference", { fontCharacter: "\\ea94" });
      Codicon.goToFile = new Codicon("go-to-file", { fontCharacter: "\\ea94" });
      Codicon.symbolEnum = new Codicon("symbol-enum", { fontCharacter: "\\ea95" });
      Codicon.symbolValue = new Codicon("symbol-value", { fontCharacter: "\\ea95" });
      Codicon.symbolRuler = new Codicon("symbol-ruler", { fontCharacter: "\\ea96" });
      Codicon.symbolUnit = new Codicon("symbol-unit", { fontCharacter: "\\ea96" });
      Codicon.activateBreakpoints = new Codicon("activate-breakpoints", { fontCharacter: "\\ea97" });
      Codicon.archive = new Codicon("archive", { fontCharacter: "\\ea98" });
      Codicon.arrowBoth = new Codicon("arrow-both", { fontCharacter: "\\ea99" });
      Codicon.arrowDown = new Codicon("arrow-down", { fontCharacter: "\\ea9a" });
      Codicon.arrowLeft = new Codicon("arrow-left", { fontCharacter: "\\ea9b" });
      Codicon.arrowRight = new Codicon("arrow-right", { fontCharacter: "\\ea9c" });
      Codicon.arrowSmallDown = new Codicon("arrow-small-down", { fontCharacter: "\\ea9d" });
      Codicon.arrowSmallLeft = new Codicon("arrow-small-left", { fontCharacter: "\\ea9e" });
      Codicon.arrowSmallRight = new Codicon("arrow-small-right", { fontCharacter: "\\ea9f" });
      Codicon.arrowSmallUp = new Codicon("arrow-small-up", { fontCharacter: "\\eaa0" });
      Codicon.arrowUp = new Codicon("arrow-up", { fontCharacter: "\\eaa1" });
      Codicon.bell = new Codicon("bell", { fontCharacter: "\\eaa2" });
      Codicon.bold = new Codicon("bold", { fontCharacter: "\\eaa3" });
      Codicon.book = new Codicon("book", { fontCharacter: "\\eaa4" });
      Codicon.bookmark = new Codicon("bookmark", { fontCharacter: "\\eaa5" });
      Codicon.debugBreakpointConditionalUnverified = new Codicon("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" });
      Codicon.debugBreakpointConditional = new Codicon("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" });
      Codicon.debugBreakpointConditionalDisabled = new Codicon("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" });
      Codicon.debugBreakpointDataUnverified = new Codicon("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" });
      Codicon.debugBreakpointData = new Codicon("debug-breakpoint-data", { fontCharacter: "\\eaa9" });
      Codicon.debugBreakpointDataDisabled = new Codicon("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" });
      Codicon.debugBreakpointLogUnverified = new Codicon("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" });
      Codicon.debugBreakpointLog = new Codicon("debug-breakpoint-log", { fontCharacter: "\\eaab" });
      Codicon.debugBreakpointLogDisabled = new Codicon("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" });
      Codicon.briefcase = new Codicon("briefcase", { fontCharacter: "\\eaac" });
      Codicon.broadcast = new Codicon("broadcast", { fontCharacter: "\\eaad" });
      Codicon.browser = new Codicon("browser", { fontCharacter: "\\eaae" });
      Codicon.bug = new Codicon("bug", { fontCharacter: "\\eaaf" });
      Codicon.calendar = new Codicon("calendar", { fontCharacter: "\\eab0" });
      Codicon.caseSensitive = new Codicon("case-sensitive", { fontCharacter: "\\eab1" });
      Codicon.check = new Codicon("check", { fontCharacter: "\\eab2" });
      Codicon.checklist = new Codicon("checklist", { fontCharacter: "\\eab3" });
      Codicon.chevronDown = new Codicon("chevron-down", { fontCharacter: "\\eab4" });
      Codicon.dropDownButton = new Codicon("drop-down-button", Codicon.chevronDown.definition);
      Codicon.chevronLeft = new Codicon("chevron-left", { fontCharacter: "\\eab5" });
      Codicon.chevronRight = new Codicon("chevron-right", { fontCharacter: "\\eab6" });
      Codicon.chevronUp = new Codicon("chevron-up", { fontCharacter: "\\eab7" });
      Codicon.chromeClose = new Codicon("chrome-close", { fontCharacter: "\\eab8" });
      Codicon.chromeMaximize = new Codicon("chrome-maximize", { fontCharacter: "\\eab9" });
      Codicon.chromeMinimize = new Codicon("chrome-minimize", { fontCharacter: "\\eaba" });
      Codicon.chromeRestore = new Codicon("chrome-restore", { fontCharacter: "\\eabb" });
      Codicon.circleOutline = new Codicon("circle-outline", { fontCharacter: "\\eabc" });
      Codicon.debugBreakpointUnverified = new Codicon("debug-breakpoint-unverified", { fontCharacter: "\\eabc" });
      Codicon.circleSlash = new Codicon("circle-slash", { fontCharacter: "\\eabd" });
      Codicon.circuitBoard = new Codicon("circuit-board", { fontCharacter: "\\eabe" });
      Codicon.clearAll = new Codicon("clear-all", { fontCharacter: "\\eabf" });
      Codicon.clippy = new Codicon("clippy", { fontCharacter: "\\eac0" });
      Codicon.closeAll = new Codicon("close-all", { fontCharacter: "\\eac1" });
      Codicon.cloudDownload = new Codicon("cloud-download", { fontCharacter: "\\eac2" });
      Codicon.cloudUpload = new Codicon("cloud-upload", { fontCharacter: "\\eac3" });
      Codicon.code = new Codicon("code", { fontCharacter: "\\eac4" });
      Codicon.collapseAll = new Codicon("collapse-all", { fontCharacter: "\\eac5" });
      Codicon.colorMode = new Codicon("color-mode", { fontCharacter: "\\eac6" });
      Codicon.commentDiscussion = new Codicon("comment-discussion", { fontCharacter: "\\eac7" });
      Codicon.compareChanges = new Codicon("compare-changes", { fontCharacter: "\\eafd" });
      Codicon.creditCard = new Codicon("credit-card", { fontCharacter: "\\eac9" });
      Codicon.dash = new Codicon("dash", { fontCharacter: "\\eacc" });
      Codicon.dashboard = new Codicon("dashboard", { fontCharacter: "\\eacd" });
      Codicon.database = new Codicon("database", { fontCharacter: "\\eace" });
      Codicon.debugContinue = new Codicon("debug-continue", { fontCharacter: "\\eacf" });
      Codicon.debugDisconnect = new Codicon("debug-disconnect", { fontCharacter: "\\ead0" });
      Codicon.debugPause = new Codicon("debug-pause", { fontCharacter: "\\ead1" });
      Codicon.debugRestart = new Codicon("debug-restart", { fontCharacter: "\\ead2" });
      Codicon.debugStart = new Codicon("debug-start", { fontCharacter: "\\ead3" });
      Codicon.debugStepInto = new Codicon("debug-step-into", { fontCharacter: "\\ead4" });
      Codicon.debugStepOut = new Codicon("debug-step-out", { fontCharacter: "\\ead5" });
      Codicon.debugStepOver = new Codicon("debug-step-over", { fontCharacter: "\\ead6" });
      Codicon.debugStop = new Codicon("debug-stop", { fontCharacter: "\\ead7" });
      Codicon.debug = new Codicon("debug", { fontCharacter: "\\ead8" });
      Codicon.deviceCameraVideo = new Codicon("device-camera-video", { fontCharacter: "\\ead9" });
      Codicon.deviceCamera = new Codicon("device-camera", { fontCharacter: "\\eada" });
      Codicon.deviceMobile = new Codicon("device-mobile", { fontCharacter: "\\eadb" });
      Codicon.diffAdded = new Codicon("diff-added", { fontCharacter: "\\eadc" });
      Codicon.diffIgnored = new Codicon("diff-ignored", { fontCharacter: "\\eadd" });
      Codicon.diffModified = new Codicon("diff-modified", { fontCharacter: "\\eade" });
      Codicon.diffRemoved = new Codicon("diff-removed", { fontCharacter: "\\eadf" });
      Codicon.diffRenamed = new Codicon("diff-renamed", { fontCharacter: "\\eae0" });
      Codicon.diff = new Codicon("diff", { fontCharacter: "\\eae1" });
      Codicon.discard = new Codicon("discard", { fontCharacter: "\\eae2" });
      Codicon.editorLayout = new Codicon("editor-layout", { fontCharacter: "\\eae3" });
      Codicon.emptyWindow = new Codicon("empty-window", { fontCharacter: "\\eae4" });
      Codicon.exclude = new Codicon("exclude", { fontCharacter: "\\eae5" });
      Codicon.extensions = new Codicon("extensions", { fontCharacter: "\\eae6" });
      Codicon.eyeClosed = new Codicon("eye-closed", { fontCharacter: "\\eae7" });
      Codicon.fileBinary = new Codicon("file-binary", { fontCharacter: "\\eae8" });
      Codicon.fileCode = new Codicon("file-code", { fontCharacter: "\\eae9" });
      Codicon.fileMedia = new Codicon("file-media", { fontCharacter: "\\eaea" });
      Codicon.filePdf = new Codicon("file-pdf", { fontCharacter: "\\eaeb" });
      Codicon.fileSubmodule = new Codicon("file-submodule", { fontCharacter: "\\eaec" });
      Codicon.fileSymlinkDirectory = new Codicon("file-symlink-directory", { fontCharacter: "\\eaed" });
      Codicon.fileSymlinkFile = new Codicon("file-symlink-file", { fontCharacter: "\\eaee" });
      Codicon.fileZip = new Codicon("file-zip", { fontCharacter: "\\eaef" });
      Codicon.files = new Codicon("files", { fontCharacter: "\\eaf0" });
      Codicon.filter = new Codicon("filter", { fontCharacter: "\\eaf1" });
      Codicon.flame = new Codicon("flame", { fontCharacter: "\\eaf2" });
      Codicon.foldDown = new Codicon("fold-down", { fontCharacter: "\\eaf3" });
      Codicon.foldUp = new Codicon("fold-up", { fontCharacter: "\\eaf4" });
      Codicon.fold = new Codicon("fold", { fontCharacter: "\\eaf5" });
      Codicon.folderActive = new Codicon("folder-active", { fontCharacter: "\\eaf6" });
      Codicon.folderOpened = new Codicon("folder-opened", { fontCharacter: "\\eaf7" });
      Codicon.gear = new Codicon("gear", { fontCharacter: "\\eaf8" });
      Codicon.gift = new Codicon("gift", { fontCharacter: "\\eaf9" });
      Codicon.gistSecret = new Codicon("gist-secret", { fontCharacter: "\\eafa" });
      Codicon.gist = new Codicon("gist", { fontCharacter: "\\eafb" });
      Codicon.gitCommit = new Codicon("git-commit", { fontCharacter: "\\eafc" });
      Codicon.gitCompare = new Codicon("git-compare", { fontCharacter: "\\eafd" });
      Codicon.gitMerge = new Codicon("git-merge", { fontCharacter: "\\eafe" });
      Codicon.githubAction = new Codicon("github-action", { fontCharacter: "\\eaff" });
      Codicon.githubAlt = new Codicon("github-alt", { fontCharacter: "\\eb00" });
      Codicon.globe = new Codicon("globe", { fontCharacter: "\\eb01" });
      Codicon.grabber = new Codicon("grabber", { fontCharacter: "\\eb02" });
      Codicon.graph = new Codicon("graph", { fontCharacter: "\\eb03" });
      Codicon.gripper = new Codicon("gripper", { fontCharacter: "\\eb04" });
      Codicon.heart = new Codicon("heart", { fontCharacter: "\\eb05" });
      Codicon.home = new Codicon("home", { fontCharacter: "\\eb06" });
      Codicon.horizontalRule = new Codicon("horizontal-rule", { fontCharacter: "\\eb07" });
      Codicon.hubot = new Codicon("hubot", { fontCharacter: "\\eb08" });
      Codicon.inbox = new Codicon("inbox", { fontCharacter: "\\eb09" });
      Codicon.issueClosed = new Codicon("issue-closed", { fontCharacter: "\\eba4" });
      Codicon.issueReopened = new Codicon("issue-reopened", { fontCharacter: "\\eb0b" });
      Codicon.issues = new Codicon("issues", { fontCharacter: "\\eb0c" });
      Codicon.italic = new Codicon("italic", { fontCharacter: "\\eb0d" });
      Codicon.jersey = new Codicon("jersey", { fontCharacter: "\\eb0e" });
      Codicon.json = new Codicon("json", { fontCharacter: "\\eb0f" });
      Codicon.kebabVertical = new Codicon("kebab-vertical", { fontCharacter: "\\eb10" });
      Codicon.key = new Codicon("key", { fontCharacter: "\\eb11" });
      Codicon.law = new Codicon("law", { fontCharacter: "\\eb12" });
      Codicon.lightbulbAutofix = new Codicon("lightbulb-autofix", { fontCharacter: "\\eb13" });
      Codicon.linkExternal = new Codicon("link-external", { fontCharacter: "\\eb14" });
      Codicon.link = new Codicon("link", { fontCharacter: "\\eb15" });
      Codicon.listOrdered = new Codicon("list-ordered", { fontCharacter: "\\eb16" });
      Codicon.listUnordered = new Codicon("list-unordered", { fontCharacter: "\\eb17" });
      Codicon.liveShare = new Codicon("live-share", { fontCharacter: "\\eb18" });
      Codicon.loading = new Codicon("loading", { fontCharacter: "\\eb19" });
      Codicon.location = new Codicon("location", { fontCharacter: "\\eb1a" });
      Codicon.mailRead = new Codicon("mail-read", { fontCharacter: "\\eb1b" });
      Codicon.mail = new Codicon("mail", { fontCharacter: "\\eb1c" });
      Codicon.markdown = new Codicon("markdown", { fontCharacter: "\\eb1d" });
      Codicon.megaphone = new Codicon("megaphone", { fontCharacter: "\\eb1e" });
      Codicon.mention = new Codicon("mention", { fontCharacter: "\\eb1f" });
      Codicon.milestone = new Codicon("milestone", { fontCharacter: "\\eb20" });
      Codicon.mortarBoard = new Codicon("mortar-board", { fontCharacter: "\\eb21" });
      Codicon.move = new Codicon("move", { fontCharacter: "\\eb22" });
      Codicon.multipleWindows = new Codicon("multiple-windows", { fontCharacter: "\\eb23" });
      Codicon.mute = new Codicon("mute", { fontCharacter: "\\eb24" });
      Codicon.noNewline = new Codicon("no-newline", { fontCharacter: "\\eb25" });
      Codicon.note = new Codicon("note", { fontCharacter: "\\eb26" });
      Codicon.octoface = new Codicon("octoface", { fontCharacter: "\\eb27" });
      Codicon.openPreview = new Codicon("open-preview", { fontCharacter: "\\eb28" });
      Codicon.package_ = new Codicon("package", { fontCharacter: "\\eb29" });
      Codicon.paintcan = new Codicon("paintcan", { fontCharacter: "\\eb2a" });
      Codicon.pin = new Codicon("pin", { fontCharacter: "\\eb2b" });
      Codicon.play = new Codicon("play", { fontCharacter: "\\eb2c" });
      Codicon.run = new Codicon("run", { fontCharacter: "\\eb2c" });
      Codicon.plug = new Codicon("plug", { fontCharacter: "\\eb2d" });
      Codicon.preserveCase = new Codicon("preserve-case", { fontCharacter: "\\eb2e" });
      Codicon.preview = new Codicon("preview", { fontCharacter: "\\eb2f" });
      Codicon.project = new Codicon("project", { fontCharacter: "\\eb30" });
      Codicon.pulse = new Codicon("pulse", { fontCharacter: "\\eb31" });
      Codicon.question = new Codicon("question", { fontCharacter: "\\eb32" });
      Codicon.quote = new Codicon("quote", { fontCharacter: "\\eb33" });
      Codicon.radioTower = new Codicon("radio-tower", { fontCharacter: "\\eb34" });
      Codicon.reactions = new Codicon("reactions", { fontCharacter: "\\eb35" });
      Codicon.references = new Codicon("references", { fontCharacter: "\\eb36" });
      Codicon.refresh = new Codicon("refresh", { fontCharacter: "\\eb37" });
      Codicon.regex = new Codicon("regex", { fontCharacter: "\\eb38" });
      Codicon.remoteExplorer = new Codicon("remote-explorer", { fontCharacter: "\\eb39" });
      Codicon.remote = new Codicon("remote", { fontCharacter: "\\eb3a" });
      Codicon.remove = new Codicon("remove", { fontCharacter: "\\eb3b" });
      Codicon.replaceAll = new Codicon("replace-all", { fontCharacter: "\\eb3c" });
      Codicon.replace = new Codicon("replace", { fontCharacter: "\\eb3d" });
      Codicon.repoClone = new Codicon("repo-clone", { fontCharacter: "\\eb3e" });
      Codicon.repoForcePush = new Codicon("repo-force-push", { fontCharacter: "\\eb3f" });
      Codicon.repoPull = new Codicon("repo-pull", { fontCharacter: "\\eb40" });
      Codicon.repoPush = new Codicon("repo-push", { fontCharacter: "\\eb41" });
      Codicon.report = new Codicon("report", { fontCharacter: "\\eb42" });
      Codicon.requestChanges = new Codicon("request-changes", { fontCharacter: "\\eb43" });
      Codicon.rocket = new Codicon("rocket", { fontCharacter: "\\eb44" });
      Codicon.rootFolderOpened = new Codicon("root-folder-opened", { fontCharacter: "\\eb45" });
      Codicon.rootFolder = new Codicon("root-folder", { fontCharacter: "\\eb46" });
      Codicon.rss = new Codicon("rss", { fontCharacter: "\\eb47" });
      Codicon.ruby = new Codicon("ruby", { fontCharacter: "\\eb48" });
      Codicon.saveAll = new Codicon("save-all", { fontCharacter: "\\eb49" });
      Codicon.saveAs = new Codicon("save-as", { fontCharacter: "\\eb4a" });
      Codicon.save = new Codicon("save", { fontCharacter: "\\eb4b" });
      Codicon.screenFull = new Codicon("screen-full", { fontCharacter: "\\eb4c" });
      Codicon.screenNormal = new Codicon("screen-normal", { fontCharacter: "\\eb4d" });
      Codicon.searchStop = new Codicon("search-stop", { fontCharacter: "\\eb4e" });
      Codicon.server = new Codicon("server", { fontCharacter: "\\eb50" });
      Codicon.settingsGear = new Codicon("settings-gear", { fontCharacter: "\\eb51" });
      Codicon.settings = new Codicon("settings", { fontCharacter: "\\eb52" });
      Codicon.shield = new Codicon("shield", { fontCharacter: "\\eb53" });
      Codicon.smiley = new Codicon("smiley", { fontCharacter: "\\eb54" });
      Codicon.sortPrecedence = new Codicon("sort-precedence", { fontCharacter: "\\eb55" });
      Codicon.splitHorizontal = new Codicon("split-horizontal", { fontCharacter: "\\eb56" });
      Codicon.splitVertical = new Codicon("split-vertical", { fontCharacter: "\\eb57" });
      Codicon.squirrel = new Codicon("squirrel", { fontCharacter: "\\eb58" });
      Codicon.starFull = new Codicon("star-full", { fontCharacter: "\\eb59" });
      Codicon.starHalf = new Codicon("star-half", { fontCharacter: "\\eb5a" });
      Codicon.symbolClass = new Codicon("symbol-class", { fontCharacter: "\\eb5b" });
      Codicon.symbolColor = new Codicon("symbol-color", { fontCharacter: "\\eb5c" });
      Codicon.symbolCustomColor = new Codicon("symbol-customcolor", { fontCharacter: "\\eb5c" });
      Codicon.symbolConstant = new Codicon("symbol-constant", { fontCharacter: "\\eb5d" });
      Codicon.symbolEnumMember = new Codicon("symbol-enum-member", { fontCharacter: "\\eb5e" });
      Codicon.symbolField = new Codicon("symbol-field", { fontCharacter: "\\eb5f" });
      Codicon.symbolFile = new Codicon("symbol-file", { fontCharacter: "\\eb60" });
      Codicon.symbolInterface = new Codicon("symbol-interface", { fontCharacter: "\\eb61" });
      Codicon.symbolKeyword = new Codicon("symbol-keyword", { fontCharacter: "\\eb62" });
      Codicon.symbolMisc = new Codicon("symbol-misc", { fontCharacter: "\\eb63" });
      Codicon.symbolOperator = new Codicon("symbol-operator", { fontCharacter: "\\eb64" });
      Codicon.symbolProperty = new Codicon("symbol-property", { fontCharacter: "\\eb65" });
      Codicon.wrench = new Codicon("wrench", { fontCharacter: "\\eb65" });
      Codicon.wrenchSubaction = new Codicon("wrench-subaction", { fontCharacter: "\\eb65" });
      Codicon.symbolSnippet = new Codicon("symbol-snippet", { fontCharacter: "\\eb66" });
      Codicon.tasklist = new Codicon("tasklist", { fontCharacter: "\\eb67" });
      Codicon.telescope = new Codicon("telescope", { fontCharacter: "\\eb68" });
      Codicon.textSize = new Codicon("text-size", { fontCharacter: "\\eb69" });
      Codicon.threeBars = new Codicon("three-bars", { fontCharacter: "\\eb6a" });
      Codicon.thumbsdown = new Codicon("thumbsdown", { fontCharacter: "\\eb6b" });
      Codicon.thumbsup = new Codicon("thumbsup", { fontCharacter: "\\eb6c" });
      Codicon.tools = new Codicon("tools", { fontCharacter: "\\eb6d" });
      Codicon.triangleDown = new Codicon("triangle-down", { fontCharacter: "\\eb6e" });
      Codicon.triangleLeft = new Codicon("triangle-left", { fontCharacter: "\\eb6f" });
      Codicon.triangleRight = new Codicon("triangle-right", { fontCharacter: "\\eb70" });
      Codicon.triangleUp = new Codicon("triangle-up", { fontCharacter: "\\eb71" });
      Codicon.twitter = new Codicon("twitter", { fontCharacter: "\\eb72" });
      Codicon.unfold = new Codicon("unfold", { fontCharacter: "\\eb73" });
      Codicon.unlock = new Codicon("unlock", { fontCharacter: "\\eb74" });
      Codicon.unmute = new Codicon("unmute", { fontCharacter: "\\eb75" });
      Codicon.unverified = new Codicon("unverified", { fontCharacter: "\\eb76" });
      Codicon.verified = new Codicon("verified", { fontCharacter: "\\eb77" });
      Codicon.versions = new Codicon("versions", { fontCharacter: "\\eb78" });
      Codicon.vmActive = new Codicon("vm-active", { fontCharacter: "\\eb79" });
      Codicon.vmOutline = new Codicon("vm-outline", { fontCharacter: "\\eb7a" });
      Codicon.vmRunning = new Codicon("vm-running", { fontCharacter: "\\eb7b" });
      Codicon.watch = new Codicon("watch", { fontCharacter: "\\eb7c" });
      Codicon.whitespace = new Codicon("whitespace", { fontCharacter: "\\eb7d" });
      Codicon.wholeWord = new Codicon("whole-word", { fontCharacter: "\\eb7e" });
      Codicon.window = new Codicon("window", { fontCharacter: "\\eb7f" });
      Codicon.wordWrap = new Codicon("word-wrap", { fontCharacter: "\\eb80" });
      Codicon.zoomIn = new Codicon("zoom-in", { fontCharacter: "\\eb81" });
      Codicon.zoomOut = new Codicon("zoom-out", { fontCharacter: "\\eb82" });
      Codicon.listFilter = new Codicon("list-filter", { fontCharacter: "\\eb83" });
      Codicon.listFlat = new Codicon("list-flat", { fontCharacter: "\\eb84" });
      Codicon.listSelection = new Codicon("list-selection", { fontCharacter: "\\eb85" });
      Codicon.selection = new Codicon("selection", { fontCharacter: "\\eb85" });
      Codicon.listTree = new Codicon("list-tree", { fontCharacter: "\\eb86" });
      Codicon.debugBreakpointFunctionUnverified = new Codicon("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" });
      Codicon.debugBreakpointFunction = new Codicon("debug-breakpoint-function", { fontCharacter: "\\eb88" });
      Codicon.debugBreakpointFunctionDisabled = new Codicon("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" });
      Codicon.debugStackframeActive = new Codicon("debug-stackframe-active", { fontCharacter: "\\eb89" });
      Codicon.debugStackframeDot = new Codicon("debug-stackframe-dot", { fontCharacter: "\\eb8a" });
      Codicon.debugStackframe = new Codicon("debug-stackframe", { fontCharacter: "\\eb8b" });
      Codicon.debugStackframeFocused = new Codicon("debug-stackframe-focused", { fontCharacter: "\\eb8b" });
      Codicon.debugBreakpointUnsupported = new Codicon("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" });
      Codicon.symbolString = new Codicon("symbol-string", { fontCharacter: "\\eb8d" });
      Codicon.debugReverseContinue = new Codicon("debug-reverse-continue", { fontCharacter: "\\eb8e" });
      Codicon.debugStepBack = new Codicon("debug-step-back", { fontCharacter: "\\eb8f" });
      Codicon.debugRestartFrame = new Codicon("debug-restart-frame", { fontCharacter: "\\eb90" });
      Codicon.callIncoming = new Codicon("call-incoming", { fontCharacter: "\\eb92" });
      Codicon.callOutgoing = new Codicon("call-outgoing", { fontCharacter: "\\eb93" });
      Codicon.menu = new Codicon("menu", { fontCharacter: "\\eb94" });
      Codicon.expandAll = new Codicon("expand-all", { fontCharacter: "\\eb95" });
      Codicon.feedback = new Codicon("feedback", { fontCharacter: "\\eb96" });
      Codicon.groupByRefType = new Codicon("group-by-ref-type", { fontCharacter: "\\eb97" });
      Codicon.ungroupByRefType = new Codicon("ungroup-by-ref-type", { fontCharacter: "\\eb98" });
      Codicon.account = new Codicon("account", { fontCharacter: "\\eb99" });
      Codicon.bellDot = new Codicon("bell-dot", { fontCharacter: "\\eb9a" });
      Codicon.debugConsole = new Codicon("debug-console", { fontCharacter: "\\eb9b" });
      Codicon.library = new Codicon("library", { fontCharacter: "\\eb9c" });
      Codicon.output = new Codicon("output", { fontCharacter: "\\eb9d" });
      Codicon.runAll = new Codicon("run-all", { fontCharacter: "\\eb9e" });
      Codicon.syncIgnored = new Codicon("sync-ignored", { fontCharacter: "\\eb9f" });
      Codicon.pinned = new Codicon("pinned", { fontCharacter: "\\eba0" });
      Codicon.githubInverted = new Codicon("github-inverted", { fontCharacter: "\\eba1" });
      Codicon.debugAlt = new Codicon("debug-alt", { fontCharacter: "\\eb91" });
      Codicon.serverProcess = new Codicon("server-process", { fontCharacter: "\\eba2" });
      Codicon.serverEnvironment = new Codicon("server-environment", { fontCharacter: "\\eba3" });
      Codicon.pass = new Codicon("pass", { fontCharacter: "\\eba4" });
      Codicon.stopCircle = new Codicon("stop-circle", { fontCharacter: "\\eba5" });
      Codicon.playCircle = new Codicon("play-circle", { fontCharacter: "\\eba6" });
      Codicon.record = new Codicon("record", { fontCharacter: "\\eba7" });
      Codicon.debugAltSmall = new Codicon("debug-alt-small", { fontCharacter: "\\eba8" });
      Codicon.vmConnect = new Codicon("vm-connect", { fontCharacter: "\\eba9" });
      Codicon.cloud = new Codicon("cloud", { fontCharacter: "\\ebaa" });
      Codicon.merge = new Codicon("merge", { fontCharacter: "\\ebab" });
      Codicon.exportIcon = new Codicon("export", { fontCharacter: "\\ebac" });
      Codicon.graphLeft = new Codicon("graph-left", { fontCharacter: "\\ebad" });
      Codicon.magnet = new Codicon("magnet", { fontCharacter: "\\ebae" });
      Codicon.notebook = new Codicon("notebook", { fontCharacter: "\\ebaf" });
      Codicon.redo = new Codicon("redo", { fontCharacter: "\\ebb0" });
      Codicon.checkAll = new Codicon("check-all", { fontCharacter: "\\ebb1" });
      Codicon.pinnedDirty = new Codicon("pinned-dirty", { fontCharacter: "\\ebb2" });
      Codicon.passFilled = new Codicon("pass-filled", { fontCharacter: "\\ebb3" });
      Codicon.circleLargeFilled = new Codicon("circle-large-filled", { fontCharacter: "\\ebb4" });
      Codicon.circleLargeOutline = new Codicon("circle-large-outline", { fontCharacter: "\\ebb5" });
      Codicon.combine = new Codicon("combine", { fontCharacter: "\\ebb6" });
      Codicon.gather = new Codicon("gather", { fontCharacter: "\\ebb6" });
      Codicon.table = new Codicon("table", { fontCharacter: "\\ebb7" });
      Codicon.variableGroup = new Codicon("variable-group", { fontCharacter: "\\ebb8" });
      Codicon.typeHierarchy = new Codicon("type-hierarchy", { fontCharacter: "\\ebb9" });
      Codicon.typeHierarchySub = new Codicon("type-hierarchy-sub", { fontCharacter: "\\ebba" });
      Codicon.typeHierarchySuper = new Codicon("type-hierarchy-super", { fontCharacter: "\\ebbb" });
      Codicon.gitPullRequestCreate = new Codicon("git-pull-request-create", { fontCharacter: "\\ebbc" });
      Codicon.runAbove = new Codicon("run-above", { fontCharacter: "\\ebbd" });
      Codicon.runBelow = new Codicon("run-below", { fontCharacter: "\\ebbe" });
      Codicon.notebookTemplate = new Codicon("notebook-template", { fontCharacter: "\\ebbf" });
      Codicon.debugRerun = new Codicon("debug-rerun", { fontCharacter: "\\ebc0" });
      Codicon.workspaceTrusted = new Codicon("workspace-trusted", { fontCharacter: "\\ebc1" });
      Codicon.workspaceUntrusted = new Codicon("workspace-untrusted", { fontCharacter: "\\ebc2" });
      Codicon.workspaceUnspecified = new Codicon("workspace-unspecified", { fontCharacter: "\\ebc3" });
      Codicon.terminalCmd = new Codicon("terminal-cmd", { fontCharacter: "\\ebc4" });
      Codicon.terminalDebian = new Codicon("terminal-debian", { fontCharacter: "\\ebc5" });
      Codicon.terminalLinux = new Codicon("terminal-linux", { fontCharacter: "\\ebc6" });
      Codicon.terminalPowershell = new Codicon("terminal-powershell", { fontCharacter: "\\ebc7" });
      Codicon.terminalTmux = new Codicon("terminal-tmux", { fontCharacter: "\\ebc8" });
      Codicon.terminalUbuntu = new Codicon("terminal-ubuntu", { fontCharacter: "\\ebc9" });
      Codicon.terminalBash = new Codicon("terminal-bash", { fontCharacter: "\\ebca" });
      Codicon.arrowSwap = new Codicon("arrow-swap", { fontCharacter: "\\ebcb" });
      Codicon.copy = new Codicon("copy", { fontCharacter: "\\ebcc" });
      Codicon.personAdd = new Codicon("person-add", { fontCharacter: "\\ebcd" });
      Codicon.filterFilled = new Codicon("filter-filled", { fontCharacter: "\\ebce" });
      Codicon.wand = new Codicon("wand", { fontCharacter: "\\ebcf" });
      Codicon.debugLineByLine = new Codicon("debug-line-by-line", { fontCharacter: "\\ebd0" });
      Codicon.inspect = new Codicon("inspect", { fontCharacter: "\\ebd1" });
      Codicon.layers = new Codicon("layers", { fontCharacter: "\\ebd2" });
      Codicon.layersDot = new Codicon("layers-dot", { fontCharacter: "\\ebd3" });
      Codicon.layersActive = new Codicon("layers-active", { fontCharacter: "\\ebd4" });
      Codicon.compass = new Codicon("compass", { fontCharacter: "\\ebd5" });
      Codicon.compassDot = new Codicon("compass-dot", { fontCharacter: "\\ebd6" });
      Codicon.compassActive = new Codicon("compass-active", { fontCharacter: "\\ebd7" });
      Codicon.azure = new Codicon("azure", { fontCharacter: "\\ebd8" });
      Codicon.issueDraft = new Codicon("issue-draft", { fontCharacter: "\\ebd9" });
      Codicon.gitPullRequestClosed = new Codicon("git-pull-request-closed", { fontCharacter: "\\ebda" });
      Codicon.gitPullRequestDraft = new Codicon("git-pull-request-draft", { fontCharacter: "\\ebdb" });
      Codicon.debugAll = new Codicon("debug-all", { fontCharacter: "\\ebdc" });
      Codicon.debugCoverage = new Codicon("debug-coverage", { fontCharacter: "\\ebdd" });
      Codicon.runErrors = new Codicon("run-errors", { fontCharacter: "\\ebde" });
      Codicon.folderLibrary = new Codicon("folder-library", { fontCharacter: "\\ebdf" });
      Codicon.debugContinueSmall = new Codicon("debug-continue-small", { fontCharacter: "\\ebe0" });
      Codicon.beakerStop = new Codicon("beaker-stop", { fontCharacter: "\\ebe1" });
      Codicon.graphLine = new Codicon("graph-line", { fontCharacter: "\\ebe2" });
      Codicon.graphScatter = new Codicon("graph-scatter", { fontCharacter: "\\ebe3" });
      Codicon.pieChart = new Codicon("pie-chart", { fontCharacter: "\\ebe4" });
      Codicon.bracket = new Codicon("bracket", Codicon.json.definition);
      Codicon.bracketDot = new Codicon("bracket-dot", { fontCharacter: "\\ebe5" });
      Codicon.bracketError = new Codicon("bracket-error", { fontCharacter: "\\ebe6" });
      Codicon.lockSmall = new Codicon("lock-small", { fontCharacter: "\\ebe7" });
      Codicon.azureDevops = new Codicon("azure-devops", { fontCharacter: "\\ebe8" });
      Codicon.verifiedFilled = new Codicon("verified-filled", { fontCharacter: "\\ebe9" });
      Codicon.newLine = new Codicon("newline", { fontCharacter: "\\ebea" });
      Codicon.layout = new Codicon("layout", { fontCharacter: "\\ebeb" });
      Codicon.layoutActivitybarLeft = new Codicon("layout-activitybar-left", { fontCharacter: "\\ebec" });
      Codicon.layoutActivitybarRight = new Codicon("layout-activitybar-right", { fontCharacter: "\\ebed" });
      Codicon.layoutPanelLeft = new Codicon("layout-panel-left", { fontCharacter: "\\ebee" });
      Codicon.layoutPanelCenter = new Codicon("layout-panel-center", { fontCharacter: "\\ebef" });
      Codicon.layoutPanelJustify = new Codicon("layout-panel-justify", { fontCharacter: "\\ebf0" });
      Codicon.layoutPanelRight = new Codicon("layout-panel-right", { fontCharacter: "\\ebf1" });
      Codicon.layoutPanel = new Codicon("layout-panel", { fontCharacter: "\\ebf2" });
      Codicon.layoutSidebarLeft = new Codicon("layout-sidebar-left", { fontCharacter: "\\ebf3" });
      Codicon.layoutSidebarRight = new Codicon("layout-sidebar-right", { fontCharacter: "\\ebf4" });
      Codicon.layoutStatusbar = new Codicon("layout-statusbar", { fontCharacter: "\\ebf5" });
      Codicon.layoutMenubar = new Codicon("layout-menubar", { fontCharacter: "\\ebf6" });
      Codicon.layoutCentered = new Codicon("layout-centered", { fontCharacter: "\\ebf7" });
      Codicon.target = new Codicon("target", { fontCharacter: "\\ebf8" });
      Codicon.indent = new Codicon("indent", { fontCharacter: "\\ebf9" });
      Codicon.recordSmall = new Codicon("record-small", { fontCharacter: "\\ebfa" });
      Codicon.errorSmall = new Codicon("error-small", { fontCharacter: "\\ebfb" });
      Codicon.arrowCircleDown = new Codicon("arrow-circle-down", { fontCharacter: "\\ebfc" });
      Codicon.arrowCircleLeft = new Codicon("arrow-circle-left", { fontCharacter: "\\ebfd" });
      Codicon.arrowCircleRight = new Codicon("arrow-circle-right", { fontCharacter: "\\ebfe" });
      Codicon.arrowCircleUp = new Codicon("arrow-circle-up", { fontCharacter: "\\ebff" });
      Codicon.dialogError = new Codicon("dialog-error", Codicon.error.definition);
      Codicon.dialogWarning = new Codicon("dialog-warning", Codicon.warning.definition);
      Codicon.dialogInfo = new Codicon("dialog-info", Codicon.info.definition);
      Codicon.dialogClose = new Codicon("dialog-close", Codicon.close.definition);
      Codicon.treeItemExpanded = new Codicon("tree-item-expanded", Codicon.chevronDown.definition);
      Codicon.treeFilterOnTypeOn = new Codicon("tree-filter-on-type-on", Codicon.listFilter.definition);
      Codicon.treeFilterOnTypeOff = new Codicon("tree-filter-on-type-off", Codicon.listSelection.definition);
      Codicon.treeFilterClear = new Codicon("tree-filter-clear", Codicon.close.definition);
      Codicon.treeItemLoading = new Codicon("tree-item-loading", Codicon.loading.definition);
      Codicon.menuSelection = new Codicon("menu-selection", Codicon.check.definition);
      Codicon.menuSubmenu = new Codicon("menu-submenu", Codicon.chevronRight.definition);
      Codicon.menuBarMore = new Codicon("menubar-more", Codicon.more.definition);
      Codicon.scrollbarButtonLeft = new Codicon("scrollbar-button-left", Codicon.triangleLeft.definition);
      Codicon.scrollbarButtonRight = new Codicon("scrollbar-button-right", Codicon.triangleRight.definition);
      Codicon.scrollbarButtonUp = new Codicon("scrollbar-button-up", Codicon.triangleUp.definition);
      Codicon.scrollbarButtonDown = new Codicon("scrollbar-button-down", Codicon.triangleDown.definition);
      Codicon.toolBarMore = new Codicon("toolbar-more", Codicon.more.definition);
      Codicon.quickInputBack = new Codicon("quick-input-back", Codicon.arrowLeft.definition);
      (function(CSSIcon2) {
        CSSIcon2.iconNameSegment = "[A-Za-z0-9]+";
        CSSIcon2.iconNameExpression = "[A-Za-z0-9-]+";
        CSSIcon2.iconModifierExpression = "~[A-Za-z]+";
        CSSIcon2.iconNameCharacter = "[A-Za-z0-9~-]";
        const cssIconIdRegex = new RegExp(`^(${CSSIcon2.iconNameExpression})(${CSSIcon2.iconModifierExpression})?$`);
        function asClassNameArray(icon) {
          if (icon instanceof Codicon) {
            return ["codicon", "codicon-" + icon.id];
          }
          const match = cssIconIdRegex.exec(icon.id);
          if (!match) {
            return asClassNameArray(Codicon.error);
          }
          let [, id, modifier] = match;
          const classNames = ["codicon", "codicon-" + id];
          if (modifier) {
            classNames.push("codicon-modifier-" + modifier.substr(1));
          }
          return classNames;
        }
        CSSIcon2.asClassNameArray = asClassNameArray;
        function asClassName(icon) {
          return asClassNameArray(icon).join(" ");
        }
        CSSIcon2.asClassName = asClassName;
        function asCSSSelector(icon) {
          return "." + asClassNameArray(icon).join(".");
        }
        CSSIcon2.asCSSSelector = asCSSSelector;
      })(CSSIcon || (CSSIcon = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token, CompletionItemKinds, InlineCompletionTriggerKind, SignatureHelpTriggerKind, DocumentHighlightKind, SymbolKinds, FoldingRangeKind, Command, InlayHintKind, TokenizationRegistry2;
  var init_languages = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js"() {
      init_uri();
      init_range();
      init_tokenizationRegistry();
      init_codicons();
      Token = class {
        constructor(offset, type, language) {
          this._tokenBrand = void 0;
          this.offset = offset;
          this.type = type;
          this.language = language;
        }
        toString() {
          return "(" + this.offset + ", " + this.type + ")";
        }
      };
      (function(CompletionItemKinds2) {
        const byKind = /* @__PURE__ */ new Map();
        byKind.set(0, Codicon.symbolMethod);
        byKind.set(1, Codicon.symbolFunction);
        byKind.set(2, Codicon.symbolConstructor);
        byKind.set(3, Codicon.symbolField);
        byKind.set(4, Codicon.symbolVariable);
        byKind.set(5, Codicon.symbolClass);
        byKind.set(6, Codicon.symbolStruct);
        byKind.set(7, Codicon.symbolInterface);
        byKind.set(8, Codicon.symbolModule);
        byKind.set(9, Codicon.symbolProperty);
        byKind.set(10, Codicon.symbolEvent);
        byKind.set(11, Codicon.symbolOperator);
        byKind.set(12, Codicon.symbolUnit);
        byKind.set(13, Codicon.symbolValue);
        byKind.set(15, Codicon.symbolEnum);
        byKind.set(14, Codicon.symbolConstant);
        byKind.set(15, Codicon.symbolEnum);
        byKind.set(16, Codicon.symbolEnumMember);
        byKind.set(17, Codicon.symbolKeyword);
        byKind.set(27, Codicon.symbolSnippet);
        byKind.set(18, Codicon.symbolText);
        byKind.set(19, Codicon.symbolColor);
        byKind.set(20, Codicon.symbolFile);
        byKind.set(21, Codicon.symbolReference);
        byKind.set(22, Codicon.symbolCustomColor);
        byKind.set(23, Codicon.symbolFolder);
        byKind.set(24, Codicon.symbolTypeParameter);
        byKind.set(25, Codicon.account);
        byKind.set(26, Codicon.issues);
        function toIcon(kind) {
          let codicon = byKind.get(kind);
          if (!codicon) {
            console.info("No codicon found for CompletionItemKind " + kind);
            codicon = Codicon.symbolProperty;
          }
          return codicon;
        }
        CompletionItemKinds2.toIcon = toIcon;
        const data = /* @__PURE__ */ new Map();
        data.set("method", 0);
        data.set("function", 1);
        data.set("constructor", 2);
        data.set("field", 3);
        data.set("variable", 4);
        data.set("class", 5);
        data.set("struct", 6);
        data.set("interface", 7);
        data.set("module", 8);
        data.set("property", 9);
        data.set("event", 10);
        data.set("operator", 11);
        data.set("unit", 12);
        data.set("value", 13);
        data.set("constant", 14);
        data.set("enum", 15);
        data.set("enum-member", 16);
        data.set("enumMember", 16);
        data.set("keyword", 17);
        data.set("snippet", 27);
        data.set("text", 18);
        data.set("color", 19);
        data.set("file", 20);
        data.set("reference", 21);
        data.set("customcolor", 22);
        data.set("folder", 23);
        data.set("type-parameter", 24);
        data.set("typeParameter", 24);
        data.set("account", 25);
        data.set("issue", 26);
        function fromString(value, strict) {
          let res = data.get(value);
          if (typeof res === "undefined" && !strict) {
            res = 9;
          }
          return res;
        }
        CompletionItemKinds2.fromString = fromString;
      })(CompletionItemKinds || (CompletionItemKinds = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
      })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind || (DocumentHighlightKind = {}));
      (function(SymbolKinds2) {
        const byKind = /* @__PURE__ */ new Map();
        byKind.set(0, Codicon.symbolFile);
        byKind.set(1, Codicon.symbolModule);
        byKind.set(2, Codicon.symbolNamespace);
        byKind.set(3, Codicon.symbolPackage);
        byKind.set(4, Codicon.symbolClass);
        byKind.set(5, Codicon.symbolMethod);
        byKind.set(6, Codicon.symbolProperty);
        byKind.set(7, Codicon.symbolField);
        byKind.set(8, Codicon.symbolConstructor);
        byKind.set(9, Codicon.symbolEnum);
        byKind.set(10, Codicon.symbolInterface);
        byKind.set(11, Codicon.symbolFunction);
        byKind.set(12, Codicon.symbolVariable);
        byKind.set(13, Codicon.symbolConstant);
        byKind.set(14, Codicon.symbolString);
        byKind.set(15, Codicon.symbolNumber);
        byKind.set(16, Codicon.symbolBoolean);
        byKind.set(17, Codicon.symbolArray);
        byKind.set(18, Codicon.symbolObject);
        byKind.set(19, Codicon.symbolKey);
        byKind.set(20, Codicon.symbolNull);
        byKind.set(21, Codicon.symbolEnumMember);
        byKind.set(22, Codicon.symbolStruct);
        byKind.set(23, Codicon.symbolEvent);
        byKind.set(24, Codicon.symbolOperator);
        byKind.set(25, Codicon.symbolTypeParameter);
        function toIcon(kind) {
          let icon = byKind.get(kind);
          if (!icon) {
            console.info("No codicon found for SymbolKind " + kind);
            icon = Codicon.symbolProperty;
          }
          return icon;
        }
        SymbolKinds2.toIcon = toIcon;
      })(SymbolKinds || (SymbolKinds = {}));
      FoldingRangeKind = class {
        constructor(value) {
          this.value = value;
        }
      };
      FoldingRangeKind.Comment = new FoldingRangeKind("comment");
      FoldingRangeKind.Imports = new FoldingRangeKind("imports");
      FoldingRangeKind.Region = new FoldingRangeKind("region");
      (function(Command2) {
        function is(obj) {
          if (!obj || typeof obj !== "object") {
            return false;
          }
          return typeof obj.id === "string" && typeof obj.title === "string";
        }
        Command2.is = is;
      })(Command || (Command = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind || (InlayHintKind = {}));
      TokenizationRegistry2 = new TokenizationRegistry();
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport, CompletionItemInsertTextRule, CompletionItemKind, CompletionItemTag, CompletionTriggerKind, ContentWidgetPositionPreference, CursorChangeReason, DefaultEndOfLine, DocumentHighlightKind2, EditorAutoIndentStrategy, EditorOption, EndOfLinePreference, EndOfLineSequence, IndentAction, InjectedTextCursorStops, InlayHintKind2, InlineCompletionTriggerKind2, KeyCode, MarkerSeverity, MarkerTag, MinimapPosition, MouseTargetType, OverlayWidgetPositionPreference, OverviewRulerLane, PositionAffinity, RenderLineNumbersType, RenderMinimap, ScrollType, ScrollbarVisibility, SelectionDirection, SignatureHelpTriggerKind2, SymbolKind, SymbolTag, TextEditorCursorBlinkingStyle, TextEditorCursorStyle, TrackedRangeStickiness, WrappingIndent;
  var init_standaloneEnums = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js"() {
      (function(AccessibilitySupport2) {
        AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
        AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
        AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
      })(AccessibilitySupport || (AccessibilitySupport = {}));
      (function(CompletionItemInsertTextRule2) {
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
      })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
      (function(CompletionItemKind2) {
        CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
        CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
        CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
        CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
        CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
        CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
        CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
        CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
        CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
        CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
        CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
        CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
        CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
        CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
        CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
        CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
        CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
        CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
        CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
        CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
        CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
        CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
        CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
        CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
        CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
        CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
        CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
        CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
      })(CompletionItemKind || (CompletionItemKind = {}));
      (function(CompletionItemTag2) {
        CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
      })(CompletionItemTag || (CompletionItemTag = {}));
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
      })(CompletionTriggerKind || (CompletionTriggerKind = {}));
      (function(ContentWidgetPositionPreference2) {
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
      })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
      (function(CursorChangeReason2) {
        CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
        CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
        CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
        CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
        CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
        CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
        CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
      })(CursorChangeReason || (CursorChangeReason = {}));
      (function(DefaultEndOfLine2) {
        DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
        DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
      })(DefaultEndOfLine || (DefaultEndOfLine = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
      (function(EditorAutoIndentStrategy2) {
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
      })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
      (function(EditorOption2) {
        EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
        EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
        EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
        EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
        EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
        EditorOption2[EditorOption2["autoClosingBrackets"] = 5] = "autoClosingBrackets";
        EditorOption2[EditorOption2["autoClosingDelete"] = 6] = "autoClosingDelete";
        EditorOption2[EditorOption2["autoClosingOvertype"] = 7] = "autoClosingOvertype";
        EditorOption2[EditorOption2["autoClosingQuotes"] = 8] = "autoClosingQuotes";
        EditorOption2[EditorOption2["autoIndent"] = 9] = "autoIndent";
        EditorOption2[EditorOption2["automaticLayout"] = 10] = "automaticLayout";
        EditorOption2[EditorOption2["autoSurround"] = 11] = "autoSurround";
        EditorOption2[EditorOption2["bracketPairColorization"] = 12] = "bracketPairColorization";
        EditorOption2[EditorOption2["guides"] = 13] = "guides";
        EditorOption2[EditorOption2["codeLens"] = 14] = "codeLens";
        EditorOption2[EditorOption2["codeLensFontFamily"] = 15] = "codeLensFontFamily";
        EditorOption2[EditorOption2["codeLensFontSize"] = 16] = "codeLensFontSize";
        EditorOption2[EditorOption2["colorDecorators"] = 17] = "colorDecorators";
        EditorOption2[EditorOption2["columnSelection"] = 18] = "columnSelection";
        EditorOption2[EditorOption2["comments"] = 19] = "comments";
        EditorOption2[EditorOption2["contextmenu"] = 20] = "contextmenu";
        EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 21] = "copyWithSyntaxHighlighting";
        EditorOption2[EditorOption2["cursorBlinking"] = 22] = "cursorBlinking";
        EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 23] = "cursorSmoothCaretAnimation";
        EditorOption2[EditorOption2["cursorStyle"] = 24] = "cursorStyle";
        EditorOption2[EditorOption2["cursorSurroundingLines"] = 25] = "cursorSurroundingLines";
        EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 26] = "cursorSurroundingLinesStyle";
        EditorOption2[EditorOption2["cursorWidth"] = 27] = "cursorWidth";
        EditorOption2[EditorOption2["disableLayerHinting"] = 28] = "disableLayerHinting";
        EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 29] = "disableMonospaceOptimizations";
        EditorOption2[EditorOption2["domReadOnly"] = 30] = "domReadOnly";
        EditorOption2[EditorOption2["dragAndDrop"] = 31] = "dragAndDrop";
        EditorOption2[EditorOption2["emptySelectionClipboard"] = 32] = "emptySelectionClipboard";
        EditorOption2[EditorOption2["extraEditorClassName"] = 33] = "extraEditorClassName";
        EditorOption2[EditorOption2["fastScrollSensitivity"] = 34] = "fastScrollSensitivity";
        EditorOption2[EditorOption2["find"] = 35] = "find";
        EditorOption2[EditorOption2["fixedOverflowWidgets"] = 36] = "fixedOverflowWidgets";
        EditorOption2[EditorOption2["folding"] = 37] = "folding";
        EditorOption2[EditorOption2["foldingStrategy"] = 38] = "foldingStrategy";
        EditorOption2[EditorOption2["foldingHighlight"] = 39] = "foldingHighlight";
        EditorOption2[EditorOption2["foldingImportsByDefault"] = 40] = "foldingImportsByDefault";
        EditorOption2[EditorOption2["foldingMaximumRegions"] = 41] = "foldingMaximumRegions";
        EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 42] = "unfoldOnClickAfterEndOfLine";
        EditorOption2[EditorOption2["fontFamily"] = 43] = "fontFamily";
        EditorOption2[EditorOption2["fontInfo"] = 44] = "fontInfo";
        EditorOption2[EditorOption2["fontLigatures"] = 45] = "fontLigatures";
        EditorOption2[EditorOption2["fontSize"] = 46] = "fontSize";
        EditorOption2[EditorOption2["fontWeight"] = 47] = "fontWeight";
        EditorOption2[EditorOption2["formatOnPaste"] = 48] = "formatOnPaste";
        EditorOption2[EditorOption2["formatOnType"] = 49] = "formatOnType";
        EditorOption2[EditorOption2["glyphMargin"] = 50] = "glyphMargin";
        EditorOption2[EditorOption2["gotoLocation"] = 51] = "gotoLocation";
        EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 52] = "hideCursorInOverviewRuler";
        EditorOption2[EditorOption2["hover"] = 53] = "hover";
        EditorOption2[EditorOption2["inDiffEditor"] = 54] = "inDiffEditor";
        EditorOption2[EditorOption2["inlineSuggest"] = 55] = "inlineSuggest";
        EditorOption2[EditorOption2["letterSpacing"] = 56] = "letterSpacing";
        EditorOption2[EditorOption2["lightbulb"] = 57] = "lightbulb";
        EditorOption2[EditorOption2["lineDecorationsWidth"] = 58] = "lineDecorationsWidth";
        EditorOption2[EditorOption2["lineHeight"] = 59] = "lineHeight";
        EditorOption2[EditorOption2["lineNumbers"] = 60] = "lineNumbers";
        EditorOption2[EditorOption2["lineNumbersMinChars"] = 61] = "lineNumbersMinChars";
        EditorOption2[EditorOption2["linkedEditing"] = 62] = "linkedEditing";
        EditorOption2[EditorOption2["links"] = 63] = "links";
        EditorOption2[EditorOption2["matchBrackets"] = 64] = "matchBrackets";
        EditorOption2[EditorOption2["minimap"] = 65] = "minimap";
        EditorOption2[EditorOption2["mouseStyle"] = 66] = "mouseStyle";
        EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 67] = "mouseWheelScrollSensitivity";
        EditorOption2[EditorOption2["mouseWheelZoom"] = 68] = "mouseWheelZoom";
        EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 69] = "multiCursorMergeOverlapping";
        EditorOption2[EditorOption2["multiCursorModifier"] = 70] = "multiCursorModifier";
        EditorOption2[EditorOption2["multiCursorPaste"] = 71] = "multiCursorPaste";
        EditorOption2[EditorOption2["occurrencesHighlight"] = 72] = "occurrencesHighlight";
        EditorOption2[EditorOption2["overviewRulerBorder"] = 73] = "overviewRulerBorder";
        EditorOption2[EditorOption2["overviewRulerLanes"] = 74] = "overviewRulerLanes";
        EditorOption2[EditorOption2["padding"] = 75] = "padding";
        EditorOption2[EditorOption2["parameterHints"] = 76] = "parameterHints";
        EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 77] = "peekWidgetDefaultFocus";
        EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 78] = "definitionLinkOpensInPeek";
        EditorOption2[EditorOption2["quickSuggestions"] = 79] = "quickSuggestions";
        EditorOption2[EditorOption2["quickSuggestionsDelay"] = 80] = "quickSuggestionsDelay";
        EditorOption2[EditorOption2["readOnly"] = 81] = "readOnly";
        EditorOption2[EditorOption2["renameOnType"] = 82] = "renameOnType";
        EditorOption2[EditorOption2["renderControlCharacters"] = 83] = "renderControlCharacters";
        EditorOption2[EditorOption2["renderFinalNewline"] = 84] = "renderFinalNewline";
        EditorOption2[EditorOption2["renderLineHighlight"] = 85] = "renderLineHighlight";
        EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 86] = "renderLineHighlightOnlyWhenFocus";
        EditorOption2[EditorOption2["renderValidationDecorations"] = 87] = "renderValidationDecorations";
        EditorOption2[EditorOption2["renderWhitespace"] = 88] = "renderWhitespace";
        EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 89] = "revealHorizontalRightPadding";
        EditorOption2[EditorOption2["roundedSelection"] = 90] = "roundedSelection";
        EditorOption2[EditorOption2["rulers"] = 91] = "rulers";
        EditorOption2[EditorOption2["scrollbar"] = 92] = "scrollbar";
        EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 93] = "scrollBeyondLastColumn";
        EditorOption2[EditorOption2["scrollBeyondLastLine"] = 94] = "scrollBeyondLastLine";
        EditorOption2[EditorOption2["scrollPredominantAxis"] = 95] = "scrollPredominantAxis";
        EditorOption2[EditorOption2["selectionClipboard"] = 96] = "selectionClipboard";
        EditorOption2[EditorOption2["selectionHighlight"] = 97] = "selectionHighlight";
        EditorOption2[EditorOption2["selectOnLineNumbers"] = 98] = "selectOnLineNumbers";
        EditorOption2[EditorOption2["showFoldingControls"] = 99] = "showFoldingControls";
        EditorOption2[EditorOption2["showUnused"] = 100] = "showUnused";
        EditorOption2[EditorOption2["snippetSuggestions"] = 101] = "snippetSuggestions";
        EditorOption2[EditorOption2["smartSelect"] = 102] = "smartSelect";
        EditorOption2[EditorOption2["smoothScrolling"] = 103] = "smoothScrolling";
        EditorOption2[EditorOption2["stickyTabStops"] = 104] = "stickyTabStops";
        EditorOption2[EditorOption2["stopRenderingLineAfter"] = 105] = "stopRenderingLineAfter";
        EditorOption2[EditorOption2["suggest"] = 106] = "suggest";
        EditorOption2[EditorOption2["suggestFontSize"] = 107] = "suggestFontSize";
        EditorOption2[EditorOption2["suggestLineHeight"] = 108] = "suggestLineHeight";
        EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 109] = "suggestOnTriggerCharacters";
        EditorOption2[EditorOption2["suggestSelection"] = 110] = "suggestSelection";
        EditorOption2[EditorOption2["tabCompletion"] = 111] = "tabCompletion";
        EditorOption2[EditorOption2["tabIndex"] = 112] = "tabIndex";
        EditorOption2[EditorOption2["unicodeHighlighting"] = 113] = "unicodeHighlighting";
        EditorOption2[EditorOption2["unusualLineTerminators"] = 114] = "unusualLineTerminators";
        EditorOption2[EditorOption2["useShadowDOM"] = 115] = "useShadowDOM";
        EditorOption2[EditorOption2["useTabStops"] = 116] = "useTabStops";
        EditorOption2[EditorOption2["wordSeparators"] = 117] = "wordSeparators";
        EditorOption2[EditorOption2["wordWrap"] = 118] = "wordWrap";
        EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 119] = "wordWrapBreakAfterCharacters";
        EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 120] = "wordWrapBreakBeforeCharacters";
        EditorOption2[EditorOption2["wordWrapColumn"] = 121] = "wordWrapColumn";
        EditorOption2[EditorOption2["wordWrapOverride1"] = 122] = "wordWrapOverride1";
        EditorOption2[EditorOption2["wordWrapOverride2"] = 123] = "wordWrapOverride2";
        EditorOption2[EditorOption2["wrappingIndent"] = 124] = "wrappingIndent";
        EditorOption2[EditorOption2["wrappingStrategy"] = 125] = "wrappingStrategy";
        EditorOption2[EditorOption2["showDeprecated"] = 126] = "showDeprecated";
        EditorOption2[EditorOption2["inlayHints"] = 127] = "inlayHints";
        EditorOption2[EditorOption2["editorClassName"] = 128] = "editorClassName";
        EditorOption2[EditorOption2["pixelRatio"] = 129] = "pixelRatio";
        EditorOption2[EditorOption2["tabFocusMode"] = 130] = "tabFocusMode";
        EditorOption2[EditorOption2["layoutInfo"] = 131] = "layoutInfo";
        EditorOption2[EditorOption2["wrappingInfo"] = 132] = "wrappingInfo";
      })(EditorOption || (EditorOption = {}));
      (function(EndOfLinePreference2) {
        EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
        EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
        EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
      })(EndOfLinePreference || (EndOfLinePreference = {}));
      (function(EndOfLineSequence2) {
        EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
        EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
      })(EndOfLineSequence || (EndOfLineSequence = {}));
      (function(IndentAction2) {
        IndentAction2[IndentAction2["None"] = 0] = "None";
        IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
        IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
        IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
      })(IndentAction || (IndentAction = {}));
      (function(InjectedTextCursorStops3) {
        InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
        InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
      })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind2 || (InlayHintKind2 = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
      })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
      (function(KeyCode2) {
        KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
        KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
        KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
        KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
        KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
        KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
        KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
        KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
        KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
        KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
        KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
        KeyCode2[KeyCode2["Space"] = 10] = "Space";
        KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
        KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
        KeyCode2[KeyCode2["End"] = 13] = "End";
        KeyCode2[KeyCode2["Home"] = 14] = "Home";
        KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
        KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
        KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
        KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
        KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
        KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
        KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
        KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
        KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
        KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
        KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
        KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
        KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
        KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
        KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
        KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
        KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
        KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
        KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
        KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
        KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
        KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
        KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
        KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
        KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
        KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
        KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
        KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
        KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
        KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
        KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
        KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
        KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
        KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
        KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
        KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
        KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
        KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
        KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
        KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
        KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
        KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
        KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
        KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
        KeyCode2[KeyCode2["F1"] = 59] = "F1";
        KeyCode2[KeyCode2["F2"] = 60] = "F2";
        KeyCode2[KeyCode2["F3"] = 61] = "F3";
        KeyCode2[KeyCode2["F4"] = 62] = "F4";
        KeyCode2[KeyCode2["F5"] = 63] = "F5";
        KeyCode2[KeyCode2["F6"] = 64] = "F6";
        KeyCode2[KeyCode2["F7"] = 65] = "F7";
        KeyCode2[KeyCode2["F8"] = 66] = "F8";
        KeyCode2[KeyCode2["F9"] = 67] = "F9";
        KeyCode2[KeyCode2["F10"] = 68] = "F10";
        KeyCode2[KeyCode2["F11"] = 69] = "F11";
        KeyCode2[KeyCode2["F12"] = 70] = "F12";
        KeyCode2[KeyCode2["F13"] = 71] = "F13";
        KeyCode2[KeyCode2["F14"] = 72] = "F14";
        KeyCode2[KeyCode2["F15"] = 73] = "F15";
        KeyCode2[KeyCode2["F16"] = 74] = "F16";
        KeyCode2[KeyCode2["F17"] = 75] = "F17";
        KeyCode2[KeyCode2["F18"] = 76] = "F18";
        KeyCode2[KeyCode2["F19"] = 77] = "F19";
        KeyCode2[KeyCode2["NumLock"] = 78] = "NumLock";
        KeyCode2[KeyCode2["ScrollLock"] = 79] = "ScrollLock";
        KeyCode2[KeyCode2["Semicolon"] = 80] = "Semicolon";
        KeyCode2[KeyCode2["Equal"] = 81] = "Equal";
        KeyCode2[KeyCode2["Comma"] = 82] = "Comma";
        KeyCode2[KeyCode2["Minus"] = 83] = "Minus";
        KeyCode2[KeyCode2["Period"] = 84] = "Period";
        KeyCode2[KeyCode2["Slash"] = 85] = "Slash";
        KeyCode2[KeyCode2["Backquote"] = 86] = "Backquote";
        KeyCode2[KeyCode2["BracketLeft"] = 87] = "BracketLeft";
        KeyCode2[KeyCode2["Backslash"] = 88] = "Backslash";
        KeyCode2[KeyCode2["BracketRight"] = 89] = "BracketRight";
        KeyCode2[KeyCode2["Quote"] = 90] = "Quote";
        KeyCode2[KeyCode2["OEM_8"] = 91] = "OEM_8";
        KeyCode2[KeyCode2["IntlBackslash"] = 92] = "IntlBackslash";
        KeyCode2[KeyCode2["Numpad0"] = 93] = "Numpad0";
        KeyCode2[KeyCode2["Numpad1"] = 94] = "Numpad1";
        KeyCode2[KeyCode2["Numpad2"] = 95] = "Numpad2";
        KeyCode2[KeyCode2["Numpad3"] = 96] = "Numpad3";
        KeyCode2[KeyCode2["Numpad4"] = 97] = "Numpad4";
        KeyCode2[KeyCode2["Numpad5"] = 98] = "Numpad5";
        KeyCode2[KeyCode2["Numpad6"] = 99] = "Numpad6";
        KeyCode2[KeyCode2["Numpad7"] = 100] = "Numpad7";
        KeyCode2[KeyCode2["Numpad8"] = 101] = "Numpad8";
        KeyCode2[KeyCode2["Numpad9"] = 102] = "Numpad9";
        KeyCode2[KeyCode2["NumpadMultiply"] = 103] = "NumpadMultiply";
        KeyCode2[KeyCode2["NumpadAdd"] = 104] = "NumpadAdd";
        KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode2[KeyCode2["NumpadSubtract"] = 106] = "NumpadSubtract";
        KeyCode2[KeyCode2["NumpadDecimal"] = 107] = "NumpadDecimal";
        KeyCode2[KeyCode2["NumpadDivide"] = 108] = "NumpadDivide";
        KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
        KeyCode2[KeyCode2["ABNT_C1"] = 110] = "ABNT_C1";
        KeyCode2[KeyCode2["ABNT_C2"] = 111] = "ABNT_C2";
        KeyCode2[KeyCode2["AudioVolumeMute"] = 112] = "AudioVolumeMute";
        KeyCode2[KeyCode2["AudioVolumeUp"] = 113] = "AudioVolumeUp";
        KeyCode2[KeyCode2["AudioVolumeDown"] = 114] = "AudioVolumeDown";
        KeyCode2[KeyCode2["BrowserSearch"] = 115] = "BrowserSearch";
        KeyCode2[KeyCode2["BrowserHome"] = 116] = "BrowserHome";
        KeyCode2[KeyCode2["BrowserBack"] = 117] = "BrowserBack";
        KeyCode2[KeyCode2["BrowserForward"] = 118] = "BrowserForward";
        KeyCode2[KeyCode2["MediaTrackNext"] = 119] = "MediaTrackNext";
        KeyCode2[KeyCode2["MediaTrackPrevious"] = 120] = "MediaTrackPrevious";
        KeyCode2[KeyCode2["MediaStop"] = 121] = "MediaStop";
        KeyCode2[KeyCode2["MediaPlayPause"] = 122] = "MediaPlayPause";
        KeyCode2[KeyCode2["LaunchMediaPlayer"] = 123] = "LaunchMediaPlayer";
        KeyCode2[KeyCode2["LaunchMail"] = 124] = "LaunchMail";
        KeyCode2[KeyCode2["LaunchApp2"] = 125] = "LaunchApp2";
        KeyCode2[KeyCode2["Clear"] = 126] = "Clear";
        KeyCode2[KeyCode2["MAX_VALUE"] = 127] = "MAX_VALUE";
      })(KeyCode || (KeyCode = {}));
      (function(MarkerSeverity2) {
        MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
        MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
        MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
        MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
      })(MarkerSeverity || (MarkerSeverity = {}));
      (function(MarkerTag2) {
        MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
        MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
      })(MarkerTag || (MarkerTag = {}));
      (function(MinimapPosition3) {
        MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
        MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
      })(MinimapPosition || (MinimapPosition = {}));
      (function(MouseTargetType2) {
        MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
        MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
        MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
        MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
        MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
        MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
        MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
        MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
        MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
        MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
        MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
        MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
        MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
        MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
      })(MouseTargetType || (MouseTargetType = {}));
      (function(OverlayWidgetPositionPreference2) {
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
      })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane || (OverviewRulerLane = {}));
      (function(PositionAffinity2) {
        PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
        PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
        PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
      })(PositionAffinity || (PositionAffinity = {}));
      (function(RenderLineNumbersType2) {
        RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
        RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
        RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
        RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
        RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
      })(RenderLineNumbersType || (RenderLineNumbersType = {}));
      (function(RenderMinimap2) {
        RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
        RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
        RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
      })(RenderMinimap || (RenderMinimap = {}));
      (function(ScrollType2) {
        ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
        ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
      })(ScrollType || (ScrollType = {}));
      (function(ScrollbarVisibility2) {
        ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
        ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
      })(ScrollbarVisibility || (ScrollbarVisibility = {}));
      (function(SelectionDirection2) {
        SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
        SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
      })(SelectionDirection || (SelectionDirection = {}));
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
      (function(SymbolKind2) {
        SymbolKind2[SymbolKind2["File"] = 0] = "File";
        SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
        SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
        SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
        SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
        SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
        SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
        SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
        SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
        SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
        SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
        SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
        SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
        SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
        SymbolKind2[SymbolKind2["String"] = 14] = "String";
        SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
        SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
        SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
        SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
        SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
        SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
        SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
        SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
        SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
        SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
        SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
      })(SymbolKind || (SymbolKind = {}));
      (function(SymbolTag2) {
        SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
      })(SymbolTag || (SymbolTag = {}));
      (function(TextEditorCursorBlinkingStyle2) {
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
      })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
      (function(TextEditorCursorStyle2) {
        TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
        TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
        TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
        TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
        TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
        TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
      })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
      (function(TrackedRangeStickiness2) {
        TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
      })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
      (function(WrappingIndent2) {
        WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
        WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
        WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
        WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
      })(WrappingIndent || (WrappingIndent = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      languages: void 0,
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }
  var KeyMod;
  var init_editorBaseApi = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"() {
      init_cancellation();
      init_event();
      init_keyCodes();
      init_uri();
      init_position();
      init_range();
      init_selection();
      init_languages();
      init_standaloneEnums();
      KeyMod = class {
        static chord(firstPart, secondPart) {
          return KeyChord(firstPart, secondPart);
        }
      };
      KeyMod.CtrlCmd = 2048;
      KeyMod.Shift = 1024;
      KeyMod.Alt = 512;
      KeyMod.WinCtrl = 256;
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  function once2(computeFn) {
    const cache = {};
    return (input) => {
      if (!cache.hasOwnProperty(input)) {
        cache[input] = computeFn(input);
      }
      return cache[input];
    };
  }
  var WordCharacterClassifier, getMapForWordSeparators;
  var init_wordCharacterClassifier = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"() {
      init_characterClassifier();
      WordCharacterClassifier = class extends CharacterClassifier {
        constructor(wordSeparators) {
          super(0);
          for (let i = 0, len = wordSeparators.length; i < len; i++) {
            this.set(wordSeparators.charCodeAt(i), 2);
          }
          this.set(32, 1);
          this.set(9, 1);
        }
      };
      getMapForWordSeparators = once2((input) => new WordCharacterClassifier(input));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js
  var init_objects = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js"() {
      init_types();
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2, MinimapPosition2, InjectedTextCursorStops2;
  var init_model = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js"() {
      init_objects();
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
      (function(MinimapPosition3) {
        MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
        MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
      })(MinimapPosition2 || (MinimapPosition2 = {}));
      (function(InjectedTextCursorStops3) {
        InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
        InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
      })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
  }
  var Searcher;
  var init_textModelSearch = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"() {
      init_strings();
      init_wordCharacterClassifier();
      init_position();
      init_range();
      init_model();
      Searcher = class {
        constructor(wordSeparators, searchRegex) {
          this._wordSeparators = wordSeparators;
          this._searchRegex = searchRegex;
          this._prevMatchStartIndex = -1;
          this._prevMatchLength = 0;
        }
        reset(lastIndex) {
          this._searchRegex.lastIndex = lastIndex;
          this._prevMatchStartIndex = -1;
          this._prevMatchLength = 0;
        }
        next(text) {
          const textLength = text.length;
          let m;
          do {
            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
              return null;
            }
            m = this._searchRegex.exec(text);
            if (!m) {
              return null;
            }
            const matchStartIndex = m.index;
            const matchLength = m[0].length;
            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
              if (matchLength === 0) {
                if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
                  this._searchRegex.lastIndex += 2;
                } else {
                  this._searchRegex.lastIndex += 1;
                }
                continue;
              }
              return null;
            }
            this._prevMatchStartIndex = matchStartIndex;
            this._prevMatchLength = matchLength;
            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
              return m;
            }
          } while (m);
          return null;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }
  var UnicodeTextModelHighlighter, CodePointHighlighter;
  var init_unicodeTextModelHighlighter = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"() {
      init_range();
      init_textModelSearch();
      init_strings();
      init_types();
      init_wordHelper();
      UnicodeTextModelHighlighter = class {
        static computeUnicodeHighlights(model, options, range) {
          const startLine = range ? range.startLineNumber : 1;
          const endLine = range ? range.endLineNumber : model.getLineCount();
          const codePointHighlighter = new CodePointHighlighter(options);
          const candidates = codePointHighlighter.getCandidateCodePoints();
          let regex;
          if (candidates === "allNonBasicAscii") {
            regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
          } else {
            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
          }
          const searcher = new Searcher(null, regex);
          const ranges = [];
          let hasMore = false;
          let m;
          let ambiguousCharacterCount = 0;
          let invisibleCharacterCount = 0;
          let nonBasicAsciiCharacterCount = 0;
          forLoop:
            for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
              const lineContent = model.getLineContent(lineNumber);
              const lineLength = lineContent.length;
              searcher.reset(0);
              do {
                m = searcher.next(lineContent);
                if (m) {
                  let startIndex = m.index;
                  let endIndex = m.index + m[0].length;
                  if (startIndex > 0) {
                    const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                    if (isHighSurrogate(charCodeBefore)) {
                      startIndex--;
                    }
                  }
                  if (endIndex + 1 < lineLength) {
                    const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                    if (isHighSurrogate(charCodeBefore)) {
                      endIndex++;
                    }
                  }
                  const str = lineContent.substring(startIndex, endIndex);
                  const word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
                  const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
                  if (highlightReason !== 0) {
                    if (highlightReason === 3) {
                      ambiguousCharacterCount++;
                    } else if (highlightReason === 2) {
                      invisibleCharacterCount++;
                    } else if (highlightReason === 1) {
                      nonBasicAsciiCharacterCount++;
                    } else {
                      assertNever(highlightReason);
                    }
                    const MAX_RESULT_LENGTH = 1e3;
                    if (ranges.length >= MAX_RESULT_LENGTH) {
                      hasMore = true;
                      break forLoop;
                    }
                    ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
                  }
                }
              } while (m);
            }
          return {
            ranges,
            hasMore,
            ambiguousCharacterCount,
            invisibleCharacterCount,
            nonBasicAsciiCharacterCount
          };
        }
        static computeUnicodeHighlightReason(char, options) {
          const codePointHighlighter = new CodePointHighlighter(options);
          const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
          switch (reason) {
            case 0:
              return null;
            case 2:
              return { kind: 1 };
            case 3: {
              const codePoint = char.codePointAt(0);
              const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
              const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
              return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
            }
            case 1:
              return { kind: 2 };
          }
        }
      };
      CodePointHighlighter = class {
        constructor(options) {
          this.options = options;
          this.allowedCodePoints = new Set(options.allowedCodePoints);
          this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
        }
        getCandidateCodePoints() {
          if (this.options.nonBasicASCII) {
            return "allNonBasicAscii";
          }
          const set = /* @__PURE__ */ new Set();
          if (this.options.invisibleCharacters) {
            for (const cp of InvisibleCharacters.codePoints) {
              if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
                set.add(cp);
              }
            }
          }
          if (this.options.ambiguousCharacters) {
            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
              set.add(cp);
            }
          }
          for (const cp of this.allowedCodePoints) {
            set.delete(cp);
          }
          return set;
        }
        shouldHighlightNonBasicASCII(character, wordContext) {
          const codePoint = character.codePointAt(0);
          if (this.allowedCodePoints.has(codePoint)) {
            return 0;
          }
          if (this.options.nonBasicASCII) {
            return 1;
          }
          let hasBasicASCIICharacters = false;
          let hasNonConfusableNonBasicAsciiCharacter = false;
          if (wordContext) {
            for (let char of wordContext) {
              const codePoint2 = char.codePointAt(0);
              const isBasicASCII2 = isBasicASCII(char);
              hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
              if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
                hasNonConfusableNonBasicAsciiCharacter = true;
              }
            }
          }
          if (!hasBasicASCIICharacters && hasNonConfusableNonBasicAsciiCharacter) {
            return 0;
          }
          if (this.options.invisibleCharacters) {
            if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
              return 2;
            }
          }
          if (this.options.ambiguousCharacters) {
            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
              return 3;
            }
          }
          return 0;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var __awaiter2, MirrorModel, EditorSimpleWorker;
  var init_editorSimpleWorker = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"() {
      init_diff();
      init_platform();
      init_uri();
      init_position();
      init_range();
      init_diffComputer();
      init_mirrorTextModel();
      init_wordHelper();
      init_linkComputer();
      init_inplaceReplaceSupport();
      init_editorBaseApi();
      init_types();
      init_stopwatch();
      init_unicodeTextModelHighlighter();
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      MirrorModel = class extends MirrorTextModel {
        get uri() {
          return this._uri;
        }
        get eol() {
          return this._eol;
        }
        getValue() {
          return this.getText();
        }
        getLinesContent() {
          return this._lines.slice(0);
        }
        getLineCount() {
          return this._lines.length;
        }
        getLineContent(lineNumber) {
          return this._lines[lineNumber - 1];
        }
        getWordAtPosition(position, wordDefinition) {
          const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
          if (wordAtText) {
            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
          }
          return null;
        }
        words(wordDefinition) {
          const lines = this._lines;
          const wordenize = this._wordenize.bind(this);
          let lineNumber = 0;
          let lineText = "";
          let wordRangesIdx = 0;
          let wordRanges = [];
          return {
            *[Symbol.iterator]() {
              while (true) {
                if (wordRangesIdx < wordRanges.length) {
                  const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                  wordRangesIdx += 1;
                  yield value;
                } else {
                  if (lineNumber < lines.length) {
                    lineText = lines[lineNumber];
                    wordRanges = wordenize(lineText, wordDefinition);
                    wordRangesIdx = 0;
                    lineNumber += 1;
                  } else {
                    break;
                  }
                }
              }
            }
          };
        }
        getLineWords(lineNumber, wordDefinition) {
          const content = this._lines[lineNumber - 1];
          const ranges = this._wordenize(content, wordDefinition);
          const words = [];
          for (const range of ranges) {
            words.push({
              word: content.substring(range.start, range.end),
              startColumn: range.start + 1,
              endColumn: range.end + 1
            });
          }
          return words;
        }
        _wordenize(content, wordDefinition) {
          const result = [];
          let match;
          wordDefinition.lastIndex = 0;
          while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
              break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
          }
          return result;
        }
        getValueInRange(range) {
          range = this._validateRange(range);
          if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
          }
          const lineEnding = this._eol;
          const startLineIndex = range.startLineNumber - 1;
          const endLineIndex = range.endLineNumber - 1;
          const resultLines = [];
          resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
          for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
          }
          resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
          return resultLines.join(lineEnding);
        }
        offsetAt(position) {
          position = this._validatePosition(position);
          this._ensureLineStarts();
          return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
        }
        positionAt(offset) {
          offset = Math.floor(offset);
          offset = Math.max(0, offset);
          this._ensureLineStarts();
          const out = this._lineStarts.getIndexOf(offset);
          const lineLength = this._lines[out.index].length;
          return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
          };
        }
        _validateRange(range) {
          const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
          const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
          if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
            return {
              startLineNumber: start.lineNumber,
              startColumn: start.column,
              endLineNumber: end.lineNumber,
              endColumn: end.column
            };
          }
          return range;
        }
        _validatePosition(position) {
          if (!Position.isIPosition(position)) {
            throw new Error("bad position");
          }
          let { lineNumber, column } = position;
          let hasChanged = false;
          if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
          } else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
          } else {
            const maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
              column = 1;
              hasChanged = true;
            } else if (column > maxCharacter) {
              column = maxCharacter;
              hasChanged = true;
            }
          }
          if (!hasChanged) {
            return position;
          } else {
            return { lineNumber, column };
          }
        }
      };
      EditorSimpleWorker = class {
        constructor(host, foreignModuleFactory) {
          this._host = host;
          this._models = /* @__PURE__ */ Object.create(null);
          this._foreignModuleFactory = foreignModuleFactory;
          this._foreignModule = null;
        }
        dispose() {
          this._models = /* @__PURE__ */ Object.create(null);
        }
        _getModel(uri) {
          return this._models[uri];
        }
        _getModels() {
          const all = [];
          Object.keys(this._models).forEach((key) => all.push(this._models[key]));
          return all;
        }
        acceptNewModel(data) {
          this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
        }
        acceptModelChanged(strURL, e) {
          if (!this._models[strURL]) {
            return;
          }
          const model = this._models[strURL];
          model.onEvents(e);
        }
        acceptRemovedModel(strURL) {
          if (!this._models[strURL]) {
            return;
          }
          delete this._models[strURL];
        }
        computeUnicodeHighlights(url, options, range) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(url);
            if (!model) {
              return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
            }
            return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
          });
        }
        computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
          return __awaiter2(this, void 0, void 0, function* () {
            const original = this._getModel(originalUrl);
            const modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
              return null;
            }
            const originalLines = original.getLinesContent();
            const modifiedLines = modified.getLinesContent();
            const diffComputer = new DiffComputer(originalLines, modifiedLines, {
              shouldComputeCharChanges: true,
              shouldPostProcessCharChanges: true,
              shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
              shouldMakePrettyDiff: true,
              maxComputationTime
            });
            const diffResult = diffComputer.computeDiff();
            const identical = diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified);
            return {
              quitEarly: diffResult.quitEarly,
              identical,
              changes: diffResult.changes
            };
          });
        }
        _modelsAreIdentical(original, modified) {
          const originalLineCount = original.getLineCount();
          const modifiedLineCount = modified.getLineCount();
          if (originalLineCount !== modifiedLineCount) {
            return false;
          }
          for (let line = 1; line <= originalLineCount; line++) {
            const originalLine = original.getLineContent(line);
            const modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
              return false;
            }
          }
          return true;
        }
        computeMoreMinimalEdits(modelUrl, edits) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return edits;
            }
            const result = [];
            let lastEol = void 0;
            edits = edits.slice(0).sort((a, b) => {
              if (a.range && b.range) {
                return Range.compareRangesUsingStarts(a.range, b.range);
              }
              const aRng = a.range ? 0 : 1;
              const bRng = b.range ? 0 : 1;
              return aRng - bRng;
            });
            for (let { range, text, eol } of edits) {
              if (typeof eol === "number") {
                lastEol = eol;
              }
              if (Range.isEmpty(range) && !text) {
                continue;
              }
              const original = model.getValueInRange(range);
              text = text.replace(/\r\n|\n|\r/g, model.eol);
              if (original === text) {
                continue;
              }
              if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                result.push({ range, text });
                continue;
              }
              const changes = stringDiff(original, text, false);
              const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
              for (const change of changes) {
                const start = model.positionAt(editOffset + change.originalStart);
                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                const newEdit = {
                  text: text.substr(change.modifiedStart, change.modifiedLength),
                  range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                };
                if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                  result.push(newEdit);
                }
              }
            }
            if (typeof lastEol === "number") {
              result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
            }
            return result;
          });
        }
        computeLinks(modelUrl) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return null;
            }
            return computeLinks(model);
          });
        }
        textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const sw = new StopWatch(true);
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const seen = /* @__PURE__ */ new Set();
            outer:
              for (let url of modelUrls) {
                const model = this._getModel(url);
                if (!model) {
                  continue;
                }
                for (let word of model.words(wordDefRegExp)) {
                  if (word === leadingWord || !isNaN(Number(word))) {
                    continue;
                  }
                  seen.add(word);
                  if (seen.size > EditorSimpleWorker._suggestionsLimit) {
                    break outer;
                  }
                }
              }
            return { words: Array.from(seen), duration: sw.elapsed() };
          });
        }
        computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return /* @__PURE__ */ Object.create(null);
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const result = /* @__PURE__ */ Object.create(null);
            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
              const words = model.getLineWords(line, wordDefRegExp);
              for (const word of words) {
                if (!isNaN(Number(word.word))) {
                  continue;
                }
                let array = result[word.word];
                if (!array) {
                  array = [];
                  result[word.word] = array;
                }
                array.push({
                  startLineNumber: line,
                  startColumn: word.startColumn,
                  endLineNumber: line,
                  endColumn: word.endColumn
                });
              }
            }
            return result;
          });
        }
        navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return null;
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
              range = {
                startLineNumber: range.startLineNumber,
                startColumn: range.startColumn,
                endLineNumber: range.endLineNumber,
                endColumn: range.endColumn + 1
              };
            }
            const selectionText = model.getValueInRange(range);
            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            if (!wordRange) {
              return null;
            }
            const word = model.getValueInRange(wordRange);
            const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return result;
          });
        }
        loadForeignModule(moduleId, createData, foreignHostMethods) {
          const proxyMethodRequest = (method, args) => {
            return this._host.fhr(method, args);
          };
          const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
          const ctx = {
            host: foreignHost,
            getMirrorModels: () => {
              return this._getModels();
            }
          };
          if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            return Promise.resolve(getAllMethodNames(this._foreignModule));
          }
          return Promise.reject(new Error(`Unexpected usage`));
        }
        fmr(method, args) {
          if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
            return Promise.reject(new Error("Missing requestHandler or method: " + method));
          }
          try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
      EditorSimpleWorker._diffLimit = 1e5;
      EditorSimpleWorker._suggestionsLimit = 1e4;
      if (typeof importScripts === "function") {
        globals.monaco = createMonacoBaseAPI();
      }
    }
  });

  // ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var editor_worker_exports = {};
  __export(editor_worker_exports, {
    initialize: () => initialize
  });
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      self.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    self.onmessage = (e) => {
      simpleWorker.onmessage(e.data);
    };
  }
  var initialized;
  var init_editor_worker = __esm({
    "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js"() {
      init_simpleWorker();
      init_editorSimpleWorker();
      initialized = false;
      self.onmessage = (e) => {
        if (!initialized) {
          initialize(null);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/version.js
  var require_version = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.versionInfo = exports.version = void 0;
      var version = "16.6.0";
      exports.version = version;
      var versionInfo = Object.freeze({
        major: 16,
        minor: 6,
        patch: 0,
        preReleaseTag: null
      });
      exports.versionInfo = versionInfo;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.devAssert = devAssert;
      function devAssert(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isPromise.js
  var require_isPromise = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isPromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPromise = isPromise;
      function isPromise(value) {
        return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isObjectLike = isObjectLike;
      function isObjectLike(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.js
  var require_invariant = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invariant = invariant;
      function invariant(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(
            message != null ? message : "Unexpected invariant triggered."
          );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getLocation = getLocation;
      var _invariant = require_invariant();
      var LineRegExp = /\r\n|[\n\r]/g;
      function getLocation(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match of source.body.matchAll(LineRegExp)) {
          typeof match.index === "number" || (0, _invariant.invariant)(false);
          if (match.index >= position) {
            break;
          }
          lastLineStart = match.index + match[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printLocation = printLocation;
      exports.printSourceLocation = printSourceLocation;
      var _location = require_location();
      function printLocation(location) {
        return printSourceLocation(
          location.source,
          (0, _location.getLocation)(location.source, location.start)
        );
      }
      function printSourceLocation(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i = 0; i < locationLine.length; i += 80) {
            subLines.push(locationLine.slice(i, i + 80));
          }
          return locationStr + printPrefixedLines([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines([
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLError = void 0;
      exports.formatError = formatError;
      exports.printError = printError;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError = class extends Error {
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path !== null && path !== void 0 ? path : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty(
            Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
          );
          const nodeLocations = undefinedIfEmpty(
            (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
          );
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
            (loc) => (0, _location.getLocation)(loc.source, loc.start)
          );
          const originalExtensions = (0, _isObjectLike.isObjectLike)(
            originalError === null || originalError === void 0 ? void 0 : originalError.extensions
          ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, GraphQLError);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports.GraphQLError = GraphQLError;
      function undefinedIfEmpty(array) {
        return array === void 0 || array.length === 0 ? void 0 : array;
      }
      function printError(error) {
        return error.toString();
      }
      function formatError(error) {
        return error.toJSON();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.js
  var require_syntaxError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.syntaxError = syntaxError;
      var _GraphQLError = require_GraphQLError();
      function syntaxError(source, position, description) {
        return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
          source,
          positions: [position]
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.js
  var require_ast = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
      exports.isNode = isNode;
      var Location = class {
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports.Location = Location;
      var Token2 = class {
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports.Token = Token2;
      var QueryDocumentKeys = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports.QueryDocumentKeys = QueryDocumentKeys;
      var kindValues = new Set(Object.keys(QueryDocumentKeys));
      function isNode(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues.has(maybeKind);
      }
      var OperationTypeNode;
      exports.OperationTypeNode = OperationTypeNode;
      (function(OperationTypeNode2) {
        OperationTypeNode2["QUERY"] = "query";
        OperationTypeNode2["MUTATION"] = "mutation";
        OperationTypeNode2["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DirectiveLocation = void 0;
      var DirectiveLocation;
      exports.DirectiveLocation = DirectiveLocation;
      (function(DirectiveLocation2) {
        DirectiveLocation2["QUERY"] = "QUERY";
        DirectiveLocation2["MUTATION"] = "MUTATION";
        DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation2["FIELD"] = "FIELD";
        DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation2["SCHEMA"] = "SCHEMA";
        DirectiveLocation2["SCALAR"] = "SCALAR";
        DirectiveLocation2["OBJECT"] = "OBJECT";
        DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation2["INTERFACE"] = "INTERFACE";
        DirectiveLocation2["UNION"] = "UNION";
        DirectiveLocation2["ENUM"] = "ENUM";
        DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Kind = void 0;
      var Kind;
      exports.Kind = Kind;
      (function(Kind2) {
        Kind2["NAME"] = "Name";
        Kind2["DOCUMENT"] = "Document";
        Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind2["SELECTION_SET"] = "SelectionSet";
        Kind2["FIELD"] = "Field";
        Kind2["ARGUMENT"] = "Argument";
        Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind2["INLINE_FRAGMENT"] = "InlineFragment";
        Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind2["VARIABLE"] = "Variable";
        Kind2["INT"] = "IntValue";
        Kind2["FLOAT"] = "FloatValue";
        Kind2["STRING"] = "StringValue";
        Kind2["BOOLEAN"] = "BooleanValue";
        Kind2["NULL"] = "NullValue";
        Kind2["ENUM"] = "EnumValue";
        Kind2["LIST"] = "ListValue";
        Kind2["OBJECT"] = "ObjectValue";
        Kind2["OBJECT_FIELD"] = "ObjectField";
        Kind2["DIRECTIVE"] = "Directive";
        Kind2["NAMED_TYPE"] = "NamedType";
        Kind2["LIST_TYPE"] = "ListType";
        Kind2["NON_NULL_TYPE"] = "NonNullType";
        Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind2["FIELD_DEFINITION"] = "FieldDefinition";
        Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind || (exports.Kind = Kind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDigit = isDigit;
      exports.isLetter = isLetter;
      exports.isNameContinue = isNameContinue;
      exports.isNameStart = isNameStart;
      exports.isWhiteSpace = isWhiteSpace;
      function isWhiteSpace(code) {
        return code === 9 || code === 32;
      }
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter(code) {
        return code >= 97 && code <= 122 || code >= 65 && code <= 90;
      }
      function isNameStart(code) {
        return isLetter(code) || code === 95;
      }
      function isNameContinue(code) {
        return isLetter(code) || isDigit(code) || code === 95;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dedentBlockStringLines = dedentBlockStringLines;
      exports.isPrintableAsBlockString = isPrintableAsBlockString;
      exports.printBlockString = printBlockString;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i = 0; i < lines.length; ++i) {
          var _firstNonEmptyLine;
          const line = lines[i];
          const indent = leadingWhitespace(line);
          if (indent === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
          lastNonEmptyLine = i;
          if (i !== 0 && indent < commonIndent) {
            commonIndent = indent;
          }
        }
        return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
          (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
          lastNonEmptyLine + 1
        );
      }
      function leadingWhitespace(str) {
        let i = 0;
        while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
          ++i;
        }
        return i;
      }
      function isPrintableAsBlockString(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i = 0; i < value.length; ++i) {
          switch (value.codePointAt(i)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            case 13:
              return false;
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
          (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
        );
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.js
  var require_tokenKind = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TokenKind = void 0;
      var TokenKind;
      exports.TokenKind = TokenKind;
      (function(TokenKind2) {
        TokenKind2["SOF"] = "<SOF>";
        TokenKind2["EOF"] = "<EOF>";
        TokenKind2["BANG"] = "!";
        TokenKind2["DOLLAR"] = "$";
        TokenKind2["AMP"] = "&";
        TokenKind2["PAREN_L"] = "(";
        TokenKind2["PAREN_R"] = ")";
        TokenKind2["SPREAD"] = "...";
        TokenKind2["COLON"] = ":";
        TokenKind2["EQUALS"] = "=";
        TokenKind2["AT"] = "@";
        TokenKind2["BRACKET_L"] = "[";
        TokenKind2["BRACKET_R"] = "]";
        TokenKind2["BRACE_L"] = "{";
        TokenKind2["PIPE"] = "|";
        TokenKind2["BRACE_R"] = "}";
        TokenKind2["NAME"] = "Name";
        TokenKind2["INT"] = "Int";
        TokenKind2["FLOAT"] = "Float";
        TokenKind2["STRING"] = "String";
        TokenKind2["BLOCK_STRING"] = "BlockString";
        TokenKind2["COMMENT"] = "Comment";
      })(TokenKind || (exports.TokenKind = TokenKind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.js
  var require_lexer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Lexer = void 0;
      exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _blockString = require_blockString();
      var _characterClasses = require_characterClasses();
      var _tokenKind = require_tokenKind();
      var Lexer = class {
        constructor(source) {
          const startOfFileToken = new _ast.Token(
            _tokenKind.TokenKind.SOF,
            0,
            0,
            0,
            0
          );
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        advance() {
          this.lastToken = this.token;
          const token = this.token = this.lookahead();
          return token;
        }
        lookahead() {
          let token = this.token;
          if (token.kind !== _tokenKind.TokenKind.EOF) {
            do {
              if (token.next) {
                token = token.next;
              } else {
                const nextToken = readNextToken(this, token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
              }
            } while (token.kind === _tokenKind.TokenKind.COMMENT);
          }
          return token;
        }
      };
      exports.Lexer = Lexer;
      function isPunctuatorTokenKind(kind) {
        return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
      }
      function isUnicodeScalarValue(code) {
        return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
      }
      function isSupplementaryCodePoint(body, location) {
        return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
      }
      function isLeadingSurrogate(code) {
        return code >= 55296 && code <= 56319;
      }
      function isTrailingSurrogate(code) {
        return code >= 56320 && code <= 57343;
      }
      function printCodePointAt(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === void 0) {
          return _tokenKind.TokenKind.EOF;
        } else if (code >= 32 && code <= 126) {
          const char = String.fromCodePoint(code);
          return char === '"' ? `'"'` : `"${char}"`;
        }
        return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
      }
      function createToken(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new _ast.Token(kind, start, end, line, col, value);
      }
      function readNextToken(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          switch (code) {
            case 65279:
            case 9:
            case 32:
            case 44:
              ++position;
              continue;
            case 10:
              ++position;
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 13:
              if (body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 35:
              return readComment(lexer, position);
            case 33:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BANG,
                position,
                position + 1
              );
            case 36:
              return createToken(
                lexer,
                _tokenKind.TokenKind.DOLLAR,
                position,
                position + 1
              );
            case 38:
              return createToken(
                lexer,
                _tokenKind.TokenKind.AMP,
                position,
                position + 1
              );
            case 40:
              return createToken(
                lexer,
                _tokenKind.TokenKind.PAREN_L,
                position,
                position + 1
              );
            case 41:
              return createToken(
                lexer,
                _tokenKind.TokenKind.PAREN_R,
                position,
                position + 1
              );
            case 46:
              if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                return createToken(
                  lexer,
                  _tokenKind.TokenKind.SPREAD,
                  position,
                  position + 3
                );
              }
              break;
            case 58:
              return createToken(
                lexer,
                _tokenKind.TokenKind.COLON,
                position,
                position + 1
              );
            case 61:
              return createToken(
                lexer,
                _tokenKind.TokenKind.EQUALS,
                position,
                position + 1
              );
            case 64:
              return createToken(
                lexer,
                _tokenKind.TokenKind.AT,
                position,
                position + 1
              );
            case 91:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACKET_L,
                position,
                position + 1
              );
            case 93:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACKET_R,
                position,
                position + 1
              );
            case 123:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACE_L,
                position,
                position + 1
              );
            case 124:
              return createToken(
                lexer,
                _tokenKind.TokenKind.PIPE,
                position,
                position + 1
              );
            case 125:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACE_R,
                position,
                position + 1
              );
            case 34:
              if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                return readBlockString(lexer, position);
              }
              return readString(lexer, position);
          }
          if ((0, _characterClasses.isDigit)(code) || code === 45) {
            return readNumber(lexer, position, code);
          }
          if ((0, _characterClasses.isNameStart)(code)) {
            return readName(lexer, position);
          }
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
          );
        }
        return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
      }
      function readComment(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            break;
          }
        }
        return createToken(
          lexer,
          _tokenKind.TokenKind.COMMENT,
          start,
          position,
          body.slice(start + 1, position)
        );
      }
      function readNumber(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 45) {
          code = body.charCodeAt(++position);
        }
        if (code === 48) {
          code = body.charCodeAt(++position);
          if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid number, unexpected digit after 0: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
        } else {
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46) {
          isFloat = true;
          code = body.charCodeAt(++position);
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 69 || code === 101) {
          isFloat = true;
          code = body.charCodeAt(++position);
          if (code === 43 || code === 45) {
            code = body.charCodeAt(++position);
          }
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, expected digit but got: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
        return createToken(
          lexer,
          isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
          start,
          position,
          body.slice(start, position)
        );
      }
      function readDigits(lexer, start, firstCode) {
        if (!(0, _characterClasses.isDigit)(firstCode)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            start,
            `Invalid number, expected digit but got: ${printCodePointAt(
              lexer,
              start
            )}.`
          );
        }
        const body = lexer.source.body;
        let position = start + 1;
        while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
          ++position;
        }
        return position;
      }
      function readString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = "";
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34) {
            value += body.slice(chunkStart, position);
            return createToken(
              lexer,
              _tokenKind.TokenKind.STRING,
              start,
              position + 1,
              value
            );
          }
          if (code === 92) {
            value += body.slice(chunkStart, position);
            const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
            value += escape.value;
            position += escape.size;
            chunkStart = position;
            continue;
          }
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readEscapedUnicodeVariableWidth(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while (size < 12) {
          const code = body.charCodeAt(position + size++);
          if (code === 125) {
            if (size < 5 || !isUnicodeScalarValue(point)) {
              break;
            }
            return {
              value: String.fromCodePoint(point),
              size
            };
          }
          point = point << 4 | readHexDigit(code);
          if (point < 0) {
            break;
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(
            position,
            position + size
          )}".`
        );
      }
      function readEscapedUnicodeFixedWidth(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode(body, position + 2);
        if (isUnicodeScalarValue(code)) {
          return {
            value: String.fromCodePoint(code),
            size: 6
          };
        }
        if (isLeadingSurrogate(code)) {
          if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
            const trailingCode = read16BitHexCode(body, position + 8);
            if (isTrailingSurrogate(trailingCode)) {
              return {
                value: String.fromCodePoint(code, trailingCode),
                size: 12
              };
            }
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
        );
      }
      function read16BitHexCode(body, position) {
        return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
      }
      function readHexDigit(code) {
        return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
      }
      function readEscapedCharacter(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch (code) {
          case 34:
            return {
              value: '"',
              size: 2
            };
          case 92:
            return {
              value: "\\",
              size: 2
            };
          case 47:
            return {
              value: "/",
              size: 2
            };
          case 98:
            return {
              value: "\b",
              size: 2
            };
          case 102:
            return {
              value: "\f",
              size: 2
            };
          case 110:
            return {
              value: "\n",
              size: 2
            };
          case 114:
            return {
              value: "\r",
              size: 2
            };
          case 116:
            return {
              value: "	",
              size: 2
            };
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid character escape sequence: "${body.slice(
            position,
            position + 2
          )}".`
        );
      }
      function readBlockString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = "";
        const blockLines = [];
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token = createToken(
              lexer,
              _tokenKind.TokenKind.BLOCK_STRING,
              start,
              position + 3,
              (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
            );
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token;
          }
          if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1;
            position += 4;
            continue;
          }
          if (code === 10 || code === 13) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 13 && body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readName(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
          } else {
            break;
          }
        }
        return createToken(
          lexer,
          _tokenKind.TokenKind.NAME,
          start,
          position,
          body.slice(start, position)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inspect = inspect;
      var MAX_ARRAY_LENGTH = 10;
      var MAX_RECURSIVE_DEPTH = 2;
      function inspect(value) {
        return formatValue(value, []);
      }
      function formatValue(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray(value, seenValues);
        }
        return formatObject(value, seenValues);
      }
      function isJSONable(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[" + getObjectTag(object) + "]";
        }
        const properties = entries.map(
          ([key, value]) => key + ": " + formatValue(value, seenValues)
        );
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray(array, seenValues) {
        if (array.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH, array.length);
        const remaining = array.length - len;
        const items = [];
        for (let i = 0; i < len; ++i) {
          items.push(formatValue(array[i], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object.constructor === "function") {
          const name = object.constructor.name;
          if (typeof name === "string" && name !== "") {
            return name;
          }
        }
        return tag;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.instanceOf = void 0;
      var _inspect = require_inspect();
      var instanceOf = false ? function instanceOf2(value, constructor) {
        return value instanceof constructor;
      } : function instanceOf2(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
          if (className === valueClassName) {
            const stringifiedValue = (0, _inspect.inspect)(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      };
      exports.instanceOf = instanceOf;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.js
  var require_source = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Source = void 0;
      exports.isSource = isSource;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var Source = class {
        constructor(body, name = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || (0, _devAssert.devAssert)(
            false,
            `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
          );
          this.body = body;
          this.name = name;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
            false,
            "line in locationOffset is 1-indexed and must be positive."
          );
          this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
            false,
            "column in locationOffset is 1-indexed and must be positive."
          );
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
      exports.Source = Source;
      function isSource(source) {
        return (0, _instanceOf.instanceOf)(source, Source);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.js
  var require_parser = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Parser = void 0;
      exports.parse = parse;
      exports.parseConstValue = parseConstValue;
      exports.parseType = parseType;
      exports.parseValue = parseValue;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function parse(source, options) {
        const parser = new Parser(source, options);
        return parser.parseDocument();
      }
      function parseValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseConstValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseType(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const type = parser.parseTypeReference();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return type;
      }
      var Parser = class {
        constructor(source, options = {}) {
          const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
          this._lexer = new _lexer.Lexer(sourceObj);
          this._options = options;
          this._tokenCounter = 0;
        }
        parseName() {
          const token = this.expectToken(_tokenKind.TokenKind.NAME);
          return this.node(token, {
            kind: _kinds.Kind.NAME,
            value: token.value
          });
        }
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(
              _tokenKind.TokenKind.SOF,
              this.parseDefinition,
              _tokenKind.TokenKind.EOF
            )
          });
        }
        parseDefinition() {
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                this._lexer.token.start,
                "Unexpected description, descriptions are supported only on type definitions."
              );
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: _kinds.Kind.OPERATION_DEFINITION,
              operation: _ast.OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name;
          if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
          }
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseOperationType() {
          const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return _ast.OperationTypeNode.QUERY;
            case "mutation":
              return _ast.OperationTypeNode.MUTATION;
            case "subscription":
              return _ast.OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        parseVariableDefinitions() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseVariableDefinition,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.DOLLAR);
          return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
          });
        }
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(
              _tokenKind.TokenKind.BRACE_L,
              this.parseSelection,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        parseSelection() {
          return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name;
          if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
          } else {
            name = nameOrAlias;
          }
          return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            item,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseFragmentDefinition() {
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        parseValueLiteral(isConst) {
          const token = this._lexer.token;
          switch (token.kind) {
            case _tokenKind.TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.INT,
                value: token.value
              });
            case _tokenKind.TokenKind.FLOAT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.FLOAT,
                value: token.value
              });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
              this.advanceLexer();
              switch (token.value) {
                case "true":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token, {
                    kind: _kinds.Kind.NULL
                  });
                default:
                  return this.node(token, {
                    kind: _kinds.Kind.ENUM,
                    value: token.value
                  });
              }
            case _tokenKind.TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(_tokenKind.TokenKind.DOLLAR);
                if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw (0, _syntaxError.syntaxError)(
                    this._lexer.source,
                    token.start,
                    `Unexpected variable "$${varName}" in constant value.`
                  );
                } else {
                  throw this.unexpected(token);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token = this._lexer.token;
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.STRING,
            value: token.value,
            block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
          });
        }
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(
              _tokenKind.TokenKind.BRACKET_L,
              item,
              _tokenKind.TokenKind.BRACKET_R
            )
          });
        }
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(
              _tokenKind.TokenKind.BRACE_L,
              item,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(_tokenKind.TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.AT);
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        parseTypeReference() {
          const start = this._lexer.token;
          let type;
          if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type = this.node(start, {
              kind: _kinds.Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type = this.parseNamedType();
          }
          if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
              kind: _kinds.Kind.NON_NULL_TYPE,
              type
            });
          }
          return type;
        }
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        peekDescription() {
          return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
        }
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseNamedType();
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type
          });
        }
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
          });
        }
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
        }
        parseFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseFieldDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type,
            directives
          });
        }
        parseArgumentDefs() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type,
            defaultValue,
            directives
          });
        }
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types
          });
        }
        parseUnionMemberTypes() {
          return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
        }
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
          });
        }
        parseEnumValuesDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseEnumValueDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
          });
        }
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              `${getTokenDesc(
                this._lexer.token
              )} is reserved and cannot be used for an enum value.`
            );
          }
          return this.parseName();
        }
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
          });
        }
        parseInputFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
          });
        }
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          if (directives.length === 0 && types.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types
          });
        }
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
          });
        }
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
          });
        }
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(_tokenKind.TokenKind.AT);
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
          });
        }
        parseDirectiveLocations() {
          return this.delimitedMany(
            _tokenKind.TokenKind.PIPE,
            this.parseDirectiveLocation
          );
        }
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name = this.parseName();
          if (Object.prototype.hasOwnProperty.call(
            _directiveLocation.DirectiveLocation,
            name.value
          )) {
            return name;
          }
          throw this.unexpected(start);
        }
        node(startToken, node) {
          if (this._options.noLocation !== true) {
            node.loc = new _ast.Location(
              startToken,
              this._lexer.lastToken,
              this._lexer.source
            );
          }
          return node;
        }
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        expectToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return token;
          }
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
          );
        }
        expectOptionalToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        expectKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
          } else {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Expected "${value}", found ${getTokenDesc(token)}.`
            );
          }
        }
        expectOptionalKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        unexpected(atToken) {
          const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Unexpected ${getTokenDesc(token)}.`
          );
        }
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
        advanceLexer() {
          const { maxTokens } = this._options;
          const token = this._lexer.advance();
          if (maxTokens !== void 0 && token.kind !== _tokenKind.TokenKind.EOF) {
            ++this._tokenCounter;
            if (this._tokenCounter > maxTokens) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                token.start,
                `Document contains more that ${maxTokens} tokens. Parsing aborted.`
              );
            }
          }
        }
      };
      exports.Parser = Parser;
      function getTokenDesc(token) {
        const value = token.value;
        return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
      }
      function getTokenKindDesc(kind) {
        return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/didYouMean.js
  var require_didYouMean = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/didYouMean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.didYouMean = didYouMean;
      var MAX_SUGGESTIONS = 5;
      function didYouMean(firstArg, secondArg) {
        const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
        let message = " Did you mean ";
        if (subMessage) {
          message += subMessage + " ";
        }
        const suggestions = suggestionsArg.map((x) => `"${x}"`);
        switch (suggestions.length) {
          case 0:
            return "";
          case 1:
            return message + suggestions[0] + "?";
          case 2:
            return message + suggestions[0] + " or " + suggestions[1] + "?";
        }
        const selected = suggestions.slice(0, MAX_SUGGESTIONS);
        const lastItem = selected.pop();
        return message + selected.join(", ") + ", or " + lastItem + "?";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/identityFunc.js
  var require_identityFunc = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/identityFunc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.identityFunc = identityFunc;
      function identityFunc(x) {
        return x;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/keyMap.js
  var require_keyMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/keyMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyMap = keyMap;
      function keyMap(list, keyFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = item;
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/keyValMap.js
  var require_keyValMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/keyValMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyValMap = keyValMap;
      function keyValMap(list, keyFn, valFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = valFn(item);
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/mapValue.js
  var require_mapValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/mapValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapValue = mapValue;
      function mapValue(map, fn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map)) {
          result[key] = fn(map[key], key);
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/naturalCompare.js
  var require_naturalCompare = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/naturalCompare.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.naturalCompare = naturalCompare;
      function naturalCompare(aStr, bStr) {
        let aIndex = 0;
        let bIndex = 0;
        while (aIndex < aStr.length && bIndex < bStr.length) {
          let aChar = aStr.charCodeAt(aIndex);
          let bChar = bStr.charCodeAt(bIndex);
          if (isDigit(aChar) && isDigit(bChar)) {
            let aNum = 0;
            do {
              ++aIndex;
              aNum = aNum * 10 + aChar - DIGIT_0;
              aChar = aStr.charCodeAt(aIndex);
            } while (isDigit(aChar) && aNum > 0);
            let bNum = 0;
            do {
              ++bIndex;
              bNum = bNum * 10 + bChar - DIGIT_0;
              bChar = bStr.charCodeAt(bIndex);
            } while (isDigit(bChar) && bNum > 0);
            if (aNum < bNum) {
              return -1;
            }
            if (aNum > bNum) {
              return 1;
            }
          } else {
            if (aChar < bChar) {
              return -1;
            }
            if (aChar > bChar) {
              return 1;
            }
            ++aIndex;
            ++bIndex;
          }
        }
        return aStr.length - bStr.length;
      }
      var DIGIT_0 = 48;
      var DIGIT_9 = 57;
      function isDigit(code) {
        return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/suggestionList.js
  var require_suggestionList = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/suggestionList.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.suggestionList = suggestionList;
      var _naturalCompare = require_naturalCompare();
      function suggestionList(input, options) {
        const optionsByDistance = /* @__PURE__ */ Object.create(null);
        const lexicalDistance = new LexicalDistance(input);
        const threshold = Math.floor(input.length * 0.4) + 1;
        for (const option of options) {
          const distance = lexicalDistance.measure(option, threshold);
          if (distance !== void 0) {
            optionsByDistance[option] = distance;
          }
        }
        return Object.keys(optionsByDistance).sort((a, b) => {
          const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
          return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
        });
      }
      var LexicalDistance = class {
        constructor(input) {
          this._input = input;
          this._inputLowerCase = input.toLowerCase();
          this._inputArray = stringToArray(this._inputLowerCase);
          this._rows = [
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0)
          ];
        }
        measure(option, threshold) {
          if (this._input === option) {
            return 0;
          }
          const optionLowerCase = option.toLowerCase();
          if (this._inputLowerCase === optionLowerCase) {
            return 1;
          }
          let a = stringToArray(optionLowerCase);
          let b = this._inputArray;
          if (a.length < b.length) {
            const tmp = a;
            a = b;
            b = tmp;
          }
          const aLength = a.length;
          const bLength = b.length;
          if (aLength - bLength > threshold) {
            return void 0;
          }
          const rows = this._rows;
          for (let j = 0; j <= bLength; j++) {
            rows[0][j] = j;
          }
          for (let i = 1; i <= aLength; i++) {
            const upRow = rows[(i - 1) % 3];
            const currentRow = rows[i % 3];
            let smallestCell = currentRow[0] = i;
            for (let j = 1; j <= bLength; j++) {
              const cost = a[i - 1] === b[j - 1] ? 0 : 1;
              let currentCell = Math.min(
                upRow[j] + 1,
                currentRow[j - 1] + 1,
                upRow[j - 1] + cost
              );
              if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
                currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
              }
              if (currentCell < smallestCell) {
                smallestCell = currentCell;
              }
              currentRow[j] = currentCell;
            }
            if (smallestCell > threshold) {
              return void 0;
            }
          }
          const distance = rows[aLength % 3][bLength];
          return distance <= threshold ? distance : void 0;
        }
      };
      function stringToArray(str) {
        const strLength = str.length;
        const array = new Array(strLength);
        for (let i = 0; i < strLength; ++i) {
          array[i] = str.charCodeAt(i);
        }
        return array;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/toObjMap.js
  var require_toObjMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/toObjMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toObjMap = toObjMap;
      function toObjMap(obj) {
        if (obj == null) {
          return /* @__PURE__ */ Object.create(null);
        }
        if (Object.getPrototypeOf(obj) === null) {
          return obj;
        }
        const map = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of Object.entries(obj)) {
          map[key] = value;
        }
        return map;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printString = printString;
      function printString(str) {
        return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
      }
      var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer(str) {
        return escapeSequences[str.charCodeAt(0)];
      }
      var escapeSequences = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BREAK = void 0;
      exports.getEnterLeaveForKind = getEnterLeaveForKind;
      exports.getVisitFn = getVisitFn;
      exports.visit = visit;
      exports.visitInParallel = visitInParallel;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var BREAK = Object.freeze({});
      exports.BREAK = BREAK;
      function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path[path.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties(
                  {},
                  Object.getOwnPropertyDescriptors(node)
                );
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
              false,
              `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
            );
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i = 0; i < visitors.length; ++i) {
            const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                  if (result === false) {
                    skipping[i] = node;
                  } else if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                  if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i] === node) {
                  skipping[i] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.print = print;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor();
      function print(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer);
      }
      var MAX_LINE_LENGTH = 80;
      var printDocASTReducer = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        Document: {
          leave: (node) => join(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join(
              [
                node.operation,
                join([node.name, varDefs]),
                join(node.directives, " ")
              ],
              " "
            );
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block(selections)
        },
        Field: {
          leave({ alias, name, arguments: args, directives, selectionSet }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
              argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([argsLine, join(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name, value }) => name + ": " + value
        },
        FragmentSpread: {
          leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join(
            [
              "...",
              wrap("on ", typeCondition),
              join(directives, " "),
              selectionSet
            ],
            " "
          )
        },
        FragmentDefinition: {
          leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        },
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name, value }) => name + ": " + value
        },
        Directive: {
          leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
        },
        NamedType: {
          leave: ({ name }) => name
        },
        ListType: {
          leave: ({ type }) => "[" + type + "]"
        },
        NonNullType: {
          leave: ({ type }) => type + "!"
        },
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
            [
              "type",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        FieldDefinition: {
          leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
            [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
            " "
          )
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
            [
              "interface",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeDefinition: {
          leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
            ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
            " "
          )
        },
        EnumTypeDefinition: {
          leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join(
            ["extend schema", join(directives, " "), block(operationTypes)],
            " "
          )
        },
        ScalarTypeExtension: {
          leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join(
            [
              "extend type",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        InterfaceTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join(
            [
              "extend interface",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeExtension: {
          leave: ({ name, directives, types }) => join(
            [
              "extend union",
              name,
              join(directives, " "),
              wrap("= ", join(types, " | "))
            ],
            " "
          )
        },
        EnumTypeExtension: {
          leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
        }
      };
      function join(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block(array) {
        return wrap("{\n", indent(join(array, "\n")), "\n}");
      }
      function wrap(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent(str) {
        return wrap("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/valueFromASTUntyped.js
  var require_valueFromASTUntyped = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/valueFromASTUntyped.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromASTUntyped = valueFromASTUntyped;
      var _keyValMap = require_keyValMap();
      var _kinds = require_kinds();
      function valueFromASTUntyped(valueNode, variables) {
        switch (valueNode.kind) {
          case _kinds.Kind.NULL:
            return null;
          case _kinds.Kind.INT:
            return parseInt(valueNode.value, 10);
          case _kinds.Kind.FLOAT:
            return parseFloat(valueNode.value);
          case _kinds.Kind.STRING:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.BOOLEAN:
            return valueNode.value;
          case _kinds.Kind.LIST:
            return valueNode.values.map(
              (node) => valueFromASTUntyped(node, variables)
            );
          case _kinds.Kind.OBJECT:
            return (0, _keyValMap.keyValMap)(
              valueNode.fields,
              (field) => field.name.value,
              (field) => valueFromASTUntyped(field.value, variables)
            );
          case _kinds.Kind.VARIABLE:
            return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/assertName.js
  var require_assertName = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/assertName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertEnumValueName = assertEnumValueName;
      exports.assertName = assertName;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _characterClasses = require_characterClasses();
      function assertName(name) {
        name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.length === 0) {
          throw new _GraphQLError.GraphQLError(
            "Expected name to be a non-empty string."
          );
        }
        for (let i = 1; i < name.length; ++i) {
          if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
            throw new _GraphQLError.GraphQLError(
              `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
            );
          }
        }
        if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
          throw new _GraphQLError.GraphQLError(
            `Names must start with [_a-zA-Z] but "${name}" does not.`
          );
        }
        return name;
      }
      function assertEnumValueName(name) {
        if (name === "true" || name === "false" || name === "null") {
          throw new _GraphQLError.GraphQLError(
            `Enum values cannot be named: ${name}`
          );
        }
        return assertName(name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/definition.js
  var require_definition = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/definition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = void 0;
      exports.argsToArgsConfig = argsToArgsConfig;
      exports.assertAbstractType = assertAbstractType;
      exports.assertCompositeType = assertCompositeType;
      exports.assertEnumType = assertEnumType;
      exports.assertInputObjectType = assertInputObjectType;
      exports.assertInputType = assertInputType;
      exports.assertInterfaceType = assertInterfaceType;
      exports.assertLeafType = assertLeafType;
      exports.assertListType = assertListType;
      exports.assertNamedType = assertNamedType;
      exports.assertNonNullType = assertNonNullType;
      exports.assertNullableType = assertNullableType;
      exports.assertObjectType = assertObjectType;
      exports.assertOutputType = assertOutputType;
      exports.assertScalarType = assertScalarType;
      exports.assertType = assertType;
      exports.assertUnionType = assertUnionType;
      exports.assertWrappingType = assertWrappingType;
      exports.defineArguments = defineArguments;
      exports.getNamedType = getNamedType;
      exports.getNullableType = getNullableType;
      exports.isAbstractType = isAbstractType;
      exports.isCompositeType = isCompositeType;
      exports.isEnumType = isEnumType;
      exports.isInputObjectType = isInputObjectType;
      exports.isInputType = isInputType;
      exports.isInterfaceType = isInterfaceType;
      exports.isLeafType = isLeafType;
      exports.isListType = isListType;
      exports.isNamedType = isNamedType;
      exports.isNonNullType = isNonNullType;
      exports.isNullableType = isNullableType;
      exports.isObjectType = isObjectType;
      exports.isOutputType = isOutputType;
      exports.isRequiredArgument = isRequiredArgument;
      exports.isRequiredInputField = isRequiredInputField;
      exports.isScalarType = isScalarType;
      exports.isType = isType;
      exports.isUnionType = isUnionType;
      exports.isWrappingType = isWrappingType;
      exports.resolveObjMapThunk = resolveObjMapThunk;
      exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
      var _devAssert = require_devAssert();
      var _didYouMean = require_didYouMean();
      var _identityFunc = require_identityFunc();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _keyMap = require_keyMap();
      var _keyValMap = require_keyValMap();
      var _mapValue = require_mapValue();
      var _suggestionList = require_suggestionList();
      var _toObjMap = require_toObjMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _assertName = require_assertName();
      function isType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
      }
      function assertType(type) {
        if (!isType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`
          );
        }
        return type;
      }
      function isScalarType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
      }
      function assertScalarType(type) {
        if (!isScalarType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`
          );
        }
        return type;
      }
      function isObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
      }
      function assertObjectType(type) {
        if (!isObjectType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`
          );
        }
        return type;
      }
      function isInterfaceType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
      }
      function assertInterfaceType(type) {
        if (!isInterfaceType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`
          );
        }
        return type;
      }
      function isUnionType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
      }
      function assertUnionType(type) {
        if (!isUnionType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`
          );
        }
        return type;
      }
      function isEnumType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
      }
      function assertEnumType(type) {
        if (!isEnumType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`
          );
        }
        return type;
      }
      function isInputObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
      }
      function assertInputObjectType(type) {
        if (!isInputObjectType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(
              type
            )} to be a GraphQL Input Object type.`
          );
        }
        return type;
      }
      function isListType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLList);
      }
      function assertListType(type) {
        if (!isListType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`
          );
        }
        return type;
      }
      function isNonNullType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
      }
      function assertNonNullType(type) {
        if (!isNonNullType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`
          );
        }
        return type;
      }
      function isInputType(type) {
        return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
      }
      function assertInputType(type) {
        if (!isInputType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`
          );
        }
        return type;
      }
      function isOutputType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
      }
      function assertOutputType(type) {
        if (!isOutputType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`
          );
        }
        return type;
      }
      function isLeafType(type) {
        return isScalarType(type) || isEnumType(type);
      }
      function assertLeafType(type) {
        if (!isLeafType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`
          );
        }
        return type;
      }
      function isCompositeType(type) {
        return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
      }
      function assertCompositeType(type) {
        if (!isCompositeType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`
          );
        }
        return type;
      }
      function isAbstractType(type) {
        return isInterfaceType(type) || isUnionType(type);
      }
      function assertAbstractType(type) {
        if (!isAbstractType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`
          );
        }
        return type;
      }
      var GraphQLList = class {
        constructor(ofType) {
          isType(ofType) || (0, _devAssert.devAssert)(
            false,
            `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLList";
        }
        toString() {
          return "[" + String(this.ofType) + "]";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLList = GraphQLList;
      var GraphQLNonNull = class {
        constructor(ofType) {
          isNullableType(ofType) || (0, _devAssert.devAssert)(
            false,
            `Expected ${(0, _inspect.inspect)(
              ofType
            )} to be a GraphQL nullable type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLNonNull";
        }
        toString() {
          return String(this.ofType) + "!";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLNonNull = GraphQLNonNull;
      function isWrappingType(type) {
        return isListType(type) || isNonNullType(type);
      }
      function assertWrappingType(type) {
        if (!isWrappingType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`
          );
        }
        return type;
      }
      function isNullableType(type) {
        return isType(type) && !isNonNullType(type);
      }
      function assertNullableType(type) {
        if (!isNullableType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`
          );
        }
        return type;
      }
      function getNullableType(type) {
        if (type) {
          return isNonNullType(type) ? type.ofType : type;
        }
      }
      function isNamedType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
      }
      function assertNamedType(type) {
        if (!isNamedType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`
          );
        }
        return type;
      }
      function getNamedType(type) {
        if (type) {
          let unwrappedType = type;
          while (isWrappingType(unwrappedType)) {
            unwrappedType = unwrappedType.ofType;
          }
          return unwrappedType;
        }
      }
      function resolveReadonlyArrayThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      function resolveObjMapThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      var GraphQLScalarType = class {
        constructor(config) {
          var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
          const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.specifiedByURL = config.specifiedByURL;
          this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
          this.parseValue = parseValue;
          this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(
            (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
          );
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`
          );
          config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
          );
          if (config.parseLiteral) {
            typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(
              false,
              `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
            );
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLScalarType";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLScalarType = GraphQLScalarType;
      var GraphQLObjectType = class {
        constructor(config) {
          var _config$extensionASTN2;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.isTypeOf = config.isTypeOf;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
          this._fields = () => defineFieldMap(config);
          this._interfaces = () => defineInterfaces(config);
          config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLObjectType = GraphQLObjectType;
      function defineInterfaces(config) {
        var _config$interfaces;
        const interfaces = resolveReadonlyArrayThunk(
          (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
        );
        Array.isArray(interfaces) || (0, _devAssert.devAssert)(
          false,
          `${config.name} interfaces must be an Array or a function which returns an Array.`
        );
        return interfaces;
      }
      function defineFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
          false,
          `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
        );
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          var _fieldConfig$args;
          isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} field config must be an object.`
          );
          fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
          );
          const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
          isPlainObj(argsConfig) || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} args must be an object with argument names as keys.`
          );
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            args: defineArguments(argsConfig),
            resolve: fieldConfig.resolve,
            subscribe: fieldConfig.subscribe,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function defineArguments(config) {
        return Object.entries(config).map(([argName, argConfig]) => ({
          name: (0, _assertName.assertName)(argName),
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
          astNode: argConfig.astNode
        }));
      }
      function isPlainObj(obj) {
        return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
      }
      function fieldsToFieldsConfig(fields) {
        return (0, _mapValue.mapValue)(fields, (field) => ({
          description: field.description,
          type: field.type,
          args: argsToArgsConfig(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
      }
      function argsToArgsConfig(args) {
        return (0, _keyValMap.keyValMap)(
          args,
          (arg) => arg.name,
          (arg) => ({
            description: arg.description,
            type: arg.type,
            defaultValue: arg.defaultValue,
            deprecationReason: arg.deprecationReason,
            extensions: arg.extensions,
            astNode: arg.astNode
          })
        );
      }
      function isRequiredArgument(arg) {
        return isNonNullType(arg.type) && arg.defaultValue === void 0;
      }
      var GraphQLInterfaceType = class {
        constructor(config) {
          var _config$extensionASTN3;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
          this._fields = defineFieldMap.bind(void 0, config);
          this._interfaces = defineInterfaces.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInterfaceType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInterfaceType = GraphQLInterfaceType;
      var GraphQLUnionType = class {
        constructor(config) {
          var _config$extensionASTN4;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
          this._types = defineTypes.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLUnionType";
        }
        getTypes() {
          if (typeof this._types === "function") {
            this._types = this._types();
          }
          return this._types;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLUnionType = GraphQLUnionType;
      function defineTypes(config) {
        const types = resolveReadonlyArrayThunk(config.types);
        Array.isArray(types) || (0, _devAssert.devAssert)(
          false,
          `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
        );
        return types;
      }
      var GraphQLEnumType = class {
        constructor(config) {
          var _config$extensionASTN5;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
          this._values = defineEnumValues(this.name, config.values);
          this._valueLookup = new Map(
            this._values.map((enumValue) => [enumValue.value, enumValue])
          );
          this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLEnumType";
        }
        getValues() {
          return this._values;
        }
        getValue(name) {
          return this._nameLookup[name];
        }
        serialize(outputValue) {
          const enumValue = this._valueLookup.get(outputValue);
          if (enumValue === void 0) {
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
                outputValue
              )}`
            );
          }
          return enumValue.name;
        }
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            const valueStr = (0, _inspect.inspect)(inputValue);
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
            );
          }
          const enumValue = this.getValue(inputValue);
          if (enumValue == null) {
            throw new _GraphQLError.GraphQLError(
              `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
            );
          }
          return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
          if (valueNode.kind !== _kinds.Kind.ENUM) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          const enumValue = this.getValue(valueNode.value);
          if (enumValue == null) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(
              `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          return enumValue.value;
        }
        toConfig() {
          const values = (0, _keyValMap.keyValMap)(
            this.getValues(),
            (value) => value.name,
            (value) => ({
              description: value.description,
              value: value.value,
              deprecationReason: value.deprecationReason,
              extensions: value.extensions,
              astNode: value.astNode
            })
          );
          return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLEnumType = GraphQLEnumType;
      function didYouMeanEnumValue(enumType, unknownValueStr) {
        const allNames = enumType.getValues().map((value) => value.name);
        const suggestedValues = (0, _suggestionList.suggestionList)(
          unknownValueStr,
          allNames
        );
        return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
      }
      function defineEnumValues(typeName, valueMap) {
        isPlainObj(valueMap) || (0, _devAssert.devAssert)(
          false,
          `${typeName} values must be an object with value names as keys.`
        );
        return Object.entries(valueMap).map(([valueName, valueConfig]) => {
          isPlainObj(valueConfig) || (0, _devAssert.devAssert)(
            false,
            `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
              valueConfig
            )}.`
          );
          return {
            name: (0, _assertName.assertEnumValueName)(valueName),
            description: valueConfig.description,
            value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
            deprecationReason: valueConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
            astNode: valueConfig.astNode
          };
        });
      }
      var GraphQLInputObjectType = class {
        constructor(config) {
          var _config$extensionASTN6;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
          this._fields = defineInputFieldMap.bind(void 0, config);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInputObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        toConfig() {
          const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInputObjectType = GraphQLInputObjectType;
      function defineInputFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
          false,
          `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
        );
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
          );
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            defaultValue: fieldConfig.defaultValue,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function isRequiredInputField(field) {
        return isNonNullType(field.type) && field.defaultValue === void 0;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/typeComparators.js
  var require_typeComparators = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/typeComparators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doTypesOverlap = doTypesOverlap;
      exports.isEqualType = isEqualType;
      exports.isTypeSubTypeOf = isTypeSubTypeOf;
      var _definition = require_definition();
      function isEqualType(typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        return false;
      }
      function isTypeSubTypeOf(schema, maybeSubType, superType) {
        if (maybeSubType === superType) {
          return true;
        }
        if ((0, _definition.isNonNullType)(superType)) {
          if ((0, _definition.isNonNullType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
        }
        if ((0, _definition.isListType)(superType)) {
          if ((0, _definition.isListType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isListType)(maybeSubType)) {
          return false;
        }
        return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
      }
      function doTypesOverlap(schema, typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isAbstractType)(typeA)) {
          if ((0, _definition.isAbstractType)(typeB)) {
            return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
          }
          return schema.isSubType(typeA, typeB);
        }
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.isSubType(typeB, typeA);
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/scalars.js
  var require_scalars = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/scalars.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = void 0;
      exports.isSpecifiedScalarType = isSpecifiedScalarType;
      exports.specifiedScalarTypes = void 0;
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var GRAPHQL_MAX_INT = 2147483647;
      exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
      var GRAPHQL_MIN_INT = -2147483648;
      exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
      var GraphQLInt = new _definition.GraphQLScalarType({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
                coercedValue
              )}`
            );
          }
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(
              "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${inputValue}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          const num = parseInt(valueNode.value, 10);
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
              {
                nodes: valueNode
              }
            );
          }
          return num;
        }
      });
      exports.GraphQLInt = GraphQLInt;
      var GraphQLFloat = new _definition.GraphQLScalarType({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
                coercedValue
              )}`
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _printer.print)(
                valueNode
              )}`,
              valueNode
            );
          }
          return parseFloat(valueNode.value);
        }
      });
      exports.GraphQLFloat = GraphQLFloat;
      var GraphQLString = new _definition.GraphQLScalarType({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
          }
          if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
          }
          throw new _GraphQLError.GraphQLError(
            `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            throw new _GraphQLError.GraphQLError(
              `String cannot represent a non string value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING) {
            throw new _GraphQLError.GraphQLError(
              `String cannot represent a non string value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports.GraphQLString = GraphQLString;
      var GraphQLBoolean = new _definition.GraphQLScalarType({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue;
          }
          if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
          }
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "boolean") {
            throw new _GraphQLError.GraphQLError(
              `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
            throw new _GraphQLError.GraphQLError(
              `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports.GraphQLBoolean = GraphQLBoolean;
      var GraphQLID = new _definition.GraphQLScalarType({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
          }
          throw new _GraphQLError.GraphQLError(
            `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue === "string") {
            return inputValue;
          }
          if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
          }
          throw new _GraphQLError.GraphQLError(
            `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
          );
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports.GraphQLID = GraphQLID;
      var specifiedScalarTypes = Object.freeze([
        GraphQLString,
        GraphQLInt,
        GraphQLFloat,
        GraphQLBoolean,
        GraphQLID
      ]);
      exports.specifiedScalarTypes = specifiedScalarTypes;
      function isSpecifiedScalarType(type) {
        return specifiedScalarTypes.some(({ name }) => type.name === name);
      }
      function serializeObject(outputValue) {
        if ((0, _isObjectLike.isObjectLike)(outputValue)) {
          if (typeof outputValue.valueOf === "function") {
            const valueOfResult = outputValue.valueOf();
            if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
              return valueOfResult;
            }
          }
          if (typeof outputValue.toJSON === "function") {
            return outputValue.toJSON();
          }
        }
        return outputValue;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/directives.js
  var require_directives = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/directives.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = void 0;
      exports.assertDirective = assertDirective;
      exports.isDirective = isDirective;
      exports.isSpecifiedDirective = isSpecifiedDirective;
      exports.specifiedDirectives = void 0;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _directiveLocation = require_directiveLocation();
      var _assertName = require_assertName();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function isDirective(directive) {
        return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
      }
      function assertDirective(directive) {
        if (!isDirective(directive)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
          );
        }
        return directive;
      }
      var GraphQLDirective = class {
        constructor(config) {
          var _config$isRepeatable, _config$args;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.locations = config.locations;
          this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          Array.isArray(config.locations) || (0, _devAssert.devAssert)(
            false,
            `@${config.name} locations must be an Array.`
          );
          const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
          (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
            false,
            `@${config.name} args must be an object with argument names as keys.`
          );
          this.args = (0, _definition.defineArguments)(args);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLDirective";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: (0, _definition.argsToArgsConfig)(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
          };
        }
        toString() {
          return "@" + this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLDirective = GraphQLDirective;
      var GraphQLIncludeDirective = new GraphQLDirective({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Included when true."
          }
        }
      });
      exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
      var GraphQLSkipDirective = new GraphQLDirective({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Skipped when true."
          }
        }
      });
      exports.GraphQLSkipDirective = GraphQLSkipDirective;
      var DEFAULT_DEPRECATION_REASON = "No longer supported";
      exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
      var GraphQLDeprecatedDirective = new GraphQLDirective({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ENUM_VALUE
        ],
        args: {
          reason: {
            type: _scalars.GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON
          }
        }
      });
      exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
      var GraphQLSpecifiedByDirective = new GraphQLDirective({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behavior of this scalar.",
        locations: [_directiveLocation.DirectiveLocation.SCALAR],
        args: {
          url: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
          }
        }
      });
      exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
      var specifiedDirectives = Object.freeze([
        GraphQLIncludeDirective,
        GraphQLSkipDirective,
        GraphQLDeprecatedDirective,
        GraphQLSpecifiedByDirective
      ]);
      exports.specifiedDirectives = specifiedDirectives;
      function isSpecifiedDirective(directive) {
        return specifiedDirectives.some(({ name }) => name === directive.name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isIterableObject.js
  var require_isIterableObject = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isIterableObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIterableObject = isIterableObject;
      function isIterableObject(maybeIterable) {
        return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/astFromValue.js
  var require_astFromValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/astFromValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.astFromValue = astFromValue;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function astFromValue(value, type) {
        if ((0, _definition.isNonNullType)(type)) {
          const astValue = astFromValue(value, type.ofType);
          if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
            return null;
          }
          return astValue;
        }
        if (value === null) {
          return {
            kind: _kinds.Kind.NULL
          };
        }
        if (value === void 0) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value) {
              const itemNode = astFromValue(item, itemType);
              if (itemNode != null) {
                valuesNodes.push(itemNode);
              }
            }
            return {
              kind: _kinds.Kind.LIST,
              values: valuesNodes
            };
          }
          return astFromValue(value, itemType);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(value)) {
            return null;
          }
          const fieldNodes = [];
          for (const field of Object.values(type.getFields())) {
            const fieldValue = astFromValue(value[field.name], field.type);
            if (fieldValue) {
              fieldNodes.push({
                kind: _kinds.Kind.OBJECT_FIELD,
                name: {
                  kind: _kinds.Kind.NAME,
                  value: field.name
                },
                value: fieldValue
              });
            }
          }
          return {
            kind: _kinds.Kind.OBJECT,
            fields: fieldNodes
          };
        }
        if ((0, _definition.isLeafType)(type)) {
          const serialized = type.serialize(value);
          if (serialized == null) {
            return null;
          }
          if (typeof serialized === "boolean") {
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: serialized
            };
          }
          if (typeof serialized === "number" && Number.isFinite(serialized)) {
            const stringNum = String(serialized);
            return integerStringRegExp.test(stringNum) ? {
              kind: _kinds.Kind.INT,
              value: stringNum
            } : {
              kind: _kinds.Kind.FLOAT,
              value: stringNum
            };
          }
          if (typeof serialized === "string") {
            if ((0, _definition.isEnumType)(type)) {
              return {
                kind: _kinds.Kind.ENUM,
                value: serialized
              };
            }
            if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
              return {
                kind: _kinds.Kind.INT,
                value: serialized
              };
            }
            return {
              kind: _kinds.Kind.STRING,
              value: serialized
            };
          }
          throw new TypeError(
            `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
          );
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
      var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/introspection.js
  var require_introspection = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/introspection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = void 0;
      exports.isIntrospectionType = isIntrospectionType;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _directiveLocation = require_directiveLocation();
      var _printer = require_printer();
      var _astFromValue = require_astFromValue();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var __Schema = new _definition.GraphQLObjectType({
        name: "__Schema",
        description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
        fields: () => ({
          description: {
            type: _scalars.GraphQLString,
            resolve: (schema) => schema.description
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))
            ),
            resolve(schema) {
              return Object.values(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (schema) => schema.getQueryType()
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getMutationType()
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getSubscriptionType()
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__Directive)
              )
            ),
            resolve: (schema) => schema.getDirectives()
          }
        })
      });
      exports.__Schema = __Schema;
      var __Directive = new _definition.GraphQLObjectType({
        name: "__Directive",
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (directive) => directive.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (directive) => directive.description
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (directive) => directive.isRepeatable
          },
          locations: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__DirectiveLocation)
              )
            ),
            resolve: (directive) => directive.locations
          },
          args: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__InputValue)
              )
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          }
        })
      });
      exports.__Directive = __Directive;
      var __DirectiveLocation = new _definition.GraphQLEnumType({
        name: "__DirectiveLocation",
        description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
        values: {
          QUERY: {
            value: _directiveLocation.DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
          },
          MUTATION: {
            value: _directiveLocation.DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
          },
          SUBSCRIPTION: {
            value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
          },
          FIELD: {
            value: _directiveLocation.DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
          },
          FRAGMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
          },
          FRAGMENT_SPREAD: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
          },
          INLINE_FRAGMENT: {
            value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
          },
          VARIABLE_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
          },
          SCHEMA: {
            value: _directiveLocation.DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
          },
          SCALAR: {
            value: _directiveLocation.DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
          },
          OBJECT: {
            value: _directiveLocation.DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
          },
          FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
          },
          ARGUMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
          },
          INTERFACE: {
            value: _directiveLocation.DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
          },
          UNION: {
            value: _directiveLocation.DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
          },
          ENUM: {
            value: _directiveLocation.DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
          },
          ENUM_VALUE: {
            value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
          },
          INPUT_OBJECT: {
            value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
          },
          INPUT_FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
          }
        }
      });
      exports.__DirectiveLocation = __DirectiveLocation;
      var __Type = new _definition.GraphQLObjectType({
        name: "__Type",
        description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
        fields: () => ({
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind),
            resolve(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind.NON_NULL;
              }
              (0, _invariant.invariant)(
                false,
                `Unexpected type: "${(0, _inspect.inspect)(type)}".`
              );
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: (type) => "name" in type ? type.name : void 0
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (type) => "description" in type ? type.description : void 0
          },
          specifiedByURL: {
            type: _scalars.GraphQLString,
            resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
          },
          fields: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Field)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                const fields = Object.values(type.getFields());
                return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type, _args, _context, { schema }) {
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__EnumValue)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isEnumType)(type)) {
                const values = type.getValues();
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isInputObjectType)(type)) {
                const values = Object.values(type.getFields());
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: (type) => "ofType" in type ? type.ofType : void 0
          }
        })
      });
      exports.__Type = __Type;
      var __Field = new _definition.GraphQLObjectType({
        name: "__Field",
        description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (field) => field.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.description
          },
          args: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__InputValue)
              )
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (field) => field.type
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.deprecationReason
          }
        })
      });
      exports.__Field = __Field;
      var __InputValue = new _definition.GraphQLObjectType({
        name: "__InputValue",
        description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (inputValue) => inputValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (inputValue) => inputValue.description
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (inputValue) => inputValue.type
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve(inputValue) {
              const { type, defaultValue } = inputValue;
              const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (obj) => obj.deprecationReason
          }
        })
      });
      exports.__InputValue = __InputValue;
      var __EnumValue = new _definition.GraphQLObjectType({
        name: "__EnumValue",
        description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (enumValue) => enumValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.description
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (enumValue) => enumValue.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.deprecationReason
          }
        })
      });
      exports.__EnumValue = __EnumValue;
      var TypeKind;
      exports.TypeKind = TypeKind;
      (function(TypeKind2) {
        TypeKind2["SCALAR"] = "SCALAR";
        TypeKind2["OBJECT"] = "OBJECT";
        TypeKind2["INTERFACE"] = "INTERFACE";
        TypeKind2["UNION"] = "UNION";
        TypeKind2["ENUM"] = "ENUM";
        TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
        TypeKind2["LIST"] = "LIST";
        TypeKind2["NON_NULL"] = "NON_NULL";
      })(TypeKind || (exports.TypeKind = TypeKind = {}));
      var __TypeKind = new _definition.GraphQLEnumType({
        name: "__TypeKind",
        description: "An enum describing what kind of type a given `__Type` is.",
        values: {
          SCALAR: {
            value: TypeKind.SCALAR,
            description: "Indicates this type is a scalar."
          },
          OBJECT: {
            value: TypeKind.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
          },
          INTERFACE: {
            value: TypeKind.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
          },
          UNION: {
            value: TypeKind.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
          },
          ENUM: {
            value: TypeKind.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
          },
          INPUT_OBJECT: {
            value: TypeKind.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
          },
          LIST: {
            value: TypeKind.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
          },
          NON_NULL: {
            value: TypeKind.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
          }
        }
      });
      exports.__TypeKind = __TypeKind;
      var SchemaMetaFieldDef = {
        name: "__schema",
        type: new _definition.GraphQLNonNull(__Schema),
        description: "Access the current type schema of this server.",
        args: [],
        resolve: (_source, _args, _context, { schema }) => schema,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
      var TypeMetaFieldDef = {
        name: "__type",
        type: __Type,
        description: "Request the type information of a single type.",
        args: [
          {
            name: "name",
            description: void 0,
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            defaultValue: void 0,
            deprecationReason: void 0,
            extensions: /* @__PURE__ */ Object.create(null),
            astNode: void 0
          }
        ],
        resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeMetaFieldDef = TypeMetaFieldDef;
      var TypeNameMetaFieldDef = {
        name: "__typename",
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The name of the current Object type at runtime.",
        args: [],
        resolve: (_source, _args, _context, { parentType }) => parentType.name,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
      var introspectionTypes = Object.freeze([
        __Schema,
        __Directive,
        __DirectiveLocation,
        __Type,
        __Field,
        __InputValue,
        __EnumValue,
        __TypeKind
      ]);
      exports.introspectionTypes = introspectionTypes;
      function isIntrospectionType(type) {
        return introspectionTypes.some(({ name }) => type.name === name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/schema.js
  var require_schema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/schema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSchema = void 0;
      exports.assertSchema = assertSchema;
      exports.isSchema = isSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _ast = require_ast();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      function isSchema(schema) {
        return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
      }
      function assertSchema(schema) {
        if (!isSchema(schema)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`
          );
        }
        return schema;
      }
      var GraphQLSchema = class {
        constructor(config) {
          var _config$extensionASTN, _config$directives;
          this.__validationErrors = config.assumeValid === true ? [] : void 0;
          (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
          !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(
            false,
            `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
              config.types
            )}.`
          );
          !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(
            false,
            `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config.directives)}.`
          );
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          this._queryType = config.query;
          this._mutationType = config.mutation;
          this._subscriptionType = config.subscription;
          this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
          const allReferencedTypes = new Set(config.types);
          if (config.types != null) {
            for (const type of config.types) {
              allReferencedTypes.delete(type);
              collectReferencedTypes(type, allReferencedTypes);
            }
          }
          if (this._queryType != null) {
            collectReferencedTypes(this._queryType, allReferencedTypes);
          }
          if (this._mutationType != null) {
            collectReferencedTypes(this._mutationType, allReferencedTypes);
          }
          if (this._subscriptionType != null) {
            collectReferencedTypes(this._subscriptionType, allReferencedTypes);
          }
          for (const directive of this._directives) {
            if ((0, _directives.isDirective)(directive)) {
              for (const arg of directive.args) {
                collectReferencedTypes(arg.type, allReferencedTypes);
              }
            }
          }
          collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
          this._typeMap = /* @__PURE__ */ Object.create(null);
          this._subTypeMap = /* @__PURE__ */ Object.create(null);
          this._implementationsMap = /* @__PURE__ */ Object.create(null);
          for (const namedType of allReferencedTypes) {
            if (namedType == null) {
              continue;
            }
            const typeName = namedType.name;
            typeName || (0, _devAssert.devAssert)(
              false,
              "One of the provided types for building the Schema is missing a name."
            );
            if (this._typeMap[typeName] !== void 0) {
              throw new Error(
                `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
              );
            }
            this._typeMap[typeName] = namedType;
            if ((0, _definition.isInterfaceType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.interfaces.push(namedType);
                }
              }
            } else if ((0, _definition.isObjectType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.objects.push(namedType);
                }
              }
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLSchema";
        }
        getQueryType() {
          return this._queryType;
        }
        getMutationType() {
          return this._mutationType;
        }
        getSubscriptionType() {
          return this._subscriptionType;
        }
        getRootType(operation) {
          switch (operation) {
            case _ast.OperationTypeNode.QUERY:
              return this.getQueryType();
            case _ast.OperationTypeNode.MUTATION:
              return this.getMutationType();
            case _ast.OperationTypeNode.SUBSCRIPTION:
              return this.getSubscriptionType();
          }
        }
        getTypeMap() {
          return this._typeMap;
        }
        getType(name) {
          return this.getTypeMap()[name];
        }
        getPossibleTypes(abstractType) {
          return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
          const implementations = this._implementationsMap[interfaceType.name];
          return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
          };
        }
        isSubType(abstractType, maybeSubType) {
          let map = this._subTypeMap[abstractType.name];
          if (map === void 0) {
            map = /* @__PURE__ */ Object.create(null);
            if ((0, _definition.isUnionType)(abstractType)) {
              for (const type of abstractType.getTypes()) {
                map[type.name] = true;
              }
            } else {
              const implementations = this.getImplementations(abstractType);
              for (const type of implementations.objects) {
                map[type.name] = true;
              }
              for (const type of implementations.interfaces) {
                map[type.name] = true;
              }
            }
            this._subTypeMap[abstractType.name] = map;
          }
          return map[maybeSubType.name] !== void 0;
        }
        getDirectives() {
          return this._directives;
        }
        getDirective(name) {
          return this.getDirectives().find((directive) => directive.name === name);
        }
        toConfig() {
          return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== void 0
          };
        }
      };
      exports.GraphQLSchema = GraphQLSchema;
      function collectReferencedTypes(type, typeSet) {
        const namedType = (0, _definition.getNamedType)(type);
        if (!typeSet.has(namedType)) {
          typeSet.add(namedType);
          if ((0, _definition.isUnionType)(namedType)) {
            for (const memberType of namedType.getTypes()) {
              collectReferencedTypes(memberType, typeSet);
            }
          } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
            for (const interfaceType of namedType.getInterfaces()) {
              collectReferencedTypes(interfaceType, typeSet);
            }
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
              for (const arg of field.args) {
                collectReferencedTypes(arg.type, typeSet);
              }
            }
          } else if ((0, _definition.isInputObjectType)(namedType)) {
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
            }
          }
        }
        return typeSet;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/validate.js
  var require_validate = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSchema = assertValidSchema;
      exports.validateSchema = validateSchema;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _typeComparators = require_typeComparators();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function validateSchema(schema) {
        (0, _schema.assertSchema)(schema);
        if (schema.__validationErrors) {
          return schema.__validationErrors;
        }
        const context = new SchemaValidationContext(schema);
        validateRootTypes(context);
        validateDirectives(context);
        validateTypes(context);
        const errors = context.getErrors();
        schema.__validationErrors = errors;
        return errors;
      }
      function assertValidSchema(schema) {
        const errors = validateSchema(schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      var SchemaValidationContext = class {
        constructor(schema) {
          this._errors = [];
          this.schema = schema;
        }
        reportError(message, nodes) {
          const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
          this._errors.push(
            new _GraphQLError.GraphQLError(message, {
              nodes: _nodes
            })
          );
        }
        getErrors() {
          return this._errors;
        }
      };
      function validateRootTypes(context) {
        const schema = context.schema;
        const queryType = schema.getQueryType();
        if (!queryType) {
          context.reportError("Query root type must be provided.", schema.astNode);
        } else if (!(0, _definition.isObjectType)(queryType)) {
          var _getOperationTypeNode;
          context.reportError(
            `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
            (_getOperationTypeNode = getOperationTypeNode(
              schema,
              _ast.OperationTypeNode.QUERY
            )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
          );
        }
        const mutationType = schema.getMutationType();
        if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
          var _getOperationTypeNode2;
          context.reportError(
            `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
            (_getOperationTypeNode2 = getOperationTypeNode(
              schema,
              _ast.OperationTypeNode.MUTATION
            )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
          );
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
          var _getOperationTypeNode3;
          context.reportError(
            `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
            (_getOperationTypeNode3 = getOperationTypeNode(
              schema,
              _ast.OperationTypeNode.SUBSCRIPTION
            )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
          );
        }
      }
      function getOperationTypeNode(schema, operation) {
        var _flatMap$find;
        return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
          (schemaNode) => {
            var _schemaNode$operation;
            return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
          }
        ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
      }
      function validateDirectives(context) {
        for (const directive of context.schema.getDirectives()) {
          if (!(0, _directives.isDirective)(directive)) {
            context.reportError(
              `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
              directive === null || directive === void 0 ? void 0 : directive.astNode
            );
            continue;
          }
          validateName(context, directive);
          for (const arg of directive.args) {
            validateName(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              context.reportError(
                `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
                arg.astNode
              );
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode;
              context.reportError(
                `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
                [
                  getDeprecatedDirectiveNode(arg.astNode),
                  (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
                ]
              );
            }
          }
        }
      }
      function validateName(context, node) {
        if (node.name.startsWith("__")) {
          context.reportError(
            `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
            node.astNode
          );
        }
      }
      function validateTypes(context) {
        const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
        const typeMap = context.schema.getTypeMap();
        for (const type of Object.values(typeMap)) {
          if (!(0, _definition.isNamedType)(type)) {
            context.reportError(
              `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,
              type.astNode
            );
            continue;
          }
          if (!(0, _introspection.isIntrospectionType)(type)) {
            validateName(context, type);
          }
          if ((0, _definition.isObjectType)(type)) {
            validateFields(context, type);
            validateInterfaces(context, type);
          } else if ((0, _definition.isInterfaceType)(type)) {
            validateFields(context, type);
            validateInterfaces(context, type);
          } else if ((0, _definition.isUnionType)(type)) {
            validateUnionMembers(context, type);
          } else if ((0, _definition.isEnumType)(type)) {
            validateEnumValues(context, type);
          } else if ((0, _definition.isInputObjectType)(type)) {
            validateInputFields(context, type);
            validateInputObjectCircularRefs(type);
          }
        }
      }
      function validateFields(context, type) {
        const fields = Object.values(type.getFields());
        if (fields.length === 0) {
          context.reportError(`Type ${type.name} must define one or more fields.`, [
            type.astNode,
            ...type.extensionASTNodes
          ]);
        }
        for (const field of fields) {
          validateName(context, field);
          if (!(0, _definition.isOutputType)(field.type)) {
            var _field$astNode;
            context.reportError(
              `The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
              (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
            );
          }
          for (const arg of field.args) {
            const argName = arg.name;
            validateName(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              var _arg$astNode2;
              context.reportError(
                `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
                (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
              );
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode3;
              context.reportError(
                `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
                [
                  getDeprecatedDirectiveNode(arg.astNode),
                  (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
                ]
              );
            }
          }
        }
      }
      function validateInterfaces(context, type) {
        const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
        for (const iface of type.getInterfaces()) {
          if (!(0, _definition.isInterfaceType)(iface)) {
            context.reportError(
              `Type ${(0, _inspect.inspect)(
                type
              )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
              getAllImplementsInterfaceNodes(type, iface)
            );
            continue;
          }
          if (type === iface) {
            context.reportError(
              `Type ${type.name} cannot implement itself because it would create a circular reference.`,
              getAllImplementsInterfaceNodes(type, iface)
            );
            continue;
          }
          if (ifaceTypeNames[iface.name]) {
            context.reportError(
              `Type ${type.name} can only implement ${iface.name} once.`,
              getAllImplementsInterfaceNodes(type, iface)
            );
            continue;
          }
          ifaceTypeNames[iface.name] = true;
          validateTypeImplementsAncestors(context, type, iface);
          validateTypeImplementsInterface(context, type, iface);
        }
      }
      function validateTypeImplementsInterface(context, type, iface) {
        const typeFieldMap = type.getFields();
        for (const ifaceField of Object.values(iface.getFields())) {
          const fieldName = ifaceField.name;
          const typeField = typeFieldMap[fieldName];
          if (!typeField) {
            context.reportError(
              `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
              [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
            );
            continue;
          }
          if (!(0, _typeComparators.isTypeSubTypeOf)(
            context.schema,
            typeField.type,
            ifaceField.type
          )) {
            var _ifaceField$astNode, _typeField$astNode;
            context.reportError(
              `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
              [
                (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
                (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
              ]
            );
          }
          for (const ifaceArg of ifaceField.args) {
            const argName = ifaceArg.name;
            const typeArg = typeField.args.find((arg) => arg.name === argName);
            if (!typeArg) {
              context.reportError(
                `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
                [ifaceArg.astNode, typeField.astNode]
              );
              continue;
            }
            if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
              var _ifaceArg$astNode, _typeArg$astNode;
              context.reportError(
                `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
                [
                  (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                  (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
                ]
              );
            }
          }
          for (const typeArg of typeField.args) {
            const argName = typeArg.name;
            const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
            if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
              context.reportError(
                `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
                [typeArg.astNode, ifaceField.astNode]
              );
            }
          }
        }
      }
      function validateTypeImplementsAncestors(context, type, iface) {
        const ifaceInterfaces = type.getInterfaces();
        for (const transitive of iface.getInterfaces()) {
          if (!ifaceInterfaces.includes(transitive)) {
            context.reportError(
              transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
              [
                ...getAllImplementsInterfaceNodes(iface, transitive),
                ...getAllImplementsInterfaceNodes(type, iface)
              ]
            );
          }
        }
      }
      function validateUnionMembers(context, union) {
        const memberTypes = union.getTypes();
        if (memberTypes.length === 0) {
          context.reportError(
            `Union type ${union.name} must define one or more member types.`,
            [union.astNode, ...union.extensionASTNodes]
          );
        }
        const includedTypeNames = /* @__PURE__ */ Object.create(null);
        for (const memberType of memberTypes) {
          if (includedTypeNames[memberType.name]) {
            context.reportError(
              `Union type ${union.name} can only include type ${memberType.name} once.`,
              getUnionMemberTypeNodes(union, memberType.name)
            );
            continue;
          }
          includedTypeNames[memberType.name] = true;
          if (!(0, _definition.isObjectType)(memberType)) {
            context.reportError(
              `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
              getUnionMemberTypeNodes(union, String(memberType))
            );
          }
        }
      }
      function validateEnumValues(context, enumType) {
        const enumValues = enumType.getValues();
        if (enumValues.length === 0) {
          context.reportError(
            `Enum type ${enumType.name} must define one or more values.`,
            [enumType.astNode, ...enumType.extensionASTNodes]
          );
        }
        for (const enumValue of enumValues) {
          validateName(context, enumValue);
        }
      }
      function validateInputFields(context, inputObj) {
        const fields = Object.values(inputObj.getFields());
        if (fields.length === 0) {
          context.reportError(
            `Input Object type ${inputObj.name} must define one or more fields.`,
            [inputObj.astNode, ...inputObj.extensionASTNodes]
          );
        }
        for (const field of fields) {
          validateName(context, field);
          if (!(0, _definition.isInputType)(field.type)) {
            var _field$astNode2;
            context.reportError(
              `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
              (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
            );
          }
          if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
            var _field$astNode3;
            context.reportError(
              `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(field.astNode),
                (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
              ]
            );
          }
        }
      }
      function createInputObjectCircularRefsValidator(context) {
        const visitedTypes = /* @__PURE__ */ Object.create(null);
        const fieldPath = [];
        const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
        return detectCycleRecursive;
        function detectCycleRecursive(inputObj) {
          if (visitedTypes[inputObj.name]) {
            return;
          }
          visitedTypes[inputObj.name] = true;
          fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
          const fields = Object.values(inputObj.getFields());
          for (const field of fields) {
            if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
              const fieldType = field.type.ofType;
              const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
              fieldPath.push(field);
              if (cycleIndex === void 0) {
                detectCycleRecursive(fieldType);
              } else {
                const cyclePath = fieldPath.slice(cycleIndex);
                const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
                context.reportError(
                  `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                  cyclePath.map((fieldObj) => fieldObj.astNode)
                );
              }
              fieldPath.pop();
            }
          }
          fieldPathIndexByTypeName[inputObj.name] = void 0;
        }
      }
      function getAllImplementsInterfaceNodes(type, iface) {
        const { astNode, extensionASTNodes } = type;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((typeNode) => {
          var _typeNode$interfaces;
          return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
        }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
      }
      function getUnionMemberTypeNodes(union, typeName) {
        const { astNode, extensionASTNodes } = union;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((unionNode) => {
          var _unionNode$types;
          return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
        }).filter((typeNode) => typeNode.name.value === typeName);
      }
      function getDeprecatedDirectiveNode(definitionNode) {
        var _definitionNode$direc;
        return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
          (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/typeFromAST.js
  var require_typeFromAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/typeFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typeFromAST = typeFromAST;
      var _kinds = require_kinds();
      var _definition = require_definition();
      function typeFromAST(schema, typeNode) {
        switch (typeNode.kind) {
          case _kinds.Kind.LIST_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLList(innerType);
          }
          case _kinds.Kind.NON_NULL_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLNonNull(innerType);
          }
          case _kinds.Kind.NAMED_TYPE:
            return schema.getType(typeNode.name.value);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/TypeInfo.js
  var require_TypeInfo = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/TypeInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TypeInfo = void 0;
      exports.visitWithTypeInfo = visitWithTypeInfo;
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _typeFromAST = require_typeFromAST();
      var TypeInfo = class {
        constructor(schema, initialType, getFieldDefFn) {
          this._schema = schema;
          this._typeStack = [];
          this._parentTypeStack = [];
          this._inputTypeStack = [];
          this._fieldDefStack = [];
          this._defaultValueStack = [];
          this._directive = null;
          this._argument = null;
          this._enumValue = null;
          this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
          if (initialType) {
            if ((0, _definition.isInputType)(initialType)) {
              this._inputTypeStack.push(initialType);
            }
            if ((0, _definition.isCompositeType)(initialType)) {
              this._parentTypeStack.push(initialType);
            }
            if ((0, _definition.isOutputType)(initialType)) {
              this._typeStack.push(initialType);
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "TypeInfo";
        }
        getType() {
          if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
          }
        }
        getParentType() {
          if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
          }
        }
        getInputType() {
          if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
          }
        }
        getParentInputType() {
          if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
          }
        }
        getFieldDef() {
          if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
          }
        }
        getDefaultValue() {
          if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
          }
        }
        getDirective() {
          return this._directive;
        }
        getArgument() {
          return this._argument;
        }
        getEnumValue() {
          return this._enumValue;
        }
        enter(node) {
          const schema = this._schema;
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET: {
              const namedType = (0, _definition.getNamedType)(this.getType());
              this._parentTypeStack.push(
                (0, _definition.isCompositeType)(namedType) ? namedType : void 0
              );
              break;
            }
            case _kinds.Kind.FIELD: {
              const parentType = this.getParentType();
              let fieldDef;
              let fieldType;
              if (parentType) {
                fieldDef = this._getFieldDef(schema, parentType, node);
                if (fieldDef) {
                  fieldType = fieldDef.type;
                }
              }
              this._fieldDefStack.push(fieldDef);
              this._typeStack.push(
                (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
              );
              break;
            }
            case _kinds.Kind.DIRECTIVE:
              this._directive = schema.getDirective(node.name.value);
              break;
            case _kinds.Kind.OPERATION_DEFINITION: {
              const rootType = schema.getRootType(node.operation);
              this._typeStack.push(
                (0, _definition.isObjectType)(rootType) ? rootType : void 0
              );
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION: {
              const typeConditionAST = node.typeCondition;
              const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
              this._typeStack.push(
                (0, _definition.isOutputType)(outputType) ? outputType : void 0
              );
              break;
            }
            case _kinds.Kind.VARIABLE_DEFINITION: {
              const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(inputType) ? inputType : void 0
              );
              break;
            }
            case _kinds.Kind.ARGUMENT: {
              var _this$getDirective;
              let argDef;
              let argType;
              const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
              if (fieldOrDirective) {
                argDef = fieldOrDirective.args.find(
                  (arg) => arg.name === node.name.value
                );
                if (argDef) {
                  argType = argDef.type;
                }
              }
              this._argument = argDef;
              this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(argType) ? argType : void 0
              );
              break;
            }
            case _kinds.Kind.LIST: {
              const listType = (0, _definition.getNullableType)(this.getInputType());
              const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
              this._defaultValueStack.push(void 0);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(itemType) ? itemType : void 0
              );
              break;
            }
            case _kinds.Kind.OBJECT_FIELD: {
              const objectType = (0, _definition.getNamedType)(this.getInputType());
              let inputFieldType;
              let inputField;
              if ((0, _definition.isInputObjectType)(objectType)) {
                inputField = objectType.getFields()[node.name.value];
                if (inputField) {
                  inputFieldType = inputField.type;
                }
              }
              this._defaultValueStack.push(
                inputField ? inputField.defaultValue : void 0
              );
              this._inputTypeStack.push(
                (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
              );
              break;
            }
            case _kinds.Kind.ENUM: {
              const enumType = (0, _definition.getNamedType)(this.getInputType());
              let enumValue;
              if ((0, _definition.isEnumType)(enumType)) {
                enumValue = enumType.getValue(node.value);
              }
              this._enumValue = enumValue;
              break;
            }
            default:
          }
        }
        leave(node) {
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET:
              this._parentTypeStack.pop();
              break;
            case _kinds.Kind.FIELD:
              this._fieldDefStack.pop();
              this._typeStack.pop();
              break;
            case _kinds.Kind.DIRECTIVE:
              this._directive = null;
              break;
            case _kinds.Kind.OPERATION_DEFINITION:
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
              this._typeStack.pop();
              break;
            case _kinds.Kind.VARIABLE_DEFINITION:
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ARGUMENT:
              this._argument = null;
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.LIST:
            case _kinds.Kind.OBJECT_FIELD:
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ENUM:
              this._enumValue = null;
              break;
            default:
          }
        }
      };
      exports.TypeInfo = TypeInfo;
      function getFieldDef(schema, parentType, fieldNode) {
        const name = fieldNode.name.value;
        if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        }
        if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        }
        if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
          return _introspection.TypeNameMetaFieldDef;
        }
        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
          return parentType.getFields()[name];
        }
      }
      function visitWithTypeInfo(typeInfo, visitor) {
        return {
          enter(...args) {
            const node = args[0];
            typeInfo.enter(node);
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
            if (fn) {
              const result = fn.apply(visitor, args);
              if (result !== void 0) {
                typeInfo.leave(node);
                if ((0, _ast.isNode)(result)) {
                  typeInfo.enter(result);
                }
              }
              return result;
            }
          },
          leave(...args) {
            const node = args[0];
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
            let result;
            if (fn) {
              result = fn.apply(visitor, args);
            }
            typeInfo.leave(node);
            return result;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/predicates.js
  var require_predicates = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/predicates.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isConstValueNode = isConstValueNode;
      exports.isDefinitionNode = isDefinitionNode;
      exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
      exports.isSelectionNode = isSelectionNode;
      exports.isTypeDefinitionNode = isTypeDefinitionNode;
      exports.isTypeExtensionNode = isTypeExtensionNode;
      exports.isTypeNode = isTypeNode;
      exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
      exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
      exports.isValueNode = isValueNode;
      var _kinds = require_kinds();
      function isDefinitionNode(node) {
        return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
      }
      function isExecutableDefinitionNode(node) {
        return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
      }
      function isSelectionNode(node) {
        return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
      }
      function isValueNode(node) {
        return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
      }
      function isConstValueNode(node) {
        return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
      }
      function isTypeNode(node) {
        return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
      }
      function isTypeSystemDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
      }
      function isTypeDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
      }
      function isTypeSystemExtensionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
      }
      function isTypeExtensionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
  var require_ExecutableDefinitionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      function ExecutableDefinitionsRule(context) {
        return {
          Document(node) {
            for (const definition of node.definitions) {
              if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `The ${defName} definition is not executable.`,
                    {
                      nodes: definition
                    }
                  )
                );
              }
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
  var require_FieldsOnCorrectTypeRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _naturalCompare = require_naturalCompare();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function FieldsOnCorrectTypeRule(context) {
        return {
          Field(node) {
            const type = context.getParentType();
            if (type) {
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                const schema = context.getSchema();
                const fieldName = node.name.value;
                let suggestion = (0, _didYouMean.didYouMean)(
                  "to use an inline fragment on",
                  getSuggestedTypeNames(schema, type, fieldName)
                );
                if (suggestion === "") {
                  suggestion = (0, _didYouMean.didYouMean)(
                    getSuggestedFieldNames(type, fieldName)
                  );
                }
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          }
        };
      }
      function getSuggestedTypeNames(schema, type, fieldName) {
        if (!(0, _definition.isAbstractType)(type)) {
          return [];
        }
        const suggestedTypes = /* @__PURE__ */ new Set();
        const usageCount = /* @__PURE__ */ Object.create(null);
        for (const possibleType of schema.getPossibleTypes(type)) {
          if (!possibleType.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleType);
          usageCount[possibleType.name] = 1;
          for (const possibleInterface of possibleType.getInterfaces()) {
            var _usageCount$possibleI;
            if (!possibleInterface.getFields()[fieldName]) {
              continue;
            }
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
          }
        }
        return [...suggestedTypes].sort((typeA, typeB) => {
          const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
          if (usageCountDiff !== 0) {
            return usageCountDiff;
          }
          if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
          }
          if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
          }
          return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
        }).map((x) => x.name);
      }
      function getSuggestedFieldNames(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
          const possibleFieldNames = Object.keys(type.getFields());
          return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
        }
        return [];
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
  var require_FragmentsOnCompositeTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function FragmentsOnCompositeTypesRule(context) {
        return {
          InlineFragment(node) {
            const typeCondition = node.typeCondition;
            if (typeCondition) {
              const type = (0, _typeFromAST.typeFromAST)(
                context.getSchema(),
                typeCondition
              );
              if (type && !(0, _definition.isCompositeType)(type)) {
                const typeStr = (0, _printer.print)(typeCondition);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment cannot condition on non composite type "${typeStr}".`,
                    {
                      nodes: typeCondition
                    }
                  )
                );
              }
            }
          },
          FragmentDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(
              context.getSchema(),
              node.typeCondition
            );
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(node.typeCondition);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: node.typeCondition
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
  var require_KnownArgumentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
      exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownArgumentNamesRule(context) {
        return {
          ...KnownArgumentNamesOnDirectivesRule(context),
          Argument(argNode) {
            const argDef = context.getArgument();
            const fieldDef = context.getFieldDef();
            const parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
              const argName = argNode.name.value;
              const knownArgsNames = fieldDef.args.map((arg) => arg.name);
              const suggestions = (0, _suggestionList.suggestionList)(
                argName,
                knownArgsNames
              );
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                  {
                    nodes: argNode
                  }
                )
              );
            }
          }
        };
      }
      function KnownArgumentNamesOnDirectivesRule(context) {
        const directiveArgs = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
          }
        }
        return {
          Directive(directiveNode) {
            const directiveName = directiveNode.name.value;
            const knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
              for (const argNode of directiveNode.arguments) {
                const argName = argNode.name.value;
                if (!knownArgs.includes(argName)) {
                  const suggestions = (0, _suggestionList.suggestionList)(
                    argName,
                    knownArgs
                  );
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                      {
                        nodes: argNode
                      }
                    )
                  );
                }
              }
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownDirectivesRule.js
  var require_KnownDirectivesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownDirectivesRule = KnownDirectivesRule;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownDirectivesRule(context) {
        const locationsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          locationsMap[directive.name] = directive.locations;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map((name) => name.value);
          }
        }
        return {
          Directive(node, _key, _parent, _path, ancestors) {
            const name = node.name.value;
            const locations = locationsMap[name];
            if (!locations) {
              context.reportError(
                new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                  nodes: node
                })
              );
              return;
            }
            const candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && !locations.includes(candidateLocation)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${name}" may not be used on ${candidateLocation}.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      function getDirectiveLocationForASTPath(ancestors) {
        const appliedTo = ancestors[ancestors.length - 1];
        "kind" in appliedTo || (0, _invariant.invariant)(false);
        switch (appliedTo.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
          case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
          case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
          case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
          case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
          case _kinds.Kind.SCHEMA_DEFINITION:
          case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
          case _kinds.Kind.SCALAR_TYPE_DEFINITION:
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
          case _kinds.Kind.OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
          case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
          case _kinds.Kind.UNION_TYPE_DEFINITION:
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
          case _kinds.Kind.ENUM_TYPE_DEFINITION:
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
          case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
          case _kinds.Kind.INPUT_VALUE_DEFINITION: {
            const parentNode = ancestors[ancestors.length - 3];
            "kind" in parentNode || (0, _invariant.invariant)(false);
            return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
          }
          default:
            (0, _invariant.invariant)(
              false,
              "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
            );
        }
      }
      function getDirectiveLocationForOperation(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return _directiveLocation.DirectiveLocation.QUERY;
          case _ast.OperationTypeNode.MUTATION:
            return _directiveLocation.DirectiveLocation.MUTATION;
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
  var require_KnownFragmentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function KnownFragmentNamesRule(context) {
        return {
          FragmentSpread(node) {
            const fragmentName = node.name.value;
            const fragment = context.getFragment(fragmentName);
            if (!fragment) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown fragment "${fragmentName}".`,
                  {
                    nodes: node.name
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownTypeNamesRule.js
  var require_KnownTypeNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownTypeNamesRule = KnownTypeNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _predicates = require_predicates();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      function KnownTypeNamesRule(context) {
        const schema = context.getSchema();
        const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
          }
        }
        const typeNames = [
          ...Object.keys(existingTypesMap),
          ...Object.keys(definedTypes)
        ];
        return {
          NamedType(node, _1, parent, _2, ancestors) {
            const typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
              var _ancestors$;
              const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
              const isSDL = definitionNode != null && isSDLNode(definitionNode);
              if (isSDL && standardTypeNames.includes(typeName)) {
                return;
              }
              const suggestedTypes = (0, _suggestionList.suggestionList)(
                typeName,
                isSDL ? standardTypeNames.concat(typeNames) : typeNames
              );
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      var standardTypeNames = [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ].map((type) => type.name);
      function isSDLNode(value) {
        return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
  var require_LoneAnonymousOperationRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      function LoneAnonymousOperationRule(context) {
        let operationCount = 0;
        return {
          Document(node) {
            operationCount = node.definitions.filter(
              (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
            ).length;
          },
          OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  "This anonymous operation must be the only defined operation.",
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
  var require_LoneSchemaDefinitionRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
      var _GraphQLError = require_GraphQLError();
      function LoneSchemaDefinitionRule(context) {
        var _ref, _ref2, _oldSchema$astNode;
        const oldSchema = context.getSchema();
        const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
        let schemaDefinitionsCount = 0;
        return {
          SchemaDefinition(node) {
            if (alreadyDefined) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  "Cannot define a new schema within a schema extension.",
                  {
                    nodes: node
                  }
                )
              );
              return;
            }
            if (schemaDefinitionsCount > 0) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  "Must provide only one schema definition.",
                  {
                    nodes: node
                  }
                )
              );
            }
            ++schemaDefinitionsCount;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
  var require_NoFragmentCyclesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
      var _GraphQLError = require_GraphQLError();
      function NoFragmentCyclesRule(context) {
        const visitedFrags = /* @__PURE__ */ Object.create(null);
        const spreadPath = [];
        const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
          }
        };
        function detectCycleRecursive(fragment) {
          if (visitedFrags[fragment.name.value]) {
            return;
          }
          const fragmentName = fragment.name.value;
          visitedFrags[fragmentName] = true;
          const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
          if (spreadNodes.length === 0) {
            return;
          }
          spreadPathIndexByName[fragmentName] = spreadPath.length;
          for (const spreadNode of spreadNodes) {
            const spreadName = spreadNode.name.value;
            const cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === void 0) {
              const spreadFragment = context.getFragment(spreadName);
              if (spreadFragment) {
                detectCycleRecursive(spreadFragment);
              }
            } else {
              const cyclePath = spreadPath.slice(cycleIndex);
              const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                  {
                    nodes: cyclePath
                  }
                )
              );
            }
            spreadPath.pop();
          }
          spreadPathIndexByName[fragmentName] = void 0;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
  var require_NoUndefinedVariablesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUndefinedVariablesRule(context) {
        let variableNameDefined = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              variableNameDefined = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                const varName = node.name.value;
                if (variableNameDefined[varName] !== true) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                      {
                        nodes: [node, operation]
                      }
                    )
                  );
                }
              }
            }
          },
          VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
  var require_NoUnusedFragmentsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedFragmentsRule(context) {
        const operationDefs = [];
        const fragmentDefs = [];
        return {
          OperationDefinition(node) {
            operationDefs.push(node);
            return false;
          },
          FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
          },
          Document: {
            leave() {
              const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
              for (const operation of operationDefs) {
                for (const fragment of context.getRecursivelyReferencedFragments(
                  operation
                )) {
                  fragmentNameUsed[fragment.name.value] = true;
                }
              }
              for (const fragmentDef of fragmentDefs) {
                const fragName = fragmentDef.name.value;
                if (fragmentNameUsed[fragName] !== true) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Fragment "${fragName}" is never used.`,
                      {
                        nodes: fragmentDef
                      }
                    )
                  );
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
  var require_NoUnusedVariablesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedVariablesRule(context) {
        let variableDefs = [];
        return {
          OperationDefinition: {
            enter() {
              variableDefs = [];
            },
            leave(operation) {
              const variableNameUsed = /* @__PURE__ */ Object.create(null);
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                variableNameUsed[node.name.value] = true;
              }
              for (const variableDef of variableDefs) {
                const variableName = variableDef.variable.name.value;
                if (variableNameUsed[variableName] !== true) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                      {
                        nodes: variableDef
                      }
                    )
                  );
                }
              }
            }
          },
          VariableDefinition(def) {
            variableDefs.push(def);
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/sortValueNode.js
  var require_sortValueNode = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/sortValueNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sortValueNode = sortValueNode;
      var _naturalCompare = require_naturalCompare();
      var _kinds = require_kinds();
      function sortValueNode(valueNode) {
        switch (valueNode.kind) {
          case _kinds.Kind.OBJECT:
            return { ...valueNode, fields: sortFields(valueNode.fields) };
          case _kinds.Kind.LIST:
            return { ...valueNode, values: valueNode.values.map(sortValueNode) };
          case _kinds.Kind.INT:
          case _kinds.Kind.FLOAT:
          case _kinds.Kind.STRING:
          case _kinds.Kind.BOOLEAN:
          case _kinds.Kind.NULL:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.VARIABLE:
            return valueNode;
        }
      }
      function sortFields(fields) {
        return fields.map((fieldNode) => ({
          ...fieldNode,
          value: sortValueNode(fieldNode.value)
        })).sort(
          (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
  var require_OverlappingFieldsCanBeMergedRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _sortValueNode = require_sortValueNode();
      var _typeFromAST = require_typeFromAST();
      function reasonMessage(reason) {
        if (Array.isArray(reason)) {
          return reason.map(
            ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
          ).join(" and ");
        }
        return reason;
      }
      function OverlappingFieldsCanBeMergedRule(context) {
        const comparedFragmentPairs = new PairSet();
        const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
        return {
          SelectionSet(selectionSet) {
            const conflicts = findConflictsWithinSelectionSet(
              context,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              context.getParentType(),
              selectionSet
            );
            for (const [[responseName, reason], fields1, fields2] of conflicts) {
              const reasonMsg = reasonMessage(reason);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                  {
                    nodes: fields1.concat(fields2)
                  }
                )
              );
            }
          }
        };
      }
      function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
        const conflicts = [];
        const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          parentType,
          selectionSet
        );
        collectConflictsWithin(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          fieldMap
        );
        if (fragmentNames.length !== 0) {
          for (let i = 0; i < fragmentNames.length; i++) {
            collectConflictsBetweenFieldsAndFragment(
              context,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              false,
              fieldMap,
              fragmentNames[i]
            );
            for (let j = i + 1; j < fragmentNames.length; j++) {
              collectConflictsBetweenFragments(
                context,
                conflicts,
                cachedFieldsAndFragmentNames,
                comparedFragmentPairs,
                false,
                fragmentNames[i],
                fragmentNames[j]
              );
            }
          }
        }
        return conflicts;
      }
      function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          return;
        }
        const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          fragment
        );
        if (fieldMap === fieldMap2) {
          return;
        }
        collectConflictsBetween(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          fieldMap2
        );
        for (const referencedFragmentName of referencedFragmentNames) {
          if (comparedFragmentPairs.has(
            referencedFragmentName,
            fragmentName,
            areMutuallyExclusive
          )) {
            continue;
          }
          comparedFragmentPairs.add(
            referencedFragmentName,
            fragmentName,
            areMutuallyExclusive
          );
          collectConflictsBetweenFieldsAndFragment(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap,
            referencedFragmentName
          );
        }
      }
      function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
        if (fragmentName1 === fragmentName2) {
          return;
        }
        if (comparedFragmentPairs.has(
          fragmentName1,
          fragmentName2,
          areMutuallyExclusive
        )) {
          return;
        }
        comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
        const fragment1 = context.getFragment(fragmentName1);
        const fragment2 = context.getFragment(fragmentName2);
        if (!fragment1 || !fragment2) {
          return;
        }
        const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          fragment1
        );
        const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          fragment2
        );
        collectConflictsBetween(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fieldMap2
        );
        for (const referencedFragmentName2 of referencedFragmentNames2) {
          collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            referencedFragmentName2
          );
        }
        for (const referencedFragmentName1 of referencedFragmentNames1) {
          collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            referencedFragmentName1,
            fragmentName2
          );
        }
      }
      function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
        const conflicts = [];
        const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          parentType1,
          selectionSet1
        );
        const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          parentType2,
          selectionSet2
        );
        collectConflictsBetween(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fieldMap2
        );
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFieldsAndFragment(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap1,
            fragmentName2
          );
        }
        for (const fragmentName1 of fragmentNames1) {
          collectConflictsBetweenFieldsAndFragment(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap2,
            fragmentName1
          );
        }
        for (const fragmentName1 of fragmentNames1) {
          for (const fragmentName2 of fragmentNames2) {
            collectConflictsBetweenFragments(
              context,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              areMutuallyExclusive,
              fragmentName1,
              fragmentName2
            );
          }
        }
        return conflicts;
      }
      function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
        for (const [responseName, fields] of Object.entries(fieldMap)) {
          if (fields.length > 1) {
            for (let i = 0; i < fields.length; i++) {
              for (let j = i + 1; j < fields.length; j++) {
                const conflict = findConflict(
                  context,
                  cachedFieldsAndFragmentNames,
                  comparedFragmentPairs,
                  false,
                  responseName,
                  fields[i],
                  fields[j]
                );
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
        for (const [responseName, fields1] of Object.entries(fieldMap1)) {
          const fields2 = fieldMap2[responseName];
          if (fields2) {
            for (const field1 of fields1) {
              for (const field2 of fields2) {
                const conflict = findConflict(
                  context,
                  cachedFieldsAndFragmentNames,
                  comparedFragmentPairs,
                  parentFieldsAreMutuallyExclusive,
                  responseName,
                  field1,
                  field2
                );
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
        const [parentType1, node1, def1] = field1;
        const [parentType2, node2, def2] = field2;
        const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
        if (!areMutuallyExclusive) {
          const name1 = node1.name.value;
          const name2 = node2.name.value;
          if (name1 !== name2) {
            return [
              [responseName, `"${name1}" and "${name2}" are different fields`],
              [node1],
              [node2]
            ];
          }
          if (stringifyArguments(node1) !== stringifyArguments(node2)) {
            return [
              [responseName, "they have differing arguments"],
              [node1],
              [node2]
            ];
          }
        }
        const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
        const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
        if (type1 && type2 && doTypesConflict(type1, type2)) {
          return [
            [
              responseName,
              `they return conflicting types "${(0, _inspect.inspect)(
                type1
              )}" and "${(0, _inspect.inspect)(type2)}"`
            ],
            [node1],
            [node2]
          ];
        }
        const selectionSet1 = node1.selectionSet;
        const selectionSet2 = node2.selectionSet;
        if (selectionSet1 && selectionSet2) {
          const conflicts = findConflictsBetweenSubSelectionSets(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            (0, _definition.getNamedType)(type1),
            selectionSet1,
            (0, _definition.getNamedType)(type2),
            selectionSet2
          );
          return subfieldConflicts(conflicts, responseName, node1, node2);
        }
      }
      function stringifyArguments(fieldNode) {
        var _fieldNode$arguments;
        const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
        const inputObjectWithArgs = {
          kind: _kinds.Kind.OBJECT,
          fields: args.map((argNode) => ({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: argNode.name,
            value: argNode.value
          }))
        };
        return (0, _printer.print)(
          (0, _sortValueNode.sortValueNode)(inputObjectWithArgs)
        );
      }
      function doTypesConflict(type1, type2) {
        if ((0, _definition.isListType)(type1)) {
          return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isListType)(type2)) {
          return true;
        }
        if ((0, _definition.isNonNullType)(type1)) {
          return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return true;
        }
        if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
          return type1 !== type2;
        }
        return false;
      }
      function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
        const cached = cachedFieldsAndFragmentNames.get(selectionSet);
        if (cached) {
          return cached;
        }
        const nodeAndDefs = /* @__PURE__ */ Object.create(null);
        const fragmentNames = /* @__PURE__ */ Object.create(null);
        _collectFieldsAndFragmentNames(
          context,
          parentType,
          selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        const result = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, result);
        return result;
      }
      function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
        const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
        if (cached) {
          return cached;
        }
        const fragmentType = (0, _typeFromAST.typeFromAST)(
          context.getSchema(),
          fragment.typeCondition
        );
        return getFieldsAndFragmentNames(
          context,
          cachedFieldsAndFragmentNames,
          fragmentType,
          fragment.selectionSet
        );
      }
      function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              const fieldName = selection.name.value;
              let fieldDef;
              if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                fieldDef = parentType.getFields()[fieldName];
              }
              const responseName = selection.alias ? selection.alias.value : fieldName;
              if (!nodeAndDefs[responseName]) {
                nodeAndDefs[responseName] = [];
              }
              nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD:
              fragmentNames[selection.name.value] = true;
              break;
            case _kinds.Kind.INLINE_FRAGMENT: {
              const typeCondition = selection.typeCondition;
              const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
              _collectFieldsAndFragmentNames(
                context,
                inlineFragmentType,
                selection.selectionSet,
                nodeAndDefs,
                fragmentNames
              );
              break;
            }
          }
        }
      }
      function subfieldConflicts(conflicts, responseName, node1, node2) {
        if (conflicts.length > 0) {
          return [
            [responseName, conflicts.map(([reason]) => reason)],
            [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
            [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
          ];
        }
      }
      var PairSet = class {
        constructor() {
          this._data = /* @__PURE__ */ new Map();
        }
        has(a, b, areMutuallyExclusive) {
          var _this$_data$get;
          const [key1, key2] = a < b ? [a, b] : [b, a];
          const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
          if (result === void 0) {
            return false;
          }
          return areMutuallyExclusive ? true : areMutuallyExclusive === result;
        }
        add(a, b, areMutuallyExclusive) {
          const [key1, key2] = a < b ? [a, b] : [b, a];
          const map = this._data.get(key1);
          if (map === void 0) {
            this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
          } else {
            map.set(key2, areMutuallyExclusive);
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
  var require_PossibleFragmentSpreadsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function PossibleFragmentSpreadsRule(context) {
        return {
          InlineFragment(node) {
            const fragType = context.getType();
            const parentType = context.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
              context.getSchema(),
              fragType,
              parentType
            )) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          FragmentSpread(node) {
            const fragName = node.name.value;
            const fragType = getFragmentType(context, fragName);
            const parentType = context.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
              context.getSchema(),
              fragType,
              parentType
            )) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      function getFragmentType(context, name) {
        const frag = context.getFragment(name);
        if (frag) {
          const type = (0, _typeFromAST.typeFromAST)(
            context.getSchema(),
            frag.typeCondition
          );
          if ((0, _definition.isCompositeType)(type)) {
            return type;
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
  var require_PossibleTypeExtensionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      function PossibleTypeExtensionsRule(context) {
        const schema = context.getSchema();
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
          }
        }
        return {
          ScalarTypeExtension: checkExtension,
          ObjectTypeExtension: checkExtension,
          InterfaceTypeExtension: checkExtension,
          UnionTypeExtension: checkExtension,
          EnumTypeExtension: checkExtension,
          InputObjectTypeExtension: checkExtension
        };
        function checkExtension(node) {
          const typeName = node.name.value;
          const defNode = definedTypes[typeName];
          const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
          let expectedKind;
          if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
          } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
          }
          if (expectedKind) {
            if (expectedKind !== node.kind) {
              const kindStr = extensionKindToTypeName(node.kind);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot extend non-${kindStr} type "${typeName}".`,
                  {
                    nodes: defNode ? [defNode, node] : node
                  }
                )
              );
            }
          } else {
            const allTypeNames = Object.keys({
              ...definedTypes,
              ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
            });
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              allTypeNames
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      }
      var defKindToExtKind = {
        [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
        [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
        [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
      };
      function typeToExtKind(type) {
        if ((0, _definition.isScalarType)(type)) {
          return _kinds.Kind.SCALAR_TYPE_EXTENSION;
        }
        if ((0, _definition.isObjectType)(type)) {
          return _kinds.Kind.OBJECT_TYPE_EXTENSION;
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
        }
        if ((0, _definition.isUnionType)(type)) {
          return _kinds.Kind.UNION_TYPE_EXTENSION;
        }
        if ((0, _definition.isEnumType)(type)) {
          return _kinds.Kind.ENUM_TYPE_EXTENSION;
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function extensionKindToTypeName(kind) {
        switch (kind) {
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar";
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return "object";
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface";
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return "union";
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return "enum";
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";
          default:
            (0, _invariant.invariant)(
              false,
              "Unexpected kind: " + (0, _inspect.inspect)(kind)
            );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
  var require_ProvidedRequiredArgumentsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
      exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      function ProvidedRequiredArgumentsRule(context) {
        return {
          ...ProvidedRequiredArgumentsOnDirectivesRule(context),
          Field: {
            leave(fieldNode) {
              var _fieldNode$arguments;
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                return false;
              }
              const providedArgs = new Set(
                (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
              );
              for (const argDef of fieldDef.args) {
                if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                  const argTypeStr = (0, _inspect.inspect)(argDef.type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                      {
                        nodes: fieldNode
                      }
                    )
                  );
                }
              }
            }
          }
        };
      }
      function ProvidedRequiredArgumentsOnDirectivesRule(context) {
        var _schema$getDirectives;
        const requiredArgsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
            directive.args.filter(_definition.isRequiredArgument),
            (arg) => arg.name
          );
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
              argNodes.filter(isRequiredArgumentNode),
              (arg) => arg.name.value
            );
          }
        }
        return {
          Directive: {
            leave(directiveNode) {
              const directiveName = directiveNode.name.value;
              const requiredArgs = requiredArgsMap[directiveName];
              if (requiredArgs) {
                var _directiveNode$argume;
                const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
                for (const [argName, argDef] of Object.entries(requiredArgs)) {
                  if (!argNodeMap.has(argName)) {
                    const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                    context.reportError(
                      new _GraphQLError.GraphQLError(
                        `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                        {
                          nodes: directiveNode
                        }
                      )
                    );
                  }
                }
              }
            }
          }
        };
      }
      function isRequiredArgumentNode(arg) {
        return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ScalarLeafsRule.js
  var require_ScalarLeafsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ScalarLeafsRule = ScalarLeafsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function ScalarLeafsRule(context) {
        return {
          Field(node) {
            const type = context.getType();
            const selectionSet = node.selectionSet;
            if (type) {
              if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                if (selectionSet) {
                  const fieldName = node.name.value;
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                      {
                        nodes: selectionSet
                      }
                    )
                  );
                }
              } else if (!selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/printPathArray.js
  var require_printPathArray = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/printPathArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printPathArray = printPathArray;
      function printPathArray(path) {
        return path.map(
          (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
        ).join("");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/Path.js
  var require_Path = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/Path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addPath = addPath;
      exports.pathToArray = pathToArray;
      function addPath(prev, key, typename) {
        return {
          prev,
          key,
          typename
        };
      }
      function pathToArray(path) {
        const flattened = [];
        let curr = path;
        while (curr) {
          flattened.push(curr.key);
          curr = curr.prev;
        }
        return flattened.reverse();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/coerceInputValue.js
  var require_coerceInputValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/coerceInputValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coerceInputValue = coerceInputValue;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _Path = require_Path();
      var _printPathArray = require_printPathArray();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function coerceInputValue(inputValue, type, onError = defaultOnError) {
        return coerceInputValueImpl(inputValue, type, onError, void 0);
      }
      function defaultOnError(path, invalidValue, error) {
        let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
        }
        error.message = errorPrefix + ": " + error.message;
        throw error;
      }
      function coerceInputValueImpl(inputValue, type, onError, path) {
        if ((0, _definition.isNonNullType)(type)) {
          if (inputValue != null) {
            return coerceInputValueImpl(inputValue, type.ofType, onError, path);
          }
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected non-nullable type "${(0, _inspect.inspect)(
                type
              )}" not to be null.`
            )
          );
          return;
        }
        if (inputValue == null) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(inputValue)) {
            return Array.from(inputValue, (itemValue, index) => {
              const itemPath = (0, _Path.addPath)(path, index, void 0);
              return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
            });
          }
          return [coerceInputValueImpl(inputValue, itemType, onError, path)];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type.name}" to be an object.`
              )
            );
            return;
          }
          const coercedValue = {};
          const fieldDefs = type.getFields();
          for (const field of Object.values(fieldDefs)) {
            const fieldValue = inputValue[field.name];
            if (fieldValue === void 0) {
              if (field.defaultValue !== void 0) {
                coercedValue[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                const typeStr = (0, _inspect.inspect)(field.type);
                onError(
                  (0, _Path.pathToArray)(path),
                  inputValue,
                  new _GraphQLError.GraphQLError(
                    `Field "${field.name}" of required type "${typeStr}" was not provided.`
                  )
                );
              }
              continue;
            }
            coercedValue[field.name] = coerceInputValueImpl(
              fieldValue,
              field.type,
              onError,
              (0, _Path.addPath)(path, field.name, type.name)
            );
          }
          for (const fieldName of Object.keys(inputValue)) {
            if (!fieldDefs[fieldName]) {
              const suggestions = (0, _suggestionList.suggestionList)(
                fieldName,
                Object.keys(type.getFields())
              );
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)
                )
              );
            }
          }
          return coercedValue;
        }
        if ((0, _definition.isLeafType)(type)) {
          let parseResult;
          try {
            parseResult = type.parseValue(inputValue);
          } catch (error) {
            if (error instanceof _GraphQLError.GraphQLError) {
              onError((0, _Path.pathToArray)(path), inputValue, error);
            } else {
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Expected type "${type.name}". ` + error.message,
                  {
                    originalError: error
                  }
                )
              );
            }
            return;
          }
          if (parseResult === void 0) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(`Expected type "${type.name}".`)
            );
          }
          return parseResult;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/valueFromAST.js
  var require_valueFromAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/valueFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromAST = valueFromAST;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _kinds = require_kinds();
      var _definition = require_definition();
      function valueFromAST(valueNode, type, variables) {
        if (!valueNode) {
          return;
        }
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variables == null || variables[variableName] === void 0) {
            return;
          }
          const variableValue = variables[variableName];
          if (variableValue === null && (0, _definition.isNonNullType)(type)) {
            return;
          }
          return variableValue;
        }
        if ((0, _definition.isNonNullType)(type)) {
          if (valueNode.kind === _kinds.Kind.NULL) {
            return;
          }
          return valueFromAST(valueNode, type.ofType, variables);
        }
        if (valueNode.kind === _kinds.Kind.NULL) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if (valueNode.kind === _kinds.Kind.LIST) {
            const coercedValues = [];
            for (const itemNode of valueNode.values) {
              if (isMissingVariable(itemNode, variables)) {
                if ((0, _definition.isNonNullType)(itemType)) {
                  return;
                }
                coercedValues.push(null);
              } else {
                const itemValue = valueFromAST(itemNode, itemType, variables);
                if (itemValue === void 0) {
                  return;
                }
                coercedValues.push(itemValue);
              }
            }
            return coercedValues;
          }
          const coercedValue = valueFromAST(valueNode, itemType, variables);
          if (coercedValue === void 0) {
            return;
          }
          return [coercedValue];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (valueNode.kind !== _kinds.Kind.OBJECT) {
            return;
          }
          const coercedObj = /* @__PURE__ */ Object.create(null);
          const fieldNodes = (0, _keyMap.keyMap)(
            valueNode.fields,
            (field) => field.name.value
          );
          for (const field of Object.values(type.getFields())) {
            const fieldNode = fieldNodes[field.name];
            if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
              if (field.defaultValue !== void 0) {
                coercedObj[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                return;
              }
              continue;
            }
            const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
            if (fieldValue === void 0) {
              return;
            }
            coercedObj[field.name] = fieldValue;
          }
          return coercedObj;
        }
        if ((0, _definition.isLeafType)(type)) {
          let result;
          try {
            result = type.parseLiteral(valueNode, variables);
          } catch (_error) {
            return;
          }
          if (result === void 0) {
            return;
          }
          return result;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
      function isMissingVariable(valueNode, variables) {
        return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/values.js
  var require_values = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/values.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getArgumentValues = getArgumentValues;
      exports.getDirectiveValues = getDirectiveValues;
      exports.getVariableValues = getVariableValues;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _printPathArray = require_printPathArray();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _coerceInputValue = require_coerceInputValue();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      function getVariableValues(schema, varDefNodes, inputs, options) {
        const errors = [];
        const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
        try {
          const coerced = coerceVariableValues(
            schema,
            varDefNodes,
            inputs,
            (error) => {
              if (maxErrors != null && errors.length >= maxErrors) {
                throw new _GraphQLError.GraphQLError(
                  "Too many errors processing variables, error limit reached. Execution aborted."
                );
              }
              errors.push(error);
            }
          );
          if (errors.length === 0) {
            return {
              coerced
            };
          }
        } catch (error) {
          errors.push(error);
        }
        return {
          errors
        };
      }
      function coerceVariableValues(schema, varDefNodes, inputs, onError) {
        const coercedValues = {};
        for (const varDefNode of varDefNodes) {
          const varName = varDefNode.variable.name.value;
          const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
          if (!(0, _definition.isInputType)(varType)) {
            const varTypeStr = (0, _printer.print)(varDefNode.type);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
                {
                  nodes: varDefNode.type
                }
              )
            );
            continue;
          }
          if (!hasOwnProperty(inputs, varName)) {
            if (varDefNode.defaultValue) {
              coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
                varDefNode.defaultValue,
                varType
              );
            } else if ((0, _definition.isNonNullType)(varType)) {
              const varTypeStr = (0, _inspect.inspect)(varType);
              onError(
                new _GraphQLError.GraphQLError(
                  `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                  {
                    nodes: varDefNode
                  }
                )
              );
            }
            continue;
          }
          const value = inputs[varName];
          if (value === null && (0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
                {
                  nodes: varDefNode
                }
              )
            );
            continue;
          }
          coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
            value,
            varType,
            (path, invalidValue, error) => {
              let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
              if (path.length > 0) {
                prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                  path
                )}"`;
              }
              onError(
                new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
                  nodes: varDefNode,
                  originalError: error.originalError
                })
              );
            }
          );
        }
        return coercedValues;
      }
      function getArgumentValues(def, node, variableValues) {
        var _node$arguments;
        const coercedValues = {};
        const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
        const argNodeMap = (0, _keyMap.keyMap)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const argDef of def.args) {
          const name = argDef.name;
          const argType = argDef.type;
          const argumentNode = argNodeMap[name];
          if (!argumentNode) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was not provided.`,
                {
                  nodes: node
                }
              );
            }
            continue;
          }
          const valueNode = argumentNode.value;
          let isNull = valueNode.kind === _kinds.Kind.NULL;
          if (valueNode.kind === _kinds.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
              if (argDef.defaultValue !== void 0) {
                coercedValues[name] = argDef.defaultValue;
              } else if ((0, _definition.isNonNullType)(argType)) {
                throw new _GraphQLError.GraphQLError(
                  `Argument "${name}" of required type "${(0, _inspect.inspect)(
                    argType
                  )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                  {
                    nodes: valueNode
                  }
                );
              }
              continue;
            }
            isNull = variableValues[variableName] == null;
          }
          if (isNull && (0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" of non-null type "${(0, _inspect.inspect)(
                argType
              )}" must not be null.`,
              {
                nodes: valueNode
              }
            );
          }
          const coercedValue = (0, _valueFromAST.valueFromAST)(
            valueNode,
            argType,
            variableValues
          );
          if (coercedValue === void 0) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" has invalid value ${(0, _printer.print)(
                valueNode
              )}.`,
              {
                nodes: valueNode
              }
            );
          }
          coercedValues[name] = coercedValue;
        }
        return coercedValues;
      }
      function getDirectiveValues(directiveDef, node, variableValues) {
        var _node$directives;
        const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
          (directive) => directive.name.value === directiveDef.name
        );
        if (directiveNode) {
          return getArgumentValues(directiveDef, directiveNode, variableValues);
        }
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/collectFields.js
  var require_collectFields = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/collectFields.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.collectFields = collectFields;
      exports.collectSubfields = collectSubfields;
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _directives = require_directives();
      var _typeFromAST = require_typeFromAST();
      var _values = require_values();
      function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = /* @__PURE__ */ new Map();
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selectionSet,
          fields,
          /* @__PURE__ */ new Set()
        );
        return fields;
      }
      function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = /* @__PURE__ */ new Map();
        const visitedFragmentNames = /* @__PURE__ */ new Set();
        for (const node of fieldNodes) {
          if (node.selectionSet) {
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              returnType,
              node.selectionSet,
              subFieldNodes,
              visitedFragmentNames
            );
          }
        }
        return subFieldNodes;
      }
      function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              if (!shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              const name = getFieldEntryKey(selection);
              const fieldList = fields.get(name);
              if (fieldList !== void 0) {
                fieldList.push(selection);
              } else {
                fields.set(name, [selection]);
              }
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT: {
              if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                continue;
              }
              collectFieldsImpl(
                schema,
                fragments,
                variableValues,
                runtimeType,
                selection.selectionSet,
                fields,
                visitedFragmentNames
              );
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD: {
              const fragName = selection.name.value;
              if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              visitedFragmentNames.add(fragName);
              const fragment = fragments[fragName];
              if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                continue;
              }
              collectFieldsImpl(
                schema,
                fragments,
                variableValues,
                runtimeType,
                fragment.selectionSet,
                fields,
                visitedFragmentNames
              );
              break;
            }
          }
        }
      }
      function shouldIncludeNode(variableValues, node) {
        const skip = (0, _values.getDirectiveValues)(
          _directives.GraphQLSkipDirective,
          node,
          variableValues
        );
        if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
          return false;
        }
        const include = (0, _values.getDirectiveValues)(
          _directives.GraphQLIncludeDirective,
          node,
          variableValues
        );
        if ((include === null || include === void 0 ? void 0 : include.if) === false) {
          return false;
        }
        return true;
      }
      function doesFragmentConditionMatch(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
          return true;
        }
        const conditionalType = (0, _typeFromAST.typeFromAST)(
          schema,
          typeConditionNode
        );
        if (conditionalType === type) {
          return true;
        }
        if ((0, _definition.isAbstractType)(conditionalType)) {
          return schema.isSubType(conditionalType, type);
        }
        return false;
      }
      function getFieldEntryKey(node) {
        return node.alias ? node.alias.value : node.name.value;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
  var require_SingleFieldSubscriptionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _collectFields = require_collectFields();
      function SingleFieldSubscriptionsRule(context) {
        return {
          OperationDefinition(node) {
            if (node.operation === "subscription") {
              const schema = context.getSchema();
              const subscriptionType = schema.getSubscriptionType();
              if (subscriptionType) {
                const operationName = node.name ? node.name.value : null;
                const variableValues = /* @__PURE__ */ Object.create(null);
                const document = context.getDocument();
                const fragments = /* @__PURE__ */ Object.create(null);
                for (const definition of document.definitions) {
                  if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    fragments[definition.name.value] = definition;
                  }
                }
                const fields = (0, _collectFields.collectFields)(
                  schema,
                  fragments,
                  variableValues,
                  subscriptionType,
                  node.selectionSet
                );
                if (fields.size > 1) {
                  const fieldSelectionLists = [...fields.values()];
                  const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                  const extraFieldSelections = extraFieldSelectionLists.flat();
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                      {
                        nodes: extraFieldSelections
                      }
                    )
                  );
                }
                for (const fieldNodes of fields.values()) {
                  const field = fieldNodes[0];
                  const fieldName = field.name.value;
                  if (fieldName.startsWith("__")) {
                    context.reportError(
                      new _GraphQLError.GraphQLError(
                        operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                        {
                          nodes: fieldNodes
                        }
                      )
                    );
                  }
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/groupBy.js
  var require_groupBy = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/groupBy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.groupBy = groupBy;
      function groupBy(list, keyFn) {
        const result = /* @__PURE__ */ new Map();
        for (const item of list) {
          const key = keyFn(item);
          const group = result.get(key);
          if (group === void 0) {
            result.set(key, [item]);
          } else {
            group.push(item);
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
  var require_UniqueArgumentDefinitionNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentDefinitionNamesRule(context) {
        return {
          DirectiveDefinition(directiveNode) {
            var _directiveNode$argume;
            const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
          },
          InterfaceTypeDefinition: checkArgUniquenessPerField,
          InterfaceTypeExtension: checkArgUniquenessPerField,
          ObjectTypeDefinition: checkArgUniquenessPerField,
          ObjectTypeExtension: checkArgUniquenessPerField
        };
        function checkArgUniquenessPerField(typeNode) {
          var _typeNode$fields;
          const typeName = typeNode.name.value;
          const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
          for (const fieldDef of fieldNodes) {
            var _fieldDef$arguments;
            const fieldName = fieldDef.name.value;
            const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
            checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
          }
          return false;
        }
        function checkArgUniqueness(parentName, argumentNodes) {
          const seenArgs = (0, _groupBy.groupBy)(
            argumentNodes,
            (arg) => arg.name.value
          );
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Argument "${parentName}(${argName}:)" can only be defined once.`,
                  {
                    nodes: argNodes.map((node) => node.name)
                  }
                )
              );
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
  var require_UniqueArgumentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentNamesRule(context) {
        return {
          Field: checkArgUniqueness,
          Directive: checkArgUniqueness
        };
        function checkArgUniqueness(parentNode) {
          var _parentNode$arguments;
          const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
          const seenArgs = (0, _groupBy.groupBy)(
            argumentNodes,
            (arg) => arg.name.value
          );
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one argument named "${argName}".`,
                  {
                    nodes: argNodes.map((node) => node.name)
                  }
                )
              );
            }
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
  var require_UniqueDirectiveNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueDirectiveNamesRule(context) {
        const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          DirectiveDefinition(node) {
            const directiveName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                  {
                    nodes: node.name
                  }
                )
              );
              return;
            }
            if (knownDirectiveNames[directiveName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one directive named "@${directiveName}".`,
                  {
                    nodes: [knownDirectiveNames[directiveName], node.name]
                  }
                )
              );
            } else {
              knownDirectiveNames[directiveName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
  var require_UniqueDirectivesPerLocationRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _directives = require_directives();
      function UniqueDirectivesPerLocationRule(context) {
        const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
          }
        }
        const schemaDirectives = /* @__PURE__ */ Object.create(null);
        const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
        return {
          enter(node) {
            if (!("directives" in node) || !node.directives) {
              return;
            }
            let seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
              seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
              const typeName = node.name.value;
              seenDirectives = typeDirectivesMap[typeName];
              if (seenDirectives === void 0) {
                typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
              }
            } else {
              seenDirectives = /* @__PURE__ */ Object.create(null);
            }
            for (const directive of node.directives) {
              const directiveName = directive.name.value;
              if (uniqueDirectiveMap[directiveName]) {
                if (seenDirectives[directiveName]) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `The directive "@${directiveName}" can only be used once at this location.`,
                      {
                        nodes: [seenDirectives[directiveName], directive]
                      }
                    )
                  );
                } else {
                  seenDirectives[directiveName] = directive;
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
  var require_UniqueEnumValueNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueEnumValueNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownValueNames = /* @__PURE__ */ Object.create(null);
        return {
          EnumTypeDefinition: checkValueUniqueness,
          EnumTypeExtension: checkValueUniqueness
        };
        function checkValueUniqueness(node) {
          var _node$values;
          const typeName = node.name.value;
          if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          const valueNames = knownValueNames[typeName];
          for (const valueDef of valueNodes) {
            const valueName = valueDef.name.value;
            const existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                  {
                    nodes: valueDef.name
                  }
                )
              );
            } else if (valueNames[valueName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Enum value "${typeName}.${valueName}" can only be defined once.`,
                  {
                    nodes: [valueNames[valueName], valueDef.name]
                  }
                )
              );
            } else {
              valueNames[valueName] = valueDef.name;
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
  var require_UniqueFieldDefinitionNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueFieldDefinitionNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownFieldNames = /* @__PURE__ */ Object.create(null);
        return {
          InputObjectTypeDefinition: checkFieldUniqueness,
          InputObjectTypeExtension: checkFieldUniqueness,
          InterfaceTypeDefinition: checkFieldUniqueness,
          InterfaceTypeExtension: checkFieldUniqueness,
          ObjectTypeDefinition: checkFieldUniqueness,
          ObjectTypeExtension: checkFieldUniqueness
        };
        function checkFieldUniqueness(node) {
          var _node$fields;
          const typeName = node.name.value;
          if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          const fieldNames = knownFieldNames[typeName];
          for (const fieldDef of fieldNodes) {
            const fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                  {
                    nodes: fieldDef.name
                  }
                )
              );
            } else if (fieldNames[fieldName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${typeName}.${fieldName}" can only be defined once.`,
                  {
                    nodes: [fieldNames[fieldName], fieldDef.name]
                  }
                )
              );
            } else {
              fieldNames[fieldName] = fieldDef.name;
            }
          }
          return false;
        }
      }
      function hasField(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
          return type.getFields()[fieldName] != null;
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
  var require_UniqueFragmentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueFragmentNamesRule(context) {
        const knownFragmentNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            const fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one fragment named "${fragmentName}".`,
                  {
                    nodes: [knownFragmentNames[fragmentName], node.name]
                  }
                )
              );
            } else {
              knownFragmentNames[fragmentName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
  var require_UniqueInputFieldNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      function UniqueInputFieldNamesRule(context) {
        const knownNameStack = [];
        let knownNames = /* @__PURE__ */ Object.create(null);
        return {
          ObjectValue: {
            enter() {
              knownNameStack.push(knownNames);
              knownNames = /* @__PURE__ */ Object.create(null);
            },
            leave() {
              const prevKnownNames = knownNameStack.pop();
              prevKnownNames || (0, _invariant.invariant)(false);
              knownNames = prevKnownNames;
            }
          },
          ObjectField(node) {
            const fieldName = node.name.value;
            if (knownNames[fieldName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one input field named "${fieldName}".`,
                  {
                    nodes: [knownNames[fieldName], node.name]
                  }
                )
              );
            } else {
              knownNames[fieldName] = node.name;
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
  var require_UniqueOperationNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationNamesRule(context) {
        const knownOperationNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition(node) {
            const operationName = node.name;
            if (operationName) {
              if (knownOperationNames[operationName.value]) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `There can be only one operation named "${operationName.value}".`,
                    {
                      nodes: [
                        knownOperationNames[operationName.value],
                        operationName
                      ]
                    }
                  )
                );
              } else {
                knownOperationNames[operationName.value] = operationName;
              }
            }
            return false;
          },
          FragmentDefinition: () => false
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
  var require_UniqueOperationTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationTypesRule(context) {
        const schema = context.getSchema();
        const definedOperationTypes = /* @__PURE__ */ Object.create(null);
        const existingOperationTypes = schema ? {
          query: schema.getQueryType(),
          mutation: schema.getMutationType(),
          subscription: schema.getSubscriptionType()
        } : {};
        return {
          SchemaDefinition: checkOperationTypes,
          SchemaExtension: checkOperationTypes
        };
        function checkOperationTypes(node) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            const operation = operationType.operation;
            const alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                  {
                    nodes: operationType
                  }
                )
              );
            } else if (alreadyDefinedOperationType) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one ${operation} type in schema.`,
                  {
                    nodes: [alreadyDefinedOperationType, operationType]
                  }
                )
              );
            } else {
              definedOperationTypes[operation] = operationType;
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
  var require_UniqueTypeNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueTypeNamesRule(context) {
        const knownTypeNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          ScalarTypeDefinition: checkTypeName,
          ObjectTypeDefinition: checkTypeName,
          InterfaceTypeDefinition: checkTypeName,
          UnionTypeDefinition: checkTypeName,
          EnumTypeDefinition: checkTypeName,
          InputObjectTypeDefinition: checkTypeName
        };
        function checkTypeName(node) {
          const typeName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownTypeNames[typeName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one type named "${typeName}".`,
                {
                  nodes: [knownTypeNames[typeName], node.name]
                }
              )
            );
          } else {
            knownTypeNames[typeName] = node.name;
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
  var require_UniqueVariableNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueVariableNamesRule(context) {
        return {
          OperationDefinition(operationNode) {
            var _operationNode$variab;
            const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
            const seenVariableDefinitions = (0, _groupBy.groupBy)(
              variableDefinitions,
              (node) => node.variable.name.value
            );
            for (const [variableName, variableNodes] of seenVariableDefinitions) {
              if (variableNodes.length > 1) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `There can be only one variable named "$${variableName}".`,
                    {
                      nodes: variableNodes.map((node) => node.variable.name)
                    }
                  )
                );
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
  var require_ValuesOfCorrectTypeRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      function ValuesOfCorrectTypeRule(context) {
        return {
          ListValue(node) {
            const type = (0, _definition.getNullableType)(
              context.getParentInputType()
            );
            if (!(0, _definition.isListType)(type)) {
              isValidValueNode(context, node);
              return false;
            }
          },
          ObjectValue(node) {
            const type = (0, _definition.getNamedType)(context.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
              isValidValueNode(context, node);
              return false;
            }
            const fieldNodeMap = (0, _keyMap.keyMap)(
              node.fields,
              (field) => field.name.value
            );
            for (const fieldDef of Object.values(type.getFields())) {
              const fieldNode = fieldNodeMap[fieldDef.name];
              if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                const typeStr = (0, _inspect.inspect)(fieldDef.type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          },
          ObjectField(node) {
            const parentType = (0, _definition.getNamedType)(
              context.getParentInputType()
            );
            const fieldType = context.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
              const suggestions = (0, _suggestionList.suggestionList)(
                node.name.value,
                Object.keys(parentType.getFields())
              );
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          NullValue(node) {
            const type = context.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Expected value of type "${(0, _inspect.inspect)(
                    type
                  )}", found ${(0, _printer.print)(node)}.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          EnumValue: (node) => isValidValueNode(context, node),
          IntValue: (node) => isValidValueNode(context, node),
          FloatValue: (node) => isValidValueNode(context, node),
          StringValue: (node) => isValidValueNode(context, node),
          BooleanValue: (node) => isValidValueNode(context, node)
        };
      }
      function isValidValueNode(context, node) {
        const locationType = context.getInputType();
        if (!locationType) {
          return;
        }
        const type = (0, _definition.getNamedType)(locationType);
        if (!(0, _definition.isLeafType)(type)) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
          return;
        }
        try {
          const parseResult = type.parseLiteral(
            node,
            void 0
          );
          if (parseResult === void 0) {
            const typeStr = (0, _inspect.inspect)(locationType);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                  node
                )}.`,
                {
                  nodes: node
                }
              )
            );
          }
        } catch (error) {
          const typeStr = (0, _inspect.inspect)(locationType);
          if (error instanceof _GraphQLError.GraphQLError) {
            context.reportError(error);
          } else {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                  node
                )}; ` + error.message,
                {
                  nodes: node,
                  originalError: error
                }
              )
            );
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
  var require_VariablesAreInputTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function VariablesAreInputTypesRule(context) {
        return {
          VariableDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(
              context.getSchema(),
              node.type
            );
            if (type !== void 0 && !(0, _definition.isInputType)(type)) {
              const variableName = node.variable.name.value;
              const typeName = (0, _printer.print)(node.type);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                  {
                    nodes: node.type
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
  var require_VariablesInAllowedPositionRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function VariablesInAllowedPositionRule(context) {
        let varDefMap = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              varDefMap = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node, type, defaultValue } of usages) {
                const varName = node.name.value;
                const varDef = varDefMap[varName];
                if (varDef && type) {
                  const schema = context.getSchema();
                  const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                  if (varType && !allowedVariableUsage(
                    schema,
                    varType,
                    varDef.defaultValue,
                    type,
                    defaultValue
                  )) {
                    const varTypeStr = (0, _inspect.inspect)(varType);
                    const typeStr = (0, _inspect.inspect)(type);
                    context.reportError(
                      new _GraphQLError.GraphQLError(
                        `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                        {
                          nodes: [varDef, node]
                        }
                      )
                    );
                  }
                }
              }
            }
          },
          VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
          }
        };
      }
      function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
        if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
          const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
          const hasLocationDefaultValue = locationDefaultValue !== void 0;
          if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
          }
          const nullableLocationType = locationType.ofType;
          return (0, _typeComparators.isTypeSubTypeOf)(
            schema,
            varType,
            nullableLocationType
          );
        }
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/specifiedRules.js
  var require_specifiedRules = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/specifiedRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.specifiedSDLRules = exports.specifiedRules = void 0;
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var specifiedRules = Object.freeze([
        _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
        _UniqueOperationNamesRule.UniqueOperationNamesRule,
        _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
        _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
        _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
        _ScalarLeafsRule.ScalarLeafsRule,
        _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
        _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
        _KnownFragmentNamesRule.KnownFragmentNamesRule,
        _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
        _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
        _NoFragmentCyclesRule.NoFragmentCyclesRule,
        _UniqueVariableNamesRule.UniqueVariableNamesRule,
        _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
        _NoUnusedVariablesRule.NoUnusedVariablesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _KnownArgumentNamesRule.KnownArgumentNamesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
        _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
        _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
      ]);
      exports.specifiedRules = specifiedRules;
      var specifiedSDLRules = Object.freeze([
        _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
        _UniqueOperationTypesRule.UniqueOperationTypesRule,
        _UniqueTypeNamesRule.UniqueTypeNamesRule,
        _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
        _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
        _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
        _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
        _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
      ]);
      exports.specifiedSDLRules = specifiedSDLRules;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/ValidationContext.js
  var require_ValidationContext = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/ValidationContext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _TypeInfo = require_TypeInfo();
      var ASTValidationContext = class {
        constructor(ast, onError) {
          this._ast = ast;
          this._fragments = void 0;
          this._fragmentSpreads = /* @__PURE__ */ new Map();
          this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
          this._onError = onError;
        }
        get [Symbol.toStringTag]() {
          return "ASTValidationContext";
        }
        reportError(error) {
          this._onError(error);
        }
        getDocument() {
          return this._ast;
        }
        getFragment(name) {
          let fragments;
          if (this._fragments) {
            fragments = this._fragments;
          } else {
            fragments = /* @__PURE__ */ Object.create(null);
            for (const defNode of this.getDocument().definitions) {
              if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[defNode.name.value] = defNode;
              }
            }
            this._fragments = fragments;
          }
          return fragments[name];
        }
        getFragmentSpreads(node) {
          let spreads = this._fragmentSpreads.get(node);
          if (!spreads) {
            spreads = [];
            const setsToVisit = [node];
            let set;
            while (set = setsToVisit.pop()) {
              for (const selection of set.selections) {
                if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                  spreads.push(selection);
                } else if (selection.selectionSet) {
                  setsToVisit.push(selection.selectionSet);
                }
              }
            }
            this._fragmentSpreads.set(node, spreads);
          }
          return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
          let fragments = this._recursivelyReferencedFragments.get(operation);
          if (!fragments) {
            fragments = [];
            const collectedNames = /* @__PURE__ */ Object.create(null);
            const nodesToVisit = [operation.selectionSet];
            let node;
            while (node = nodesToVisit.pop()) {
              for (const spread of this.getFragmentSpreads(node)) {
                const fragName = spread.name.value;
                if (collectedNames[fragName] !== true) {
                  collectedNames[fragName] = true;
                  const fragment = this.getFragment(fragName);
                  if (fragment) {
                    fragments.push(fragment);
                    nodesToVisit.push(fragment.selectionSet);
                  }
                }
              }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
          }
          return fragments;
        }
      };
      exports.ASTValidationContext = ASTValidationContext;
      var SDLValidationContext = class extends ASTValidationContext {
        constructor(ast, schema, onError) {
          super(ast, onError);
          this._schema = schema;
        }
        get [Symbol.toStringTag]() {
          return "SDLValidationContext";
        }
        getSchema() {
          return this._schema;
        }
      };
      exports.SDLValidationContext = SDLValidationContext;
      var ValidationContext = class extends ASTValidationContext {
        constructor(schema, ast, typeInfo, onError) {
          super(ast, onError);
          this._schema = schema;
          this._typeInfo = typeInfo;
          this._variableUsages = /* @__PURE__ */ new Map();
          this._recursiveVariableUsages = /* @__PURE__ */ new Map();
        }
        get [Symbol.toStringTag]() {
          return "ValidationContext";
        }
        getSchema() {
          return this._schema;
        }
        getVariableUsages(node) {
          let usages = this._variableUsages.get(node);
          if (!usages) {
            const newUsages = [];
            const typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(
              node,
              (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
                VariableDefinition: () => false,
                Variable(variable) {
                  newUsages.push({
                    node: variable,
                    type: typeInfo.getInputType(),
                    defaultValue: typeInfo.getDefaultValue()
                  });
                }
              })
            );
            usages = newUsages;
            this._variableUsages.set(node, usages);
          }
          return usages;
        }
        getRecursiveVariableUsages(operation) {
          let usages = this._recursiveVariableUsages.get(operation);
          if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)) {
              usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
          }
          return usages;
        }
        getType() {
          return this._typeInfo.getType();
        }
        getParentType() {
          return this._typeInfo.getParentType();
        }
        getInputType() {
          return this._typeInfo.getInputType();
        }
        getParentInputType() {
          return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
          return this._typeInfo.getFieldDef();
        }
        getDirective() {
          return this._typeInfo.getDirective();
        }
        getArgument() {
          return this._typeInfo.getArgument();
        }
        getEnumValue() {
          return this._typeInfo.getEnumValue();
        }
      };
      exports.ValidationContext = ValidationContext;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/validate.js
  var require_validate2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSDL = assertValidSDL;
      exports.assertValidSDLExtension = assertValidSDLExtension;
      exports.validate = validate;
      exports.validateSDL = validateSDL;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _visitor = require_visitor();
      var _validate = require_validate();
      var _TypeInfo = require_TypeInfo();
      var _specifiedRules = require_specifiedRules();
      var _ValidationContext = require_ValidationContext();
      function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
        var _options$maxErrors;
        const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
        documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        const abortObj = Object.freeze({});
        const errors = [];
        const context = new _ValidationContext.ValidationContext(
          schema,
          documentAST,
          typeInfo,
          (error) => {
            if (errors.length >= maxErrors) {
              errors.push(
                new _GraphQLError.GraphQLError(
                  "Too many validation errors, error limit reached. Validation aborted."
                )
              );
              throw abortObj;
            }
            errors.push(error);
          }
        );
        const visitor = (0, _visitor.visitInParallel)(
          rules.map((rule) => rule(context))
        );
        try {
          (0, _visitor.visit)(
            documentAST,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
          );
        } catch (e) {
          if (e !== abortObj) {
            throw e;
          }
        }
        return errors;
      }
      function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
        const errors = [];
        const context = new _ValidationContext.SDLValidationContext(
          documentAST,
          schemaToExtend,
          (error) => {
            errors.push(error);
          }
        );
        const visitors = rules.map((rule) => rule(context));
        (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
        return errors;
      }
      function assertValidSDL(documentAST) {
        const errors = validateSDL(documentAST);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      function assertValidSDLExtension(documentAST, schema) {
        const errors = validateSDL(documentAST, schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/memoize3.js
  var require_memoize3 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/memoize3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.memoize3 = memoize3;
      function memoize3(fn) {
        let cache0;
        return function memoized(a1, a2, a3) {
          if (cache0 === void 0) {
            cache0 = /* @__PURE__ */ new WeakMap();
          }
          let cache1 = cache0.get(a1);
          if (cache1 === void 0) {
            cache1 = /* @__PURE__ */ new WeakMap();
            cache0.set(a1, cache1);
          }
          let cache2 = cache1.get(a2);
          if (cache2 === void 0) {
            cache2 = /* @__PURE__ */ new WeakMap();
            cache1.set(a2, cache2);
          }
          let fnResult = cache2.get(a3);
          if (fnResult === void 0) {
            fnResult = fn(a1, a2, a3);
            cache2.set(a3, fnResult);
          }
          return fnResult;
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/promiseForObject.js
  var require_promiseForObject = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/promiseForObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseForObject = promiseForObject;
      function promiseForObject(object) {
        return Promise.all(Object.values(object)).then((resolvedValues) => {
          const resolvedObject = /* @__PURE__ */ Object.create(null);
          for (const [i, key] of Object.keys(object).entries()) {
            resolvedObject[key] = resolvedValues[i];
          }
          return resolvedObject;
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/promiseReduce.js
  var require_promiseReduce = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/promiseReduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseReduce = promiseReduce;
      var _isPromise = require_isPromise();
      function promiseReduce(values, callbackFn, initialValue) {
        let accumulator = initialValue;
        for (const value of values) {
          accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
        }
        return accumulator;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/toError.js
  var require_toError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/toError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toError = toError;
      var _inspect = require_inspect();
      function toError(thrownValue) {
        return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
      }
      var NonErrorThrown = class extends Error {
        constructor(thrownValue) {
          super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
          this.name = "NonErrorThrown";
          this.thrownValue = thrownValue;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/locatedError.js
  var require_locatedError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/locatedError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.locatedError = locatedError;
      var _toError = require_toError();
      var _GraphQLError = require_GraphQLError();
      function locatedError(rawOriginalError, nodes, path) {
        var _nodes;
        const originalError = (0, _toError.toError)(rawOriginalError);
        if (isLocatedGraphQLError(originalError)) {
          return originalError;
        }
        return new _GraphQLError.GraphQLError(originalError.message, {
          nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
          source: originalError.source,
          positions: originalError.positions,
          path,
          originalError
        });
      }
      function isLocatedGraphQLError(error) {
        return Array.isArray(error.path);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/execute.js
  var require_execute = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/execute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidExecutionArguments = assertValidExecutionArguments;
      exports.buildExecutionContext = buildExecutionContext;
      exports.buildResolveInfo = buildResolveInfo;
      exports.defaultTypeResolver = exports.defaultFieldResolver = void 0;
      exports.execute = execute;
      exports.executeSync = executeSync;
      exports.getFieldDef = getFieldDef;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _isPromise = require_isPromise();
      var _memoize = require_memoize3();
      var _Path = require_Path();
      var _promiseForObject = require_promiseForObject();
      var _promiseReduce = require_promiseReduce();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _collectFields = require_collectFields();
      var _values = require_values();
      var collectSubfields = (0, _memoize.memoize3)(
        (exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(
          exeContext.schema,
          exeContext.fragments,
          exeContext.variableValues,
          returnType,
          fieldNodes
        )
      );
      function execute(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(
          false,
          "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
        );
        const { schema, document, variableValues, rootValue } = args;
        assertValidExecutionArguments(schema, document, variableValues);
        const exeContext = buildExecutionContext(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const { operation } = exeContext;
          const result = executeOperation(exeContext, operation, rootValue);
          if ((0, _isPromise.isPromise)(result)) {
            return result.then(
              (data) => buildResponse(data, exeContext.errors),
              (error) => {
                exeContext.errors.push(error);
                return buildResponse(null, exeContext.errors);
              }
            );
          }
          return buildResponse(result, exeContext.errors);
        } catch (error) {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      }
      function executeSync(args) {
        const result = execute(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function buildResponse(data, errors) {
        return errors.length === 0 ? {
          data
        } : {
          errors,
          data
        };
      }
      function assertValidExecutionArguments(schema, document, rawVariableValues) {
        document || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(
          false,
          "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
        );
      }
      function buildExecutionContext(args) {
        var _definition$name, _operation$variableDe;
        const {
          schema,
          document,
          rootValue,
          contextValue,
          variableValues: rawVariableValues,
          operationName,
          fieldResolver,
          typeResolver,
          subscribeFieldResolver
        } = args;
        let operation;
        const fragments = /* @__PURE__ */ Object.create(null);
        for (const definition of document.definitions) {
          switch (definition.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              if (operationName == null) {
                if (operation !== void 0) {
                  return [
                    new _GraphQLError.GraphQLError(
                      "Must provide operation name if query contains multiple operations."
                    )
                  ];
                }
                operation = definition;
              } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                operation = definition;
              }
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              fragments[definition.name.value] = definition;
              break;
            default:
          }
        }
        if (!operation) {
          if (operationName != null) {
            return [
              new _GraphQLError.GraphQLError(
                `Unknown operation named "${operationName}".`
              )
            ];
          }
          return [new _GraphQLError.GraphQLError("Must provide an operation.")];
        }
        const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
        const coercedVariableValues = (0, _values.getVariableValues)(
          schema,
          variableDefinitions,
          rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
          {
            maxErrors: 50
          }
        );
        if (coercedVariableValues.errors) {
          return coercedVariableValues.errors;
        }
        return {
          schema,
          fragments,
          rootValue,
          contextValue,
          operation,
          variableValues: coercedVariableValues.coerced,
          fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
          typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
          subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
          errors: []
        };
      }
      function executeOperation(exeContext, operation, rootValue) {
        const rootType = exeContext.schema.getRootType(operation.operation);
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError(
            `Schema is not configured to execute ${operation.operation} operation.`,
            {
              nodes: operation
            }
          );
        }
        const rootFields = (0, _collectFields.collectFields)(
          exeContext.schema,
          exeContext.fragments,
          exeContext.variableValues,
          rootType,
          operation.selectionSet
        );
        const path = void 0;
        switch (operation.operation) {
          case _ast.OperationTypeNode.QUERY:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
          case _ast.OperationTypeNode.MUTATION:
            return executeFieldsSerially(
              exeContext,
              rootType,
              rootValue,
              path,
              rootFields
            );
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
        }
      }
      function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
        return (0, _promiseReduce.promiseReduce)(
          fields.entries(),
          (results, [responseName, fieldNodes]) => {
            const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
            const result = executeField(
              exeContext,
              parentType,
              sourceValue,
              fieldNodes,
              fieldPath
            );
            if (result === void 0) {
              return results;
            }
            if ((0, _isPromise.isPromise)(result)) {
              return result.then((resolvedResult) => {
                results[responseName] = resolvedResult;
                return results;
              });
            }
            results[responseName] = result;
            return results;
          },
          /* @__PURE__ */ Object.create(null)
        );
      }
      function executeFields(exeContext, parentType, sourceValue, path, fields) {
        const results = /* @__PURE__ */ Object.create(null);
        let containsPromise = false;
        for (const [responseName, fieldNodes] of fields.entries()) {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result !== void 0) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
              containsPromise = true;
            }
          }
        }
        if (!containsPromise) {
          return results;
        }
        return (0, _promiseForObject.promiseForObject)(results);
      }
      function executeField(exeContext, parentType, source, fieldNodes, path) {
        var _fieldDef$resolve;
        const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
        if (!fieldDef) {
          return;
        }
        const returnType = fieldDef.type;
        const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
        const info = buildResolveInfo(
          exeContext,
          fieldDef,
          fieldNodes,
          parentType,
          path
        );
        try {
          const args = (0, _values.getArgumentValues)(
            fieldDef,
            fieldNodes[0],
            exeContext.variableValues
          );
          const contextValue = exeContext.contextValue;
          const result = resolveFn(source, args, contextValue, info);
          let completed;
          if ((0, _isPromise.isPromise)(result)) {
            completed = result.then(
              (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
            );
          } else {
            completed = completeValue(
              exeContext,
              returnType,
              fieldNodes,
              info,
              path,
              result
            );
          }
          if ((0, _isPromise.isPromise)(completed)) {
            return completed.then(void 0, (rawError) => {
              const error = (0, _locatedError.locatedError)(
                rawError,
                fieldNodes,
                (0, _Path.pathToArray)(path)
              );
              return handleFieldError(error, returnType, exeContext);
            });
          }
          return completed;
        } catch (rawError) {
          const error = (0, _locatedError.locatedError)(
            rawError,
            fieldNodes,
            (0, _Path.pathToArray)(path)
          );
          return handleFieldError(error, returnType, exeContext);
        }
      }
      function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
        return {
          fieldName: fieldDef.name,
          fieldNodes,
          returnType: fieldDef.type,
          parentType,
          path,
          schema: exeContext.schema,
          fragments: exeContext.fragments,
          rootValue: exeContext.rootValue,
          operation: exeContext.operation,
          variableValues: exeContext.variableValues
        };
      }
      function handleFieldError(error, returnType, exeContext) {
        if ((0, _definition.isNonNullType)(returnType)) {
          throw error;
        }
        exeContext.errors.push(error);
        return null;
      }
      function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (result instanceof Error) {
          throw result;
        }
        if ((0, _definition.isNonNullType)(returnType)) {
          const completed = completeValue(
            exeContext,
            returnType.ofType,
            fieldNodes,
            info,
            path,
            result
          );
          if (completed === null) {
            throw new Error(
              `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
            );
          }
          return completed;
        }
        if (result == null) {
          return null;
        }
        if ((0, _definition.isListType)(returnType)) {
          return completeListValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        if ((0, _definition.isLeafType)(returnType)) {
          return completeLeafValue(returnType, result);
        }
        if ((0, _definition.isAbstractType)(returnType)) {
          return completeAbstractValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        if ((0, _definition.isObjectType)(returnType)) {
          return completeObjectValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        (0, _invariant.invariant)(
          false,
          "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType)
        );
      }
      function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (!(0, _isIterableObject.isIterableObject)(result)) {
          throw new _GraphQLError.GraphQLError(
            `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
          );
        }
        const itemType = returnType.ofType;
        let containsPromise = false;
        const completedResults = Array.from(result, (item, index) => {
          const itemPath = (0, _Path.addPath)(path, index, void 0);
          try {
            let completedItem;
            if ((0, _isPromise.isPromise)(item)) {
              completedItem = item.then(
                (resolved) => completeValue(
                  exeContext,
                  itemType,
                  fieldNodes,
                  info,
                  itemPath,
                  resolved
                )
              );
            } else {
              completedItem = completeValue(
                exeContext,
                itemType,
                fieldNodes,
                info,
                itemPath,
                item
              );
            }
            if ((0, _isPromise.isPromise)(completedItem)) {
              containsPromise = true;
              return completedItem.then(void 0, (rawError) => {
                const error = (0, _locatedError.locatedError)(
                  rawError,
                  fieldNodes,
                  (0, _Path.pathToArray)(itemPath)
                );
                return handleFieldError(error, itemType, exeContext);
              });
            }
            return completedItem;
          } catch (rawError) {
            const error = (0, _locatedError.locatedError)(
              rawError,
              fieldNodes,
              (0, _Path.pathToArray)(itemPath)
            );
            return handleFieldError(error, itemType, exeContext);
          }
        });
        return containsPromise ? Promise.all(completedResults) : completedResults;
      }
      function completeLeafValue(returnType, result) {
        const serializedResult = returnType.serialize(result);
        if (serializedResult == null) {
          throw new Error(
            `Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(
              serializedResult
            )}`
          );
        }
        return serializedResult;
      }
      function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
        var _returnType$resolveTy;
        const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
        const contextValue = exeContext.contextValue;
        const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
        if ((0, _isPromise.isPromise)(runtimeType)) {
          return runtimeType.then(
            (resolvedRuntimeType) => completeObjectValue(
              exeContext,
              ensureValidRuntimeType(
                resolvedRuntimeType,
                exeContext,
                returnType,
                fieldNodes,
                info,
                result
              ),
              fieldNodes,
              info,
              path,
              result
            )
          );
        }
        return completeObjectValue(
          exeContext,
          ensureValidRuntimeType(
            runtimeType,
            exeContext,
            returnType,
            fieldNodes,
            info,
            result
          ),
          fieldNodes,
          info,
          path,
          result
        );
      }
      function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
        if (runtimeTypeName == null) {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
            fieldNodes
          );
        }
        if ((0, _definition.isObjectType)(runtimeTypeName)) {
          throw new _GraphQLError.GraphQLError(
            "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
          );
        }
        if (typeof runtimeTypeName !== "string") {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`
          );
        }
        const runtimeType = exeContext.schema.getType(runtimeTypeName);
        if (runtimeType == null) {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
            {
              nodes: fieldNodes
            }
          );
        }
        if (!(0, _definition.isObjectType)(runtimeType)) {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
            {
              nodes: fieldNodes
            }
          );
        }
        if (!exeContext.schema.isSubType(returnType, runtimeType)) {
          throw new _GraphQLError.GraphQLError(
            `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
            {
              nodes: fieldNodes
            }
          );
        }
        return runtimeType;
      }
      function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
        const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
        if (returnType.isTypeOf) {
          const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf) => {
              if (!resolvedIsTypeOf) {
                throw invalidReturnTypeError(returnType, result, fieldNodes);
              }
              return executeFields(
                exeContext,
                returnType,
                result,
                path,
                subFieldNodes
              );
            });
          }
          if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
        }
        return executeFields(exeContext, returnType, result, path, subFieldNodes);
      }
      function invalidReturnTypeError(returnType, result, fieldNodes) {
        return new _GraphQLError.GraphQLError(
          `Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`,
          {
            nodes: fieldNodes
          }
        );
      }
      var defaultTypeResolver = function(value, contextValue, info, abstractType) {
        if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
          return value.__typename;
        }
        const possibleTypes = info.schema.getPossibleTypes(abstractType);
        const promisedIsTypeOfResults = [];
        for (let i = 0; i < possibleTypes.length; i++) {
          const type = possibleTypes[i];
          if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if ((0, _isPromise.isPromise)(isTypeOfResult)) {
              promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
              return type.name;
            }
          }
        }
        if (promisedIsTypeOfResults.length) {
          return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
            for (let i = 0; i < isTypeOfResults.length; i++) {
              if (isTypeOfResults[i]) {
                return possibleTypes[i].name;
              }
            }
          });
        }
      };
      exports.defaultTypeResolver = defaultTypeResolver;
      var defaultFieldResolver = function(source, args, contextValue, info) {
        if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
          const property = source[info.fieldName];
          if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
          }
          return property;
        }
      };
      exports.defaultFieldResolver = defaultFieldResolver;
      function getFieldDef(schema, parentType, fieldNode) {
        const fieldName = fieldNode.name.value;
        if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
          return _introspection.TypeNameMetaFieldDef;
        }
        return parentType.getFields()[fieldName];
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/graphql.js
  var require_graphql = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/graphql.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.graphql = graphql;
      exports.graphqlSync = graphqlSync;
      var _devAssert = require_devAssert();
      var _isPromise = require_isPromise();
      var _parser = require_parser();
      var _validate = require_validate();
      var _validate2 = require_validate2();
      var _execute = require_execute();
      function graphql(args) {
        return new Promise((resolve2) => resolve2(graphqlImpl(args)));
      }
      function graphqlSync(args) {
        const result = graphqlImpl(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function graphqlImpl(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(
          false,
          "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
        );
        const {
          schema,
          source,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        } = args;
        const schemaValidationErrors = (0, _validate.validateSchema)(schema);
        if (schemaValidationErrors.length > 0) {
          return {
            errors: schemaValidationErrors
          };
        }
        let document;
        try {
          document = (0, _parser.parse)(source);
        } catch (syntaxError) {
          return {
            errors: [syntaxError]
          };
        }
        const validationErrors = (0, _validate2.validate)(schema, document);
        if (validationErrors.length > 0) {
          return {
            errors: validationErrors
          };
        }
        return (0, _execute.execute)({
          schema,
          document,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/index.js
  var require_type = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/type/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _directives.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _schema.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _introspection.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _introspection.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _introspection.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _introspection.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _introspection.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _introspection.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _introspection.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _directives.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _definition.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _assertName.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _definition.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _definition.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _assertName.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _definition.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _definition.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _definition.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _definition.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _schema.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _definition.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _definition.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _validate.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _definition.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _definition.getNullableType;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _introspection.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _directives.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _definition.isEnumType;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _definition.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _introspection.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _definition.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _definition.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _definition.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _definition.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _definition.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _definition.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _schema.isSchema;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _directives.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _scalars.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _definition.isType;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _definition.isUnionType;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.isWrappingType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _directives.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _scalars.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _validate.validateSchema;
        }
      });
      var _schema = require_schema();
      var _definition = require_definition();
      var _directives = require_directives();
      var _scalars = require_scalars();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _assertName = require_assertName();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/index.js
  var require_language = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _visitor.BREAK;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _directiveLocation.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _kinds.Kind;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _lexer.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _ast.Location;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _ast.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _source.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _ast.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _tokenKind.TokenKind;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _visitor.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _location.getLocation;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _visitor.getVisitFn;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isValueNode;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _parser.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _parser.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _parser.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _parser.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _printer.print;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printLocation;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _visitor.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _visitor.visitInParallel;
        }
      });
      var _source = require_source();
      var _location = require_location();
      var _printLocation = require_printLocation();
      var _kinds = require_kinds();
      var _tokenKind = require_tokenKind();
      var _lexer = require_lexer();
      var _parser = require_parser();
      var _printer = require_printer();
      var _visitor = require_visitor();
      var _ast = require_ast();
      var _predicates = require_predicates();
      var _directiveLocation = require_directiveLocation();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAsyncIterable = isAsyncIterable;
      function isAsyncIterable(maybeAsyncIterable) {
        return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/mapAsyncIterator.js
  var require_mapAsyncIterator = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/mapAsyncIterator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapAsyncIterator = mapAsyncIterator;
      function mapAsyncIterator(iterable, callback) {
        const iterator = iterable[Symbol.asyncIterator]();
        async function mapResult(result) {
          if (result.done) {
            return result;
          }
          try {
            return {
              value: await callback(result.value),
              done: false
            };
          } catch (error) {
            if (typeof iterator.return === "function") {
              try {
                await iterator.return();
              } catch (_e) {
              }
            }
            throw error;
          }
        }
        return {
          async next() {
            return mapResult(await iterator.next());
          },
          async return() {
            return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
              value: void 0,
              done: true
            };
          },
          async throw(error) {
            if (typeof iterator.throw === "function") {
              return mapResult(await iterator.throw(error));
            }
            throw error;
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/subscribe.js
  var require_subscribe = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/subscribe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSourceEventStream = createSourceEventStream;
      exports.subscribe = subscribe;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isAsyncIterable = require_isAsyncIterable();
      var _Path = require_Path();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _collectFields = require_collectFields();
      var _execute = require_execute();
      var _mapAsyncIterator = require_mapAsyncIterator();
      var _values = require_values();
      async function subscribe(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(
          false,
          "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
        );
        const resultOrStream = await createSourceEventStream(args);
        if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
          return resultOrStream;
        }
        const mapSourceToResponse = (payload) => (0, _execute.execute)({ ...args, rootValue: payload });
        return (0, _mapAsyncIterator.mapAsyncIterator)(
          resultOrStream,
          mapSourceToResponse
        );
      }
      function toNormalizedArgs(args) {
        const firstArg = args[0];
        if (firstArg && "document" in firstArg) {
          return firstArg;
        }
        return {
          schema: firstArg,
          document: args[1],
          rootValue: args[2],
          contextValue: args[3],
          variableValues: args[4],
          operationName: args[5],
          subscribeFieldResolver: args[6]
        };
      }
      async function createSourceEventStream(...rawArgs) {
        const args = toNormalizedArgs(rawArgs);
        const { schema, document, variableValues } = args;
        (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
        const exeContext = (0, _execute.buildExecutionContext)(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const eventStream = await executeSubscription(exeContext);
          if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
            throw new Error(
              `Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`
            );
          }
          return eventStream;
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            return {
              errors: [error]
            };
          }
          throw error;
        }
      }
      async function executeSubscription(exeContext) {
        const { schema, fragments, operation, variableValues, rootValue } = exeContext;
        const rootType = schema.getSubscriptionType();
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured to execute subscription operation.",
            {
              nodes: operation
            }
          );
        }
        const rootFields = (0, _collectFields.collectFields)(
          schema,
          fragments,
          variableValues,
          rootType,
          operation.selectionSet
        );
        const [responseName, fieldNodes] = [...rootFields.entries()][0];
        const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
        if (!fieldDef) {
          const fieldName = fieldNodes[0].name.value;
          throw new _GraphQLError.GraphQLError(
            `The subscription field "${fieldName}" is not defined.`,
            {
              nodes: fieldNodes
            }
          );
        }
        const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
        const info = (0, _execute.buildResolveInfo)(
          exeContext,
          fieldDef,
          fieldNodes,
          rootType,
          path
        );
        try {
          var _fieldDef$subscribe;
          const args = (0, _values.getArgumentValues)(
            fieldDef,
            fieldNodes[0],
            variableValues
          );
          const contextValue = exeContext.contextValue;
          const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
          const eventStream = await resolveFn(rootValue, args, contextValue, info);
          if (eventStream instanceof Error) {
            throw eventStream;
          }
          return eventStream;
        } catch (error) {
          throw (0, _locatedError.locatedError)(
            error,
            fieldNodes,
            (0, _Path.pathToArray)(path)
          );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/index.js
  var require_execution = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/execution/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _subscribe.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _execute.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _execute.executeSync;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _values.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _values.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _values.getVariableValues;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _Path.pathToArray;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _subscribe.subscribe;
        }
      });
      var _Path = require_Path();
      var _execute = require_execute();
      var _subscribe = require_subscribe();
      var _values = require_values();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
  var require_NoDeprecatedCustomRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function NoDeprecatedCustomRule(context) {
        return {
          Field(node) {
            const fieldDef = context.getFieldDef();
            const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
            if (fieldDef && deprecationReason != null) {
              const parentType = context.getParentType();
              parentType != null || (0, _invariant.invariant)(false);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          Argument(node) {
            const argDef = context.getArgument();
            const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
            if (argDef && deprecationReason != null) {
              const directiveDef = context.getDirective();
              if (directiveDef != null) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                    {
                      nodes: node
                    }
                  )
                );
              } else {
                const parentType = context.getParentType();
                const fieldDef = context.getFieldDef();
                parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          },
          ObjectField(node) {
            const inputObjectDef = (0, _definition.getNamedType)(
              context.getParentInputType()
            );
            if ((0, _definition.isInputObjectType)(inputObjectDef)) {
              const inputFieldDef = inputObjectDef.getFields()[node.name.value];
              const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
              if (deprecationReason != null) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          },
          EnumValue(node) {
            const enumValueDef = context.getEnumValue();
            const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
            if (enumValueDef && deprecationReason != null) {
              const enumTypeDef = (0, _definition.getNamedType)(
                context.getInputType()
              );
              enumTypeDef != null || (0, _invariant.invariant)(false);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
  var require_NoSchemaIntrospectionCustomRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _introspection = require_introspection();
      function NoSchemaIntrospectionCustomRule(context) {
        return {
          Field(node) {
            const type = (0, _definition.getNamedType)(context.getType());
            if (type && (0, _introspection.isIntrospectionType)(type)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/index.js
  var require_validation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/validation/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownArgumentNamesRule.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _KnownDirectivesRule.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownFragmentNamesRule.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownTypeNamesRule.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _NoFragmentCyclesRule.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedVariablesRule.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _ScalarLeafsRule.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationNamesRule.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationTypesRule.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueTypeNamesRule.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueVariableNamesRule.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _ValidationContext.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _specifiedRules.specifiedRules;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _validate.validate;
        }
      });
      var _validate = require_validate2();
      var _ValidationContext = require_ValidationContext();
      var _specifiedRules = require_specifiedRules();
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
      var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/index.js
  var require_error = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.GraphQLError;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.formatError;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _locatedError.locatedError;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.printError;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _syntaxError.syntaxError;
        }
      });
      var _GraphQLError = require_GraphQLError();
      var _syntaxError = require_syntaxError();
      var _locatedError = require_locatedError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/getIntrospectionQuery.js
  var require_getIntrospectionQuery = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/getIntrospectionQuery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getIntrospectionQuery = getIntrospectionQuery;
      function getIntrospectionQuery(options) {
        const optionsWithDefault = {
          descriptions: true,
          specifiedByUrl: false,
          directiveIsRepeatable: false,
          schemaDescription: false,
          inputValueDeprecation: false,
          ...options
        };
        const descriptions = optionsWithDefault.descriptions ? "description" : "";
        const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
        const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
        const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
        function inputDeprecation(str) {
          return optionsWithDefault.inputValueDeprecation ? str : "";
        }
        return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/getOperationAST.js
  var require_getOperationAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/getOperationAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationAST = getOperationAST;
      var _kinds = require_kinds();
      function getOperationAST(documentAST, operationName) {
        let operation = null;
        for (const definition of documentAST.definitions) {
          if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
            var _definition$name;
            if (operationName == null) {
              if (operation) {
                return null;
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              return definition;
            }
          }
        }
        return operation;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/getOperationRootType.js
  var require_getOperationRootType = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/getOperationRootType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationRootType = getOperationRootType;
      var _GraphQLError = require_GraphQLError();
      function getOperationRootType(schema, operation) {
        if (operation.operation === "query") {
          const queryType = schema.getQueryType();
          if (!queryType) {
            throw new _GraphQLError.GraphQLError(
              "Schema does not define the required query root type.",
              {
                nodes: operation
              }
            );
          }
          return queryType;
        }
        if (operation.operation === "mutation") {
          const mutationType = schema.getMutationType();
          if (!mutationType) {
            throw new _GraphQLError.GraphQLError(
              "Schema is not configured for mutations.",
              {
                nodes: operation
              }
            );
          }
          return mutationType;
        }
        if (operation.operation === "subscription") {
          const subscriptionType = schema.getSubscriptionType();
          if (!subscriptionType) {
            throw new _GraphQLError.GraphQLError(
              "Schema is not configured for subscriptions.",
              {
                nodes: operation
              }
            );
          }
          return subscriptionType;
        }
        throw new _GraphQLError.GraphQLError(
          "Can only have query, mutation and subscription operations.",
          {
            nodes: operation
          }
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/introspectionFromSchema.js
  var require_introspectionFromSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/introspectionFromSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionFromSchema = introspectionFromSchema;
      var _invariant = require_invariant();
      var _parser = require_parser();
      var _execute = require_execute();
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      function introspectionFromSchema(schema, options) {
        const optionsWithDefaults = {
          specifiedByUrl: true,
          directiveIsRepeatable: true,
          schemaDescription: true,
          inputValueDeprecation: true,
          ...options
        };
        const document = (0, _parser.parse)(
          (0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults)
        );
        const result = (0, _execute.executeSync)({
          schema,
          document
        });
        !result.errors && result.data || (0, _invariant.invariant)(false);
        return result.data;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/buildClientSchema.js
  var require_buildClientSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/buildClientSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildClientSchema = buildClientSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _keyValMap = require_keyValMap();
      var _parser = require_parser();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _valueFromAST = require_valueFromAST();
      function buildClientSchema(introspection, options) {
        (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(
          false,
          `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`
        );
        const schemaIntrospection = introspection.__schema;
        const typeMap = (0, _keyValMap.keyValMap)(
          schemaIntrospection.types,
          (typeIntrospection) => typeIntrospection.name,
          (typeIntrospection) => buildType(typeIntrospection)
        );
        for (const stdType of [
          ..._scalars.specifiedScalarTypes,
          ..._introspection.introspectionTypes
        ]) {
          if (typeMap[stdType.name]) {
            typeMap[stdType.name] = stdType;
          }
        }
        const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
        const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
        const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
        const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
        return new _schema.GraphQLSchema({
          description: schemaIntrospection.description,
          query: queryType,
          mutation: mutationType,
          subscription: subscriptionType,
          types: Object.values(typeMap),
          directives,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
        function getType(typeRef) {
          if (typeRef.kind === _introspection.TypeKind.LIST) {
            const itemRef = typeRef.ofType;
            if (!itemRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            return new _definition.GraphQLList(getType(itemRef));
          }
          if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
            const nullableRef = typeRef.ofType;
            if (!nullableRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            const nullableType = getType(nullableRef);
            return new _definition.GraphQLNonNull(
              (0, _definition.assertNullableType)(nullableType)
            );
          }
          return getNamedType(typeRef);
        }
        function getNamedType(typeRef) {
          const typeName = typeRef.name;
          if (!typeName) {
            throw new Error(
              `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`
            );
          }
          const type = typeMap[typeName];
          if (!type) {
            throw new Error(
              `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
            );
          }
          return type;
        }
        function getObjectType(typeRef) {
          return (0, _definition.assertObjectType)(getNamedType(typeRef));
        }
        function getInterfaceType(typeRef) {
          return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
        }
        function buildType(type) {
          if (type != null && type.name != null && type.kind != null) {
            switch (type.kind) {
              case _introspection.TypeKind.SCALAR:
                return buildScalarDef(type);
              case _introspection.TypeKind.OBJECT:
                return buildObjectDef(type);
              case _introspection.TypeKind.INTERFACE:
                return buildInterfaceDef(type);
              case _introspection.TypeKind.UNION:
                return buildUnionDef(type);
              case _introspection.TypeKind.ENUM:
                return buildEnumDef(type);
              case _introspection.TypeKind.INPUT_OBJECT:
                return buildInputObjectDef(type);
            }
          }
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(
            `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
          );
        }
        function buildScalarDef(scalarIntrospection) {
          return new _definition.GraphQLScalarType({
            name: scalarIntrospection.name,
            description: scalarIntrospection.description,
            specifiedByURL: scalarIntrospection.specifiedByURL
          });
        }
        function buildImplementationsList(implementingIntrospection) {
          if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
            return [];
          }
          if (!implementingIntrospection.interfaces) {
            const implementingIntrospectionStr = (0, _inspect.inspect)(
              implementingIntrospection
            );
            throw new Error(
              `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
            );
          }
          return implementingIntrospection.interfaces.map(getInterfaceType);
        }
        function buildObjectDef(objectIntrospection) {
          return new _definition.GraphQLObjectType({
            name: objectIntrospection.name,
            description: objectIntrospection.description,
            interfaces: () => buildImplementationsList(objectIntrospection),
            fields: () => buildFieldDefMap(objectIntrospection)
          });
        }
        function buildInterfaceDef(interfaceIntrospection) {
          return new _definition.GraphQLInterfaceType({
            name: interfaceIntrospection.name,
            description: interfaceIntrospection.description,
            interfaces: () => buildImplementationsList(interfaceIntrospection),
            fields: () => buildFieldDefMap(interfaceIntrospection)
          });
        }
        function buildUnionDef(unionIntrospection) {
          if (!unionIntrospection.possibleTypes) {
            const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
            throw new Error(
              `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
            );
          }
          return new _definition.GraphQLUnionType({
            name: unionIntrospection.name,
            description: unionIntrospection.description,
            types: () => unionIntrospection.possibleTypes.map(getObjectType)
          });
        }
        function buildEnumDef(enumIntrospection) {
          if (!enumIntrospection.enumValues) {
            const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
            throw new Error(
              `Introspection result missing enumValues: ${enumIntrospectionStr}.`
            );
          }
          return new _definition.GraphQLEnumType({
            name: enumIntrospection.name,
            description: enumIntrospection.description,
            values: (0, _keyValMap.keyValMap)(
              enumIntrospection.enumValues,
              (valueIntrospection) => valueIntrospection.name,
              (valueIntrospection) => ({
                description: valueIntrospection.description,
                deprecationReason: valueIntrospection.deprecationReason
              })
            )
          });
        }
        function buildInputObjectDef(inputObjectIntrospection) {
          if (!inputObjectIntrospection.inputFields) {
            const inputObjectIntrospectionStr = (0, _inspect.inspect)(
              inputObjectIntrospection
            );
            throw new Error(
              `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
            );
          }
          return new _definition.GraphQLInputObjectType({
            name: inputObjectIntrospection.name,
            description: inputObjectIntrospection.description,
            fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
          });
        }
        function buildFieldDefMap(typeIntrospection) {
          if (!typeIntrospection.fields) {
            throw new Error(
              `Introspection result missing fields: ${(0, _inspect.inspect)(
                typeIntrospection
              )}.`
            );
          }
          return (0, _keyValMap.keyValMap)(
            typeIntrospection.fields,
            (fieldIntrospection) => fieldIntrospection.name,
            buildField
          );
        }
        function buildField(fieldIntrospection) {
          const type = getType(fieldIntrospection.type);
          if (!(0, _definition.isOutputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(
              `Introspection must provide output type for fields, but received: ${typeStr}.`
            );
          }
          if (!fieldIntrospection.args) {
            const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
            throw new Error(
              `Introspection result missing field args: ${fieldIntrospectionStr}.`
            );
          }
          return {
            description: fieldIntrospection.description,
            deprecationReason: fieldIntrospection.deprecationReason,
            type,
            args: buildInputValueDefMap(fieldIntrospection.args)
          };
        }
        function buildInputValueDefMap(inputValueIntrospections) {
          return (0, _keyValMap.keyValMap)(
            inputValueIntrospections,
            (inputValue) => inputValue.name,
            buildInputValue
          );
        }
        function buildInputValue(inputValueIntrospection) {
          const type = getType(inputValueIntrospection.type);
          if (!(0, _definition.isInputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(
              `Introspection must provide input type for arguments, but received: ${typeStr}.`
            );
          }
          const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)(
            (0, _parser.parseValue)(inputValueIntrospection.defaultValue),
            type
          ) : void 0;
          return {
            description: inputValueIntrospection.description,
            type,
            defaultValue,
            deprecationReason: inputValueIntrospection.deprecationReason
          };
        }
        function buildDirective(directiveIntrospection) {
          if (!directiveIntrospection.args) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(
              directiveIntrospection
            );
            throw new Error(
              `Introspection result missing directive args: ${directiveIntrospectionStr}.`
            );
          }
          if (!directiveIntrospection.locations) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(
              directiveIntrospection
            );
            throw new Error(
              `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
            );
          }
          return new _directives.GraphQLDirective({
            name: directiveIntrospection.name,
            description: directiveIntrospection.description,
            isRepeatable: directiveIntrospection.isRepeatable,
            locations: directiveIntrospection.locations.slice(),
            args: buildInputValueDefMap(directiveIntrospection.args)
          });
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/extendSchema.js
  var require_extendSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/extendSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.extendSchema = extendSchema;
      exports.extendSchemaImpl = extendSchemaImpl;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _mapValue = require_mapValue();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _values = require_values();
      var _valueFromAST = require_valueFromAST();
      function extendSchema(schema, documentAST, options) {
        (0, _schema.assertSchema)(schema);
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDLExtension)(documentAST, schema);
        }
        const schemaConfig = schema.toConfig();
        const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
        return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
      }
      function extendSchemaImpl(schemaConfig, documentAST, options) {
        var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
        const typeDefs = [];
        const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
        const directiveDefs = [];
        let schemaDef;
        const schemaExtensions = [];
        for (const def of documentAST.definitions) {
          if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
            schemaDef = def;
          } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(def);
          } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
            typeDefs.push(def);
          } else if ((0, _predicates.isTypeExtensionNode)(def)) {
            const extendedTypeName = def.name.value;
            const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
            typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
          } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            directiveDefs.push(def);
          }
        }
        if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
          return schemaConfig;
        }
        const typeMap = /* @__PURE__ */ Object.create(null);
        for (const existingType of schemaConfig.types) {
          typeMap[existingType.name] = extendNamedType(existingType);
        }
        for (const typeNode of typeDefs) {
          var _stdTypeMap$name;
          const name = typeNode.name.value;
          typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
        }
        const operationTypes = {
          query: schemaConfig.query && replaceNamedType(schemaConfig.query),
          mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
          subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
          ...schemaDef && getOperationTypes([schemaDef]),
          ...getOperationTypes(schemaExtensions)
        };
        return {
          description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
          ...operationTypes,
          types: Object.values(typeMap),
          directives: [
            ...schemaConfig.directives.map(replaceDirective),
            ...directiveDefs.map(buildDirective)
          ],
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
          extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
          assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
        };
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          }
          if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            args: (0, _mapValue.mapValue)(config.args, extendArg)
          });
        }
        function extendNamedType(type) {
          if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
            return type;
          }
          if ((0, _definition.isScalarType)(type)) {
            return extendScalarType(type);
          }
          if ((0, _definition.isObjectType)(type)) {
            return extendObjectType(type);
          }
          if ((0, _definition.isInterfaceType)(type)) {
            return extendInterfaceType(type);
          }
          if ((0, _definition.isUnionType)(type)) {
            return extendUnionType(type);
          }
          if ((0, _definition.isEnumType)(type)) {
            return extendEnumType(type);
          }
          if ((0, _definition.isInputObjectType)(type)) {
            return extendInputObjectType(type);
          }
          (0, _invariant.invariant)(
            false,
            "Unexpected type: " + (0, _inspect.inspect)(type)
          );
        }
        function extendInputObjectType(type) {
          var _typeExtensionsMap$co;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
          return new _definition.GraphQLInputObjectType({
            ...config,
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, (field) => ({
                ...field,
                type: replaceType(field.type)
              })),
              ...buildInputFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendEnumType(type) {
          var _typeExtensionsMap$ty;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
          return new _definition.GraphQLEnumType({
            ...config,
            values: { ...config.values, ...buildEnumValueMap(extensions) },
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendScalarType(type) {
          var _typeExtensionsMap$co2;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
          let specifiedByURL = config.specifiedByURL;
          for (const extensionNode of extensions) {
            var _getSpecifiedByURL;
            specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
          }
          return new _definition.GraphQLScalarType({
            ...config,
            specifiedByURL,
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendObjectType(type) {
          var _typeExtensionsMap$co3;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
          return new _definition.GraphQLObjectType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendInterfaceType(type) {
          var _typeExtensionsMap$co4;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
          return new _definition.GraphQLInterfaceType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendUnionType(type) {
          var _typeExtensionsMap$co5;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
          return new _definition.GraphQLUnionType({
            ...config,
            types: () => [
              ...type.getTypes().map(replaceNamedType),
              ...buildUnionTypes(extensions)
            ],
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendField(field) {
          return {
            ...field,
            type: replaceType(field.type),
            args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
          };
        }
        function extendArg(arg) {
          return { ...arg, type: replaceType(arg.type) };
        }
        function getOperationTypes(nodes) {
          const opTypes = {};
          for (const node of nodes) {
            var _node$operationTypes;
            const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
            for (const operationType of operationTypesNodes) {
              opTypes[operationType.operation] = getNamedType(operationType.type);
            }
          }
          return opTypes;
        }
        function getNamedType(node) {
          var _stdTypeMap$name2;
          const name = node.name.value;
          const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
          if (type === void 0) {
            throw new Error(`Unknown type: "${name}".`);
          }
          return type;
        }
        function getWrappedType(node) {
          if (node.kind === _kinds.Kind.LIST_TYPE) {
            return new _definition.GraphQLList(getWrappedType(node.type));
          }
          if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
            return new _definition.GraphQLNonNull(getWrappedType(node.type));
          }
          return getNamedType(node);
        }
        function buildDirective(node) {
          var _node$description;
          return new _directives.GraphQLDirective({
            name: node.name.value,
            description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
            locations: node.locations.map(({ value }) => value),
            isRepeatable: node.repeatable,
            args: buildArgumentMap(node.arguments),
            astNode: node
          });
        }
        function buildFieldMap(nodes) {
          const fieldConfigMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields;
            const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
            for (const field of nodeFields) {
              var _field$description;
              fieldConfigMap[field.name.value] = {
                type: getWrappedType(field.type),
                description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
                args: buildArgumentMap(field.arguments),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return fieldConfigMap;
        }
        function buildArgumentMap(args) {
          const argsNodes = args !== null && args !== void 0 ? args : [];
          const argConfigMap = /* @__PURE__ */ Object.create(null);
          for (const arg of argsNodes) {
            var _arg$description;
            const type = getWrappedType(arg.type);
            argConfigMap[arg.name.value] = {
              type,
              description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
              deprecationReason: getDeprecationReason(arg),
              astNode: arg
            };
          }
          return argConfigMap;
        }
        function buildInputFieldMap(nodes) {
          const inputFieldMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields2;
            const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
            for (const field of fieldsNodes) {
              var _field$description2;
              const type = getWrappedType(field.type);
              inputFieldMap[field.name.value] = {
                type,
                description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
                defaultValue: (0, _valueFromAST.valueFromAST)(
                  field.defaultValue,
                  type
                ),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return inputFieldMap;
        }
        function buildEnumValueMap(nodes) {
          const enumValueMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$values;
            const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
            for (const value of valuesNodes) {
              var _value$description;
              enumValueMap[value.name.value] = {
                description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
                deprecationReason: getDeprecationReason(value),
                astNode: value
              };
            }
          }
          return enumValueMap;
        }
        function buildInterfaces(nodes) {
          return nodes.flatMap(
            (node) => {
              var _node$interfaces$map, _node$interfaces;
              return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
            }
          );
        }
        function buildUnionTypes(nodes) {
          return nodes.flatMap(
            (node) => {
              var _node$types$map, _node$types;
              return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
            }
          );
        }
        function buildType(astNode) {
          var _typeExtensionsMap$na;
          const name = astNode.name.value;
          const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
          switch (astNode.kind) {
            case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
              var _astNode$description;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLObjectType({
                name,
                description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
              var _astNode$description2;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInterfaceType({
                name,
                description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.ENUM_TYPE_DEFINITION: {
              var _astNode$description3;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLEnumType({
                name,
                description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
                values: buildEnumValueMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.UNION_TYPE_DEFINITION: {
              var _astNode$description4;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLUnionType({
                name,
                description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
                types: () => buildUnionTypes(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
              var _astNode$description5;
              return new _definition.GraphQLScalarType({
                name,
                description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
                specifiedByURL: getSpecifiedByURL(astNode),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
              var _astNode$description6;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInputObjectType({
                name,
                description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
                fields: () => buildInputFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
          }
        }
      }
      var stdTypeMap = (0, _keyMap.keyMap)(
        [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],
        (type) => type.name
      );
      function getDeprecationReason(node) {
        const deprecated = (0, _values.getDirectiveValues)(
          _directives.GraphQLDeprecatedDirective,
          node
        );
        return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
      }
      function getSpecifiedByURL(node) {
        const specifiedBy = (0, _values.getDirectiveValues)(
          _directives.GraphQLSpecifiedByDirective,
          node
        );
        return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/buildASTSchema.js
  var require_buildASTSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/buildASTSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildASTSchema = buildASTSchema;
      exports.buildSchema = buildSchema;
      var _devAssert = require_devAssert();
      var _kinds = require_kinds();
      var _parser = require_parser();
      var _directives = require_directives();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _extendSchema = require_extendSchema();
      function buildASTSchema(documentAST, options) {
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDL)(documentAST);
        }
        const emptySchemaConfig = {
          description: void 0,
          types: [],
          directives: [],
          extensions: /* @__PURE__ */ Object.create(null),
          extensionASTNodes: [],
          assumeValid: false
        };
        const config = (0, _extendSchema.extendSchemaImpl)(
          emptySchemaConfig,
          documentAST,
          options
        );
        if (config.astNode == null) {
          for (const type of config.types) {
            switch (type.name) {
              case "Query":
                config.query = type;
                break;
              case "Mutation":
                config.mutation = type;
                break;
              case "Subscription":
                config.subscription = type;
                break;
            }
          }
        }
        const directives = [
          ...config.directives,
          ..._directives.specifiedDirectives.filter(
            (stdDirective) => config.directives.every(
              (directive) => directive.name !== stdDirective.name
            )
          )
        ];
        return new _schema.GraphQLSchema({ ...config, directives });
      }
      function buildSchema(source, options) {
        const document = (0, _parser.parse)(source, {
          noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
          allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
        });
        return buildASTSchema(document, {
          assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/lexicographicSortSchema.js
  var require_lexicographicSortSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/lexicographicSortSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lexicographicSortSchema = lexicographicSortSchema;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyValMap = require_keyValMap();
      var _naturalCompare = require_naturalCompare();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function lexicographicSortSchema(schema) {
        const schemaConfig = schema.toConfig();
        const typeMap = (0, _keyValMap.keyValMap)(
          sortByName(schemaConfig.types),
          (type) => type.name,
          sortNamedType
        );
        return new _schema.GraphQLSchema({
          ...schemaConfig,
          types: Object.values(typeMap),
          directives: sortByName(schemaConfig.directives).map(sortDirective),
          query: replaceMaybeType(schemaConfig.query),
          mutation: replaceMaybeType(schemaConfig.mutation),
          subscription: replaceMaybeType(schemaConfig.subscription)
        });
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          } else if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceMaybeType(maybeType) {
          return maybeType && replaceNamedType(maybeType);
        }
        function sortDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            locations: sortBy(config.locations, (x) => x),
            args: sortArgs(config.args)
          });
        }
        function sortArgs(args) {
          return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
        }
        function sortFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type),
            args: field.args && sortArgs(field.args)
          }));
        }
        function sortInputFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type)
          }));
        }
        function sortTypes(array) {
          return sortByName(array).map(replaceNamedType);
        }
        function sortNamedType(type) {
          if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
            return type;
          }
          if ((0, _definition.isObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLObjectType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isInterfaceType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInterfaceType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isUnionType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLUnionType({
              ...config,
              types: () => sortTypes(config.types)
            });
          }
          if ((0, _definition.isEnumType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLEnumType({
              ...config,
              values: sortObjMap(config.values, (value) => value)
            });
          }
          if ((0, _definition.isInputObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInputObjectType({
              ...config,
              fields: () => sortInputFields(config.fields)
            });
          }
          (0, _invariant.invariant)(
            false,
            "Unexpected type: " + (0, _inspect.inspect)(type)
          );
        }
      }
      function sortObjMap(map, sortValueFn) {
        const sortedMap = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
          sortedMap[key] = sortValueFn(map[key]);
        }
        return sortedMap;
      }
      function sortByName(array) {
        return sortBy(array, (obj) => obj.name);
      }
      function sortBy(array, mapToKey) {
        return array.slice().sort((obj1, obj2) => {
          const key1 = mapToKey(obj1);
          const key2 = mapToKey(obj2);
          return (0, _naturalCompare.naturalCompare)(key1, key2);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/printSchema.js
  var require_printSchema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/printSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printIntrospectionSchema = printIntrospectionSchema;
      exports.printSchema = printSchema;
      exports.printType = printType;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _blockString = require_blockString();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      function printSchema(schema) {
        return printFilteredSchema(
          schema,
          (n) => !(0, _directives.isSpecifiedDirective)(n),
          isDefinedType
        );
      }
      function printIntrospectionSchema(schema) {
        return printFilteredSchema(
          schema,
          _directives.isSpecifiedDirective,
          _introspection.isIntrospectionType
        );
      }
      function isDefinedType(type) {
        return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
      }
      function printFilteredSchema(schema, directiveFilter, typeFilter) {
        const directives = schema.getDirectives().filter(directiveFilter);
        const types = Object.values(schema.getTypeMap()).filter(typeFilter);
        return [
          printSchemaDefinition(schema),
          ...directives.map((directive) => printDirective(directive)),
          ...types.map((type) => printType(type))
        ].filter(Boolean).join("\n\n");
      }
      function printSchemaDefinition(schema) {
        if (schema.description == null && isSchemaOfCommonNames(schema)) {
          return;
        }
        const operationTypes = [];
        const queryType = schema.getQueryType();
        if (queryType) {
          operationTypes.push(`  query: ${queryType.name}`);
        }
        const mutationType = schema.getMutationType();
        if (mutationType) {
          operationTypes.push(`  mutation: ${mutationType.name}`);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          operationTypes.push(`  subscription: ${subscriptionType.name}`);
        }
        return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
      }
      function isSchemaOfCommonNames(schema) {
        const queryType = schema.getQueryType();
        if (queryType && queryType.name !== "Query") {
          return false;
        }
        const mutationType = schema.getMutationType();
        if (mutationType && mutationType.name !== "Mutation") {
          return false;
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && subscriptionType.name !== "Subscription") {
          return false;
        }
        return true;
      }
      function printType(type) {
        if ((0, _definition.isScalarType)(type)) {
          return printScalar(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return printObject(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return printInterface(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return printUnion(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return printEnum(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return printInputObject(type);
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function printScalar(type) {
        return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
      }
      function printImplementedInterfaces(type) {
        const interfaces = type.getInterfaces();
        return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
      }
      function printObject(type) {
        return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printInterface(type) {
        return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printUnion(type) {
        const types = type.getTypes();
        const possibleTypes = types.length ? " = " + types.join(" | ") : "";
        return printDescription(type) + "union " + type.name + possibleTypes;
      }
      function printEnum(type) {
        const values = type.getValues().map(
          (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
        );
        return printDescription(type) + `enum ${type.name}` + printBlock(values);
      }
      function printInputObject(type) {
        const fields = Object.values(type.getFields()).map(
          (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
        );
        return printDescription(type) + `input ${type.name}` + printBlock(fields);
      }
      function printFields(type) {
        const fields = Object.values(type.getFields()).map(
          (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
        );
        return printBlock(fields);
      }
      function printBlock(items) {
        return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
      }
      function printArgs(args, indentation = "") {
        if (args.length === 0) {
          return "";
        }
        if (args.every((arg) => !arg.description)) {
          return "(" + args.map(printInputValue).join(", ") + ")";
        }
        return "(\n" + args.map(
          (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
        ).join("\n") + "\n" + indentation + ")";
      }
      function printInputValue(arg) {
        const defaultAST = (0, _astFromValue.astFromValue)(
          arg.defaultValue,
          arg.type
        );
        let argDecl = arg.name + ": " + String(arg.type);
        if (defaultAST) {
          argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
        }
        return argDecl + printDeprecated(arg.deprecationReason);
      }
      function printDirective(directive) {
        return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
      }
      function printDeprecated(reason) {
        if (reason == null) {
          return "";
        }
        if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
          const astValue = (0, _printer.print)({
            kind: _kinds.Kind.STRING,
            value: reason
          });
          return ` @deprecated(reason: ${astValue})`;
        }
        return " @deprecated";
      }
      function printSpecifiedByURL(scalar) {
        if (scalar.specifiedByURL == null) {
          return "";
        }
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: scalar.specifiedByURL
        });
        return ` @specifiedBy(url: ${astValue})`;
      }
      function printDescription(def, indentation = "", firstInBlock = true) {
        const { description } = def;
        if (description == null) {
          return "";
        }
        const blockString = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: description,
          block: (0, _blockString.isPrintableAsBlockString)(description)
        });
        const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
        return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/concatAST.js
  var require_concatAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/concatAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatAST = concatAST;
      var _kinds = require_kinds();
      function concatAST(documents) {
        const definitions = [];
        for (const doc of documents) {
          definitions.push(...doc.definitions);
        }
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/separateOperations.js
  var require_separateOperations = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/separateOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.separateOperations = separateOperations;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      function separateOperations(documentAST) {
        const operations = [];
        const depGraph = /* @__PURE__ */ Object.create(null);
        for (const definitionNode of documentAST.definitions) {
          switch (definitionNode.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              operations.push(definitionNode);
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              depGraph[definitionNode.name.value] = collectDependencies(
                definitionNode.selectionSet
              );
              break;
            default:
          }
        }
        const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
        for (const operation of operations) {
          const dependencies = /* @__PURE__ */ new Set();
          for (const fragmentName of collectDependencies(operation.selectionSet)) {
            collectTransitiveDependencies(dependencies, depGraph, fragmentName);
          }
          const operationName = operation.name ? operation.name.value : "";
          separatedDocumentASTs[operationName] = {
            kind: _kinds.Kind.DOCUMENT,
            definitions: documentAST.definitions.filter(
              (node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
            )
          };
        }
        return separatedDocumentASTs;
      }
      function collectTransitiveDependencies(collected, depGraph, fromName) {
        if (!collected.has(fromName)) {
          collected.add(fromName);
          const immediateDeps = depGraph[fromName];
          if (immediateDeps !== void 0) {
            for (const toName of immediateDeps) {
              collectTransitiveDependencies(collected, depGraph, toName);
            }
          }
        }
      }
      function collectDependencies(selectionSet) {
        const dependencies = [];
        (0, _visitor.visit)(selectionSet, {
          FragmentSpread(node) {
            dependencies.push(node.name.value);
          }
        });
        return dependencies;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/stripIgnoredCharacters.js
  var require_stripIgnoredCharacters = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stripIgnoredCharacters = stripIgnoredCharacters;
      var _blockString = require_blockString();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function stripIgnoredCharacters(source) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        const body = sourceObj.body;
        const lexer = new _lexer.Lexer(sourceObj);
        let strippedBody = "";
        let wasLastAddedTokenNonPunctuator = false;
        while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
          const currentToken = lexer.token;
          const tokenKind = currentToken.kind;
          const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(
            currentToken.kind
          );
          if (wasLastAddedTokenNonPunctuator) {
            if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
              strippedBody += " ";
            }
          }
          const tokenBody = body.slice(currentToken.start, currentToken.end);
          if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
            strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
              minimize: true
            });
          } else {
            strippedBody += tokenBody;
          }
          wasLastAddedTokenNonPunctuator = isNonPunctuator;
        }
        return strippedBody;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/assertValidName.js
  var require_assertValidName = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/assertValidName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidName = assertValidName;
      exports.isValidNameError = isValidNameError;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _assertName = require_assertName();
      function assertValidName(name) {
        const error = isValidNameError(name);
        if (error) {
          throw error;
        }
        return name;
      }
      function isValidNameError(name) {
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.startsWith("__")) {
          return new _GraphQLError.GraphQLError(
            `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
          );
        }
        try {
          (0, _assertName.assertName)(name);
        } catch (error) {
          return error;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/findBreakingChanges.js
  var require_findBreakingChanges = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/findBreakingChanges.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DangerousChangeType = exports.BreakingChangeType = void 0;
      exports.findBreakingChanges = findBreakingChanges;
      exports.findDangerousChanges = findDangerousChanges;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _printer = require_printer();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      var _sortValueNode = require_sortValueNode();
      var BreakingChangeType;
      exports.BreakingChangeType = BreakingChangeType;
      (function(BreakingChangeType2) {
        BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
        BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
        BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
        BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
        BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
        BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
        BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
        BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
        BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
        BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
        BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
        BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
        BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
        BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
        BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
        BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
      })(
        BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {})
      );
      var DangerousChangeType;
      exports.DangerousChangeType = DangerousChangeType;
      (function(DangerousChangeType2) {
        DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
        DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
        DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
        DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
        DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
        DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
      })(
        DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {})
      );
      function findBreakingChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter(
          (change) => change.type in BreakingChangeType
        );
      }
      function findDangerousChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter(
          (change) => change.type in DangerousChangeType
        );
      }
      function findSchemaChanges(oldSchema, newSchema) {
        return [
          ...findTypeChanges(oldSchema, newSchema),
          ...findDirectiveChanges(oldSchema, newSchema)
        ];
      }
      function findDirectiveChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const directivesDiff = diff(
          oldSchema.getDirectives(),
          newSchema.getDirectives()
        );
        for (const oldDirective of directivesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REMOVED,
            description: `${oldDirective.name} was removed.`
          });
        }
        for (const [oldDirective, newDirective] of directivesDiff.persisted) {
          const argsDiff = diff(oldDirective.args, newDirective.args);
          for (const newArg of argsDiff.added) {
            if ((0, _definition.isRequiredArgument)(newArg)) {
              schemaChanges.push({
                type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
                description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
              });
            }
          }
          for (const oldArg of argsDiff.removed) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
              description: `${oldArg.name} was removed from ${oldDirective.name}.`
            });
          }
          if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
              description: `Repeatable flag was removed from ${oldDirective.name}.`
            });
          }
          for (const location of oldDirective.locations) {
            if (!newDirective.locations.includes(location)) {
              schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
                description: `${location} was removed from ${oldDirective.name}.`
              });
            }
          }
        }
        return schemaChanges;
      }
      function findTypeChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const typesDiff = diff(
          Object.values(oldSchema.getTypeMap()),
          Object.values(newSchema.getTypeMap())
        );
        for (const oldType of typesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED,
            description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
          });
        }
        for (const [oldType, newType] of typesDiff.persisted) {
          if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
            schemaChanges.push(...findEnumTypeChanges(oldType, newType));
          } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
            schemaChanges.push(...findUnionTypeChanges(oldType, newType));
          } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
            schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
          } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
            schemaChanges.push(
              ...findFieldChanges(oldType, newType),
              ...findImplementedInterfacesChanges(oldType, newType)
            );
          } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
            schemaChanges.push(
              ...findFieldChanges(oldType, newType),
              ...findImplementedInterfacesChanges(oldType, newType)
            );
          } else if (oldType.constructor !== newType.constructor) {
            schemaChanges.push({
              type: BreakingChangeType.TYPE_CHANGED_KIND,
              description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findInputObjectTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(
          Object.values(oldType.getFields()),
          Object.values(newType.getFields())
        );
        for (const newField of fieldsDiff.added) {
          if ((0, _definition.isRequiredInputField)(newField)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
              description: `A required field ${newField.name} on input type ${oldType.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
              description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
            });
          }
        }
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
            oldField.type,
            newField.type
          );
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findUnionTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
        for (const newPossibleType of possibleTypesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
            description: `${newPossibleType.name} was added to union type ${oldType.name}.`
          });
        }
        for (const oldPossibleType of possibleTypesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
            description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findEnumTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const valuesDiff = diff(oldType.getValues(), newType.getValues());
        for (const newValue of valuesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
            description: `${newValue.name} was added to enum type ${oldType.name}.`
          });
        }
        for (const oldValue of valuesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
            description: `${oldValue.name} was removed from enum type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findImplementedInterfacesChanges(oldType, newType) {
        const schemaChanges = [];
        const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
        for (const newInterface of interfacesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
            description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
          });
        }
        for (const oldInterface of interfacesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
            description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
          });
        }
        return schemaChanges;
      }
      function findFieldChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(
          Object.values(oldType.getFields()),
          Object.values(newType.getFields())
        );
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          schemaChanges.push(...findArgChanges(oldType, oldField, newField));
          const isSafe = isChangeSafeForObjectOrInterfaceField(
            oldField.type,
            newField.type
          );
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findArgChanges(oldType, oldField, newField) {
        const schemaChanges = [];
        const argsDiff = diff(oldField.args, newField.args);
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_REMOVED,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
          });
        }
        for (const [oldArg, newArg] of argsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
            oldArg.type,
            newArg.type
          );
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.ARG_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
            });
          } else if (oldArg.defaultValue !== void 0) {
            if (newArg.defaultValue === void 0) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
              });
            } else {
              const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
              const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
              if (oldValueStr !== newValueStr) {
                schemaChanges.push({
                  type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                  description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
                });
              }
            }
          }
        }
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_ARG_ADDED,
              description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_ARG_ADDED,
              description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          }
        }
        return schemaChanges;
      }
      function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(
            oldType.ofType,
            newType.ofType
          ) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
            oldType.ofType,
            newType.ofType
          ) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
      }
      function typeKindName(type) {
        if ((0, _definition.isScalarType)(type)) {
          return "a Scalar type";
        }
        if ((0, _definition.isObjectType)(type)) {
          return "an Object type";
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return "an Interface type";
        }
        if ((0, _definition.isUnionType)(type)) {
          return "a Union type";
        }
        if ((0, _definition.isEnumType)(type)) {
          return "an Enum type";
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return "an Input type";
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function stringifyValue(value, type) {
        const ast = (0, _astFromValue.astFromValue)(value, type);
        ast != null || (0, _invariant.invariant)(false);
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
      }
      function diff(oldArray, newArray) {
        const added = [];
        const removed = [];
        const persisted = [];
        const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
        const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
        for (const oldItem of oldArray) {
          const newItem = newMap[oldItem.name];
          if (newItem === void 0) {
            removed.push(oldItem);
          } else {
            persisted.push([oldItem, newItem]);
          }
        }
        for (const newItem of newArray) {
          if (oldMap[newItem.name] === void 0) {
            added.push(newItem);
          }
        }
        return {
          added,
          persisted,
          removed
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/index.js
  var require_utilities = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/utilities/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.TypeInfo;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _assertValidName.assertValidName;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _astFromValue.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _buildClientSchema.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _coerceInputValue.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _concatAST.concatAST;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _typeComparators.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _extendSchema.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _getIntrospectionQuery.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _getOperationAST.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _getOperationRootType.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _introspectionFromSchema.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _typeComparators.isEqualType;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _typeComparators.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _assertValidName.isValidNameError;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _lexicographicSortSchema.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printSchema;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _printSchema.printType;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _separateOperations.separateOperations;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _stripIgnoredCharacters.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _typeFromAST.typeFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _valueFromAST.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _valueFromASTUntyped.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.visitWithTypeInfo;
        }
      });
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      var _getOperationAST = require_getOperationAST();
      var _getOperationRootType = require_getOperationRootType();
      var _introspectionFromSchema = require_introspectionFromSchema();
      var _buildClientSchema = require_buildClientSchema();
      var _buildASTSchema = require_buildASTSchema();
      var _extendSchema = require_extendSchema();
      var _lexicographicSortSchema = require_lexicographicSortSchema();
      var _printSchema = require_printSchema();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _astFromValue = require_astFromValue();
      var _TypeInfo = require_TypeInfo();
      var _coerceInputValue = require_coerceInputValue();
      var _concatAST = require_concatAST();
      var _separateOperations = require_separateOperations();
      var _stripIgnoredCharacters = require_stripIgnoredCharacters();
      var _typeComparators = require_typeComparators();
      var _assertValidName = require_assertValidName();
      var _findBreakingChanges = require_findBreakingChanges();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/index.js
  var require_graphql2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _index2.BREAK;
        }
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _index6.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _index.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _index6.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index2.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _index4.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _index.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _index5.GraphQLError;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _index.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _index.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _index.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _index.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _index.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _index2.Kind;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _index2.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _index2.Location;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _index4.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _index4.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _index4.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _index4.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _index2.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _index2.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _index2.TokenKind;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.TypeInfo;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _index.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _index4.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _index.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _index.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _index.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _index.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _index.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _index.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _index.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _index.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _index.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _index.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _index.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _index.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _index.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _index.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _index.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _index.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _index.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _index.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _index.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _index.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _index.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _index.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _index.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _index.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _index6.assertValidName;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _index.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _index.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _index6.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _index6.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _index6.concatAST;
        }
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _index3.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _index6.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _index3.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _index3.executeSync;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _index6.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _index6.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _index6.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _index5.formatError;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _index3.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _index3.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _index2.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _index6.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _index2.getLocation;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _index.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _index.getNullableType;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _index6.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _index6.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _index3.getVariableValues;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _index2.getVisitFn;
        }
      });
      Object.defineProperty(exports, "graphql", {
        enumerable: true,
        get: function() {
          return _graphql.graphql;
        }
      });
      Object.defineProperty(exports, "graphqlSync", {
        enumerable: true,
        get: function() {
          return _graphql.graphqlSync;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _index6.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _index.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _index.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _index.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _index.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _index.isEnumType;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _index6.isEqualType;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _index.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _index.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _index.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _index.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _index.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _index.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _index.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _index.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _index.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _index.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _index.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _index.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _index.isSchema;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _index2.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _index.isType;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _index6.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _index.isUnionType;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _index6.isValidNameError;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isValueNode;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _index.isWrappingType;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _index6.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _index5.locatedError;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _index2.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _index2.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _index2.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _index2.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _index2.print;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _index5.printError;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _index6.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _index2.printLocation;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _index6.printSchema;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _index2.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _index6.printType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _index3.responsePathAsArray;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _index6.separateOperations;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _index.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _index4.specifiedRules;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _index.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _index6.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _index3.subscribe;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _index5.syntaxError;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _index6.typeFromAST;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _index4.validate;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _index.validateSchema;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _index6.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _index6.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function() {
          return _version.version;
        }
      });
      Object.defineProperty(exports, "versionInfo", {
        enumerable: true,
        get: function() {
          return _version.versionInfo;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _index2.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _index2.visitInParallel;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.visitWithTypeInfo;
        }
      });
      var _version = require_version();
      var _graphql = require_graphql();
      var _index = require_type();
      var _index2 = require_language();
      var _index3 = require_execution();
      var _index4 = require_validation();
      var _index5 = require_error();
      var _index6 = require_utilities();
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/autocompleteUtils.js
  var require_autocompleteUtils = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/autocompleteUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hintList = exports.objectValues = exports.forEachState = exports.getFieldDef = exports.getDefinitionState = void 0;
      var graphql_1 = require_graphql2();
      var introspection_1 = require_introspection();
      function getDefinitionState(tokenState) {
        let definitionState;
        forEachState(tokenState, (state) => {
          switch (state.kind) {
            case "Query":
            case "ShortQuery":
            case "Mutation":
            case "Subscription":
            case "FragmentDefinition":
              definitionState = state;
              break;
          }
        });
        return definitionState;
      }
      exports.getDefinitionState = getDefinitionState;
      function getFieldDef(schema, type, fieldName) {
        if (fieldName === introspection_1.SchemaMetaFieldDef.name && schema.getQueryType() === type) {
          return introspection_1.SchemaMetaFieldDef;
        }
        if (fieldName === introspection_1.TypeMetaFieldDef.name && schema.getQueryType() === type) {
          return introspection_1.TypeMetaFieldDef;
        }
        if (fieldName === introspection_1.TypeNameMetaFieldDef.name && (0, graphql_1.isCompositeType)(type)) {
          return introspection_1.TypeNameMetaFieldDef;
        }
        if ("getFields" in type) {
          return type.getFields()[fieldName];
        }
        return null;
      }
      exports.getFieldDef = getFieldDef;
      function forEachState(stack, fn) {
        const reverseStateStack = [];
        let state = stack;
        while (state === null || state === void 0 ? void 0 : state.kind) {
          reverseStateStack.push(state);
          state = state.prevState;
        }
        for (let i = reverseStateStack.length - 1; i >= 0; i--) {
          fn(reverseStateStack[i]);
        }
      }
      exports.forEachState = forEachState;
      function objectValues(object) {
        const keys = Object.keys(object);
        const len = keys.length;
        const values = new Array(len);
        for (let i = 0; i < len; ++i) {
          values[i] = object[keys[i]];
        }
        return values;
      }
      exports.objectValues = objectValues;
      function hintList(token, list) {
        return filterAndSortList(list, normalizeText(token.string));
      }
      exports.hintList = hintList;
      function filterAndSortList(list, text) {
        if (!text) {
          return filterNonEmpty(list, (entry) => !entry.isDeprecated);
        }
        const byProximity = list.map((entry) => ({
          proximity: getProximity(normalizeText(entry.label), text),
          entry
        }));
        return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);
      }
      function filterNonEmpty(array, predicate) {
        const filtered = array.filter(predicate);
        return filtered.length === 0 ? array : filtered;
      }
      function normalizeText(text) {
        return text.toLowerCase().replace(/\W/g, "");
      }
      function getProximity(suggestion, text) {
        let proximity = lexicalDistance(text, suggestion);
        if (suggestion.length > text.length) {
          proximity -= suggestion.length - text.length - 1;
          proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;
        }
        return proximity;
      }
      function lexicalDistance(a, b) {
        let i;
        let j;
        const d = [];
        const aLength = a.length;
        const bLength = b.length;
        for (i = 0; i <= aLength; i++) {
          d[i] = [i];
        }
        for (j = 1; j <= bLength; j++) {
          d[0][j] = j;
        }
        for (i = 1; i <= aLength; i++) {
          for (j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
          }
        }
        return d[aLength][bLength];
      }
    }
  });

  // ../../node_modules/.pnpm/vscode-languageserver-types@3.17.2/node_modules/vscode-languageserver-types/lib/umd/main.js
  var require_main = __commonJS({
    "../../node_modules/.pnpm/vscode-languageserver-types@3.17.2/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          var v = factory(__require, exports);
          if (v !== void 0)
            module.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
        var DocumentUri;
        (function(DocumentUri2) {
          function is(value) {
            return typeof value === "string";
          }
          DocumentUri2.is = is;
        })(DocumentUri = exports2.DocumentUri || (exports2.DocumentUri = {}));
        var URI2;
        (function(URI3) {
          function is(value) {
            return typeof value === "string";
          }
          URI3.is = is;
        })(URI2 = exports2.URI || (exports2.URI = {}));
        var integer;
        (function(integer2) {
          integer2.MIN_VALUE = -2147483648;
          integer2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
          }
          integer2.is = is;
        })(integer = exports2.integer || (exports2.integer = {}));
        var uinteger;
        (function(uinteger2) {
          uinteger2.MIN_VALUE = 0;
          uinteger2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
          }
          uinteger2.is = is;
        })(uinteger = exports2.uinteger || (exports2.uinteger = {}));
        var Position2;
        (function(Position3) {
          function create(line, character) {
            if (line === Number.MAX_VALUE) {
              line = uinteger.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
              character = uinteger.MAX_VALUE;
            }
            return { line, character };
          }
          Position3.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
          }
          Position3.is = is;
        })(Position2 = exports2.Position || (exports2.Position = {}));
        var Range2;
        (function(Range3) {
          function create(one, two, three, four) {
            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
              return { start: Position2.create(one, two), end: Position2.create(three, four) };
            } else if (Position2.is(one) && Position2.is(two)) {
              return { start: one, end: two };
            } else {
              throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
          }
          Range3.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
          }
          Range3.is = is;
        })(Range2 = exports2.Range || (exports2.Range = {}));
        var Location;
        (function(Location2) {
          function create(uri, range) {
            return { uri, range };
          }
          Location2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
          }
          Location2.is = is;
        })(Location = exports2.Location || (exports2.Location = {}));
        var LocationLink;
        (function(LocationLink2) {
          function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
          }
          LocationLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
          }
          LocationLink2.is = is;
        })(LocationLink = exports2.LocationLink || (exports2.LocationLink = {}));
        var Color;
        (function(Color2) {
          function create(red, green, blue, alpha) {
            return {
              red,
              green,
              blue,
              alpha
            };
          }
          Color2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
          }
          Color2.is = is;
        })(Color = exports2.Color || (exports2.Color = {}));
        var ColorInformation;
        (function(ColorInformation2) {
          function create(range, color) {
            return {
              range,
              color
            };
          }
          ColorInformation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && Color.is(candidate.color);
          }
          ColorInformation2.is = is;
        })(ColorInformation = exports2.ColorInformation || (exports2.ColorInformation = {}));
        var ColorPresentation;
        (function(ColorPresentation2) {
          function create(label, textEdit, additionalTextEdits) {
            return {
              label,
              textEdit,
              additionalTextEdits
            };
          }
          ColorPresentation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
          }
          ColorPresentation2.is = is;
        })(ColorPresentation = exports2.ColorPresentation || (exports2.ColorPresentation = {}));
        var FoldingRangeKind2;
        (function(FoldingRangeKind3) {
          FoldingRangeKind3.Comment = "comment";
          FoldingRangeKind3.Imports = "imports";
          FoldingRangeKind3.Region = "region";
        })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
        var FoldingRange;
        (function(FoldingRange2) {
          function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
              startLine,
              endLine
            };
            if (Is.defined(startCharacter)) {
              result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
              result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
              result.kind = kind;
            }
            if (Is.defined(collapsedText)) {
              result.collapsedText = collapsedText;
            }
            return result;
          }
          FoldingRange2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
          }
          FoldingRange2.is = is;
        })(FoldingRange = exports2.FoldingRange || (exports2.FoldingRange = {}));
        var DiagnosticRelatedInformation;
        (function(DiagnosticRelatedInformation2) {
          function create(location, message) {
            return {
              location,
              message
            };
          }
          DiagnosticRelatedInformation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
          }
          DiagnosticRelatedInformation2.is = is;
        })(DiagnosticRelatedInformation = exports2.DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = {}));
        var DiagnosticSeverity;
        (function(DiagnosticSeverity2) {
          DiagnosticSeverity2.Error = 1;
          DiagnosticSeverity2.Warning = 2;
          DiagnosticSeverity2.Information = 3;
          DiagnosticSeverity2.Hint = 4;
        })(DiagnosticSeverity = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
        var DiagnosticTag;
        (function(DiagnosticTag2) {
          DiagnosticTag2.Unnecessary = 1;
          DiagnosticTag2.Deprecated = 2;
        })(DiagnosticTag = exports2.DiagnosticTag || (exports2.DiagnosticTag = {}));
        var CodeDescription;
        (function(CodeDescription2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.href);
          }
          CodeDescription2.is = is;
        })(CodeDescription = exports2.CodeDescription || (exports2.CodeDescription = {}));
        var Diagnostic;
        (function(Diagnostic2) {
          function create(range, message, severity, code, source, relatedInformation) {
            var result = { range, message };
            if (Is.defined(severity)) {
              result.severity = severity;
            }
            if (Is.defined(code)) {
              result.code = code;
            }
            if (Is.defined(source)) {
              result.source = source;
            }
            if (Is.defined(relatedInformation)) {
              result.relatedInformation = relatedInformation;
            }
            return result;
          }
          Diagnostic2.create = create;
          function is(value) {
            var _a3;
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
          }
          Diagnostic2.is = is;
        })(Diagnostic = exports2.Diagnostic || (exports2.Diagnostic = {}));
        var Command2;
        (function(Command3) {
          function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var result = { title, command };
            if (Is.defined(args) && args.length > 0) {
              result.arguments = args;
            }
            return result;
          }
          Command3.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
          }
          Command3.is = is;
        })(Command2 = exports2.Command || (exports2.Command = {}));
        var TextEdit;
        (function(TextEdit2) {
          function replace(range, newText) {
            return { range, newText };
          }
          TextEdit2.replace = replace;
          function insert(position, newText) {
            return { range: { start: position, end: position }, newText };
          }
          TextEdit2.insert = insert;
          function del(range) {
            return { range, newText: "" };
          }
          TextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
          }
          TextEdit2.is = is;
        })(TextEdit = exports2.TextEdit || (exports2.TextEdit = {}));
        var ChangeAnnotation;
        (function(ChangeAnnotation2) {
          function create(label, needsConfirmation, description) {
            var result = { label };
            if (needsConfirmation !== void 0) {
              result.needsConfirmation = needsConfirmation;
            }
            if (description !== void 0) {
              result.description = description;
            }
            return result;
          }
          ChangeAnnotation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          ChangeAnnotation2.is = is;
        })(ChangeAnnotation = exports2.ChangeAnnotation || (exports2.ChangeAnnotation = {}));
        var ChangeAnnotationIdentifier;
        (function(ChangeAnnotationIdentifier2) {
          function is(value) {
            var candidate = value;
            return Is.string(candidate);
          }
          ChangeAnnotationIdentifier2.is = is;
        })(ChangeAnnotationIdentifier = exports2.ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = {}));
        var AnnotatedTextEdit;
        (function(AnnotatedTextEdit2) {
          function replace(range, newText, annotation) {
            return { range, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.replace = replace;
          function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.insert = insert;
          function del(range, annotation) {
            return { range, newText: "", annotationId: annotation };
          }
          AnnotatedTextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          AnnotatedTextEdit2.is = is;
        })(AnnotatedTextEdit = exports2.AnnotatedTextEdit || (exports2.AnnotatedTextEdit = {}));
        var TextDocumentEdit;
        (function(TextDocumentEdit2) {
          function create(textDocument, edits) {
            return { textDocument, edits };
          }
          TextDocumentEdit2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
          }
          TextDocumentEdit2.is = is;
        })(TextDocumentEdit = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
        var CreateFile;
        (function(CreateFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "create",
              uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          CreateFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          CreateFile2.is = is;
        })(CreateFile = exports2.CreateFile || (exports2.CreateFile = {}));
        var RenameFile;
        (function(RenameFile2) {
          function create(oldUri, newUri, options, annotation) {
            var result = {
              kind: "rename",
              oldUri,
              newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          RenameFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          RenameFile2.is = is;
        })(RenameFile = exports2.RenameFile || (exports2.RenameFile = {}));
        var DeleteFile;
        (function(DeleteFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "delete",
              uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          DeleteFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          DeleteFile2.is = is;
        })(DeleteFile = exports2.DeleteFile || (exports2.DeleteFile = {}));
        var WorkspaceEdit;
        (function(WorkspaceEdit2) {
          function is(value) {
            var candidate = value;
            return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
              if (Is.string(change.kind)) {
                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
              } else {
                return TextDocumentEdit.is(change);
              }
            }));
          }
          WorkspaceEdit2.is = is;
        })(WorkspaceEdit = exports2.WorkspaceEdit || (exports2.WorkspaceEdit = {}));
        var TextEditChangeImpl = function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }();
        var ChangeAnnotations = function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }();
        var WorkspaceChange = function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }();
        exports2.WorkspaceChange = WorkspaceChange;
        var TextDocumentIdentifier;
        (function(TextDocumentIdentifier2) {
          function create(uri) {
            return { uri };
          }
          TextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
          }
          TextDocumentIdentifier2.is = is;
        })(TextDocumentIdentifier = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
        var VersionedTextDocumentIdentifier;
        (function(VersionedTextDocumentIdentifier2) {
          function create(uri, version) {
            return { uri, version };
          }
          VersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
          }
          VersionedTextDocumentIdentifier2.is = is;
        })(VersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
        var OptionalVersionedTextDocumentIdentifier;
        (function(OptionalVersionedTextDocumentIdentifier2) {
          function create(uri, version) {
            return { uri, version };
          }
          OptionalVersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
          }
          OptionalVersionedTextDocumentIdentifier2.is = is;
        })(OptionalVersionedTextDocumentIdentifier = exports2.OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = {}));
        var TextDocumentItem;
        (function(TextDocumentItem2) {
          function create(uri, languageId, version, text) {
            return { uri, languageId, version, text };
          }
          TextDocumentItem2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
          }
          TextDocumentItem2.is = is;
        })(TextDocumentItem = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
        var MarkupKind;
        (function(MarkupKind2) {
          MarkupKind2.PlainText = "plaintext";
          MarkupKind2.Markdown = "markdown";
          function is(value) {
            var candidate = value;
            return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
          }
          MarkupKind2.is = is;
        })(MarkupKind = exports2.MarkupKind || (exports2.MarkupKind = {}));
        var MarkupContent;
        (function(MarkupContent2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
          }
          MarkupContent2.is = is;
        })(MarkupContent = exports2.MarkupContent || (exports2.MarkupContent = {}));
        var CompletionItemKind2;
        (function(CompletionItemKind3) {
          CompletionItemKind3.Text = 1;
          CompletionItemKind3.Method = 2;
          CompletionItemKind3.Function = 3;
          CompletionItemKind3.Constructor = 4;
          CompletionItemKind3.Field = 5;
          CompletionItemKind3.Variable = 6;
          CompletionItemKind3.Class = 7;
          CompletionItemKind3.Interface = 8;
          CompletionItemKind3.Module = 9;
          CompletionItemKind3.Property = 10;
          CompletionItemKind3.Unit = 11;
          CompletionItemKind3.Value = 12;
          CompletionItemKind3.Enum = 13;
          CompletionItemKind3.Keyword = 14;
          CompletionItemKind3.Snippet = 15;
          CompletionItemKind3.Color = 16;
          CompletionItemKind3.File = 17;
          CompletionItemKind3.Reference = 18;
          CompletionItemKind3.Folder = 19;
          CompletionItemKind3.EnumMember = 20;
          CompletionItemKind3.Constant = 21;
          CompletionItemKind3.Struct = 22;
          CompletionItemKind3.Event = 23;
          CompletionItemKind3.Operator = 24;
          CompletionItemKind3.TypeParameter = 25;
        })(CompletionItemKind2 = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
        var InsertTextFormat;
        (function(InsertTextFormat2) {
          InsertTextFormat2.PlainText = 1;
          InsertTextFormat2.Snippet = 2;
        })(InsertTextFormat = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
        var CompletionItemTag2;
        (function(CompletionItemTag3) {
          CompletionItemTag3.Deprecated = 1;
        })(CompletionItemTag2 = exports2.CompletionItemTag || (exports2.CompletionItemTag = {}));
        var InsertReplaceEdit;
        (function(InsertReplaceEdit2) {
          function create(newText, insert, replace) {
            return { newText, insert, replace };
          }
          InsertReplaceEdit2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
          }
          InsertReplaceEdit2.is = is;
        })(InsertReplaceEdit = exports2.InsertReplaceEdit || (exports2.InsertReplaceEdit = {}));
        var InsertTextMode;
        (function(InsertTextMode2) {
          InsertTextMode2.asIs = 1;
          InsertTextMode2.adjustIndentation = 2;
        })(InsertTextMode = exports2.InsertTextMode || (exports2.InsertTextMode = {}));
        var CompletionItemLabelDetails;
        (function(CompletionItemLabelDetails2) {
          function is(value) {
            var candidate = value;
            return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          CompletionItemLabelDetails2.is = is;
        })(CompletionItemLabelDetails = exports2.CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = {}));
        var CompletionItem;
        (function(CompletionItem2) {
          function create(label) {
            return { label };
          }
          CompletionItem2.create = create;
        })(CompletionItem = exports2.CompletionItem || (exports2.CompletionItem = {}));
        var CompletionList;
        (function(CompletionList2) {
          function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
          }
          CompletionList2.create = create;
        })(CompletionList = exports2.CompletionList || (exports2.CompletionList = {}));
        var MarkedString;
        (function(MarkedString2) {
          function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          MarkedString2.fromPlainText = fromPlainText;
          function is(value) {
            var candidate = value;
            return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
          }
          MarkedString2.is = is;
        })(MarkedString = exports2.MarkedString || (exports2.MarkedString = {}));
        var Hover;
        (function(Hover2) {
          function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
          }
          Hover2.is = is;
        })(Hover = exports2.Hover || (exports2.Hover = {}));
        var ParameterInformation;
        (function(ParameterInformation2) {
          function create(label, documentation) {
            return documentation ? { label, documentation } : { label };
          }
          ParameterInformation2.create = create;
        })(ParameterInformation = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
        var SignatureInformation;
        (function(SignatureInformation2) {
          function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              parameters[_i - 2] = arguments[_i];
            }
            var result = { label };
            if (Is.defined(documentation)) {
              result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
              result.parameters = parameters;
            } else {
              result.parameters = [];
            }
            return result;
          }
          SignatureInformation2.create = create;
        })(SignatureInformation = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
        var DocumentHighlightKind3;
        (function(DocumentHighlightKind4) {
          DocumentHighlightKind4.Text = 1;
          DocumentHighlightKind4.Read = 2;
          DocumentHighlightKind4.Write = 3;
        })(DocumentHighlightKind3 = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
        var DocumentHighlight;
        (function(DocumentHighlight2) {
          function create(range, kind) {
            var result = { range };
            if (Is.number(kind)) {
              result.kind = kind;
            }
            return result;
          }
          DocumentHighlight2.create = create;
        })(DocumentHighlight = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
        var SymbolKind2;
        (function(SymbolKind3) {
          SymbolKind3.File = 1;
          SymbolKind3.Module = 2;
          SymbolKind3.Namespace = 3;
          SymbolKind3.Package = 4;
          SymbolKind3.Class = 5;
          SymbolKind3.Method = 6;
          SymbolKind3.Property = 7;
          SymbolKind3.Field = 8;
          SymbolKind3.Constructor = 9;
          SymbolKind3.Enum = 10;
          SymbolKind3.Interface = 11;
          SymbolKind3.Function = 12;
          SymbolKind3.Variable = 13;
          SymbolKind3.Constant = 14;
          SymbolKind3.String = 15;
          SymbolKind3.Number = 16;
          SymbolKind3.Boolean = 17;
          SymbolKind3.Array = 18;
          SymbolKind3.Object = 19;
          SymbolKind3.Key = 20;
          SymbolKind3.Null = 21;
          SymbolKind3.EnumMember = 22;
          SymbolKind3.Struct = 23;
          SymbolKind3.Event = 24;
          SymbolKind3.Operator = 25;
          SymbolKind3.TypeParameter = 26;
        })(SymbolKind2 = exports2.SymbolKind || (exports2.SymbolKind = {}));
        var SymbolTag2;
        (function(SymbolTag3) {
          SymbolTag3.Deprecated = 1;
        })(SymbolTag2 = exports2.SymbolTag || (exports2.SymbolTag = {}));
        var SymbolInformation;
        (function(SymbolInformation2) {
          function create(name, kind, range, uri, containerName) {
            var result = {
              name,
              kind,
              location: { uri, range }
            };
            if (containerName) {
              result.containerName = containerName;
            }
            return result;
          }
          SymbolInformation2.create = create;
        })(SymbolInformation = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
        var WorkspaceSymbol;
        (function(WorkspaceSymbol2) {
          function create(name, kind, uri, range) {
            return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
          }
          WorkspaceSymbol2.create = create;
        })(WorkspaceSymbol = exports2.WorkspaceSymbol || (exports2.WorkspaceSymbol = {}));
        var DocumentSymbol;
        (function(DocumentSymbol2) {
          function create(name, detail, kind, range, selectionRange, children) {
            var result = {
              name,
              detail,
              kind,
              range,
              selectionRange
            };
            if (children !== void 0) {
              result.children = children;
            }
            return result;
          }
          DocumentSymbol2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
          }
          DocumentSymbol2.is = is;
        })(DocumentSymbol = exports2.DocumentSymbol || (exports2.DocumentSymbol = {}));
        var CodeActionKind;
        (function(CodeActionKind2) {
          CodeActionKind2.Empty = "";
          CodeActionKind2.QuickFix = "quickfix";
          CodeActionKind2.Refactor = "refactor";
          CodeActionKind2.RefactorExtract = "refactor.extract";
          CodeActionKind2.RefactorInline = "refactor.inline";
          CodeActionKind2.RefactorRewrite = "refactor.rewrite";
          CodeActionKind2.Source = "source";
          CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
          CodeActionKind2.SourceFixAll = "source.fixAll";
        })(CodeActionKind = exports2.CodeActionKind || (exports2.CodeActionKind = {}));
        var CodeActionTriggerKind;
        (function(CodeActionTriggerKind2) {
          CodeActionTriggerKind2.Invoked = 1;
          CodeActionTriggerKind2.Automatic = 2;
        })(CodeActionTriggerKind = exports2.CodeActionTriggerKind || (exports2.CodeActionTriggerKind = {}));
        var CodeActionContext;
        (function(CodeActionContext2) {
          function create(diagnostics, only, triggerKind) {
            var result = { diagnostics };
            if (only !== void 0 && only !== null) {
              result.only = only;
            }
            if (triggerKind !== void 0 && triggerKind !== null) {
              result.triggerKind = triggerKind;
            }
            return result;
          }
          CodeActionContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
          }
          CodeActionContext2.is = is;
        })(CodeActionContext = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
        var CodeAction;
        (function(CodeAction2) {
          function create(title, kindOrCommandOrEdit, kind) {
            var result = { title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === "string") {
              checkKind = false;
              result.kind = kindOrCommandOrEdit;
            } else if (Command2.is(kindOrCommandOrEdit)) {
              result.command = kindOrCommandOrEdit;
            } else {
              result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          CodeAction2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
          }
          CodeAction2.is = is;
        })(CodeAction = exports2.CodeAction || (exports2.CodeAction = {}));
        var CodeLens;
        (function(CodeLens2) {
          function create(range, data) {
            var result = { range };
            if (Is.defined(data)) {
              result.data = data;
            }
            return result;
          }
          CodeLens2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
          }
          CodeLens2.is = is;
        })(CodeLens = exports2.CodeLens || (exports2.CodeLens = {}));
        var FormattingOptions;
        (function(FormattingOptions2) {
          function create(tabSize, insertSpaces) {
            return { tabSize, insertSpaces };
          }
          FormattingOptions2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
          }
          FormattingOptions2.is = is;
        })(FormattingOptions = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
        var DocumentLink;
        (function(DocumentLink2) {
          function create(range, target, data) {
            return { range, target, data };
          }
          DocumentLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
          }
          DocumentLink2.is = is;
        })(DocumentLink = exports2.DocumentLink || (exports2.DocumentLink = {}));
        var SelectionRange;
        (function(SelectionRange2) {
          function create(range, parent) {
            return { range, parent };
          }
          SelectionRange2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
          }
          SelectionRange2.is = is;
        })(SelectionRange = exports2.SelectionRange || (exports2.SelectionRange = {}));
        var SemanticTokenTypes;
        (function(SemanticTokenTypes2) {
          SemanticTokenTypes2["namespace"] = "namespace";
          SemanticTokenTypes2["type"] = "type";
          SemanticTokenTypes2["class"] = "class";
          SemanticTokenTypes2["enum"] = "enum";
          SemanticTokenTypes2["interface"] = "interface";
          SemanticTokenTypes2["struct"] = "struct";
          SemanticTokenTypes2["typeParameter"] = "typeParameter";
          SemanticTokenTypes2["parameter"] = "parameter";
          SemanticTokenTypes2["variable"] = "variable";
          SemanticTokenTypes2["property"] = "property";
          SemanticTokenTypes2["enumMember"] = "enumMember";
          SemanticTokenTypes2["event"] = "event";
          SemanticTokenTypes2["function"] = "function";
          SemanticTokenTypes2["method"] = "method";
          SemanticTokenTypes2["macro"] = "macro";
          SemanticTokenTypes2["keyword"] = "keyword";
          SemanticTokenTypes2["modifier"] = "modifier";
          SemanticTokenTypes2["comment"] = "comment";
          SemanticTokenTypes2["string"] = "string";
          SemanticTokenTypes2["number"] = "number";
          SemanticTokenTypes2["regexp"] = "regexp";
          SemanticTokenTypes2["operator"] = "operator";
          SemanticTokenTypes2["decorator"] = "decorator";
        })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
        var SemanticTokenModifiers;
        (function(SemanticTokenModifiers2) {
          SemanticTokenModifiers2["declaration"] = "declaration";
          SemanticTokenModifiers2["definition"] = "definition";
          SemanticTokenModifiers2["readonly"] = "readonly";
          SemanticTokenModifiers2["static"] = "static";
          SemanticTokenModifiers2["deprecated"] = "deprecated";
          SemanticTokenModifiers2["abstract"] = "abstract";
          SemanticTokenModifiers2["async"] = "async";
          SemanticTokenModifiers2["modification"] = "modification";
          SemanticTokenModifiers2["documentation"] = "documentation";
          SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
        })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
        var SemanticTokens;
        (function(SemanticTokens2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
          }
          SemanticTokens2.is = is;
        })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
        var InlineValueText;
        (function(InlineValueText2) {
          function create(range, text) {
            return { range, text };
          }
          InlineValueText2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.string(candidate.text);
          }
          InlineValueText2.is = is;
        })(InlineValueText = exports2.InlineValueText || (exports2.InlineValueText = {}));
        var InlineValueVariableLookup;
        (function(InlineValueVariableLookup2) {
          function create(range, variableName, caseSensitiveLookup) {
            return { range, variableName, caseSensitiveLookup };
          }
          InlineValueVariableLookup2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
          }
          InlineValueVariableLookup2.is = is;
        })(InlineValueVariableLookup = exports2.InlineValueVariableLookup || (exports2.InlineValueVariableLookup = {}));
        var InlineValueEvaluatableExpression;
        (function(InlineValueEvaluatableExpression2) {
          function create(range, expression) {
            return { range, expression };
          }
          InlineValueEvaluatableExpression2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
          }
          InlineValueEvaluatableExpression2.is = is;
        })(InlineValueEvaluatableExpression = exports2.InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = {}));
        var InlineValueContext;
        (function(InlineValueContext2) {
          function create(frameId, stoppedLocation) {
            return { frameId, stoppedLocation };
          }
          InlineValueContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(value.stoppedLocation);
          }
          InlineValueContext2.is = is;
        })(InlineValueContext = exports2.InlineValueContext || (exports2.InlineValueContext = {}));
        var InlayHintKind3;
        (function(InlayHintKind4) {
          InlayHintKind4.Type = 1;
          InlayHintKind4.Parameter = 2;
          function is(value) {
            return value === 1 || value === 2;
          }
          InlayHintKind4.is = is;
        })(InlayHintKind3 = exports2.InlayHintKind || (exports2.InlayHintKind = {}));
        var InlayHintLabelPart;
        (function(InlayHintLabelPart2) {
          function create(value) {
            return { value };
          }
          InlayHintLabelPart2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
          }
          InlayHintLabelPart2.is = is;
        })(InlayHintLabelPart = exports2.InlayHintLabelPart || (exports2.InlayHintLabelPart = {}));
        var InlayHint;
        (function(InlayHint2) {
          function create(position, label, kind) {
            var result = { position, label };
            if (kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          InlayHint2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
          }
          InlayHint2.is = is;
        })(InlayHint = exports2.InlayHint || (exports2.InlayHint = {}));
        var WorkspaceFolder;
        (function(WorkspaceFolder2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
          }
          WorkspaceFolder2.is = is;
        })(WorkspaceFolder = exports2.WorkspaceFolder || (exports2.WorkspaceFolder = {}));
        exports2.EOL = ["\n", "\r\n", "\r"];
        var TextDocument;
        (function(TextDocument2) {
          function create(uri, languageId, version, content) {
            return new FullTextDocument(uri, languageId, version, content);
          }
          TextDocument2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
          }
          TextDocument2.is = is;
          function applyEdits(document, edits) {
            var text = document.getText();
            var sortedEdits = mergeSort(edits, function(a, b) {
              var diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
              var e = sortedEdits[i];
              var startOffset = document.offsetAt(e.range.start);
              var endOffset = document.offsetAt(e.range.end);
              if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
              } else {
                throw new Error("Overlapping edit");
              }
              lastModifiedOffset = startOffset;
            }
            return text;
          }
          TextDocument2.applyEdits = applyEdits;
          function mergeSort(data, compare) {
            if (data.length <= 1) {
              return data;
            }
            var p = data.length / 2 | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
              var ret = compare(left[leftIdx], right[rightIdx]);
              if (ret <= 0) {
                data[i++] = left[leftIdx++];
              } else {
                data[i++] = right[rightIdx++];
              }
            }
            while (leftIdx < left.length) {
              data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
              data[i++] = right[rightIdx++];
            }
            return data;
          }
        })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
        var FullTextDocument = function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position2.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position2.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }();
        var Is;
        (function(Is2) {
          var toString = Object.prototype.toString;
          function defined(value) {
            return typeof value !== "undefined";
          }
          Is2.defined = defined;
          function undefined2(value) {
            return typeof value === "undefined";
          }
          Is2.undefined = undefined2;
          function boolean(value) {
            return value === true || value === false;
          }
          Is2.boolean = boolean;
          function string(value) {
            return toString.call(value) === "[object String]";
          }
          Is2.string = string;
          function number(value) {
            return toString.call(value) === "[object Number]";
          }
          Is2.number = number;
          function numberRange(value, min, max) {
            return toString.call(value) === "[object Number]" && min <= value && value <= max;
          }
          Is2.numberRange = numberRange;
          function integer2(value) {
            return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
          }
          Is2.integer = integer2;
          function uinteger2(value) {
            return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
          }
          Is2.uinteger = uinteger2;
          function func(value) {
            return toString.call(value) === "[object Function]";
          }
          Is2.func = func;
          function objectLiteral(value) {
            return value !== null && typeof value === "object";
          }
          Is2.objectLiteral = objectLiteral;
          function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
          }
          Is2.typedArray = typedArray;
        })(Is || (Is = {}));
      });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/CharacterStream.js
  var require_CharacterStream = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/CharacterStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var CharacterStream = class {
        constructor(sourceText) {
          this.getStartOfToken = () => this._start;
          this.getCurrentPosition = () => this._pos;
          this.eol = () => this._sourceText.length === this._pos;
          this.sol = () => this._pos === 0;
          this.peek = () => {
            return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;
          };
          this.next = () => {
            const char = this._sourceText.charAt(this._pos);
            this._pos++;
            return char;
          };
          this.eat = (pattern) => {
            const isMatched = this._testNextCharacter(pattern);
            if (isMatched) {
              this._start = this._pos;
              this._pos++;
              return this._sourceText.charAt(this._pos - 1);
            }
            return void 0;
          };
          this.eatWhile = (match) => {
            let isMatched = this._testNextCharacter(match);
            let didEat = false;
            if (isMatched) {
              didEat = isMatched;
              this._start = this._pos;
            }
            while (isMatched) {
              this._pos++;
              isMatched = this._testNextCharacter(match);
              didEat = true;
            }
            return didEat;
          };
          this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
          this.skipToEnd = () => {
            this._pos = this._sourceText.length;
          };
          this.skipTo = (position) => {
            this._pos = position;
          };
          this.match = (pattern, consume = true, caseFold = false) => {
            let token = null;
            let match = null;
            if (typeof pattern === "string") {
              const regex = new RegExp(pattern, caseFold ? "i" : "g");
              match = regex.test(this._sourceText.substr(this._pos, pattern.length));
              token = pattern;
            } else if (pattern instanceof RegExp) {
              match = this._sourceText.slice(this._pos).match(pattern);
              token = match === null || match === void 0 ? void 0 : match[0];
            }
            if (match != null) {
              if (typeof pattern === "string" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {
                if (consume) {
                  this._start = this._pos;
                  if (token && token.length) {
                    this._pos += token.length;
                  }
                }
                return match;
              }
            }
            return false;
          };
          this.backUp = (num) => {
            this._pos -= num;
          };
          this.column = () => this._pos;
          this.indentation = () => {
            const match = this._sourceText.match(/\s*/);
            let indent = 0;
            if (match && match.length !== 0) {
              const whitespaces = match[0];
              let pos = 0;
              while (whitespaces.length > pos) {
                if (whitespaces.charCodeAt(pos) === 9) {
                  indent += 2;
                } else {
                  indent++;
                }
                pos++;
              }
            }
            return indent;
          };
          this.current = () => this._sourceText.slice(this._start, this._pos);
          this._start = 0;
          this._pos = 0;
          this._sourceText = sourceText;
        }
        _testNextCharacter(pattern) {
          const character = this._sourceText.charAt(this._pos);
          let isMatched = false;
          if (typeof pattern === "string") {
            isMatched = character === pattern;
          } else {
            isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
          }
          return isMatched;
        }
      };
      exports.default = CharacterStream;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/RuleHelpers.js
  var require_RuleHelpers = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/RuleHelpers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.p = exports.t = exports.butNot = exports.list = exports.opt = void 0;
      function opt(ofRule) {
        return { ofRule };
      }
      exports.opt = opt;
      function list(ofRule, separator) {
        return { ofRule, isList: true, separator };
      }
      exports.list = list;
      function butNot(rule, exclusions) {
        const ruleMatch = rule.match;
        rule.match = (token) => {
          let check = false;
          if (ruleMatch) {
            check = ruleMatch(token);
          }
          return check && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token));
        };
        return rule;
      }
      exports.butNot = butNot;
      function t(kind, style) {
        return { style, match: (token) => token.kind === kind };
      }
      exports.t = t;
      function p(value, style) {
        return {
          style: style || "punctuation",
          match: (token) => token.kind === "Punctuation" && token.value === value
        };
      }
      exports.p = p;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/Rules.js
  var require_Rules = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/Rules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseRules = exports.LexRules = exports.isIgnored = void 0;
      var RuleHelpers_1 = require_RuleHelpers();
      var graphql_1 = require_graphql2();
      var isIgnored = (ch) => ch === " " || ch === "	" || ch === "," || ch === "\n" || ch === "\r" || ch === "\uFEFF" || ch === "\xA0";
      exports.isIgnored = isIgnored;
      exports.LexRules = {
        Name: /^[_A-Za-z][_0-9A-Za-z]*/,
        Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
        Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
        String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
        Comment: /^#.*/
      };
      exports.ParseRules = {
        Document: [(0, RuleHelpers_1.list)("Definition")],
        Definition(token) {
          switch (token.value) {
            case "{":
              return "ShortQuery";
            case "query":
              return "Query";
            case "mutation":
              return "Mutation";
            case "subscription":
              return "Subscription";
            case "fragment":
              return graphql_1.Kind.FRAGMENT_DEFINITION;
            case "schema":
              return "SchemaDef";
            case "scalar":
              return "ScalarDef";
            case "type":
              return "ObjectTypeDef";
            case "interface":
              return "InterfaceDef";
            case "union":
              return "UnionDef";
            case "enum":
              return "EnumDef";
            case "input":
              return "InputDef";
            case "extend":
              return "ExtendDef";
            case "directive":
              return "DirectiveDef";
          }
        },
        ShortQuery: ["SelectionSet"],
        Query: [
          word("query"),
          (0, RuleHelpers_1.opt)(name("def")),
          (0, RuleHelpers_1.opt)("VariableDefinitions"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        Mutation: [
          word("mutation"),
          (0, RuleHelpers_1.opt)(name("def")),
          (0, RuleHelpers_1.opt)("VariableDefinitions"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        Subscription: [
          word("subscription"),
          (0, RuleHelpers_1.opt)(name("def")),
          (0, RuleHelpers_1.opt)("VariableDefinitions"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        VariableDefinitions: [(0, RuleHelpers_1.p)("("), (0, RuleHelpers_1.list)("VariableDefinition"), (0, RuleHelpers_1.p)(")")],
        VariableDefinition: ["Variable", (0, RuleHelpers_1.p)(":"), "Type", (0, RuleHelpers_1.opt)("DefaultValue")],
        Variable: [(0, RuleHelpers_1.p)("$", "variable"), name("variable")],
        DefaultValue: [(0, RuleHelpers_1.p)("="), "Value"],
        SelectionSet: [(0, RuleHelpers_1.p)("{"), (0, RuleHelpers_1.list)("Selection"), (0, RuleHelpers_1.p)("}")],
        Selection(token, stream) {
          return token.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
        },
        AliasedField: [
          name("property"),
          (0, RuleHelpers_1.p)(":"),
          name("qualifier"),
          (0, RuleHelpers_1.opt)("Arguments"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.opt)("SelectionSet")
        ],
        Field: [
          name("property"),
          (0, RuleHelpers_1.opt)("Arguments"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.opt)("SelectionSet")
        ],
        Arguments: [(0, RuleHelpers_1.p)("("), (0, RuleHelpers_1.list)("Argument"), (0, RuleHelpers_1.p)(")")],
        Argument: [name("attribute"), (0, RuleHelpers_1.p)(":"), "Value"],
        FragmentSpread: [(0, RuleHelpers_1.p)("..."), name("def"), (0, RuleHelpers_1.list)("Directive")],
        InlineFragment: [
          (0, RuleHelpers_1.p)("..."),
          (0, RuleHelpers_1.opt)("TypeCondition"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        FragmentDefinition: [
          word("fragment"),
          (0, RuleHelpers_1.opt)((0, RuleHelpers_1.butNot)(name("def"), [word("on")])),
          "TypeCondition",
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        TypeCondition: [word("on"), "NamedType"],
        Value(token) {
          switch (token.kind) {
            case "Number":
              return "NumberValue";
            case "String":
              return "StringValue";
            case "Punctuation":
              switch (token.value) {
                case "[":
                  return "ListValue";
                case "{":
                  return "ObjectValue";
                case "$":
                  return "Variable";
                case "&":
                  return "NamedType";
              }
              return null;
            case "Name":
              switch (token.value) {
                case "true":
                case "false":
                  return "BooleanValue";
              }
              if (token.value === "null") {
                return "NullValue";
              }
              return "EnumValue";
          }
        },
        NumberValue: [(0, RuleHelpers_1.t)("Number", "number")],
        StringValue: [
          {
            style: "string",
            match: (token) => token.kind === "String",
            update(state, token) {
              if (token.value.startsWith('"""')) {
                state.inBlockstring = !token.value.slice(3).endsWith('"""');
              }
            }
          }
        ],
        BooleanValue: [(0, RuleHelpers_1.t)("Name", "builtin")],
        NullValue: [(0, RuleHelpers_1.t)("Name", "keyword")],
        EnumValue: [name("string-2")],
        ListValue: [(0, RuleHelpers_1.p)("["), (0, RuleHelpers_1.list)("Value"), (0, RuleHelpers_1.p)("]")],
        ObjectValue: [(0, RuleHelpers_1.p)("{"), (0, RuleHelpers_1.list)("ObjectField"), (0, RuleHelpers_1.p)("}")],
        ObjectField: [name("attribute"), (0, RuleHelpers_1.p)(":"), "Value"],
        Type(token) {
          return token.value === "[" ? "ListType" : "NonNullType";
        },
        ListType: [(0, RuleHelpers_1.p)("["), "Type", (0, RuleHelpers_1.p)("]"), (0, RuleHelpers_1.opt)((0, RuleHelpers_1.p)("!"))],
        NonNullType: ["NamedType", (0, RuleHelpers_1.opt)((0, RuleHelpers_1.p)("!"))],
        NamedType: [type("atom")],
        Directive: [(0, RuleHelpers_1.p)("@", "meta"), name("meta"), (0, RuleHelpers_1.opt)("Arguments")],
        DirectiveDef: [
          word("directive"),
          (0, RuleHelpers_1.p)("@", "meta"),
          name("meta"),
          (0, RuleHelpers_1.opt)("ArgumentsDef"),
          word("on"),
          (0, RuleHelpers_1.list)("DirectiveLocation", (0, RuleHelpers_1.p)("|"))
        ],
        InterfaceDef: [
          word("interface"),
          name("atom"),
          (0, RuleHelpers_1.opt)("Implements"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("FieldDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        Implements: [word("implements"), (0, RuleHelpers_1.list)("NamedType", (0, RuleHelpers_1.p)("&"))],
        DirectiveLocation: [name("string-2")],
        SchemaDef: [
          word("schema"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("OperationTypeDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        OperationTypeDef: [name("keyword"), (0, RuleHelpers_1.p)(":"), name("atom")],
        ScalarDef: [word("scalar"), name("atom"), (0, RuleHelpers_1.list)("Directive")],
        ObjectTypeDef: [
          word("type"),
          name("atom"),
          (0, RuleHelpers_1.opt)("Implements"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("FieldDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        FieldDef: [
          name("property"),
          (0, RuleHelpers_1.opt)("ArgumentsDef"),
          (0, RuleHelpers_1.p)(":"),
          "Type",
          (0, RuleHelpers_1.list)("Directive")
        ],
        ArgumentsDef: [(0, RuleHelpers_1.p)("("), (0, RuleHelpers_1.list)("InputValueDef"), (0, RuleHelpers_1.p)(")")],
        InputValueDef: [
          name("attribute"),
          (0, RuleHelpers_1.p)(":"),
          "Type",
          (0, RuleHelpers_1.opt)("DefaultValue"),
          (0, RuleHelpers_1.list)("Directive")
        ],
        UnionDef: [
          word("union"),
          name("atom"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("="),
          (0, RuleHelpers_1.list)("UnionMember", (0, RuleHelpers_1.p)("|"))
        ],
        UnionMember: ["NamedType"],
        EnumDef: [
          word("enum"),
          name("atom"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("EnumValueDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        EnumValueDef: [name("string-2"), (0, RuleHelpers_1.list)("Directive")],
        InputDef: [
          word("input"),
          name("atom"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("InputValueDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        ExtendDef: [word("extend"), "ObjectTypeDef"]
      };
      function word(value) {
        return {
          style: "keyword",
          match: (token) => token.kind === "Name" && token.value === value
        };
      }
      function name(style) {
        return {
          style,
          match: (token) => token.kind === "Name",
          update(state, token) {
            state.name = token.value;
          }
        };
      }
      function type(style) {
        return {
          style,
          match: (token) => token.kind === "Name",
          update(state, token) {
            var _a3;
            if ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.prevState) {
              state.name = token.value;
              state.prevState.prevState.type = token.value;
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/onlineParser.js
  var require_onlineParser = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/onlineParser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Rules_1 = require_Rules();
      var graphql_1 = require_graphql2();
      function onlineParser(options = {
        eatWhitespace: (stream) => stream.eatWhile(Rules_1.isIgnored),
        lexRules: Rules_1.LexRules,
        parseRules: Rules_1.ParseRules,
        editorConfig: {}
      }) {
        return {
          startState() {
            const initialState = {
              level: 0,
              step: 0,
              name: null,
              kind: null,
              type: null,
              rule: null,
              needsSeperator: false,
              prevState: null
            };
            pushRule(options.parseRules, initialState, graphql_1.Kind.DOCUMENT);
            return initialState;
          },
          token(stream, state) {
            return getToken(stream, state, options);
          }
        };
      }
      exports.default = onlineParser;
      function getToken(stream, state, options) {
        var _a3;
        if (state.inBlockstring) {
          if (stream.match(/.*"""/)) {
            state.inBlockstring = false;
            return "string";
          } else {
            stream.skipToEnd();
            return "string";
          }
        }
        const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
        if (state.rule && state.rule.length === 0) {
          popRule(state);
        } else if (state.needsAdvance) {
          state.needsAdvance = false;
          advanceRule(state, true);
        }
        if (stream.sol()) {
          const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;
          state.indentLevel = Math.floor(stream.indentation() / tabSize);
        }
        if (eatWhitespace(stream)) {
          return "ws";
        }
        const token = lex(lexRules, stream);
        if (!token) {
          const matchedSomething = stream.match(/\S+/);
          if (!matchedSomething) {
            stream.match(/\s/);
          }
          pushRule(SpecialParseRules, state, "Invalid");
          return "invalidchar";
        }
        if (token.kind === "Comment") {
          pushRule(SpecialParseRules, state, "Comment");
          return "comment";
        }
        const backupState = assign({}, state);
        if (token.kind === "Punctuation") {
          if (/^[{([]/.test(token.value)) {
            if (state.indentLevel !== void 0) {
              state.levels = (state.levels || []).concat(state.indentLevel + 1);
            }
          } else if (/^[})\]]/.test(token.value)) {
            const levels = state.levels = (state.levels || []).slice(0, -1);
            if (state.indentLevel) {
              if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {
                state.indentLevel = levels[levels.length - 1];
              }
            }
          }
        }
        while (state.rule) {
          let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];
          if (state.needsSeperator) {
            expected = expected === null || expected === void 0 ? void 0 : expected.separator;
          }
          if (expected) {
            if (expected.ofRule) {
              expected = expected.ofRule;
            }
            if (typeof expected === "string") {
              pushRule(parseRules, state, expected);
              continue;
            }
            if ((_a3 = expected.match) === null || _a3 === void 0 ? void 0 : _a3.call(expected, token)) {
              if (expected.update) {
                expected.update(state, token);
              }
              if (token.kind === "Punctuation") {
                advanceRule(state, true);
              } else {
                state.needsAdvance = true;
              }
              return expected.style;
            }
          }
          unsuccessful(state);
        }
        assign(state, backupState);
        pushRule(SpecialParseRules, state, "Invalid");
        return "invalidchar";
      }
      function assign(to, from) {
        const keys = Object.keys(from);
        for (let i = 0; i < keys.length; i++) {
          to[keys[i]] = from[keys[i]];
        }
        return to;
      }
      var SpecialParseRules = {
        Invalid: [],
        Comment: []
      };
      function pushRule(rules, state, ruleKind) {
        if (!rules[ruleKind]) {
          throw new TypeError("Unknown rule: " + ruleKind);
        }
        state.prevState = Object.assign({}, state);
        state.kind = ruleKind;
        state.name = null;
        state.type = null;
        state.rule = rules[ruleKind];
        state.step = 0;
        state.needsSeperator = false;
      }
      function popRule(state) {
        if (!state.prevState) {
          return;
        }
        state.kind = state.prevState.kind;
        state.name = state.prevState.name;
        state.type = state.prevState.type;
        state.rule = state.prevState.rule;
        state.step = state.prevState.step;
        state.needsSeperator = state.prevState.needsSeperator;
        state.prevState = state.prevState.prevState;
      }
      function advanceRule(state, successful) {
        var _a3;
        if (isList(state) && state.rule) {
          const step = state.rule[state.step];
          if (step.separator) {
            const separator = step.separator;
            state.needsSeperator = !state.needsSeperator;
            if (!state.needsSeperator && separator.ofRule) {
              return;
            }
          }
          if (successful) {
            return;
          }
        }
        state.needsSeperator = false;
        state.step++;
        while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
          popRule(state);
          if (state.rule) {
            if (isList(state)) {
              if ((_a3 = state.rule) === null || _a3 === void 0 ? void 0 : _a3[state.step].separator) {
                state.needsSeperator = !state.needsSeperator;
              }
            } else {
              state.needsSeperator = false;
              state.step++;
            }
          }
        }
      }
      function isList(state) {
        const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];
        return step && step.isList;
      }
      function unsuccessful(state) {
        while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
          popRule(state);
        }
        if (state.rule) {
          advanceRule(state, false);
        }
      }
      function lex(lexRules, stream) {
        const kinds = Object.keys(lexRules);
        for (let i = 0; i < kinds.length; i++) {
          const match = stream.match(lexRules[kinds[i]]);
          if (match && match instanceof Array) {
            return { kind: kinds[i], value: match[0] };
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/types.js
  var require_types = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleKinds = exports.AdditionalRuleKinds = void 0;
      var graphql_1 = require_graphql2();
      exports.AdditionalRuleKinds = {
        ALIASED_FIELD: "AliasedField",
        ARGUMENTS: "Arguments",
        SHORT_QUERY: "ShortQuery",
        QUERY: "Query",
        MUTATION: "Mutation",
        SUBSCRIPTION: "Subscription",
        TYPE_CONDITION: "TypeCondition",
        INVALID: "Invalid",
        COMMENT: "Comment",
        SCHEMA_DEF: "SchemaDef",
        SCALAR_DEF: "ScalarDef",
        OBJECT_TYPE_DEF: "ObjectTypeDef",
        OBJECT_VALUE: "ObjectValue",
        LIST_VALUE: "ListValue",
        INTERFACE_DEF: "InterfaceDef",
        UNION_DEF: "UnionDef",
        ENUM_DEF: "EnumDef",
        ENUM_VALUE: "EnumValue",
        FIELD_DEF: "FieldDef",
        INPUT_DEF: "InputDef",
        INPUT_VALUE_DEF: "InputValueDef",
        ARGUMENTS_DEF: "ArgumentsDef",
        EXTEND_DEF: "ExtendDef",
        DIRECTIVE_DEF: "DirectiveDef",
        IMPLEMENTS: "Implements",
        VARIABLE_DEFINITIONS: "VariableDefinitions",
        TYPE: "Type"
      };
      exports.RuleKinds = Object.assign(Object.assign({}, graphql_1.Kind), exports.AdditionalRuleKinds);
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/index.js
  var require_parser2 = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/parser/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onlineParser = exports.t = exports.p = exports.opt = exports.list = exports.butNot = exports.isIgnored = exports.ParseRules = exports.LexRules = exports.CharacterStream = void 0;
      var CharacterStream_1 = require_CharacterStream();
      Object.defineProperty(exports, "CharacterStream", { enumerable: true, get: function() {
        return __importDefault(CharacterStream_1).default;
      } });
      var Rules_1 = require_Rules();
      Object.defineProperty(exports, "LexRules", { enumerable: true, get: function() {
        return Rules_1.LexRules;
      } });
      Object.defineProperty(exports, "ParseRules", { enumerable: true, get: function() {
        return Rules_1.ParseRules;
      } });
      Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
        return Rules_1.isIgnored;
      } });
      var RuleHelpers_1 = require_RuleHelpers();
      Object.defineProperty(exports, "butNot", { enumerable: true, get: function() {
        return RuleHelpers_1.butNot;
      } });
      Object.defineProperty(exports, "list", { enumerable: true, get: function() {
        return RuleHelpers_1.list;
      } });
      Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
        return RuleHelpers_1.opt;
      } });
      Object.defineProperty(exports, "p", { enumerable: true, get: function() {
        return RuleHelpers_1.p;
      } });
      Object.defineProperty(exports, "t", { enumerable: true, get: function() {
        return RuleHelpers_1.t;
      } });
      var onlineParser_1 = require_onlineParser();
      Object.defineProperty(exports, "onlineParser", { enumerable: true, get: function() {
        return __importDefault(onlineParser_1).default;
      } });
      __exportStar(require_types(), exports);
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getAutocompleteSuggestions.js
  var require_getAutocompleteSuggestions = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getAutocompleteSuggestions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTypeInfo = exports.canUseDirective = exports.runOnlineParser = exports.getTokenAtPosition = exports.getFragmentDefinitions = exports.getVariableCompletions = exports.getAutocompleteSuggestions = exports.SuggestionCommand = void 0;
      var vscode_languageserver_types_1 = require_main();
      var graphql_1 = require_graphql2();
      var graphql_2 = require_graphql2();
      var parser_1 = require_parser2();
      var autocompleteUtils_1 = require_autocompleteUtils();
      exports.SuggestionCommand = {
        command: "editor.action.triggerSuggest",
        title: "Suggestions"
      };
      var collectFragmentDefs = (op) => {
        const externalFragments = [];
        if (op) {
          try {
            (0, graphql_2.visit)((0, graphql_2.parse)(op), {
              FragmentDefinition(def) {
                externalFragments.push(def);
              }
            });
          } catch (_a3) {
            return [];
          }
        }
        return externalFragments;
      };
      function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
        var _a3;
        const opts = Object.assign(Object.assign({}, options), { schema });
        const token = contextToken || getTokenAtPosition(queryText, cursor);
        const state = token.state.kind === "Invalid" ? token.state.prevState : token.state;
        if (!state) {
          return [];
        }
        const kind = state.kind;
        const step = state.step;
        const typeInfo = getTypeInfo(schema, token.state);
        if (kind === parser_1.RuleKinds.DOCUMENT) {
          return (0, autocompleteUtils_1.hintList)(token, [
            { label: "query", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "mutation", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "subscription", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "fragment", kind: vscode_languageserver_types_1.CompletionItemKind.Function },
            { label: "{", kind: vscode_languageserver_types_1.CompletionItemKind.Constructor }
          ]);
        }
        if (kind === parser_1.RuleKinds.IMPLEMENTS || kind === parser_1.RuleKinds.NAMED_TYPE && ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === parser_1.RuleKinds.IMPLEMENTS) {
          return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);
        }
        if (kind === parser_1.RuleKinds.SELECTION_SET || kind === parser_1.RuleKinds.FIELD || kind === parser_1.RuleKinds.ALIASED_FIELD) {
          return getSuggestionsForFieldNames(token, typeInfo, opts);
        }
        if (kind === parser_1.RuleKinds.ARGUMENTS || kind === parser_1.RuleKinds.ARGUMENT && step === 0) {
          const argDefs = typeInfo.argDefs;
          if (argDefs) {
            return (0, autocompleteUtils_1.hintList)(token, argDefs.map((argDef) => {
              var _a4;
              return {
                label: argDef.name,
                insertText: argDef.name + ": ",
                command: exports.SuggestionCommand,
                detail: String(argDef.type),
                documentation: (_a4 = argDef.description) !== null && _a4 !== void 0 ? _a4 : void 0,
                kind: vscode_languageserver_types_1.CompletionItemKind.Variable,
                type: argDef.type
              };
            }));
          }
        }
        if (kind === parser_1.RuleKinds.OBJECT_VALUE || kind === parser_1.RuleKinds.OBJECT_FIELD && step === 0) {
          if (typeInfo.objectFieldDefs) {
            const objectFields = (0, autocompleteUtils_1.objectValues)(typeInfo.objectFieldDefs);
            const completionKind = kind === parser_1.RuleKinds.OBJECT_VALUE ? vscode_languageserver_types_1.CompletionItemKind.Value : vscode_languageserver_types_1.CompletionItemKind.Field;
            return (0, autocompleteUtils_1.hintList)(token, objectFields.map((field) => {
              var _a4;
              return {
                label: field.name,
                detail: String(field.type),
                documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
                kind: completionKind,
                type: field.type
              };
            }));
          }
        }
        if (kind === parser_1.RuleKinds.ENUM_VALUE || kind === parser_1.RuleKinds.LIST_VALUE && step === 1 || kind === parser_1.RuleKinds.OBJECT_FIELD && step === 2 || kind === parser_1.RuleKinds.ARGUMENT && step === 2) {
          return getSuggestionsForInputValues(token, typeInfo, queryText, schema);
        }
        if (kind === parser_1.RuleKinds.VARIABLE && step === 1) {
          const namedInputType = (0, graphql_2.getNamedType)(typeInfo.inputType);
          const variableDefinitions = getVariableCompletions(queryText, schema, token);
          return (0, autocompleteUtils_1.hintList)(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
        }
        if (kind === parser_1.RuleKinds.TYPE_CONDITION && step === 1 || kind === parser_1.RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === parser_1.RuleKinds.TYPE_CONDITION) {
          return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);
        }
        if (kind === parser_1.RuleKinds.FRAGMENT_SPREAD && step === 1) {
          return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
        }
        if (kind === parser_1.RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === parser_1.RuleKinds.LIST_TYPE && step === 1 || kind === parser_1.RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === parser_1.RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === parser_1.RuleKinds.LIST_TYPE || state.prevState.kind === parser_1.RuleKinds.NON_NULL_TYPE)) {
          return getSuggestionsForVariableDefinition(token, schema, kind);
        }
        if (kind === parser_1.RuleKinds.DIRECTIVE) {
          return getSuggestionsForDirective(token, state, schema, kind);
        }
        return [];
      }
      exports.getAutocompleteSuggestions = getAutocompleteSuggestions;
      var insertSuffix = ` {
  $1
}`;
      var getInsertText = (field) => {
        const type = field.type;
        if ((0, graphql_2.isCompositeType)(type)) {
          return insertSuffix;
        }
        if ((0, graphql_1.isListType)(type) && (0, graphql_2.isCompositeType)(type.ofType)) {
          return insertSuffix;
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          if ((0, graphql_2.isCompositeType)(type.ofType)) {
            return insertSuffix;
          }
          if ((0, graphql_1.isListType)(type.ofType) && (0, graphql_2.isCompositeType)(type.ofType.ofType)) {
            return insertSuffix;
          }
        }
        return null;
      };
      function getSuggestionsForFieldNames(token, typeInfo, options) {
        var _a3;
        if (typeInfo.parentType) {
          const parentType = typeInfo.parentType;
          let fields = [];
          if ("getFields" in parentType) {
            fields = (0, autocompleteUtils_1.objectValues)(parentType.getFields());
          }
          if ((0, graphql_2.isCompositeType)(parentType)) {
            fields.push(graphql_2.TypeNameMetaFieldDef);
          }
          if (parentType === ((_a3 = options === null || options === void 0 ? void 0 : options.schema) === null || _a3 === void 0 ? void 0 : _a3.getQueryType())) {
            fields.push(graphql_2.SchemaMetaFieldDef, graphql_2.TypeMetaFieldDef);
          }
          return (0, autocompleteUtils_1.hintList)(token, fields.map((field, index) => {
            var _a4;
            const suggestion = {
              sortText: String(index) + field.name,
              label: field.name,
              detail: String(field.type),
              documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
              deprecated: Boolean(field.deprecationReason),
              isDeprecated: Boolean(field.deprecationReason),
              deprecationReason: field.deprecationReason,
              kind: vscode_languageserver_types_1.CompletionItemKind.Field,
              type: field.type
            };
            const insertText = getInsertText(field);
            if (insertText) {
              suggestion.insertText = field.name + insertText;
              suggestion.insertTextFormat = vscode_languageserver_types_1.InsertTextFormat.Snippet;
              suggestion.command = exports.SuggestionCommand;
            }
            return suggestion;
          }));
        }
        return [];
      }
      function getSuggestionsForInputValues(token, typeInfo, queryText, schema) {
        const namedInputType = (0, graphql_2.getNamedType)(typeInfo.inputType);
        const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);
        if (namedInputType instanceof graphql_2.GraphQLEnumType) {
          const values = namedInputType.getValues();
          return (0, autocompleteUtils_1.hintList)(token, values.map((value) => {
            var _a3;
            return {
              label: value.name,
              detail: String(namedInputType),
              documentation: (_a3 = value.description) !== null && _a3 !== void 0 ? _a3 : void 0,
              deprecated: Boolean(value.deprecationReason),
              isDeprecated: Boolean(value.deprecationReason),
              deprecationReason: value.deprecationReason,
              kind: vscode_languageserver_types_1.CompletionItemKind.EnumMember,
              type: namedInputType
            };
          }).concat(queryVariables));
        } else if (namedInputType === graphql_2.GraphQLBoolean) {
          return (0, autocompleteUtils_1.hintList)(token, queryVariables.concat([
            {
              label: "true",
              detail: String(graphql_2.GraphQLBoolean),
              documentation: "Not false.",
              kind: vscode_languageserver_types_1.CompletionItemKind.Variable,
              type: graphql_2.GraphQLBoolean
            },
            {
              label: "false",
              detail: String(graphql_2.GraphQLBoolean),
              documentation: "Not true.",
              kind: vscode_languageserver_types_1.CompletionItemKind.Variable,
              type: graphql_2.GraphQLBoolean
            }
          ]));
        }
        return queryVariables;
      }
      function getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {
        if (tokenState.needsSeperator) {
          return [];
        }
        const typeMap = schema.getTypeMap();
        const schemaInterfaces = (0, autocompleteUtils_1.objectValues)(typeMap).filter(graphql_1.isInterfaceType);
        const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);
        const inlineInterfaces = /* @__PURE__ */ new Set();
        runOnlineParser(documentText, (_, state) => {
          var _a3, _b, _c, _d, _e;
          if (state.name) {
            if (state.kind === parser_1.RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {
              inlineInterfaces.add(state.name);
            }
            if (state.kind === parser_1.RuleKinds.NAMED_TYPE && ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === parser_1.RuleKinds.IMPLEMENTS) {
              if (typeInfo.interfaceDef) {
                const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);
                if (existingType) {
                  return;
                }
                const type = schema.getType(state.name);
                const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
                typeInfo.interfaceDef = new graphql_1.GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
                  ...interfaceConfig.interfaces,
                  type || new graphql_1.GraphQLInterfaceType({ name: state.name, fields: {} })
                ] }));
              } else if (typeInfo.objectTypeDef) {
                const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);
                if (existingType) {
                  return;
                }
                const type = schema.getType(state.name);
                const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();
                typeInfo.objectTypeDef = new graphql_1.GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
                  ...objectTypeConfig.interfaces,
                  type || new graphql_1.GraphQLInterfaceType({ name: state.name, fields: {} })
                ] }));
              }
            }
          }
        });
        const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
        const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
        const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);
        const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));
        return (0, autocompleteUtils_1.hintList)(token, possibleInterfaces.map((type) => {
          const result = {
            label: type.name,
            kind: vscode_languageserver_types_1.CompletionItemKind.Interface,
            type
          };
          if (type === null || type === void 0 ? void 0 : type.description) {
            result.documentation = type.description;
          }
          return result;
        }));
      }
      function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {
        let possibleTypes;
        if (typeInfo.parentType) {
          if ((0, graphql_2.isAbstractType)(typeInfo.parentType)) {
            const abstractType = (0, graphql_2.assertAbstractType)(typeInfo.parentType);
            const possibleObjTypes = schema.getPossibleTypes(abstractType);
            const possibleIfaceMap = /* @__PURE__ */ Object.create(null);
            possibleObjTypes.forEach((type) => {
              type.getInterfaces().forEach((iface) => {
                possibleIfaceMap[iface.name] = iface;
              });
            });
            possibleTypes = possibleObjTypes.concat((0, autocompleteUtils_1.objectValues)(possibleIfaceMap));
          } else {
            possibleTypes = [typeInfo.parentType];
          }
        } else {
          const typeMap = schema.getTypeMap();
          possibleTypes = (0, autocompleteUtils_1.objectValues)(typeMap).filter(graphql_2.isCompositeType);
        }
        return (0, autocompleteUtils_1.hintList)(token, possibleTypes.map((type) => {
          const namedType = (0, graphql_2.getNamedType)(type);
          return {
            label: String(type),
            documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || "",
            kind: vscode_languageserver_types_1.CompletionItemKind.Field
          };
        }));
      }
      function getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {
        if (!queryText) {
          return [];
        }
        const typeMap = schema.getTypeMap();
        const defState = (0, autocompleteUtils_1.getDefinitionState)(token.state);
        const fragments = getFragmentDefinitions(queryText);
        if (fragmentDefs && fragmentDefs.length > 0) {
          fragments.push(...fragmentDefs);
        }
        const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === parser_1.RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && (0, graphql_2.isCompositeType)(typeInfo.parentType) && (0, graphql_2.isCompositeType)(typeMap[frag.typeCondition.name.value]) && (0, graphql_2.doTypesOverlap)(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
        return (0, autocompleteUtils_1.hintList)(token, relevantFrags.map((frag) => ({
          label: frag.name.value,
          detail: String(typeMap[frag.typeCondition.name.value]),
          documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
          kind: vscode_languageserver_types_1.CompletionItemKind.Field,
          type: typeMap[frag.typeCondition.name.value]
        })));
      }
      var getParentDefinition = (state, kind) => {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === kind) {
          return state.prevState;
        }
        if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {
          return state.prevState.prevState;
        }
        if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {
          return state.prevState.prevState.prevState;
        }
        if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {
          return state.prevState.prevState.prevState.prevState;
        }
      };
      function getVariableCompletions(queryText, schema, token) {
        let variableName = null;
        let variableType;
        const definitions = /* @__PURE__ */ Object.create({});
        runOnlineParser(queryText, (_, state) => {
          if ((state === null || state === void 0 ? void 0 : state.kind) === parser_1.RuleKinds.VARIABLE && state.name) {
            variableName = state.name;
          }
          if ((state === null || state === void 0 ? void 0 : state.kind) === parser_1.RuleKinds.NAMED_TYPE && variableName) {
            const parentDefinition = getParentDefinition(state, parser_1.RuleKinds.TYPE);
            if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
              variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
            }
          }
          if (variableName && variableType) {
            if (!definitions[variableName]) {
              definitions[variableName] = {
                detail: variableType.toString(),
                insertText: token.string === "$" ? variableName : "$" + variableName,
                label: variableName,
                type: variableType,
                kind: vscode_languageserver_types_1.CompletionItemKind.Variable
              };
              variableName = null;
              variableType = null;
            }
          }
        });
        return (0, autocompleteUtils_1.objectValues)(definitions);
      }
      exports.getVariableCompletions = getVariableCompletions;
      function getFragmentDefinitions(queryText) {
        const fragmentDefs = [];
        runOnlineParser(queryText, (_, state) => {
          if (state.kind === parser_1.RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {
            fragmentDefs.push({
              kind: parser_1.RuleKinds.FRAGMENT_DEFINITION,
              name: {
                kind: graphql_1.Kind.NAME,
                value: state.name
              },
              selectionSet: {
                kind: parser_1.RuleKinds.SELECTION_SET,
                selections: []
              },
              typeCondition: {
                kind: parser_1.RuleKinds.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: state.type
                }
              }
            });
          }
        });
        return fragmentDefs;
      }
      exports.getFragmentDefinitions = getFragmentDefinitions;
      function getSuggestionsForVariableDefinition(token, schema, _kind) {
        const inputTypeMap = schema.getTypeMap();
        const inputTypes = (0, autocompleteUtils_1.objectValues)(inputTypeMap).filter(graphql_2.isInputType);
        return (0, autocompleteUtils_1.hintList)(token, inputTypes.map((type) => ({
          label: type.name,
          documentation: type.description,
          kind: vscode_languageserver_types_1.CompletionItemKind.Variable
        })));
      }
      function getSuggestionsForDirective(token, state, schema, _kind) {
        var _a3;
        if ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) {
          const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));
          return (0, autocompleteUtils_1.hintList)(token, directives.map((directive) => ({
            label: directive.name,
            documentation: directive.description || "",
            kind: vscode_languageserver_types_1.CompletionItemKind.Function
          })));
        }
        return [];
      }
      function getTokenAtPosition(queryText, cursor) {
        let styleAtCursor = null;
        let stateAtCursor = null;
        let stringAtCursor = null;
        const token = runOnlineParser(queryText, (stream, state, style, index) => {
          if (index === cursor.line) {
            if (stream.getCurrentPosition() >= cursor.character) {
              styleAtCursor = style;
              stateAtCursor = Object.assign({}, state);
              stringAtCursor = stream.current();
              return "BREAK";
            }
          }
        });
        return {
          start: token.start,
          end: token.end,
          string: stringAtCursor || token.string,
          state: stateAtCursor || token.state,
          style: styleAtCursor || token.style
        };
      }
      exports.getTokenAtPosition = getTokenAtPosition;
      function runOnlineParser(queryText, callback) {
        const lines = queryText.split("\n");
        const parser = (0, parser_1.onlineParser)();
        let state = parser.startState();
        let style = "";
        let stream = new parser_1.CharacterStream("");
        for (let i = 0; i < lines.length; i++) {
          stream = new parser_1.CharacterStream(lines[i]);
          while (!stream.eol()) {
            style = parser.token(stream, state);
            const code = callback(stream, state, style, i);
            if (code === "BREAK") {
              break;
            }
          }
          callback(stream, state, style, i);
          if (!state.kind) {
            state = parser.startState();
          }
        }
        return {
          start: stream.getStartOfToken(),
          end: stream.getCurrentPosition(),
          string: stream.current(),
          state,
          style
        };
      }
      exports.runOnlineParser = runOnlineParser;
      function canUseDirective(state, directive) {
        var _a3;
        if (!state || !state.kind) {
          return false;
        }
        const kind = state.kind;
        const locations = directive.locations;
        switch (kind) {
          case parser_1.RuleKinds.QUERY:
            return locations.indexOf(graphql_1.DirectiveLocation.QUERY) !== -1;
          case parser_1.RuleKinds.MUTATION:
            return locations.indexOf(graphql_1.DirectiveLocation.MUTATION) !== -1;
          case parser_1.RuleKinds.SUBSCRIPTION:
            return locations.indexOf(graphql_1.DirectiveLocation.SUBSCRIPTION) !== -1;
          case parser_1.RuleKinds.FIELD:
          case parser_1.RuleKinds.ALIASED_FIELD:
            return locations.indexOf(graphql_1.DirectiveLocation.FIELD) !== -1;
          case parser_1.RuleKinds.FRAGMENT_DEFINITION:
            return locations.indexOf(graphql_1.DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
          case parser_1.RuleKinds.FRAGMENT_SPREAD:
            return locations.indexOf(graphql_1.DirectiveLocation.FRAGMENT_SPREAD) !== -1;
          case parser_1.RuleKinds.INLINE_FRAGMENT:
            return locations.indexOf(graphql_1.DirectiveLocation.INLINE_FRAGMENT) !== -1;
          case parser_1.RuleKinds.SCHEMA_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.SCHEMA) !== -1;
          case parser_1.RuleKinds.SCALAR_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.SCALAR) !== -1;
          case parser_1.RuleKinds.OBJECT_TYPE_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.OBJECT) !== -1;
          case parser_1.RuleKinds.FIELD_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.FIELD_DEFINITION) !== -1;
          case parser_1.RuleKinds.INTERFACE_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.INTERFACE) !== -1;
          case parser_1.RuleKinds.UNION_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.UNION) !== -1;
          case parser_1.RuleKinds.ENUM_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.ENUM) !== -1;
          case parser_1.RuleKinds.ENUM_VALUE:
            return locations.indexOf(graphql_1.DirectiveLocation.ENUM_VALUE) !== -1;
          case parser_1.RuleKinds.INPUT_DEF:
            return locations.indexOf(graphql_1.DirectiveLocation.INPUT_OBJECT) !== -1;
          case parser_1.RuleKinds.INPUT_VALUE_DEF:
            const prevStateKind = (_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind;
            switch (prevStateKind) {
              case parser_1.RuleKinds.ARGUMENTS_DEF:
                return locations.indexOf(graphql_1.DirectiveLocation.ARGUMENT_DEFINITION) !== -1;
              case parser_1.RuleKinds.INPUT_DEF:
                return locations.indexOf(graphql_1.DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;
            }
        }
        return false;
      }
      exports.canUseDirective = canUseDirective;
      function getTypeInfo(schema, tokenState) {
        let argDef;
        let argDefs;
        let directiveDef;
        let enumValue;
        let fieldDef;
        let inputType;
        let objectTypeDef;
        let objectFieldDefs;
        let parentType;
        let type;
        let interfaceDef;
        (0, autocompleteUtils_1.forEachState)(tokenState, (state) => {
          var _a3;
          switch (state.kind) {
            case parser_1.RuleKinds.QUERY:
            case "ShortQuery":
              type = schema.getQueryType();
              break;
            case parser_1.RuleKinds.MUTATION:
              type = schema.getMutationType();
              break;
            case parser_1.RuleKinds.SUBSCRIPTION:
              type = schema.getSubscriptionType();
              break;
            case parser_1.RuleKinds.INLINE_FRAGMENT:
            case parser_1.RuleKinds.FRAGMENT_DEFINITION:
              if (state.type) {
                type = schema.getType(state.type);
              }
              break;
            case parser_1.RuleKinds.FIELD:
            case parser_1.RuleKinds.ALIASED_FIELD: {
              if (!type || !state.name) {
                fieldDef = null;
              } else {
                fieldDef = parentType ? (0, autocompleteUtils_1.getFieldDef)(schema, parentType, state.name) : null;
                type = fieldDef ? fieldDef.type : null;
              }
              break;
            }
            case parser_1.RuleKinds.SELECTION_SET:
              parentType = (0, graphql_2.getNamedType)(type);
              break;
            case parser_1.RuleKinds.DIRECTIVE:
              directiveDef = state.name ? schema.getDirective(state.name) : null;
              break;
            case parser_1.RuleKinds.INTERFACE_DEF:
              if (state.name) {
                objectTypeDef = null;
                interfaceDef = new graphql_1.GraphQLInterfaceType({
                  name: state.name,
                  interfaces: [],
                  fields: {}
                });
              }
              break;
            case parser_1.RuleKinds.OBJECT_TYPE_DEF:
              if (state.name) {
                interfaceDef = null;
                objectTypeDef = new graphql_1.GraphQLObjectType({
                  name: state.name,
                  interfaces: [],
                  fields: {}
                });
              }
              break;
            case parser_1.RuleKinds.ARGUMENTS: {
              if (!state.prevState) {
                argDefs = null;
              } else {
                switch (state.prevState.kind) {
                  case parser_1.RuleKinds.FIELD:
                    argDefs = fieldDef && fieldDef.args;
                    break;
                  case parser_1.RuleKinds.DIRECTIVE:
                    argDefs = directiveDef && directiveDef.args;
                    break;
                  case parser_1.RuleKinds.ALIASED_FIELD: {
                    const name = (_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.name;
                    if (!name) {
                      argDefs = null;
                      break;
                    }
                    const field = parentType ? (0, autocompleteUtils_1.getFieldDef)(schema, parentType, name) : null;
                    if (!field) {
                      argDefs = null;
                      break;
                    }
                    argDefs = field.args;
                    break;
                  }
                  default:
                    argDefs = null;
                    break;
                }
              }
              break;
            }
            case parser_1.RuleKinds.ARGUMENT:
              if (argDefs) {
                for (let i = 0; i < argDefs.length; i++) {
                  if (argDefs[i].name === state.name) {
                    argDef = argDefs[i];
                    break;
                  }
                }
              }
              inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;
              break;
            case parser_1.RuleKinds.ENUM_VALUE:
              const enumType = (0, graphql_2.getNamedType)(inputType);
              enumValue = enumType instanceof graphql_2.GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;
              break;
            case parser_1.RuleKinds.LIST_VALUE:
              const nullableType = (0, graphql_2.getNullableType)(inputType);
              inputType = nullableType instanceof graphql_2.GraphQLList ? nullableType.ofType : null;
              break;
            case parser_1.RuleKinds.OBJECT_VALUE:
              const objectType = (0, graphql_2.getNamedType)(inputType);
              objectFieldDefs = objectType instanceof graphql_2.GraphQLInputObjectType ? objectType.getFields() : null;
              break;
            case parser_1.RuleKinds.OBJECT_FIELD:
              const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
              inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;
              break;
            case parser_1.RuleKinds.NAMED_TYPE:
              if (state.name) {
                type = schema.getType(state.name);
              }
              break;
          }
        });
        return {
          argDef,
          argDefs,
          directiveDef,
          enumValue,
          fieldDef,
          inputType,
          objectFieldDefs,
          parentType,
          type,
          interfaceDef,
          objectTypeDef
        };
      }
      exports.getTypeInfo = getTypeInfo;
    }
  });

  // ../../node_modules/.pnpm/nullthrows@1.1.1/node_modules/nullthrows/nullthrows.js
  var require_nullthrows = __commonJS({
    "../../node_modules/.pnpm/nullthrows@1.1.1/node_modules/nullthrows/nullthrows.js"(exports, module) {
      "use strict";
      function nullthrows(x, message) {
        if (x != null) {
          return x;
        }
        var error = new Error(message !== void 0 ? message : "Got unexpected " + x);
        error.framesToPop = 1;
        throw error;
      }
      module.exports = nullthrows;
      module.exports.default = nullthrows;
      Object.defineProperty(module.exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/fragmentDependencies.js
  var require_fragmentDependencies = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/fragmentDependencies.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = void 0;
      var graphql_1 = require_graphql2();
      var nullthrows_1 = __importDefault(require_nullthrows());
      var getFragmentDependencies = (operationString, fragmentDefinitions) => {
        if (!fragmentDefinitions) {
          return [];
        }
        let parsedOperation;
        try {
          parsedOperation = (0, graphql_1.parse)(operationString);
        } catch (error) {
          return [];
        }
        return (0, exports.getFragmentDependenciesForAST)(parsedOperation, fragmentDefinitions);
      };
      exports.getFragmentDependencies = getFragmentDependencies;
      var getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {
        if (!fragmentDefinitions) {
          return [];
        }
        const existingFrags = /* @__PURE__ */ new Map();
        const referencedFragNames = /* @__PURE__ */ new Set();
        (0, graphql_1.visit)(parsedOperation, {
          FragmentDefinition(node) {
            existingFrags.set(node.name.value, true);
          },
          FragmentSpread(node) {
            if (!referencedFragNames.has(node.name.value)) {
              referencedFragNames.add(node.name.value);
            }
          }
        });
        const asts = /* @__PURE__ */ new Set();
        referencedFragNames.forEach((name) => {
          if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
            asts.add((0, nullthrows_1.default)(fragmentDefinitions.get(name)));
          }
        });
        const referencedFragments = [];
        asts.forEach((ast) => {
          (0, graphql_1.visit)(ast, {
            FragmentSpread(node) {
              if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                asts.add((0, nullthrows_1.default)(fragmentDefinitions.get(node.name.value)));
                referencedFragNames.add(node.name.value);
              }
            }
          });
          if (!existingFrags.has(ast.name.value)) {
            referencedFragments.push(ast);
          }
        });
        return referencedFragments;
      };
      exports.getFragmentDependenciesForAST = getFragmentDependenciesForAST;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/getVariablesJSONSchema.js
  var require_getVariablesJSONSchema = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/getVariablesJSONSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getVariablesJSONSchema = exports.defaultJSONSchemaOptions = void 0;
      var graphql_1 = require_graphql2();
      exports.defaultJSONSchemaOptions = {
        useMarkdownDescription: false
      };
      function text(into, newText) {
        into.push(newText);
      }
      function renderType(into, t) {
        if ((0, graphql_1.isNonNullType)(t)) {
          renderType(into, t.ofType);
          text(into, "!");
        } else if ((0, graphql_1.isListType)(t)) {
          text(into, "[");
          renderType(into, t.ofType);
          text(into, "]");
        } else {
          text(into, t.name);
        }
      }
      function renderTypeToString(t, useMarkdown) {
        const into = [];
        if (useMarkdown) {
          text(into, "```graphql\n");
        }
        renderType(into, t);
        if (useMarkdown) {
          text(into, "\n```");
        }
        return into.join("");
      }
      var scalarTypesMap = {
        Int: "integer",
        String: "string",
        Float: "number",
        ID: "string",
        Boolean: "boolean",
        DateTime: "string"
      };
      function getJSONSchemaFromGraphQLType(type, options) {
        var _a3;
        let required = false;
        let definition = /* @__PURE__ */ Object.create(null);
        const definitions = /* @__PURE__ */ Object.create(null);
        if ("defaultValue" in type && type.defaultValue !== void 0) {
          definition.default = type.defaultValue;
        }
        if ((0, graphql_1.isEnumType)(type)) {
          definition.type = "string";
          definition.enum = type.getValues().map((val) => val.name);
        }
        if ((0, graphql_1.isScalarType)(type)) {
          definition.type = (_a3 = scalarTypesMap[type.name]) !== null && _a3 !== void 0 ? _a3 : "any";
        }
        if ((0, graphql_1.isListType)(type)) {
          definition.type = "array";
          const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type.ofType, options);
          if (def.$ref) {
            definition.items = { $ref: def.$ref };
          } else {
            definition.items = def;
          }
          if (defs) {
            Object.keys(defs).forEach((defName) => {
              definitions[defName] = defs[defName];
            });
          }
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          required = true;
          const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type.ofType, options);
          definition = def;
          if (defs) {
            Object.keys(defs).forEach((defName) => {
              definitions[defName] = defs[defName];
            });
          }
        }
        if ((0, graphql_1.isInputObjectType)(type)) {
          definition.$ref = `#/definitions/${type.name}`;
          const fields = type.getFields();
          const fieldDef = {
            type: "object",
            properties: {},
            required: []
          };
          if (type.description) {
            fieldDef.description = type.description + `
` + renderTypeToString(type);
            if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
              fieldDef.markdownDescription = type.description + `
` + renderTypeToString(type, true);
            }
          } else {
            fieldDef.description = renderTypeToString(type);
            if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
              fieldDef.markdownDescription = renderTypeToString(type, true);
            }
          }
          Object.keys(fields).forEach((fieldName) => {
            const field = fields[fieldName];
            const { required: fieldRequired, definition: typeDefinition, definitions: typeDefinitions } = getJSONSchemaFromGraphQLType(field.type, options);
            const { definition: fieldDefinition } = getJSONSchemaFromGraphQLType(field, options);
            fieldDef.properties[fieldName] = Object.assign(Object.assign({}, typeDefinition), fieldDefinition);
            const renderedField = renderTypeToString(field.type);
            fieldDef.properties[fieldName].description = field.description ? field.description + "\n" + renderedField : renderedField;
            if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
              const renderedFieldMarkdown = renderTypeToString(field.type, true);
              fieldDef.properties[fieldName].markdownDescription = field.description ? field.description + "\n" + renderedFieldMarkdown : renderedFieldMarkdown;
            }
            if (fieldRequired) {
              fieldDef.required.push(fieldName);
            }
            if (typeDefinitions) {
              Object.keys(typeDefinitions).map((defName) => {
                definitions[defName] = typeDefinitions[defName];
              });
            }
          });
          definitions[type.name] = fieldDef;
        }
        if ("description" in type && !(0, graphql_1.isScalarType)(type) && type.description && !definition.description) {
          definition.description = type.description + "\n" + renderTypeToString(type);
          if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
            definition.markdownDescription = type.description + "\n" + renderTypeToString(type, true);
          }
        } else {
          definition.description = renderTypeToString(type);
          if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
            definition.markdownDescription = renderTypeToString(type, true);
          }
        }
        return { required, definition, definitions };
      }
      function getVariablesJSONSchema(variableToType, options) {
        const jsonSchema = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          type: "object",
          properties: {},
          required: []
        };
        if (variableToType) {
          Object.entries(variableToType).forEach(([variableName, type]) => {
            var _a3;
            const { definition, required, definitions } = getJSONSchemaFromGraphQLType(type, options);
            jsonSchema.properties[variableName] = definition;
            if (required) {
              (_a3 = jsonSchema.required) === null || _a3 === void 0 ? void 0 : _a3.push(variableName);
            }
            if (definitions) {
              jsonSchema.definitions = Object.assign(Object.assign({}, jsonSchema === null || jsonSchema === void 0 ? void 0 : jsonSchema.definitions), definitions);
            }
          });
        }
        return jsonSchema;
      }
      exports.getVariablesJSONSchema = getVariablesJSONSchema;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/getASTNodeAtPosition.js
  var require_getASTNodeAtPosition = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/getASTNodeAtPosition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pointToOffset = exports.getASTNodeAtPosition = void 0;
      var graphql_1 = require_graphql2();
      function getASTNodeAtPosition(query, ast, point) {
        const offset = pointToOffset(query, point);
        let nodeContainingPosition;
        (0, graphql_1.visit)(ast, {
          enter(node) {
            if (node.kind !== "Name" && node.loc && node.loc.start <= offset && offset <= node.loc.end) {
              nodeContainingPosition = node;
            } else {
              return false;
            }
          },
          leave(node) {
            if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {
              return false;
            }
          }
        });
        return nodeContainingPosition;
      }
      exports.getASTNodeAtPosition = getASTNodeAtPosition;
      function pointToOffset(text, point) {
        const linesUntilPosition = text.split("\n").slice(0, point.line);
        return point.character + linesUntilPosition.map((line) => line.length + 1).reduce((a, b) => a + b, 0);
      }
      exports.pointToOffset = pointToOffset;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/Range.js
  var require_Range = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/Range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.locToRange = exports.offsetToPosition = exports.Position = exports.Range = void 0;
      var Range2 = class {
        constructor(start, end) {
          this.containsPosition = (position) => {
            if (this.start.line === position.line) {
              return this.start.character <= position.character;
            } else if (this.end.line === position.line) {
              return this.end.character >= position.character;
            } else {
              return this.start.line <= position.line && this.end.line >= position.line;
            }
          };
          this.start = start;
          this.end = end;
        }
        setStart(line, character) {
          this.start = new Position2(line, character);
        }
        setEnd(line, character) {
          this.end = new Position2(line, character);
        }
      };
      exports.Range = Range2;
      var Position2 = class {
        constructor(line, character) {
          this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;
          this.line = line;
          this.character = character;
        }
        setLine(line) {
          this.line = line;
        }
        setCharacter(character) {
          this.character = character;
        }
      };
      exports.Position = Position2;
      function offsetToPosition(text, loc) {
        const EOL = "\n";
        const buf = text.slice(0, loc);
        const lines = buf.split(EOL).length - 1;
        const lastLineIndex = buf.lastIndexOf(EOL);
        return new Position2(lines, loc - lastLineIndex - 1);
      }
      exports.offsetToPosition = offsetToPosition;
      function locToRange(text, loc) {
        const start = offsetToPosition(text, loc.start);
        const end = offsetToPosition(text, loc.end);
        return new Range2(start, end);
      }
      exports.locToRange = locToRange;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/validateWithCustomRules.js
  var require_validateWithCustomRules = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/validateWithCustomRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateWithCustomRules = void 0;
      var graphql_1 = require_graphql2();
      var specifiedSDLRules = [
        graphql_1.LoneSchemaDefinitionRule,
        graphql_1.UniqueOperationTypesRule,
        graphql_1.UniqueTypeNamesRule,
        graphql_1.UniqueEnumValueNamesRule,
        graphql_1.UniqueFieldDefinitionNamesRule,
        graphql_1.UniqueDirectiveNamesRule,
        graphql_1.KnownTypeNamesRule,
        graphql_1.KnownDirectivesRule,
        graphql_1.UniqueDirectivesPerLocationRule,
        graphql_1.PossibleTypeExtensionsRule,
        graphql_1.UniqueArgumentNamesRule,
        graphql_1.UniqueInputFieldNamesRule
      ];
      function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {
        const rules = graphql_1.specifiedRules.filter((rule) => {
          if (rule === graphql_1.NoUnusedFragmentsRule || rule === graphql_1.ExecutableDefinitionsRule) {
            return false;
          }
          if (isRelayCompatMode && rule === graphql_1.KnownFragmentNamesRule) {
            return false;
          }
          return true;
        });
        if (customRules) {
          Array.prototype.push.apply(rules, customRules);
        }
        if (isSchemaDocument) {
          Array.prototype.push.apply(rules, specifiedSDLRules);
        }
        const errors = (0, graphql_1.validate)(schema, ast, rules);
        return errors.filter((error) => {
          if (error.message.indexOf("Unknown directive") !== -1 && error.nodes) {
            const node = error.nodes[0];
            if (node && node.kind === graphql_1.Kind.DIRECTIVE) {
              const name = node.name.value;
              if (name === "arguments" || name === "argumentDefinitions") {
                return false;
              }
            }
          }
          return true;
        });
      }
      exports.validateWithCustomRules = validateWithCustomRules;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/collectVariables.js
  var require_collectVariables = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/collectVariables.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.collectVariables = void 0;
      var graphql_1 = require_graphql2();
      function collectVariables(schema, documentAST) {
        const variableToType = /* @__PURE__ */ Object.create(null);
        documentAST.definitions.forEach((definition) => {
          if (definition.kind === "OperationDefinition") {
            const variableDefinitions = definition.variableDefinitions;
            if (variableDefinitions) {
              variableDefinitions.forEach(({ variable, type }) => {
                const inputType = (0, graphql_1.typeFromAST)(schema, type);
                if (inputType) {
                  variableToType[variable.name.value] = inputType;
                } else if (type.kind === graphql_1.Kind.NAMED_TYPE) {
                  if (type.name.value === "Float") {
                    variableToType[variable.name.value] = graphql_1.GraphQLFloat;
                  }
                }
              });
            }
          }
        });
        return variableToType;
      }
      exports.collectVariables = collectVariables;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/getOperationFacts.js
  var require_getOperationFacts = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/getOperationFacts.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getQueryFacts = exports.getOperationASTFacts = void 0;
      var graphql_1 = require_graphql2();
      var collectVariables_1 = require_collectVariables();
      function getOperationASTFacts(documentAST, schema) {
        const variableToType = schema ? (0, collectVariables_1.collectVariables)(schema, documentAST) : void 0;
        const operations = [];
        (0, graphql_1.visit)(documentAST, {
          OperationDefinition(node) {
            operations.push(node);
          }
        });
        return { variableToType, operations };
      }
      exports.getOperationASTFacts = getOperationASTFacts;
      function getOperationFacts(schema, documentString) {
        if (!documentString) {
          return;
        }
        try {
          const documentAST = (0, graphql_1.parse)(documentString);
          return Object.assign(Object.assign({}, getOperationASTFacts(documentAST, schema)), { documentAST });
        } catch (_a3) {
          return;
        }
      }
      exports.default = getOperationFacts;
      exports.getQueryFacts = getOperationFacts;
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/index.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/utils/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getQueryFacts = exports.getOperationASTFacts = exports.getOperationFacts = exports.collectVariables = exports.validateWithCustomRules = exports.offsetToPosition = exports.locToRange = exports.Range = exports.Position = exports.pointToOffset = exports.getASTNodeAtPosition = exports.getVariablesJSONSchema = exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = void 0;
      var fragmentDependencies_1 = require_fragmentDependencies();
      Object.defineProperty(exports, "getFragmentDependencies", { enumerable: true, get: function() {
        return fragmentDependencies_1.getFragmentDependencies;
      } });
      Object.defineProperty(exports, "getFragmentDependenciesForAST", { enumerable: true, get: function() {
        return fragmentDependencies_1.getFragmentDependenciesForAST;
      } });
      var getVariablesJSONSchema_1 = require_getVariablesJSONSchema();
      Object.defineProperty(exports, "getVariablesJSONSchema", { enumerable: true, get: function() {
        return getVariablesJSONSchema_1.getVariablesJSONSchema;
      } });
      var getASTNodeAtPosition_1 = require_getASTNodeAtPosition();
      Object.defineProperty(exports, "getASTNodeAtPosition", { enumerable: true, get: function() {
        return getASTNodeAtPosition_1.getASTNodeAtPosition;
      } });
      Object.defineProperty(exports, "pointToOffset", { enumerable: true, get: function() {
        return getASTNodeAtPosition_1.pointToOffset;
      } });
      var Range_1 = require_Range();
      Object.defineProperty(exports, "Position", { enumerable: true, get: function() {
        return Range_1.Position;
      } });
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return Range_1.Range;
      } });
      Object.defineProperty(exports, "locToRange", { enumerable: true, get: function() {
        return Range_1.locToRange;
      } });
      Object.defineProperty(exports, "offsetToPosition", { enumerable: true, get: function() {
        return Range_1.offsetToPosition;
      } });
      var validateWithCustomRules_1 = require_validateWithCustomRules();
      Object.defineProperty(exports, "validateWithCustomRules", { enumerable: true, get: function() {
        return validateWithCustomRules_1.validateWithCustomRules;
      } });
      var collectVariables_1 = require_collectVariables();
      Object.defineProperty(exports, "collectVariables", { enumerable: true, get: function() {
        return collectVariables_1.collectVariables;
      } });
      var getOperationFacts_1 = require_getOperationFacts();
      Object.defineProperty(exports, "getOperationFacts", { enumerable: true, get: function() {
        return __importDefault(getOperationFacts_1).default;
      } });
      Object.defineProperty(exports, "getOperationASTFacts", { enumerable: true, get: function() {
        return getOperationFacts_1.getOperationASTFacts;
      } });
      Object.defineProperty(exports, "getQueryFacts", { enumerable: true, get: function() {
        return getOperationFacts_1.getQueryFacts;
      } });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getDefinition.js
  var require_getDefinition = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getDefinition.js"(exports) {
      "use strict";
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDefinitionQueryResultForDefinitionNode = exports.getDefinitionQueryResultForFragmentSpread = exports.getDefinitionQueryResultForField = exports.getDefinitionQueryResultForNamedType = exports.LANGUAGE = void 0;
      var utils_1 = require_utils();
      exports.LANGUAGE = "GraphQL";
      function assert(value, message) {
        if (!value) {
          throw new Error(message);
        }
      }
      function getRange(text, node) {
        const location = node.loc;
        assert(location, "Expected ASTNode to have a location.");
        return (0, utils_1.locToRange)(text, location);
      }
      function getPosition(text, node) {
        const location = node.loc;
        assert(location, "Expected ASTNode to have a location.");
        return (0, utils_1.offsetToPosition)(text, location.start);
      }
      function getDefinitionQueryResultForNamedType(text, node, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const name = node.name.value;
          const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name);
          if (defNodes.length === 0) {
            throw Error(`Definition not found for GraphQL type ${name}`);
          }
          const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || "", content, definition));
          return {
            definitions,
            queryRange: definitions.map((_) => getRange(text, node))
          };
        });
      }
      exports.getDefinitionQueryResultForNamedType = getDefinitionQueryResultForNamedType;
      function getDefinitionQueryResultForField(fieldName, typeName, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === typeName);
          if (defNodes.length === 0) {
            throw Error(`Definition not found for GraphQL type ${typeName}`);
          }
          const definitions = [];
          defNodes.forEach(({ filePath, content, definition }) => {
            var _a3;
            const fieldDefinition = (_a3 = definition.fields) === null || _a3 === void 0 ? void 0 : _a3.find((item) => item.name.value === fieldName);
            if (fieldDefinition == null) {
              return null;
            }
            definitions.push(getDefinitionForFieldDefinition(filePath || "", content, fieldDefinition));
          });
          return {
            definitions,
            queryRange: []
          };
        });
      }
      exports.getDefinitionQueryResultForField = getDefinitionQueryResultForField;
      function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const name = fragment.name.value;
          const defNodes = dependencies.filter(({ definition }) => definition.name.value === name);
          if (defNodes.length === 0) {
            throw Error(`Definition not found for GraphQL fragment ${name}`);
          }
          const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || "", content, definition));
          return {
            definitions,
            queryRange: definitions.map((_) => getRange(text, fragment))
          };
        });
      }
      exports.getDefinitionQueryResultForFragmentSpread = getDefinitionQueryResultForFragmentSpread;
      function getDefinitionQueryResultForDefinitionNode(path, text, definition) {
        return {
          definitions: [getDefinitionForFragmentDefinition(path, text, definition)],
          queryRange: definition.name ? [getRange(text, definition.name)] : []
        };
      }
      exports.getDefinitionQueryResultForDefinitionNode = getDefinitionQueryResultForDefinitionNode;
      function getDefinitionForFragmentDefinition(path, text, definition) {
        const name = definition.name;
        if (!name) {
          throw Error("Expected ASTNode to have a Name.");
        }
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
      function getDefinitionForNodeDefinition(path, text, definition) {
        const name = definition.name;
        assert(name, "Expected ASTNode to have a Name.");
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
      function getDefinitionForFieldDefinition(path, text, definition) {
        const name = definition.name;
        assert(name, "Expected ASTNode to have a Name.");
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getDiagnostics.js
  var require_getDiagnostics = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getDiagnostics.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRange = exports.validateQuery = exports.getDiagnostics = exports.DIAGNOSTIC_SEVERITY = exports.SEVERITY = void 0;
      var graphql_1 = require_graphql2();
      var graphql_2 = require_graphql2();
      var parser_1 = require_parser2();
      var utils_1 = require_utils();
      exports.SEVERITY = {
        Error: "Error",
        Warning: "Warning",
        Information: "Information",
        Hint: "Hint"
      };
      exports.DIAGNOSTIC_SEVERITY = {
        [exports.SEVERITY.Error]: 1,
        [exports.SEVERITY.Warning]: 2,
        [exports.SEVERITY.Information]: 3,
        [exports.SEVERITY.Hint]: 4
      };
      var invariant = (condition, message) => {
        if (!condition) {
          throw new Error(message);
        }
      };
      function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {
        var _a3, _b;
        let ast = null;
        if (externalFragments) {
          if (typeof externalFragments === "string") {
            query += "\n\n" + externalFragments;
          } else {
            query += "\n\n" + externalFragments.reduce((agg, node) => {
              agg += (0, graphql_1.print)(node) + "\n\n";
              return agg;
            }, "");
          }
        }
        try {
          ast = (0, graphql_2.parse)(query);
        } catch (error) {
          if (error instanceof graphql_1.GraphQLError) {
            const range = getRange((_b = (_a3 = error.locations) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, query);
            return [
              {
                severity: exports.DIAGNOSTIC_SEVERITY.Error,
                message: error.message,
                source: "GraphQL: Syntax",
                range
              }
            ];
          }
          throw error;
        }
        return validateQuery(ast, schema, customRules, isRelayCompatMode);
      }
      exports.getDiagnostics = getDiagnostics;
      function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {
        if (!schema) {
          return [];
        }
        const validationErrorAnnotations = mapCat((0, utils_1.validateWithCustomRules)(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, exports.DIAGNOSTIC_SEVERITY.Error, "Validation"));
        const deprecationWarningAnnotations = mapCat((0, graphql_1.validate)(schema, ast, [graphql_1.NoDeprecatedCustomRule]), (error) => annotations(error, exports.DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));
        return validationErrorAnnotations.concat(deprecationWarningAnnotations);
      }
      exports.validateQuery = validateQuery;
      function mapCat(array, mapper) {
        return Array.prototype.concat.apply([], array.map(mapper));
      }
      function annotations(error, severity, type) {
        if (!error.nodes) {
          return [];
        }
        const highlightedNodes = [];
        error.nodes.forEach((node) => {
          const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;
          if (highlightNode) {
            invariant(error.locations, "GraphQL validation error requires locations.");
            const loc = error.locations[0];
            const highlightLoc = getLocation(highlightNode);
            const end = loc.column + (highlightLoc.end - highlightLoc.start);
            highlightedNodes.push({
              source: `GraphQL: ${type}`,
              message: error.message,
              severity,
              range: new utils_1.Range(new utils_1.Position(loc.line - 1, loc.column - 1), new utils_1.Position(loc.line - 1, end))
            });
          }
        });
        return highlightedNodes;
      }
      function getRange(location, queryText) {
        const parser = (0, parser_1.onlineParser)();
        const state = parser.startState();
        const lines = queryText.split("\n");
        invariant(lines.length >= location.line, "Query text must have more lines than where the error happened");
        let stream = null;
        for (let i = 0; i < location.line; i++) {
          stream = new parser_1.CharacterStream(lines[i]);
          while (!stream.eol()) {
            const style = parser.token(stream, state);
            if (style === "invalidchar") {
              break;
            }
          }
        }
        invariant(stream, "Expected Parser stream to be available.");
        const line = location.line - 1;
        const start = stream.getStartOfToken();
        const end = stream.getCurrentPosition();
        return new utils_1.Range(new utils_1.Position(line, start), new utils_1.Position(line, end));
      }
      exports.getRange = getRange;
      function getLocation(node) {
        const typeCastedNode = node;
        const location = typeCastedNode.loc;
        invariant(location, "Expected ASTNode to have a location.");
        return location;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getOutline.js
  var require_getOutline = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getOutline.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOutline = void 0;
      var graphql_1 = require_graphql2();
      var utils_1 = require_utils();
      var { INLINE_FRAGMENT } = graphql_1.Kind;
      function getOutline(documentText) {
        let ast;
        try {
          ast = (0, graphql_1.parse)(documentText);
        } catch (error) {
          return null;
        }
        const visitorFns = outlineTreeConverter(documentText);
        const outlineTrees = (0, graphql_1.visit)(ast, {
          leave(node) {
            if (visitorFns !== void 0 && node.kind in visitorFns) {
              return visitorFns[node.kind](node);
            }
            return null;
          }
        });
        return { outlineTrees };
      }
      exports.getOutline = getOutline;
      function outlineTreeConverter(docText) {
        const meta = (node) => {
          return {
            representativeName: node.name,
            startPosition: (0, utils_1.offsetToPosition)(docText, node.loc.start),
            endPosition: (0, utils_1.offsetToPosition)(docText, node.loc.end),
            kind: node.kind,
            children: node.selectionSet || node.fields || node.values || node.arguments || []
          };
        };
        return {
          Field: (node) => {
            const tokenizedText = node.alias ? [buildToken("plain", node.alias), buildToken("plain", ": ")] : [];
            tokenizedText.push(buildToken("plain", node.name));
            return Object.assign({ tokenizedText }, meta(node));
          },
          OperationDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", node.operation),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          Document: (node) => node.definitions,
          SelectionSet: (node) => concatMap(node.selections, (child) => {
            return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;
          }),
          Name: (node) => node.value,
          FragmentDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "fragment"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InterfaceTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "interface"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          EnumTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "enum"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          EnumValueDefinition: (node) => Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node)),
          ObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "type"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InputObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "input"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          FragmentSpread: (node) => Object.assign({ tokenizedText: [
            buildToken("plain", "..."),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InputValueDefinition: (node) => {
            return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
          },
          FieldDefinition: (node) => {
            return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
          },
          InlineFragment: (node) => node.selectionSet
        };
      }
      function buildToken(kind, value) {
        return { kind, value };
      }
      function concatMap(arr, fn) {
        const res = [];
        for (let i = 0; i < arr.length; i++) {
          const x = fn(arr[i], i);
          if (Array.isArray(x)) {
            res.push(...x);
          } else {
            res.push(x);
          }
        }
        return res;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getHoverInformation.js
  var require_getHoverInformation = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/getHoverInformation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHoverInformation = void 0;
      var graphql_1 = require_graphql2();
      var getAutocompleteSuggestions_1 = require_getAutocompleteSuggestions();
      function getHoverInformation(schema, queryText, cursor, contextToken, config) {
        const token = contextToken || (0, getAutocompleteSuggestions_1.getTokenAtPosition)(queryText, cursor);
        if (!schema || !token || !token.state) {
          return "";
        }
        const state = token.state;
        const kind = state.kind;
        const step = state.step;
        const typeInfo = (0, getAutocompleteSuggestions_1.getTypeInfo)(schema, token.state);
        const options = Object.assign(Object.assign({}, config), { schema });
        if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderField(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.fieldDef);
          return into.join("").trim();
        } else if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderDirective(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.directiveDef);
          return into.join("").trim();
        } else if (kind === "Argument" && step === 0 && typeInfo.argDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderArg(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.argDef);
          return into.join("").trim();
        } else if (kind === "EnumValue" && typeInfo.enumValue && "description" in typeInfo.enumValue) {
          const into = [];
          renderMdCodeStart(into, options);
          renderEnumValue(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.enumValue);
          return into.join("").trim();
        } else if (kind === "NamedType" && typeInfo.type && "description" in typeInfo.type) {
          const into = [];
          renderMdCodeStart(into, options);
          renderType(into, typeInfo, options, typeInfo.type);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.type);
          return into.join("").trim();
        }
        return "";
      }
      exports.getHoverInformation = getHoverInformation;
      function renderMdCodeStart(into, options) {
        if (options.useMarkdown) {
          text(into, "```graphql\n");
        }
      }
      function renderMdCodeEnd(into, options) {
        if (options.useMarkdown) {
          text(into, "\n```");
        }
      }
      function renderField(into, typeInfo, options) {
        renderQualifiedField(into, typeInfo, options);
        renderTypeAnnotation(into, typeInfo, options, typeInfo.type);
      }
      function renderQualifiedField(into, typeInfo, options) {
        if (!typeInfo.fieldDef) {
          return;
        }
        const fieldName = typeInfo.fieldDef.name;
        if (fieldName.slice(0, 2) !== "__") {
          renderType(into, typeInfo, options, typeInfo.parentType);
          text(into, ".");
        }
        text(into, fieldName);
      }
      function renderDirective(into, typeInfo, _options) {
        if (!typeInfo.directiveDef) {
          return;
        }
        const name = "@" + typeInfo.directiveDef.name;
        text(into, name);
      }
      function renderArg(into, typeInfo, options) {
        if (typeInfo.directiveDef) {
          renderDirective(into, typeInfo, options);
        } else if (typeInfo.fieldDef) {
          renderQualifiedField(into, typeInfo, options);
        }
        if (!typeInfo.argDef) {
          return;
        }
        const name = typeInfo.argDef.name;
        text(into, "(");
        text(into, name);
        renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);
        text(into, ")");
      }
      function renderTypeAnnotation(into, typeInfo, options, t) {
        text(into, ": ");
        renderType(into, typeInfo, options, t);
      }
      function renderEnumValue(into, typeInfo, options) {
        if (!typeInfo.enumValue) {
          return;
        }
        const name = typeInfo.enumValue.name;
        renderType(into, typeInfo, options, typeInfo.inputType);
        text(into, ".");
        text(into, name);
      }
      function renderType(into, typeInfo, options, t) {
        if (!t) {
          return;
        }
        if (t instanceof graphql_1.GraphQLNonNull) {
          renderType(into, typeInfo, options, t.ofType);
          text(into, "!");
        } else if (t instanceof graphql_1.GraphQLList) {
          text(into, "[");
          renderType(into, typeInfo, options, t.ofType);
          text(into, "]");
        } else {
          text(into, t.name);
        }
      }
      function renderDescription(into, options, def) {
        if (!def) {
          return;
        }
        const description = typeof def.description === "string" ? def.description : null;
        if (description) {
          text(into, "\n\n");
          text(into, description);
        }
        renderDeprecation(into, options, def);
      }
      function renderDeprecation(into, _options, def) {
        if (!def) {
          return;
        }
        const reason = def.deprecationReason ? def.deprecationReason : null;
        if (!reason) {
          return;
        }
        text(into, "\n\n");
        text(into, "Deprecated: ");
        text(into, reason);
      }
      function text(into, content) {
        into.push(content);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/index.js
  var require_interface = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/interface/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHoverInformation = exports.getOutline = void 0;
      __exportStar(require_autocompleteUtils(), exports);
      __exportStar(require_getAutocompleteSuggestions(), exports);
      __exportStar(require_getDefinition(), exports);
      __exportStar(require_getDiagnostics(), exports);
      var getOutline_1 = require_getOutline();
      Object.defineProperty(exports, "getOutline", { enumerable: true, get: function() {
        return getOutline_1.getOutline;
      } });
      var getHoverInformation_1 = require_getHoverInformation();
      Object.defineProperty(exports, "getHoverInformation", { enumerable: true, get: function() {
        return getHoverInformation_1.getHoverInformation;
      } });
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/types.js
  var require_types2 = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompletionItemKind = exports.FileChangeTypeKind = void 0;
      exports.FileChangeTypeKind = {
        Created: 1,
        Changed: 2,
        Deleted: 3
      };
      var CompletionItemKind2;
      (function(CompletionItemKind3) {
        CompletionItemKind3.Text = 1;
        CompletionItemKind3.Method = 2;
        CompletionItemKind3.Function = 3;
        CompletionItemKind3.Constructor = 4;
        CompletionItemKind3.Field = 5;
        CompletionItemKind3.Variable = 6;
        CompletionItemKind3.Class = 7;
        CompletionItemKind3.Interface = 8;
        CompletionItemKind3.Module = 9;
        CompletionItemKind3.Property = 10;
        CompletionItemKind3.Unit = 11;
        CompletionItemKind3.Value = 12;
        CompletionItemKind3.Enum = 13;
        CompletionItemKind3.Keyword = 14;
        CompletionItemKind3.Snippet = 15;
        CompletionItemKind3.Color = 16;
        CompletionItemKind3.File = 17;
        CompletionItemKind3.Reference = 18;
        CompletionItemKind3.Folder = 19;
        CompletionItemKind3.EnumMember = 20;
        CompletionItemKind3.Constant = 21;
        CompletionItemKind3.Struct = 22;
        CompletionItemKind3.Event = 23;
        CompletionItemKind3.Operator = 24;
        CompletionItemKind3.TypeParameter = 25;
      })(CompletionItemKind2 = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/.pnpm/graphql-language-service@5.0.6_graphql@16.6.0/node_modules/graphql-language-service/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Range = exports.validateWithCustomRules = exports.collectVariables = exports.Position = exports.pointToOffset = exports.offsetToPosition = exports.getVariablesJSONSchema = exports.getQueryFacts = exports.getOperationFacts = exports.getOperationASTFacts = exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = exports.getASTNodeAtPosition = exports.FileChangeTypeKind = exports.CompletionItemKind = exports.opt = exports.t = exports.list = exports.p = exports.isIgnored = exports.LexRules = exports.RuleKinds = exports.CharacterStream = exports.ParseRules = exports.onlineParser = exports.validateQuery = exports.SuggestionCommand = exports.canUseDirective = exports.DIAGNOSTIC_SEVERITY = exports.SEVERITY = exports.getVariableCompletions = exports.getTypeInfo = exports.getTokenAtPosition = exports.getRange = exports.getOutline = exports.getHoverInformation = exports.getFragmentDefinitions = exports.getFieldDef = exports.getDiagnostics = exports.getDefinitionState = exports.getDefinitionQueryResultForField = exports.getDefinitionQueryResultForNamedType = exports.getDefinitionQueryResultForFragmentSpread = exports.getDefinitionQueryResultForDefinitionNode = exports.getAutocompleteSuggestions = void 0;
      var interface_1 = require_interface();
      Object.defineProperty(exports, "getAutocompleteSuggestions", { enumerable: true, get: function() {
        return interface_1.getAutocompleteSuggestions;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForDefinitionNode", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForDefinitionNode;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForFragmentSpread", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForFragmentSpread;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForNamedType", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForNamedType;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForField", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForField;
      } });
      Object.defineProperty(exports, "getDefinitionState", { enumerable: true, get: function() {
        return interface_1.getDefinitionState;
      } });
      Object.defineProperty(exports, "getDiagnostics", { enumerable: true, get: function() {
        return interface_1.getDiagnostics;
      } });
      Object.defineProperty(exports, "getFieldDef", { enumerable: true, get: function() {
        return interface_1.getFieldDef;
      } });
      Object.defineProperty(exports, "getFragmentDefinitions", { enumerable: true, get: function() {
        return interface_1.getFragmentDefinitions;
      } });
      Object.defineProperty(exports, "getHoverInformation", { enumerable: true, get: function() {
        return interface_1.getHoverInformation;
      } });
      Object.defineProperty(exports, "getOutline", { enumerable: true, get: function() {
        return interface_1.getOutline;
      } });
      Object.defineProperty(exports, "getRange", { enumerable: true, get: function() {
        return interface_1.getRange;
      } });
      Object.defineProperty(exports, "getTokenAtPosition", { enumerable: true, get: function() {
        return interface_1.getTokenAtPosition;
      } });
      Object.defineProperty(exports, "getTypeInfo", { enumerable: true, get: function() {
        return interface_1.getTypeInfo;
      } });
      Object.defineProperty(exports, "getVariableCompletions", { enumerable: true, get: function() {
        return interface_1.getVariableCompletions;
      } });
      Object.defineProperty(exports, "SEVERITY", { enumerable: true, get: function() {
        return interface_1.SEVERITY;
      } });
      Object.defineProperty(exports, "DIAGNOSTIC_SEVERITY", { enumerable: true, get: function() {
        return interface_1.DIAGNOSTIC_SEVERITY;
      } });
      Object.defineProperty(exports, "canUseDirective", { enumerable: true, get: function() {
        return interface_1.canUseDirective;
      } });
      Object.defineProperty(exports, "SuggestionCommand", { enumerable: true, get: function() {
        return interface_1.SuggestionCommand;
      } });
      Object.defineProperty(exports, "validateQuery", { enumerable: true, get: function() {
        return interface_1.validateQuery;
      } });
      var parser_1 = require_parser2();
      Object.defineProperty(exports, "onlineParser", { enumerable: true, get: function() {
        return parser_1.onlineParser;
      } });
      Object.defineProperty(exports, "ParseRules", { enumerable: true, get: function() {
        return parser_1.ParseRules;
      } });
      Object.defineProperty(exports, "CharacterStream", { enumerable: true, get: function() {
        return parser_1.CharacterStream;
      } });
      Object.defineProperty(exports, "RuleKinds", { enumerable: true, get: function() {
        return parser_1.RuleKinds;
      } });
      Object.defineProperty(exports, "LexRules", { enumerable: true, get: function() {
        return parser_1.LexRules;
      } });
      Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
        return parser_1.isIgnored;
      } });
      Object.defineProperty(exports, "p", { enumerable: true, get: function() {
        return parser_1.p;
      } });
      Object.defineProperty(exports, "list", { enumerable: true, get: function() {
        return parser_1.list;
      } });
      Object.defineProperty(exports, "t", { enumerable: true, get: function() {
        return parser_1.t;
      } });
      Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
        return parser_1.opt;
      } });
      var types_1 = require_types2();
      Object.defineProperty(exports, "CompletionItemKind", { enumerable: true, get: function() {
        return types_1.CompletionItemKind;
      } });
      Object.defineProperty(exports, "FileChangeTypeKind", { enumerable: true, get: function() {
        return types_1.FileChangeTypeKind;
      } });
      var utils_1 = require_utils();
      Object.defineProperty(exports, "getASTNodeAtPosition", { enumerable: true, get: function() {
        return utils_1.getASTNodeAtPosition;
      } });
      Object.defineProperty(exports, "getFragmentDependencies", { enumerable: true, get: function() {
        return utils_1.getFragmentDependencies;
      } });
      Object.defineProperty(exports, "getFragmentDependenciesForAST", { enumerable: true, get: function() {
        return utils_1.getFragmentDependenciesForAST;
      } });
      Object.defineProperty(exports, "getOperationASTFacts", { enumerable: true, get: function() {
        return utils_1.getOperationASTFacts;
      } });
      Object.defineProperty(exports, "getOperationFacts", { enumerable: true, get: function() {
        return utils_1.getOperationFacts;
      } });
      Object.defineProperty(exports, "getQueryFacts", { enumerable: true, get: function() {
        return utils_1.getQueryFacts;
      } });
      Object.defineProperty(exports, "getVariablesJSONSchema", { enumerable: true, get: function() {
        return utils_1.getVariablesJSONSchema;
      } });
      Object.defineProperty(exports, "offsetToPosition", { enumerable: true, get: function() {
        return utils_1.offsetToPosition;
      } });
      Object.defineProperty(exports, "pointToOffset", { enumerable: true, get: function() {
        return utils_1.pointToOffset;
      } });
      Object.defineProperty(exports, "Position", { enumerable: true, get: function() {
        return utils_1.Position;
      } });
      Object.defineProperty(exports, "collectVariables", { enumerable: true, get: function() {
        return utils_1.collectVariables;
      } });
      Object.defineProperty(exports, "validateWithCustomRules", { enumerable: true, get: function() {
        return utils_1.validateWithCustomRules;
      } });
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return utils_1.Range;
      } });
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/constants.js"(exports, module) {
      "use strict";
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var SEP = "/";
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR,
        SEP
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
        SEP: "\\"
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        CHAR_0: 48,
        CHAR_9: 57,
        CHAR_UPPERCASE_A: 65,
        CHAR_LOWERCASE_A: 97,
        CHAR_UPPERCASE_Z: 90,
        CHAR_LOWERCASE_Z: 122,
        CHAR_LEFT_PARENTHESES: 40,
        CHAR_RIGHT_PARENTHESES: 41,
        CHAR_ASTERISK: 42,
        CHAR_AMPERSAND: 38,
        CHAR_AT: 64,
        CHAR_BACKWARD_SLASH: 92,
        CHAR_CARRIAGE_RETURN: 13,
        CHAR_CIRCUMFLEX_ACCENT: 94,
        CHAR_COLON: 58,
        CHAR_COMMA: 44,
        CHAR_DOT: 46,
        CHAR_DOUBLE_QUOTE: 34,
        CHAR_EQUAL: 61,
        CHAR_EXCLAMATION_MARK: 33,
        CHAR_FORM_FEED: 12,
        CHAR_FORWARD_SLASH: 47,
        CHAR_GRAVE_ACCENT: 96,
        CHAR_HASH: 35,
        CHAR_HYPHEN_MINUS: 45,
        CHAR_LEFT_ANGLE_BRACKET: 60,
        CHAR_LEFT_CURLY_BRACE: 123,
        CHAR_LEFT_SQUARE_BRACKET: 91,
        CHAR_LINE_FEED: 10,
        CHAR_NO_BREAK_SPACE: 160,
        CHAR_PERCENT: 37,
        CHAR_PLUS: 43,
        CHAR_QUESTION_MARK: 63,
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        CHAR_RIGHT_CURLY_BRACE: 125,
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        CHAR_SEMICOLON: 59,
        CHAR_SINGLE_QUOTE: 39,
        CHAR_SPACE: 32,
        CHAR_TAB: 9,
        CHAR_UNDERSCORE: 95,
        CHAR_VERTICAL_LINE: 124,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/utils.js"(exports) {
      "use strict";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
      exports.basename = (path, { windows } = {}) => {
        if (windows) {
          return path.replace(/[\\/]$/, "").replace(/.*[\\/]/, "");
        } else {
          return path.replace(/\/$/, "").replace(/.*\//, "");
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/scan.js
  var require_scan = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/scan.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var {
        CHAR_ASTERISK,
        CHAR_AT,
        CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
        CHAR_COMMA,
        CHAR_DOT: CHAR_DOT2,
        CHAR_EXCLAMATION_MARK,
        CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
        CHAR_LEFT_CURLY_BRACE,
        CHAR_LEFT_PARENTHESES,
        CHAR_LEFT_SQUARE_BRACKET,
        CHAR_PLUS,
        CHAR_QUESTION_MARK: CHAR_QUESTION_MARK2,
        CHAR_RIGHT_CURLY_BRACE,
        CHAR_RIGHT_PARENTHESES,
        CHAR_RIGHT_SQUARE_BRACKET
      } = require_constants();
      var isPathSeparator2 = (code) => {
        return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH2) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT2 && (code = advance()) === CHAR_DOT2) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH2) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT2 && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH2) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK2) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
            }
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator2(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob)
            glob = utils.removeBackslashes(glob);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator2(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module.exports = scan;
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/parse.js
  var require_parse = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/parse.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var utils = require_utils2();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      };
      var syntaxError = (type, char) => {
        return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const PLATFORM_CHARS = constants.globChars(opts.windows);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index];
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type) => {
          state[type]++;
          stack.push(type);
        };
        const decrement = (type) => {
          state[type]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output = token.close + (opts.capture ? ")" : "");
          if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
              output = token.close = `)$))${extglobStar}`;
            }
            if (token.prev.type === "bos" && eos()) {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star : "");
              }
              return star;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output = output.replace(/\\/g, "");
            } else {
              output = output.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
              slashes = match[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance() || "";
            } else {
              value += advance() || "";
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix2 = POSIX_REGEX_SOURCE[rest2];
                  if (posix2) {
                    prev.value = pre + posix2;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output = "|";
            }
            push({ type: "comma", value, output });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output = `\\${value}`;
              }
              push({ type: "text", value, output });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
              value += match[0];
              state.index += match[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse.fastpaths = (input, options) => {
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        input = REPLACEMENTS[input] || input;
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(opts.windows);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true)
            return star;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
              return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
              return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default: {
              const match = /^(.*?)\.(\w+)$/.exec(str);
              if (!match)
                return;
              const source2 = create(match[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match[2];
            }
          }
        };
        const output = utils.removePrefix(input, state);
        let source = create(output);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module.exports = parse;
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/picomatch.js
  var require_picomatch = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/lib/picomatch.js"(exports, module) {
      "use strict";
      var scan = require_scan();
      var parse = require_parse();
      var utils = require_utils2();
      var constants = require_constants();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch = (glob, options, returnState = false) => {
        if (Array.isArray(glob)) {
          const fns = glob.map((input) => picomatch(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob) && glob.tokens && glob.input;
        if (glob === "" || typeof glob !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix2 = opts.windows;
        const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
          const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
        let match = input === glob;
        let output = match && format ? format(input) : input;
        if (match === false) {
          output = format ? format(input) : input;
          match = output === glob;
        }
        if (match === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match = picomatch.matchBase(input, regex, options, posix2);
          } else {
            match = regex.exec(output);
          }
        }
        return { isMatch: Boolean(match), match, output };
      };
      picomatch.matchBase = (input, glob, options) => {
        const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
        return regex.test(utils.basename(input));
      };
      picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options));
        return parse(pattern, { ...options, fastpaths: false });
      };
      picomatch.scan = (input, options) => scan(input, options);
      picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return parsed.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${parsed.output})${append}`;
        if (parsed && parsed.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
          regex.state = parsed;
        }
        return regex;
      };
      picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        const opts = options || {};
        let parsed = { negated: false, fastpaths: true };
        let prefix = "";
        let output;
        if (input.startsWith("./")) {
          input = input.slice(2);
          prefix = parsed.prefix = "./";
        }
        if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          output = parse.fastpaths(input, options);
        }
        if (output === void 0) {
          parsed = parse(input, options);
          parsed.prefix = prefix + (parsed.prefix || "");
        } else {
          parsed.output = output;
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err) {
          if (options && options.debug === true)
            throw err;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module.exports = picomatch;
    }
  });

  // ../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/index.js
  var require_picomatch_browser = __commonJS({
    "../../node_modules/.pnpm/picomatch-browser@2.2.6/node_modules/picomatch-browser/index.js"(exports, module) {
      "use strict";
      module.exports = require_picomatch();
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/schemaLoader.js
  var require_schemaLoader = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/schemaLoader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultSchemaLoader = void 0;
      var graphql_1 = require_graphql2();
      var defaultSchemaLoader = function(schemaConfig, parser) {
        var schema = schemaConfig.schema, documentAST = schemaConfig.documentAST, introspectionJSON = schemaConfig.introspectionJSON, introspectionJSONString = schemaConfig.introspectionJSONString, buildSchemaOptions = schemaConfig.buildSchemaOptions, documentString = schemaConfig.documentString;
        if (schema) {
          return schema;
        }
        if (introspectionJSONString) {
          var introspectionJSONResult = JSON.parse(introspectionJSONString);
          return (0, graphql_1.buildClientSchema)(introspectionJSONResult, buildSchemaOptions);
        }
        if (documentString && parser) {
          var docAST = parser(documentString);
          return (0, graphql_1.buildASTSchema)(docAST, buildSchemaOptions);
        }
        if (introspectionJSON) {
          return (0, graphql_1.buildClientSchema)(introspectionJSON, buildSchemaOptions);
        }
        if (documentAST) {
          return (0, graphql_1.buildASTSchema)(documentAST, buildSchemaOptions);
        }
        throw Error("no schema supplied");
      };
      exports.defaultSchemaLoader = defaultSchemaLoader;
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/LanguageService.js
  var require_LanguageService = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/LanguageService.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LanguageService = void 0;
      var graphql_1 = require_graphql2();
      var picomatch_browser_1 = __importDefault(require_picomatch_browser());
      var graphql_language_service_1 = require_dist();
      var schemaLoader_1 = require_schemaLoader();
      var schemaCache = /* @__PURE__ */ new Map();
      var LanguageService = function() {
        function LanguageService2(_a3) {
          var parser = _a3.parser, schemas = _a3.schemas, parseOptions = _a3.parseOptions, externalFragmentDefinitions = _a3.externalFragmentDefinitions, customValidationRules = _a3.customValidationRules;
          var _this = this;
          this._parser = graphql_1.parse;
          this._schemas = [];
          this._schemaCache = schemaCache;
          this._schemaLoader = schemaLoader_1.defaultSchemaLoader;
          this._parseOptions = void 0;
          this._customValidationRules = void 0;
          this._externalFragmentDefinitionNodes = null;
          this._externalFragmentDefinitionsString = null;
          this.getCompletion = function(uri, documentText, position) {
            var schema = _this.getSchemaForFile(uri);
            if (!documentText || documentText.length < 1 || !(schema === null || schema === void 0 ? void 0 : schema.schema)) {
              return [];
            }
            return (0, graphql_language_service_1.getAutocompleteSuggestions)(schema.schema, documentText, position, void 0, _this.getExternalFragmentDefinitions());
          };
          this.getDiagnostics = function(uri, documentText, customRules) {
            var schema = _this.getSchemaForFile(uri);
            if (!documentText || documentText.trim().length < 2 || !(schema === null || schema === void 0 ? void 0 : schema.schema)) {
              return [];
            }
            return (0, graphql_language_service_1.getDiagnostics)(documentText, schema.schema, customRules !== null && customRules !== void 0 ? customRules : _this._customValidationRules, false, _this.getExternalFragmentDefinitions());
          };
          this.getHover = function(uri, documentText, position, options) {
            var schema = _this.getSchemaForFile(uri);
            if (schema && (documentText === null || documentText === void 0 ? void 0 : documentText.length) > 3) {
              return (0, graphql_language_service_1.getHoverInformation)(schema.schema, documentText, position, void 0, __assign({ useMarkdown: true }, options));
            }
          };
          this.getVariablesJSONSchema = function(uri, documentText, options) {
            var schema = _this.getSchemaForFile(uri);
            if (schema && documentText.length > 3) {
              try {
                var documentAST = _this.parse(documentText);
                var operationFacts = (0, graphql_language_service_1.getOperationASTFacts)(documentAST, schema.schema);
                if (operationFacts === null || operationFacts === void 0 ? void 0 : operationFacts.variableToType) {
                  return (0, graphql_language_service_1.getVariablesJSONSchema)(operationFacts.variableToType, options);
                }
              } catch (err) {
              }
            }
            return null;
          };
          this._schemaLoader = schemaLoader_1.defaultSchemaLoader;
          if (schemas) {
            this._schemas = schemas;
            this._cacheSchemas();
          }
          if (parser) {
            this._parser = parser;
          }
          if (parseOptions) {
            this._parseOptions = parseOptions;
          }
          if (customValidationRules) {
            this._customValidationRules = customValidationRules;
          }
          if (externalFragmentDefinitions) {
            if (Array.isArray(externalFragmentDefinitions)) {
              this._externalFragmentDefinitionNodes = externalFragmentDefinitions;
            } else {
              this._externalFragmentDefinitionsString = externalFragmentDefinitions;
            }
          }
        }
        LanguageService2.prototype._cacheSchemas = function() {
          var _this = this;
          this._schemas.forEach(function(schema) {
            return _this._cacheSchema(schema);
          });
        };
        LanguageService2.prototype._cacheSchema = function(schemaConfig) {
          var schema = this._schemaLoader(schemaConfig, this.parse.bind(this));
          return this._schemaCache.set(schemaConfig.uri, __assign(__assign({}, schemaConfig), { schema }));
        };
        LanguageService2.prototype.getSchemaForFile = function(uri) {
          if (!this._schemas || !this._schemas.length) {
            return;
          }
          if (this._schemas.length === 1) {
            return this._schemaCache.get(this._schemas[0].uri);
          } else {
            var schema = this._schemas.find(function(schemaConfig) {
              if (!schemaConfig.fileMatch) {
                return false;
              }
              return schemaConfig.fileMatch.some(function(glob) {
                var isMatch = (0, picomatch_browser_1.default)(glob);
                return isMatch(uri);
              });
            });
            if (schema) {
              var cacheEntry = this._schemaCache.get(schema.uri);
              if (cacheEntry) {
                return cacheEntry;
              }
              var cache = this._cacheSchema(schema);
              return cache.get(schema.uri);
            }
          }
        };
        LanguageService2.prototype.getExternalFragmentDefinitions = function() {
          if (!this._externalFragmentDefinitionNodes && this._externalFragmentDefinitionsString) {
            var definitionNodes_1 = [];
            try {
              (0, graphql_1.visit)(this._parser(this._externalFragmentDefinitionsString), {
                FragmentDefinition: function(node) {
                  definitionNodes_1.push(node);
                }
              });
            } catch (err) {
              throw Error("Failed parsing externalFragmentDefinitions string:\n".concat(this._externalFragmentDefinitionsString));
            }
            this._externalFragmentDefinitionNodes = definitionNodes_1;
          }
          return this._externalFragmentDefinitionNodes;
        };
        LanguageService2.prototype.updateSchemas = function(schemas) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              this._schemas = schemas;
              this._cacheSchemas();
              return [2];
            });
          });
        };
        LanguageService2.prototype.updateSchema = function(schema) {
          var schemaIndex = this._schemas.findIndex(function(c) {
            return c.uri === schema.uri;
          });
          if (schemaIndex < 0) {
            console.warn("updateSchema could not find a schema in your config by that URI", schema.uri);
            return;
          }
          this._schemas[schemaIndex] = schema;
          this._cacheSchema(schema);
        };
        LanguageService2.prototype.addSchema = function(schema) {
          this._schemas.push(schema);
          this._cacheSchema(schema);
        };
        LanguageService2.prototype.parse = function(text, options) {
          return this._parser(text, options || this._parseOptions);
        };
        return LanguageService2;
      }();
      exports.LanguageService = LanguageService;
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/utils.js
  var require_utils3 = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/utils.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStringSchema = exports.toMarkerData = exports.toCompletion = exports.toGraphQLPosition = exports.toMonacoRange = exports.getModelLanguageId = void 0;
      var graphql_1 = require_graphql2();
      var graphql_language_service_1 = require_dist();
      var getModelLanguageId = function(model) {
        if ("getModeId" in model) {
          return model.getModeId();
        }
        return model.getLanguageId();
      };
      exports.getModelLanguageId = getModelLanguageId;
      function toMonacoRange(range) {
        return {
          startLineNumber: range.start.line + 1,
          startColumn: range.start.character + 1,
          endLineNumber: range.end.line + 1,
          endColumn: range.end.character + 1
        };
      }
      exports.toMonacoRange = toMonacoRange;
      function toGraphQLPosition(position) {
        return new graphql_language_service_1.Position(position.lineNumber - 1, position.column - 1);
      }
      exports.toGraphQLPosition = toGraphQLPosition;
      function toCompletion(entry, range) {
        var results = {
          label: entry.label,
          insertText: entry.insertText,
          insertTextFormat: entry.insertTextFormat,
          sortText: entry.sortText,
          filterText: entry.filterText,
          documentation: entry.documentation,
          detail: entry.detail,
          range: range ? toMonacoRange(range) : void 0,
          kind: entry.kind
        };
        if (entry.insertTextFormat) {
          results.insertTextFormat = entry.insertTextFormat;
        }
        if (entry.command) {
          results.command = __assign(__assign({}, entry.command), { id: entry.command.command });
        }
        return results;
      }
      exports.toCompletion = toCompletion;
      function toMarkerData(diagnostic) {
        return {
          startLineNumber: diagnostic.range.start.line + 1,
          endLineNumber: diagnostic.range.end.line + 1,
          startColumn: diagnostic.range.start.character + 1,
          endColumn: diagnostic.range.end.character,
          message: diagnostic.message,
          severity: 5,
          code: diagnostic.code || void 0
        };
      }
      exports.toMarkerData = toMarkerData;
      var getStringSchema = function(schemaConfig) {
        var graphQLSchema = schemaConfig.schema, documentAST = schemaConfig.documentAST, introspectionJSON = schemaConfig.introspectionJSON, introspectionJSONString = schemaConfig.introspectionJSONString, documentString = schemaConfig.documentString, rest = __rest(schemaConfig, ["schema", "documentAST", "introspectionJSON", "introspectionJSONString", "documentString"]);
        if (graphQLSchema) {
          return __assign(__assign({}, rest), { documentString: (0, graphql_1.printSchema)(graphQLSchema) });
        }
        if (introspectionJSONString) {
          return __assign(__assign({}, rest), { introspectionJSONString });
        }
        if (documentString) {
          return __assign(__assign({}, rest), { documentString });
        }
        if (introspectionJSON) {
          return __assign(__assign({}, rest), { introspectionJSONString: JSON.stringify(introspectionJSON) });
        }
        if (documentAST) {
          var schema = (0, graphql_1.buildASTSchema)(documentAST, rest.buildSchemaOptions);
          return __assign(__assign({}, rest), { documentString: (0, graphql_1.printSchema)(schema) });
        }
        throw Error("no schema supplied");
      };
      exports.getStringSchema = getStringSchema;
    }
  });

  // ../../node_modules/.pnpm/prettier@2.7.1/node_modules/prettier/standalone.js
  var require_standalone = __commonJS({
    "../../node_modules/.pnpm/prettier@2.7.1/node_modules/prettier/standalone.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          f.prettier = e();
        }
      })(function() {
        "use strict";
        var we = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
        var Ye = we((Ig, ru) => {
          var rr = function(e) {
            return e && e.Math == Math && e;
          };
          ru.exports = rr(typeof globalThis == "object" && globalThis) || rr(typeof window == "object" && window) || rr(typeof self == "object" && self) || rr(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        });
        var Dt = we((Lg, nu) => {
          nu.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        });
        var Ct = we((jg, uu) => {
          var So = Dt();
          uu.exports = !So(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        });
        var nr = we((Og, su) => {
          var xo = Dt();
          su.exports = !xo(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        });
        var Et = we((qg, iu) => {
          var bo = nr(), ur = Function.prototype.call;
          iu.exports = bo ? ur.bind(ur) : function() {
            return ur.apply(ur, arguments);
          };
        });
        var cu = we((lu) => {
          "use strict";
          var au = {}.propertyIsEnumerable, ou = Object.getOwnPropertyDescriptor, To = ou && !au.call({ 1: 2 }, 1);
          lu.f = To ? function(n) {
            var t = ou(this, n);
            return !!t && t.enumerable;
          } : au;
        });
        var sr = we((Rg, pu) => {
          pu.exports = function(e, n) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
          };
        });
        var at = we((Vg, mu) => {
          var fu = nr(), Du = Function.prototype, Bo = Du.bind, Or = Du.call, No = fu && Bo.bind(Or, Or);
          mu.exports = fu ? function(e) {
            return e && No(e);
          } : function(e) {
            return e && function() {
              return Or.apply(e, arguments);
            };
          };
        });
        var ir = we((Wg, gu) => {
          var du = at(), wo = du({}.toString), _o = du("".slice);
          gu.exports = function(e) {
            return _o(wo(e), 8, -1);
          };
        });
        var hu = we(($g, yu) => {
          var Po = Ye(), ko = at(), Io = Dt(), Lo = ir(), qr = Po.Object, jo = ko("".split);
          yu.exports = Io(function() {
            return !qr("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return Lo(e) == "String" ? jo(e, "") : qr(e);
          } : qr;
        });
        var Mr = we((Hg, vu) => {
          var Oo = Ye(), qo = Oo.TypeError;
          vu.exports = function(e) {
            if (e == null)
              throw qo("Can't call method on " + e);
            return e;
          };
        });
        var ar = we((Gg, Cu) => {
          var Mo = hu(), Ro = Mr();
          Cu.exports = function(e) {
            return Mo(Ro(e));
          };
        });
        var ot = we((Jg, Eu) => {
          Eu.exports = function(e) {
            return typeof e == "function";
          };
        });
        var Ft = we((Ug, Fu) => {
          var Vo = ot();
          Fu.exports = function(e) {
            return typeof e == "object" ? e !== null : Vo(e);
          };
        });
        var Rt = we((zg, Au) => {
          var Rr = Ye(), Wo = ot(), $o = function(e) {
            return Wo(e) ? e : void 0;
          };
          Au.exports = function(e, n) {
            return arguments.length < 2 ? $o(Rr[e]) : Rr[e] && Rr[e][n];
          };
        });
        var Vr = we((Xg, Su) => {
          var Ho = at();
          Su.exports = Ho({}.isPrototypeOf);
        });
        var bu = we((Kg, xu) => {
          var Go = Rt();
          xu.exports = Go("navigator", "userAgent") || "";
        });
        var ku = we((Yg, Pu) => {
          var _u = Ye(), Wr = bu(), Tu = _u.process, Bu = _u.Deno, Nu = Tu && Tu.versions || Bu && Bu.version, wu = Nu && Nu.v8, ft, or;
          wu && (ft = wu.split("."), or = ft[0] > 0 && ft[0] < 4 ? 1 : +(ft[0] + ft[1]));
          !or && Wr && (ft = Wr.match(/Edge\/(\d+)/), (!ft || ft[1] >= 74) && (ft = Wr.match(/Chrome\/(\d+)/), ft && (or = +ft[1])));
          Pu.exports = or;
        });
        var $r = we((Qg, Lu) => {
          var Iu = ku(), Jo = Dt();
          Lu.exports = !!Object.getOwnPropertySymbols && !Jo(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Iu && Iu < 41;
          });
        });
        var Hr = we((Zg, ju) => {
          var Uo = $r();
          ju.exports = Uo && !Symbol.sham && typeof Symbol.iterator == "symbol";
        });
        var Gr = we((e0, Ou) => {
          var zo = Ye(), Xo = Rt(), Ko = ot(), Yo = Vr(), Qo = Hr(), Zo = zo.Object;
          Ou.exports = Qo ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var n = Xo("Symbol");
            return Ko(n) && Yo(n.prototype, Zo(e));
          };
        });
        var lr = we((t0, qu) => {
          var el = Ye(), tl = el.String;
          qu.exports = function(e) {
            try {
              return tl(e);
            } catch {
              return "Object";
            }
          };
        });
        var Vt = we((r0, Mu) => {
          var rl = Ye(), nl = ot(), ul = lr(), sl = rl.TypeError;
          Mu.exports = function(e) {
            if (nl(e))
              return e;
            throw sl(ul(e) + " is not a function");
          };
        });
        var cr = we((n0, Ru) => {
          var il = Vt();
          Ru.exports = function(e, n) {
            var t = e[n];
            return t == null ? void 0 : il(t);
          };
        });
        var Wu = we((u0, Vu) => {
          var al = Ye(), Jr = Et(), Ur = ot(), zr = Ft(), ol = al.TypeError;
          Vu.exports = function(e, n) {
            var t, s;
            if (n === "string" && Ur(t = e.toString) && !zr(s = Jr(t, e)) || Ur(t = e.valueOf) && !zr(s = Jr(t, e)) || n !== "string" && Ur(t = e.toString) && !zr(s = Jr(t, e)))
              return s;
            throw ol("Can't convert object to primitive value");
          };
        });
        var Hu = we((s0, $u) => {
          $u.exports = false;
        });
        var pr = we((i0, Ju) => {
          var Gu = Ye(), ll = Object.defineProperty;
          Ju.exports = function(e, n) {
            try {
              ll(Gu, e, { value: n, configurable: true, writable: true });
            } catch {
              Gu[e] = n;
            }
            return n;
          };
        });
        var fr = we((a0, zu) => {
          var cl = Ye(), pl = pr(), Uu = "__core-js_shared__", fl = cl[Uu] || pl(Uu, {});
          zu.exports = fl;
        });
        var Xr = we((o0, Ku) => {
          var Dl = Hu(), Xu = fr();
          (Ku.exports = function(e, n) {
            return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
          })("versions", []).push({ version: "3.22.2", mode: Dl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
        });
        var Dr = we((l0, Yu) => {
          var ml = Ye(), dl = Mr(), gl = ml.Object;
          Yu.exports = function(e) {
            return gl(dl(e));
          };
        });
        var gt = we((c0, Qu) => {
          var yl = at(), hl = Dr(), vl = yl({}.hasOwnProperty);
          Qu.exports = Object.hasOwn || function(n, t) {
            return vl(hl(n), t);
          };
        });
        var Kr = we((p0, Zu) => {
          var Cl = at(), El = 0, Fl = Math.random(), Al = Cl(1 .toString);
          Zu.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Al(++El + Fl, 36);
          };
        });
        var St = we((f0, us) => {
          var Sl = Ye(), xl = Xr(), es = gt(), bl = Kr(), ts = $r(), ns = Hr(), Nt = xl("wks"), At = Sl.Symbol, rs = At && At.for, Tl = ns ? At : At && At.withoutSetter || bl;
          us.exports = function(e) {
            if (!es(Nt, e) || !(ts || typeof Nt[e] == "string")) {
              var n = "Symbol." + e;
              ts && es(At, e) ? Nt[e] = At[e] : ns && rs ? Nt[e] = rs(n) : Nt[e] = Tl(n);
            }
            return Nt[e];
          };
        });
        var os = we((D0, as) => {
          var Bl = Ye(), Nl = Et(), ss = Ft(), is = Gr(), wl = cr(), _l = Wu(), Pl = St(), kl = Bl.TypeError, Il = Pl("toPrimitive");
          as.exports = function(e, n) {
            if (!ss(e) || is(e))
              return e;
            var t = wl(e, Il), s;
            if (t) {
              if (n === void 0 && (n = "default"), s = Nl(t, e, n), !ss(s) || is(s))
                return s;
              throw kl("Can't convert object to primitive value");
            }
            return n === void 0 && (n = "number"), _l(e, n);
          };
        });
        var mr = we((m0, ls) => {
          var Ll = os(), jl = Gr();
          ls.exports = function(e) {
            var n = Ll(e, "string");
            return jl(n) ? n : n + "";
          };
        });
        var fs = we((d0, ps) => {
          var Ol = Ye(), cs = Ft(), Yr = Ol.document, ql = cs(Yr) && cs(Yr.createElement);
          ps.exports = function(e) {
            return ql ? Yr.createElement(e) : {};
          };
        });
        var Qr = we((g0, Ds) => {
          var Ml = Ct(), Rl = Dt(), Vl = fs();
          Ds.exports = !Ml && !Rl(function() {
            return Object.defineProperty(Vl("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        });
        var Zr = we((ds) => {
          var Wl = Ct(), $l = Et(), Hl = cu(), Gl = sr(), Jl = ar(), Ul = mr(), zl = gt(), Xl = Qr(), ms = Object.getOwnPropertyDescriptor;
          ds.f = Wl ? ms : function(n, t) {
            if (n = Jl(n), t = Ul(t), Xl)
              try {
                return ms(n, t);
              } catch {
              }
            if (zl(n, t))
              return Gl(!$l(Hl.f, n, t), n[t]);
          };
        });
        var ys = we((h0, gs) => {
          var Kl = Ct(), Yl = Dt();
          gs.exports = Kl && Yl(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        });
        var wt = we((v0, vs) => {
          var hs = Ye(), Ql = Ft(), Zl = hs.String, ec = hs.TypeError;
          vs.exports = function(e) {
            if (Ql(e))
              return e;
            throw ec(Zl(e) + " is not an object");
          };
        });
        var gr = we((Es) => {
          var tc = Ye(), rc = Ct(), nc = Qr(), uc = ys(), dr = wt(), Cs = mr(), sc = tc.TypeError, en = Object.defineProperty, ic = Object.getOwnPropertyDescriptor, tn = "enumerable", rn = "configurable", nn = "writable";
          Es.f = rc ? uc ? function(n, t, s) {
            if (dr(n), t = Cs(t), dr(s), typeof n == "function" && t === "prototype" && "value" in s && nn in s && !s[nn]) {
              var a = ic(n, t);
              a && a[nn] && (n[t] = s.value, s = { configurable: rn in s ? s[rn] : a[rn], enumerable: tn in s ? s[tn] : a[tn], writable: false });
            }
            return en(n, t, s);
          } : en : function(n, t, s) {
            if (dr(n), t = Cs(t), dr(s), nc)
              try {
                return en(n, t, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw sc("Accessors not supported");
            return "value" in s && (n[t] = s.value), n;
          };
        });
        var yr = we((E0, Fs) => {
          var ac = Ct(), oc = gr(), lc = sr();
          Fs.exports = ac ? function(e, n, t) {
            return oc.f(e, n, lc(1, t));
          } : function(e, n, t) {
            return e[n] = t, e;
          };
        });
        var hr = we((F0, As) => {
          var cc = at(), pc = ot(), un = fr(), fc = cc(Function.toString);
          pc(un.inspectSource) || (un.inspectSource = function(e) {
            return fc(e);
          });
          As.exports = un.inspectSource;
        });
        var bs = we((A0, xs) => {
          var Dc = Ye(), mc = ot(), dc = hr(), Ss = Dc.WeakMap;
          xs.exports = mc(Ss) && /native code/.test(dc(Ss));
        });
        var Ns = we((S0, Bs) => {
          var gc = Xr(), yc = Kr(), Ts = gc("keys");
          Bs.exports = function(e) {
            return Ts[e] || (Ts[e] = yc(e));
          };
        });
        var sn = we((x0, ws) => {
          ws.exports = {};
        });
        var js = we((b0, Ls) => {
          var hc = bs(), Is = Ye(), an = at(), vc = Ft(), Cc = yr(), on = gt(), ln = fr(), Ec = Ns(), Fc = sn(), _s = "Object already initialized", pn = Is.TypeError, Ac = Is.WeakMap, vr, Wt, Cr, Sc = function(e) {
            return Cr(e) ? Wt(e) : vr(e, {});
          }, xc = function(e) {
            return function(n) {
              var t;
              if (!vc(n) || (t = Wt(n)).type !== e)
                throw pn("Incompatible receiver, " + e + " required");
              return t;
            };
          };
          hc || ln.state ? (yt = ln.state || (ln.state = new Ac()), Ps = an(yt.get), cn = an(yt.has), ks = an(yt.set), vr = function(e, n) {
            if (cn(yt, e))
              throw new pn(_s);
            return n.facade = e, ks(yt, e, n), n;
          }, Wt = function(e) {
            return Ps(yt, e) || {};
          }, Cr = function(e) {
            return cn(yt, e);
          }) : (xt = Ec("state"), Fc[xt] = true, vr = function(e, n) {
            if (on(e, xt))
              throw new pn(_s);
            return n.facade = e, Cc(e, xt, n), n;
          }, Wt = function(e) {
            return on(e, xt) ? e[xt] : {};
          }, Cr = function(e) {
            return on(e, xt);
          });
          var yt, Ps, cn, ks, xt;
          Ls.exports = { set: vr, get: Wt, has: Cr, enforce: Sc, getterFor: xc };
        });
        var Ms = we((T0, qs) => {
          var fn = Ct(), bc = gt(), Os = Function.prototype, Tc = fn && Object.getOwnPropertyDescriptor, Dn = bc(Os, "name"), Bc = Dn && function() {
          }.name === "something", Nc = Dn && (!fn || fn && Tc(Os, "name").configurable);
          qs.exports = { EXISTS: Dn, PROPER: Bc, CONFIGURABLE: Nc };
        });
        var Hs = we((B0, $s) => {
          var wc = Ye(), Rs = ot(), _c = gt(), Vs = yr(), Pc = pr(), kc = hr(), Ws = js(), Ic = Ms().CONFIGURABLE, Lc = Ws.get, jc = Ws.enforce, Oc = String(String).split("String");
          ($s.exports = function(e, n, t, s) {
            var a = s ? !!s.unsafe : false, r = s ? !!s.enumerable : false, u = s ? !!s.noTargetGet : false, i = s && s.name !== void 0 ? s.name : n, o;
            if (Rs(t) && (String(i).slice(0, 7) === "Symbol(" && (i = "[" + String(i).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!_c(t, "name") || Ic && t.name !== i) && Vs(t, "name", i), o = jc(t), o.source || (o.source = Oc.join(typeof i == "string" ? i : ""))), e === wc) {
              r ? e[n] = t : Pc(n, t);
              return;
            } else
              a ? !u && e[n] && (r = true) : delete e[n];
            r ? e[n] = t : Vs(e, n, t);
          })(Function.prototype, "toString", function() {
            return Rs(this) && Lc(this).source || kc(this);
          });
        });
        var Er = we((N0, Gs) => {
          var qc = Math.ceil, Mc = Math.floor;
          Gs.exports = function(e) {
            var n = +e;
            return n !== n || n === 0 ? 0 : (n > 0 ? Mc : qc)(n);
          };
        });
        var Us = we((w0, Js) => {
          var Rc = Er(), Vc = Math.max, Wc = Math.min;
          Js.exports = function(e, n) {
            var t = Rc(e);
            return t < 0 ? Vc(t + n, 0) : Wc(t, n);
          };
        });
        var Xs = we((_0, zs) => {
          var $c = Er(), Hc = Math.min;
          zs.exports = function(e) {
            return e > 0 ? Hc($c(e), 9007199254740991) : 0;
          };
        });
        var _t = we((P0, Ks) => {
          var Gc = Xs();
          Ks.exports = function(e) {
            return Gc(e.length);
          };
        });
        var Zs = we((k0, Qs) => {
          var Jc = ar(), Uc = Us(), zc = _t(), Ys = function(e) {
            return function(n, t, s) {
              var a = Jc(n), r = zc(a), u = Uc(s, r), i;
              if (e && t != t) {
                for (; r > u; )
                  if (i = a[u++], i != i)
                    return true;
              } else
                for (; r > u; u++)
                  if ((e || u in a) && a[u] === t)
                    return e || u || 0;
              return !e && -1;
            };
          };
          Qs.exports = { includes: Ys(true), indexOf: Ys(false) };
        });
        var ri = we((I0, ti) => {
          var Xc = at(), mn = gt(), Kc = ar(), Yc = Zs().indexOf, Qc = sn(), ei = Xc([].push);
          ti.exports = function(e, n) {
            var t = Kc(e), s = 0, a = [], r;
            for (r in t)
              !mn(Qc, r) && mn(t, r) && ei(a, r);
            for (; n.length > s; )
              mn(t, r = n[s++]) && (~Yc(a, r) || ei(a, r));
            return a;
          };
        });
        var ui = we((L0, ni) => {
          ni.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        });
        var ii = we((si) => {
          var Zc = ri(), ep = ui(), tp = ep.concat("length", "prototype");
          si.f = Object.getOwnPropertyNames || function(n) {
            return Zc(n, tp);
          };
        });
        var oi = we((ai) => {
          ai.f = Object.getOwnPropertySymbols;
        });
        var ci = we((q0, li) => {
          var rp = Rt(), np = at(), up = ii(), sp = oi(), ip = wt(), ap = np([].concat);
          li.exports = rp("Reflect", "ownKeys") || function(n) {
            var t = up.f(ip(n)), s = sp.f;
            return s ? ap(t, s(n)) : t;
          };
        });
        var Di = we((M0, fi) => {
          var pi = gt(), op = ci(), lp = Zr(), cp = gr();
          fi.exports = function(e, n, t) {
            for (var s = op(n), a = cp.f, r = lp.f, u = 0; u < s.length; u++) {
              var i = s[u];
              !pi(e, i) && !(t && pi(t, i)) && a(e, i, r(n, i));
            }
          };
        });
        var di = we((R0, mi) => {
          var pp = Dt(), fp = ot(), Dp = /#|\.prototype\./, $t = function(e, n) {
            var t = dp[mp(e)];
            return t == yp ? true : t == gp ? false : fp(n) ? pp(n) : !!n;
          }, mp = $t.normalize = function(e) {
            return String(e).replace(Dp, ".").toLowerCase();
          }, dp = $t.data = {}, gp = $t.NATIVE = "N", yp = $t.POLYFILL = "P";
          mi.exports = $t;
        });
        var Ht = we((V0, gi) => {
          var dn = Ye(), hp = Zr().f, vp = yr(), Cp = Hs(), Ep = pr(), Fp = Di(), Ap = di();
          gi.exports = function(e, n) {
            var t = e.target, s = e.global, a = e.stat, r, u, i, o, c, v;
            if (s ? u = dn : a ? u = dn[t] || Ep(t, {}) : u = (dn[t] || {}).prototype, u)
              for (i in n) {
                if (c = n[i], e.noTargetGet ? (v = hp(u, i), o = v && v.value) : o = u[i], r = Ap(s ? i : t + (a ? "." : "#") + i, e.forced), !r && o !== void 0) {
                  if (typeof c == typeof o)
                    continue;
                  Fp(c, o);
                }
                (e.sham || o && o.sham) && vp(c, "sham", true), Cp(u, i, c, e);
              }
          };
        });
        var gn = we((W0, yi) => {
          var Sp = ir();
          yi.exports = Array.isArray || function(n) {
            return Sp(n) == "Array";
          };
        });
        var yn = we(($0, vi) => {
          var hi = at(), xp = Vt(), bp = nr(), Tp = hi(hi.bind);
          vi.exports = function(e, n) {
            return xp(e), n === void 0 ? e : bp ? Tp(e, n) : function() {
              return e.apply(n, arguments);
            };
          };
        });
        var hn = we((H0, Ei) => {
          "use strict";
          var Bp = Ye(), Np = gn(), wp = _t(), _p = yn(), Pp = Bp.TypeError, Ci = function(e, n, t, s, a, r, u, i) {
            for (var o = a, c = 0, v = u ? _p(u, i) : false, m, d; c < s; ) {
              if (c in t) {
                if (m = v ? v(t[c], c, n) : t[c], r > 0 && Np(m))
                  d = wp(m), o = Ci(e, n, m, d, o, r - 1) - 1;
                else {
                  if (o >= 9007199254740991)
                    throw Pp("Exceed the acceptable array length");
                  e[o] = m;
                }
                o++;
              }
              c++;
            }
            return o;
          };
          Ei.exports = Ci;
        });
        var Si = we((G0, Ai) => {
          var kp = St(), Ip = kp("toStringTag"), Fi = {};
          Fi[Ip] = "z";
          Ai.exports = String(Fi) === "[object z]";
        });
        var vn = we((J0, xi) => {
          var Lp = Ye(), jp = Si(), Op = ot(), Fr = ir(), qp = St(), Mp = qp("toStringTag"), Rp = Lp.Object, Vp = Fr(function() {
            return arguments;
          }()) == "Arguments", Wp = function(e, n) {
            try {
              return e[n];
            } catch {
            }
          };
          xi.exports = jp ? Fr : function(e) {
            var n, t, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Wp(n = Rp(e), Mp)) == "string" ? t : Vp ? Fr(n) : (s = Fr(n)) == "Object" && Op(n.callee) ? "Arguments" : s;
          };
        });
        var _i = we((U0, wi) => {
          var $p = at(), Hp = Dt(), bi = ot(), Gp = vn(), Jp = Rt(), Up = hr(), Ti = function() {
          }, zp = [], Bi = Jp("Reflect", "construct"), Cn = /^\s*(?:class|function)\b/, Xp = $p(Cn.exec), Kp = !Cn.exec(Ti), Gt = function(n) {
            if (!bi(n))
              return false;
            try {
              return Bi(Ti, zp, n), true;
            } catch {
              return false;
            }
          }, Ni = function(n) {
            if (!bi(n))
              return false;
            switch (Gp(n)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Kp || !!Xp(Cn, Up(n));
            } catch {
              return true;
            }
          };
          Ni.sham = true;
          wi.exports = !Bi || Hp(function() {
            var e;
            return Gt(Gt.call) || !Gt(Object) || !Gt(function() {
              e = true;
            }) || e;
          }) ? Ni : Gt;
        });
        var Li = we((z0, Ii) => {
          var Yp = Ye(), Pi = gn(), Qp = _i(), Zp = Ft(), ef = St(), tf = ef("species"), ki = Yp.Array;
          Ii.exports = function(e) {
            var n;
            return Pi(e) && (n = e.constructor, Qp(n) && (n === ki || Pi(n.prototype)) ? n = void 0 : Zp(n) && (n = n[tf], n === null && (n = void 0))), n === void 0 ? ki : n;
          };
        });
        var En = we((X0, ji) => {
          var rf = Li();
          ji.exports = function(e, n) {
            return new (rf(e))(n === 0 ? 0 : n);
          };
        });
        var Oi = we(() => {
          "use strict";
          var nf = Ht(), uf = hn(), sf = Vt(), af = Dr(), of = _t(), lf = En();
          nf({ target: "Array", proto: true }, { flatMap: function(n) {
            var t = af(this), s = of(t), a;
            return sf(n), a = lf(t, 0), a.length = uf(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;
          } });
        });
        var Fn = we((Q0, qi) => {
          qi.exports = {};
        });
        var Ri = we((Z0, Mi) => {
          var cf = St(), pf = Fn(), ff = cf("iterator"), Df = Array.prototype;
          Mi.exports = function(e) {
            return e !== void 0 && (pf.Array === e || Df[ff] === e);
          };
        });
        var An = we((ey, Wi) => {
          var mf = vn(), Vi = cr(), df = Fn(), gf = St(), yf = gf("iterator");
          Wi.exports = function(e) {
            if (e != null)
              return Vi(e, yf) || Vi(e, "@@iterator") || df[mf(e)];
          };
        });
        var Hi = we((ty, $i) => {
          var hf = Ye(), vf = Et(), Cf = Vt(), Ef = wt(), Ff = lr(), Af = An(), Sf = hf.TypeError;
          $i.exports = function(e, n) {
            var t = arguments.length < 2 ? Af(e) : n;
            if (Cf(t))
              return Ef(vf(t, e));
            throw Sf(Ff(e) + " is not iterable");
          };
        });
        var Ui = we((ry, Ji) => {
          var xf = Et(), Gi = wt(), bf = cr();
          Ji.exports = function(e, n, t) {
            var s, a;
            Gi(e);
            try {
              if (s = bf(e, "return"), !s) {
                if (n === "throw")
                  throw t;
                return t;
              }
              s = xf(s, e);
            } catch (r) {
              a = true, s = r;
            }
            if (n === "throw")
              throw t;
            if (a)
              throw s;
            return Gi(s), t;
          };
        });
        var Qi = we((ny, Yi) => {
          var Tf = Ye(), Bf = yn(), Nf = Et(), wf = wt(), _f = lr(), Pf = Ri(), kf = _t(), zi = Vr(), If = Hi(), Lf = An(), Xi = Ui(), jf = Tf.TypeError, Ar = function(e, n) {
            this.stopped = e, this.result = n;
          }, Ki = Ar.prototype;
          Yi.exports = function(e, n, t) {
            var s = t && t.that, a = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), i = Bf(n, s), o, c, v, m, d, p, f, h = function(T) {
              return o && Xi(o, "normal", T), new Ar(true, T);
            }, w = function(T) {
              return a ? (wf(T), u ? i(T[0], T[1], h) : i(T[0], T[1])) : u ? i(T, h) : i(T);
            };
            if (r)
              o = e;
            else {
              if (c = Lf(e), !c)
                throw jf(_f(e) + " is not iterable");
              if (Pf(c)) {
                for (v = 0, m = kf(e); m > v; v++)
                  if (d = w(e[v]), d && zi(Ki, d))
                    return d;
                return new Ar(false);
              }
              o = If(e, c);
            }
            for (p = o.next; !(f = Nf(p, o)).done; ) {
              try {
                d = w(f.value);
              } catch (T) {
                Xi(o, "throw", T);
              }
              if (typeof d == "object" && d && zi(Ki, d))
                return d;
            }
            return new Ar(false);
          };
        });
        var ea = we((uy, Zi) => {
          "use strict";
          var Of = mr(), qf = gr(), Mf = sr();
          Zi.exports = function(e, n, t) {
            var s = Of(n);
            s in e ? qf.f(e, s, Mf(0, t)) : e[s] = t;
          };
        });
        var ta = we(() => {
          var Rf = Ht(), Vf = Qi(), Wf = ea();
          Rf({ target: "Object", stat: true }, { fromEntries: function(n) {
            var t = {};
            return Vf(n, function(s, a) {
              Wf(t, s, a);
            }, { AS_ENTRIES: true }), t;
          } });
        });
        var ra = we(() => {
          var $f = Ht(), Hf = Ye();
          $f({ global: true }, { globalThis: Hf });
        });
        var na = we(() => {
          ra();
        });
        var ua = we(() => {
          "use strict";
          var Gf = Ht(), Jf = hn(), Uf = Dr(), zf = _t(), Xf = Er(), Kf = En();
          Gf({ target: "Array", proto: true }, { flat: function() {
            var n = arguments.length ? arguments[0] : void 0, t = Uf(this), s = zf(t), a = Kf(t, 0);
            return a.length = Jf(a, t, t, s, 0, n === void 0 ? 1 : Xf(n)), a;
          } });
        });
        var Pg = we((my, Co) => {
          var Yf = ["cliName", "cliCategory", "cliDescription"], Qf = ["_"], Zf = ["languageId"], sa, ia, aa, oa, la, ca;
          function kn(e, n) {
            if (e == null)
              return {};
            var t = eD(e, n), s, a;
            if (Object.getOwnPropertySymbols) {
              var r = Object.getOwnPropertySymbols(e);
              for (a = 0; a < r.length; a++)
                s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
            }
            return t;
          }
          function eD(e, n) {
            if (e == null)
              return {};
            var t = {}, s = Object.keys(e), a, r;
            for (r = 0; r < s.length; r++)
              a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
            return t;
          }
          Oi();
          ta();
          na();
          ua();
          function Pt(e, n) {
            return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(n) } }));
          }
          var tD = Object.create, Br = Object.defineProperty, rD = Object.getOwnPropertyDescriptor, In = Object.getOwnPropertyNames, nD = Object.getPrototypeOf, uD = Object.prototype.hasOwnProperty, mt = (e, n) => function() {
            return e && (n = (0, e[In(e)[0]])(e = 0)), n;
          }, Z = (e, n) => function() {
            return n || (0, e[In(e)[0]])((n = { exports: {} }).exports, n), n.exports;
          }, Ut = (e, n) => {
            for (var t in n)
              Br(e, t, { get: n[t], enumerable: true });
          }, ga = (e, n, t, s) => {
            if (n && typeof n == "object" || typeof n == "function")
              for (let a of In(n))
                !uD.call(e, a) && a !== t && Br(e, a, { get: () => n[a], enumerable: !(s = rD(n, a)) || s.enumerable });
            return e;
          }, sD = (e, n, t) => (t = e != null ? tD(nD(e)) : {}, ga(n || !e || !e.__esModule ? Br(t, "default", { value: e, enumerable: true }) : t, e)), lt = (e) => ga(Br({}, "__esModule", { value: true }), e), pa, fa, Tt, re = mt({ "<define:process>"() {
            pa = {}, fa = [], Tt = { env: pa, argv: fa };
          } }), ya = Z({ "package.json"(e, n) {
            n.exports = { version: "2.7.1" };
          } }), iD = Z({ "node_modules/diff/lib/diff/base.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
            function n() {
            }
            n.prototype = { diff: function(r, u) {
              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = i.callback;
              typeof i == "function" && (o = i, i = {}), this.options = i;
              var c = this;
              function v(S) {
                return o ? (setTimeout(function() {
                  o(void 0, S);
                }, 0), true) : S;
              }
              r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
              var m = u.length, d = r.length, p = 1, f = m + d, h = [{ newPos: -1, components: [] }], w = this.extractCommon(h[0], u, r, 0);
              if (h[0].newPos + 1 >= m && w + 1 >= d)
                return v([{ value: this.join(u), count: u.length }]);
              function T() {
                for (var S = -1 * p; S <= p; S += 2) {
                  var B = void 0, I = h[S - 1], k = h[S + 1], P = (k ? k.newPos : 0) - S;
                  I && (h[S - 1] = void 0);
                  var C = I && I.newPos + 1 < m, D = k && 0 <= P && P < d;
                  if (!C && !D) {
                    h[S] = void 0;
                    continue;
                  }
                  if (!C || D && I.newPos < k.newPos ? (B = s(k), c.pushComponent(B.components, void 0, true)) : (B = I, B.newPos++, c.pushComponent(B.components, true, void 0)), P = c.extractCommon(B, u, r, S), B.newPos + 1 >= m && P + 1 >= d)
                    return v(t(c, B.components, u, r, c.useLongestToken));
                  h[S] = B;
                }
                p++;
              }
              if (o)
                (function S() {
                  setTimeout(function() {
                    if (p > f)
                      return o();
                    T() || S();
                  }, 0);
                })();
              else
                for (; p <= f; ) {
                  var A = T();
                  if (A)
                    return A;
                }
            }, pushComponent: function(r, u, i) {
              var o = r[r.length - 1];
              o && o.added === u && o.removed === i ? r[r.length - 1] = { count: o.count + 1, added: u, removed: i } : r.push({ count: 1, added: u, removed: i });
            }, extractCommon: function(r, u, i, o) {
              for (var c = u.length, v = i.length, m = r.newPos, d = m - o, p = 0; m + 1 < c && d + 1 < v && this.equals(u[m + 1], i[d + 1]); )
                m++, d++, p++;
              return p && r.components.push({ count: p }), r.newPos = m, d;
            }, equals: function(r, u) {
              return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
            }, removeEmpty: function(r) {
              for (var u = [], i = 0; i < r.length; i++)
                r[i] && u.push(r[i]);
              return u;
            }, castInput: function(r) {
              return r;
            }, tokenize: function(r) {
              return r.split("");
            }, join: function(r) {
              return r.join("");
            } };
            function t(a, r, u, i, o) {
              for (var c = 0, v = r.length, m = 0, d = 0; c < v; c++) {
                var p = r[c];
                if (p.removed) {
                  if (p.value = a.join(i.slice(d, d + p.count)), d += p.count, c && r[c - 1].added) {
                    var h = r[c - 1];
                    r[c - 1] = r[c], r[c] = h;
                  }
                } else {
                  if (!p.added && o) {
                    var f = u.slice(m, m + p.count);
                    f = f.map(function(T, A) {
                      var S = i[d + A];
                      return S.length > T.length ? S : T;
                    }), p.value = a.join(f);
                  } else
                    p.value = a.join(u.slice(m, m + p.count));
                  m += p.count, p.added || (d += p.count);
                }
              }
              var w = r[v - 1];
              return v > 1 && typeof w.value == "string" && (w.added || w.removed) && a.equals("", w.value) && (r[v - 2].value += w.value, r.pop()), r;
            }
            function s(a) {
              return { newPos: a.newPos, components: a.components.slice(0) };
            }
          } }), aD = Z({ "node_modules/diff/lib/diff/array.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
            var n = t(iD());
            function t(r) {
              return r && r.__esModule ? r : { default: r };
            }
            var s = new n.default();
            e.arrayDiff = s, s.tokenize = function(r) {
              return r.slice();
            }, s.join = s.removeEmpty = function(r) {
              return r;
            };
            function a(r, u, i) {
              return s.diff(r, u, i);
            }
          } }), Ln = Z({ "src/document/doc-builders.js"(e, n) {
            "use strict";
            re();
            function t(F) {
              return { type: "concat", parts: F };
            }
            function s(F) {
              return { type: "indent", contents: F };
            }
            function a(F, l) {
              return { type: "align", contents: l, n: F };
            }
            function r(F) {
              let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return { type: "group", id: l.id, contents: F, break: Boolean(l.shouldBreak), expandedStates: l.expandedStates };
            }
            function u(F) {
              return a(Number.NEGATIVE_INFINITY, F);
            }
            function i(F) {
              return a({ type: "root" }, F);
            }
            function o(F) {
              return a(-1, F);
            }
            function c(F, l) {
              return r(F[0], Object.assign(Object.assign({}, l), {}, { expandedStates: F }));
            }
            function v(F) {
              return { type: "fill", parts: F };
            }
            function m(F, l) {
              let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return { type: "if-break", breakContents: F, flatContents: l, groupId: E.groupId };
            }
            function d(F, l) {
              return { type: "indent-if-break", contents: F, groupId: l.groupId, negate: l.negate };
            }
            function p(F) {
              return { type: "line-suffix", contents: F };
            }
            var f = { type: "line-suffix-boundary" }, h = { type: "break-parent" }, w = { type: "trim" }, T = { type: "line", hard: true }, A = { type: "line", hard: true, literal: true }, S = { type: "line" }, B = { type: "line", soft: true }, I = t([T, h]), k = t([A, h]), P = { type: "cursor", placeholder: Symbol("cursor") };
            function C(F, l) {
              let E = [];
              for (let y = 0; y < l.length; y++)
                y !== 0 && E.push(F), E.push(l[y]);
              return t(E);
            }
            function D(F, l, E) {
              let y = F;
              if (l > 0) {
                for (let N = 0; N < Math.floor(l / E); ++N)
                  y = s(y);
                y = a(l % E, y), y = a(Number.NEGATIVE_INFINITY, y);
              }
              return y;
            }
            function g(F, l) {
              return { type: "label", label: F, contents: l };
            }
            n.exports = { concat: t, join: C, line: S, softline: B, hardline: I, literalline: k, group: r, conditionalGroup: c, fill: v, lineSuffix: p, lineSuffixBoundary: f, cursor: P, breakParent: h, ifBreak: m, trim: w, indent: s, indentIfBreak: d, align: a, addAlignmentToDoc: D, markAsRoot: i, dedentToRoot: u, dedent: o, hardlineWithoutBreakParent: T, literallineWithoutBreakParent: A, label: g };
          } }), jn = Z({ "src/common/end-of-line.js"(e, n) {
            "use strict";
            re();
            function t(u) {
              let i = u.indexOf("\r");
              return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function s(u) {
              switch (u) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function a(u, i) {
              let o;
              switch (i) {
                case `
`:
                  o = /\n/g;
                  break;
                case "\r":
                  o = /\r/g;
                  break;
                case `\r
`:
                  o = /\r\n/g;
                  break;
                default:
                  throw new Error('Unexpected "eol" '.concat(JSON.stringify(i), "."));
              }
              let c = u.match(o);
              return c ? c.length : 0;
            }
            function r(u) {
              return u.replace(/\r\n?/g, `
`);
            }
            n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: r };
          } }), it = Z({ "src/utils/get-last.js"(e, n) {
            "use strict";
            re();
            var t = (s) => s[s.length - 1];
            n.exports = t;
          } });
          function oD() {
            let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(n, e ? void 0 : "g");
          }
          var lD = mt({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
            re();
          } });
          function cD(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
            return e.replace(oD(), "");
          }
          var pD = mt({ "node_modules/strip-ansi/index.js"() {
            re(), lD();
          } });
          function fD(e) {
            return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
          }
          var DD = mt({ "node_modules/is-fullwidth-code-point/index.js"() {
            re();
          } }), mD = Z({ "node_modules/emoji-regex/index.js"(e, n) {
            "use strict";
            re(), n.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), ha = {};
          Ut(ha, { default: () => dD });
          function dD(e) {
            if (typeof e != "string" || e.length === 0 || (e = cD(e), e.length === 0))
              return 0;
            e = e.replace((0, va.default)(), "  ");
            let n = 0;
            for (let t = 0; t < e.length; t++) {
              let s = e.codePointAt(t);
              s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += fD(s) ? 2 : 1);
            }
            return n;
          }
          var va, gD = mt({ "node_modules/string-width/index.js"() {
            re(), pD(), DD(), va = sD(mD());
          } }), Ca = Z({ "src/utils/get-string-width.js"(e, n) {
            "use strict";
            re();
            var t = (gD(), lt(ha)).default, s = /[^\x20-\x7F]/;
            function a(r) {
              return r ? s.test(r) ? t(r) : r.length : 0;
            }
            n.exports = a;
          } }), On = Z({ "src/document/doc-utils.js"(e, n) {
            "use strict";
            re();
            var t = it(), { literalline: s, join: a } = Ln(), r = (l) => Array.isArray(l) || l && l.type === "concat", u = (l) => {
              if (Array.isArray(l))
                return l;
              if (l.type !== "concat" && l.type !== "fill")
                throw new Error("Expect doc type to be `concat` or `fill`.");
              return l.parts;
            }, i = {};
            function o(l, E, y, N) {
              let x = [l];
              for (; x.length > 0; ) {
                let b = x.pop();
                if (b === i) {
                  y(x.pop());
                  continue;
                }
                if (y && x.push(b, i), !E || E(b) !== false)
                  if (r(b) || b.type === "fill") {
                    let L = u(b);
                    for (let M = L.length, j = M - 1; j >= 0; --j)
                      x.push(L[j]);
                  } else if (b.type === "if-break")
                    b.flatContents && x.push(b.flatContents), b.breakContents && x.push(b.breakContents);
                  else if (b.type === "group" && b.expandedStates)
                    if (N)
                      for (let L = b.expandedStates.length, M = L - 1; M >= 0; --M)
                        x.push(b.expandedStates[M]);
                    else
                      x.push(b.contents);
                  else
                    b.contents && x.push(b.contents);
              }
            }
            function c(l, E) {
              let y = /* @__PURE__ */ new Map();
              return N(l);
              function N(b) {
                if (y.has(b))
                  return y.get(b);
                let L = x(b);
                return y.set(b, L), L;
              }
              function x(b) {
                if (Array.isArray(b))
                  return E(b.map(N));
                if (b.type === "concat" || b.type === "fill") {
                  let L = b.parts.map(N);
                  return E(Object.assign(Object.assign({}, b), {}, { parts: L }));
                }
                if (b.type === "if-break") {
                  let L = b.breakContents && N(b.breakContents), M = b.flatContents && N(b.flatContents);
                  return E(Object.assign(Object.assign({}, b), {}, { breakContents: L, flatContents: M }));
                }
                if (b.type === "group" && b.expandedStates) {
                  let L = b.expandedStates.map(N), M = L[0];
                  return E(Object.assign(Object.assign({}, b), {}, { contents: M, expandedStates: L }));
                }
                if (b.contents) {
                  let L = N(b.contents);
                  return E(Object.assign(Object.assign({}, b), {}, { contents: L }));
                }
                return E(b);
              }
            }
            function v(l, E, y) {
              let N = y, x = false;
              function b(L) {
                let M = E(L);
                if (M !== void 0 && (x = true, N = M), x)
                  return false;
              }
              return o(l, b), N;
            }
            function m(l) {
              if (l.type === "group" && l.break || l.type === "line" && l.hard || l.type === "break-parent")
                return true;
            }
            function d(l) {
              return v(l, m, false);
            }
            function p(l) {
              if (l.length > 0) {
                let E = t(l);
                !E.expandedStates && !E.break && (E.break = "propagated");
              }
              return null;
            }
            function f(l) {
              let E = /* @__PURE__ */ new Set(), y = [];
              function N(b) {
                if (b.type === "break-parent" && p(y), b.type === "group") {
                  if (y.push(b), E.has(b))
                    return false;
                  E.add(b);
                }
              }
              function x(b) {
                b.type === "group" && y.pop().break && p(y);
              }
              o(l, N, x, true);
            }
            function h(l) {
              return l.type === "line" && !l.hard ? l.soft ? "" : " " : l.type === "if-break" ? l.flatContents || "" : l;
            }
            function w(l) {
              return c(l, h);
            }
            var T = (l, E) => l && l.type === "line" && l.hard && E && E.type === "break-parent";
            function A(l) {
              if (!l)
                return l;
              if (r(l) || l.type === "fill") {
                let E = u(l);
                for (; E.length > 1 && T(...E.slice(-2)); )
                  E.length -= 2;
                if (E.length > 0) {
                  let y = A(t(E));
                  E[E.length - 1] = y;
                }
                return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
              }
              switch (l.type) {
                case "align":
                case "indent":
                case "indent-if-break":
                case "group":
                case "line-suffix":
                case "label": {
                  let E = A(l.contents);
                  return Object.assign(Object.assign({}, l), {}, { contents: E });
                }
                case "if-break": {
                  let E = A(l.breakContents), y = A(l.flatContents);
                  return Object.assign(Object.assign({}, l), {}, { breakContents: E, flatContents: y });
                }
              }
              return l;
            }
            function S(l) {
              return A(I(l));
            }
            function B(l) {
              switch (l.type) {
                case "fill":
                  if (l.parts.every((y) => y === ""))
                    return "";
                  break;
                case "group":
                  if (!l.contents && !l.id && !l.break && !l.expandedStates)
                    return "";
                  if (l.contents.type === "group" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates)
                    return l.contents;
                  break;
                case "align":
                case "indent":
                case "indent-if-break":
                case "line-suffix":
                  if (!l.contents)
                    return "";
                  break;
                case "if-break":
                  if (!l.flatContents && !l.breakContents)
                    return "";
                  break;
              }
              if (!r(l))
                return l;
              let E = [];
              for (let y of u(l)) {
                if (!y)
                  continue;
                let [N, ...x] = r(y) ? u(y) : [y];
                typeof N == "string" && typeof t(E) == "string" ? E[E.length - 1] += N : E.push(N), E.push(...x);
              }
              return E.length === 0 ? "" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
            }
            function I(l) {
              return c(l, (E) => B(E));
            }
            function k(l) {
              let E = [], y = l.filter(Boolean);
              for (; y.length > 0; ) {
                let N = y.shift();
                if (!!N) {
                  if (r(N)) {
                    y.unshift(...u(N));
                    continue;
                  }
                  if (E.length > 0 && typeof t(E) == "string" && typeof N == "string") {
                    E[E.length - 1] += N;
                    continue;
                  }
                  E.push(N);
                }
              }
              return E;
            }
            function P(l) {
              return c(l, (E) => Array.isArray(E) ? k(E) : E.parts ? Object.assign(Object.assign({}, E), {}, { parts: k(E.parts) }) : E);
            }
            function C(l) {
              return c(l, (E) => typeof E == "string" && E.includes(`
`) ? D(E) : E);
            }
            function D(l) {
              let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
              return a(E, l.split(`
`)).parts;
            }
            function g(l) {
              if (l.type === "line")
                return true;
            }
            function F(l) {
              return v(l, g, false);
            }
            n.exports = { isConcat: r, getDocParts: u, willBreak: d, traverseDoc: o, findInDoc: v, mapDoc: c, propagateBreaks: f, removeLines: w, stripTrailingHardline: S, normalizeParts: k, normalizeDoc: P, cleanDoc: I, replaceTextEndOfLine: D, replaceEndOfLine: C, canBreak: F };
          } }), yD = Z({ "src/document/doc-printer.js"(e, n) {
            "use strict";
            re();
            var { convertEndOfLineToChars: t } = jn(), s = it(), a = Ca(), { fill: r, cursor: u, indent: i } = Ln(), { isConcat: o, getDocParts: c } = On(), v, m = 1, d = 2;
            function p() {
              return { value: "", length: 0, queue: [] };
            }
            function f(B, I) {
              return w(B, { type: "indent" }, I);
            }
            function h(B, I, k) {
              return I === Number.NEGATIVE_INFINITY ? B.root || p() : I < 0 ? w(B, { type: "dedent" }, k) : I ? I.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w(B, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, k) : B;
            }
            function w(B, I, k) {
              let P = I.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I], C = "", D = 0, g = 0, F = 0;
              for (let L of P)
                switch (L.type) {
                  case "indent":
                    y(), k.useTabs ? l(1) : E(k.tabWidth);
                    break;
                  case "stringAlign":
                    y(), C += L.n, D += L.n.length;
                    break;
                  case "numberAlign":
                    g += 1, F += L.n;
                    break;
                  default:
                    throw new Error("Unexpected type '".concat(L.type, "'"));
                }
              return x(), Object.assign(Object.assign({}, B), {}, { value: C, length: D, queue: P });
              function l(L) {
                C += "	".repeat(L), D += k.tabWidth * L;
              }
              function E(L) {
                C += " ".repeat(L), D += L;
              }
              function y() {
                k.useTabs ? N() : x();
              }
              function N() {
                g > 0 && l(g), b();
              }
              function x() {
                F > 0 && E(F), b();
              }
              function b() {
                g = 0, F = 0;
              }
            }
            function T(B) {
              if (B.length === 0)
                return 0;
              let I = 0;
              for (; B.length > 0 && typeof s(B) == "string" && /^[\t ]*$/.test(s(B)); )
                I += B.pop().length;
              if (B.length > 0 && typeof s(B) == "string") {
                let k = s(B).replace(/[\t ]*$/, "");
                I += s(B).length - k.length, B[B.length - 1] = k;
              }
              return I;
            }
            function A(B, I, k, P, C, D) {
              let g = I.length, F = [B], l = [];
              for (; k >= 0; ) {
                if (F.length === 0) {
                  if (g === 0)
                    return true;
                  F.push(I[g - 1]), g--;
                  continue;
                }
                let [E, y, N] = F.pop();
                if (typeof N == "string")
                  l.push(N), k -= a(N);
                else if (o(N)) {
                  let x = c(N);
                  for (let b = x.length - 1; b >= 0; b--)
                    F.push([E, y, x[b]]);
                } else
                  switch (N.type) {
                    case "indent":
                      F.push([f(E, P), y, N.contents]);
                      break;
                    case "align":
                      F.push([h(E, N.n, P), y, N.contents]);
                      break;
                    case "trim":
                      k += T(l);
                      break;
                    case "group": {
                      if (D && N.break)
                        return false;
                      let x = N.break ? m : y;
                      F.push([E, x, N.expandedStates && x === m ? s(N.expandedStates) : N.contents]), N.id && (v[N.id] = x);
                      break;
                    }
                    case "fill":
                      for (let x = N.parts.length - 1; x >= 0; x--)
                        F.push([E, y, N.parts[x]]);
                      break;
                    case "if-break":
                    case "indent-if-break": {
                      let x = N.groupId ? v[N.groupId] : y;
                      if (x === m) {
                        let b = N.type === "if-break" ? N.breakContents : N.negate ? N.contents : i(N.contents);
                        b && F.push([E, y, b]);
                      }
                      if (x === d) {
                        let b = N.type === "if-break" ? N.flatContents : N.negate ? i(N.contents) : N.contents;
                        b && F.push([E, y, b]);
                      }
                      break;
                    }
                    case "line":
                      switch (y) {
                        case d:
                          if (!N.hard) {
                            N.soft || (l.push(" "), k -= 1);
                            break;
                          }
                          return true;
                        case m:
                          return true;
                      }
                      break;
                    case "line-suffix":
                      C = true;
                      break;
                    case "line-suffix-boundary":
                      if (C)
                        return false;
                      break;
                    case "label":
                      F.push([E, y, N.contents]);
                      break;
                  }
              }
              return false;
            }
            function S(B, I) {
              v = {};
              let k = I.printWidth, P = t(I.endOfLine), C = 0, D = [[p(), m, B]], g = [], F = false, l = [];
              for (; D.length > 0; ) {
                let [y, N, x] = D.pop();
                if (typeof x == "string") {
                  let b = P !== `
` ? x.replace(/\n/g, P) : x;
                  g.push(b), C += a(b);
                } else if (o(x)) {
                  let b = c(x);
                  for (let L = b.length - 1; L >= 0; L--)
                    D.push([y, N, b[L]]);
                } else
                  switch (x.type) {
                    case "cursor":
                      g.push(u.placeholder);
                      break;
                    case "indent":
                      D.push([f(y, I), N, x.contents]);
                      break;
                    case "align":
                      D.push([h(y, x.n, I), N, x.contents]);
                      break;
                    case "trim":
                      C -= T(g);
                      break;
                    case "group":
                      switch (N) {
                        case d:
                          if (!F) {
                            D.push([y, x.break ? m : d, x.contents]);
                            break;
                          }
                        case m: {
                          F = false;
                          let b = [y, d, x.contents], L = k - C, M = l.length > 0;
                          if (!x.break && A(b, D, L, I, M))
                            D.push(b);
                          else if (x.expandedStates) {
                            let j = s(x.expandedStates);
                            if (x.break) {
                              D.push([y, m, j]);
                              break;
                            } else
                              for (let $ = 1; $ < x.expandedStates.length + 1; $++)
                                if ($ >= x.expandedStates.length) {
                                  D.push([y, m, j]);
                                  break;
                                } else {
                                  let V = x.expandedStates[$], q = [y, d, V];
                                  if (A(q, D, L, I, M)) {
                                    D.push(q);
                                    break;
                                  }
                                }
                          } else
                            D.push([y, m, x.contents]);
                          break;
                        }
                      }
                      x.id && (v[x.id] = s(D)[1]);
                      break;
                    case "fill": {
                      let b = k - C, { parts: L } = x;
                      if (L.length === 0)
                        break;
                      let [M, j] = L, $ = [y, d, M], V = [y, m, M], q = A($, [], b, I, l.length > 0, true);
                      if (L.length === 1) {
                        q ? D.push($) : D.push(V);
                        break;
                      }
                      let Y = [y, d, j], H = [y, m, j];
                      if (L.length === 2) {
                        q ? D.push(Y, $) : D.push(H, V);
                        break;
                      }
                      L.splice(0, 2);
                      let R = [y, N, r(L)], Q = L[0];
                      A([y, d, [M, j, Q]], [], b, I, l.length > 0, true) ? D.push(R, Y, $) : q ? D.push(R, H, $) : D.push(R, H, V);
                      break;
                    }
                    case "if-break":
                    case "indent-if-break": {
                      let b = x.groupId ? v[x.groupId] : N;
                      if (b === m) {
                        let L = x.type === "if-break" ? x.breakContents : x.negate ? x.contents : i(x.contents);
                        L && D.push([y, N, L]);
                      }
                      if (b === d) {
                        let L = x.type === "if-break" ? x.flatContents : x.negate ? i(x.contents) : x.contents;
                        L && D.push([y, N, L]);
                      }
                      break;
                    }
                    case "line-suffix":
                      l.push([y, N, x.contents]);
                      break;
                    case "line-suffix-boundary":
                      l.length > 0 && D.push([y, N, { type: "line", hard: true }]);
                      break;
                    case "line":
                      switch (N) {
                        case d:
                          if (x.hard)
                            F = true;
                          else {
                            x.soft || (g.push(" "), C += 1);
                            break;
                          }
                        case m:
                          if (l.length > 0) {
                            D.push([y, N, x], ...l.reverse()), l = [];
                            break;
                          }
                          x.literal ? y.root ? (g.push(P, y.root.value), C = y.root.length) : (g.push(P), C = 0) : (C -= T(g), g.push(P + y.value), C = y.length);
                          break;
                      }
                      break;
                    case "label":
                      D.push([y, N, x.contents]);
                      break;
                    default:
                  }
                D.length === 0 && l.length > 0 && (D.push(...l.reverse()), l = []);
              }
              let E = g.indexOf(u.placeholder);
              if (E !== -1) {
                let y = g.indexOf(u.placeholder, E + 1), N = g.slice(0, E).join(""), x = g.slice(E + 1, y).join(""), b = g.slice(y + 1).join("");
                return { formatted: N + x + b, cursorNodeStart: N.length, cursorNodeText: x };
              }
              return { formatted: g.join("") };
            }
            n.exports = { printDocToString: S };
          } }), hD = Z({ "src/document/doc-debug.js"(e, n) {
            "use strict";
            re();
            var { isConcat: t, getDocParts: s } = On();
            function a(u) {
              if (!u)
                return "";
              if (t(u)) {
                let i = [];
                for (let o of s(u))
                  if (t(o))
                    i.push(...a(o).parts);
                  else {
                    let c = a(o);
                    c !== "" && i.push(c);
                  }
                return { type: "concat", parts: i };
              }
              return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
            }
            function r(u) {
              let i = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Set();
              return c(a(u));
              function c(m, d, p) {
                if (typeof m == "string")
                  return JSON.stringify(m);
                if (t(m)) {
                  let f = s(m).map(c).filter(Boolean);
                  return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
                }
                if (m.type === "line") {
                  let f = Array.isArray(p) && p[d + 1] && p[d + 1].type === "break-parent";
                  return m.literal ? f ? "literalline" : "literallineWithoutBreakParent" : m.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : m.soft ? "softline" : "line";
                }
                if (m.type === "break-parent")
                  return Array.isArray(p) && p[d - 1] && p[d - 1].type === "line" && p[d - 1].hard ? void 0 : "breakParent";
                if (m.type === "trim")
                  return "trim";
                if (m.type === "indent")
                  return "indent(" + c(m.contents) + ")";
                if (m.type === "align")
                  return m.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(m.contents) + ")" : m.n < 0 ? "dedent(" + c(m.contents) + ")" : m.n.type === "root" ? "markAsRoot(" + c(m.contents) + ")" : "align(" + JSON.stringify(m.n) + ", " + c(m.contents) + ")";
                if (m.type === "if-break")
                  return "ifBreak(" + c(m.breakContents) + (m.flatContents ? ", " + c(m.flatContents) : "") + (m.groupId ? (m.flatContents ? "" : ', ""') + ", { groupId: ".concat(v(m.groupId), " }") : "") + ")";
                if (m.type === "indent-if-break") {
                  let f = [];
                  m.negate && f.push("negate: true"), m.groupId && f.push("groupId: ".concat(v(m.groupId)));
                  let h = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                  return "indentIfBreak(".concat(c(m.contents)).concat(h, ")");
                }
                if (m.type === "group") {
                  let f = [];
                  m.break && m.break !== "propagated" && f.push("shouldBreak: true"), m.id && f.push("id: ".concat(v(m.id)));
                  let h = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                  return m.expandedStates ? "conditionalGroup([".concat(m.expandedStates.map((w) => c(w)).join(","), "]").concat(h, ")") : "group(".concat(c(m.contents)).concat(h, ")");
                }
                if (m.type === "fill")
                  return "fill([".concat(m.parts.map((f) => c(f)).join(", "), "])");
                if (m.type === "line-suffix")
                  return "lineSuffix(" + c(m.contents) + ")";
                if (m.type === "line-suffix-boundary")
                  return "lineSuffixBoundary";
                if (m.type === "label")
                  return "label(".concat(JSON.stringify(m.label), ", ").concat(c(m.contents), ")");
                throw new Error("Unknown doc type " + m.type);
              }
              function v(m) {
                if (typeof m != "symbol")
                  return JSON.stringify(String(m));
                if (m in i)
                  return i[m];
                let d = String(m).slice(7, -1) || "symbol";
                for (let p = 0; ; p++) {
                  let f = d + (p > 0 ? " #".concat(p) : "");
                  if (!o.has(f))
                    return o.add(f), i[m] = "Symbol.for(".concat(JSON.stringify(f), ")");
                }
              }
            }
            n.exports = { printDocToDebug: r };
          } }), Oe = Z({ "src/document/index.js"(e, n) {
            "use strict";
            re(), n.exports = { builders: Ln(), printer: yD(), utils: On(), debug: hD() };
          } }), Ea = {};
          Ut(Ea, { default: () => vD });
          function vD(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          }
          var CD = mt({ "node_modules/escape-string-regexp/index.js"() {
            re();
          } }), Fa = Z({ "node_modules/semver/internal/debug.js"(e, n) {
            re();
            var t = typeof Tt == "object" && Tt.env && Tt.env.NODE_DEBUG && /\bsemver\b/i.test(Tt.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++)
                a[r] = arguments[r];
              return console.error("SEMVER", ...a);
            } : () => {
            };
            n.exports = t;
          } }), Aa = Z({ "node_modules/semver/internal/constants.js"(e, n) {
            re();
            var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
            n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: r };
          } }), ED = Z({ "node_modules/semver/internal/re.js"(e, n) {
            re();
            var { MAX_SAFE_COMPONENT_LENGTH: t } = Aa(), s = Fa();
            e = n.exports = {};
            var a = e.re = [], r = e.src = [], u = e.t = {}, i = 0, o = (c, v, m) => {
              let d = i++;
              s(c, d, v), u[c] = d, r[d] = v, a[d] = new RegExp(v, m ? "g" : void 0);
            };
            o("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), o("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), o("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), o("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), o("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), o("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), o("FULL", "^".concat(r[u.FULLPLAIN], "$")), o("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), o("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), o("GTLT", "((?:<|>)?=?)"), o("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), o("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), o("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), o("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), o("COERCERTL", r[u.COERCE], true), o("LONETILDE", "(?:~>?)"), o("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", o("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), o("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("LONECARET", "(?:\\^)"), o("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", o("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), o("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), o("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), o("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", o("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), o("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), o("STAR", "(<|>)?=?\\s*\\*"), o("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), o("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
          } }), FD = Z({ "node_modules/semver/internal/parse-options.js"(e, n) {
            re();
            var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((r) => a[r]).reduce((r, u) => (r[u] = true, r), {}) : {};
            n.exports = s;
          } }), AD = Z({ "node_modules/semver/internal/identifiers.js"(e, n) {
            re();
            var t = /^[0-9]+$/, s = (r, u) => {
              let i = t.test(r), o = t.test(u);
              return i && o && (r = +r, u = +u), r === u ? 0 : i && !o ? -1 : o && !i ? 1 : r < u ? -1 : 1;
            }, a = (r, u) => s(u, r);
            n.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
          } }), SD = Z({ "node_modules/semver/classes/semver.js"(e, n) {
            re();
            var t = Fa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Aa(), { re: r, t: u } = ED(), i = FD(), { compareIdentifiers: o } = AD(), c = class {
              constructor(v, m) {
                if (m = i(m), v instanceof c) {
                  if (v.loose === !!m.loose && v.includePrerelease === !!m.includePrerelease)
                    return v;
                  v = v.version;
                } else if (typeof v != "string")
                  throw new TypeError("Invalid Version: ".concat(v));
                if (v.length > s)
                  throw new TypeError("version is longer than ".concat(s, " characters"));
                t("SemVer", v, m), this.options = m, this.loose = !!m.loose, this.includePrerelease = !!m.includePrerelease;
                let d = v.trim().match(m.loose ? r[u.LOOSE] : r[u.FULL]);
                if (!d)
                  throw new TypeError("Invalid Version: ".concat(v));
                if (this.raw = v, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > a || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > a || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > a || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                d[4] ? this.prerelease = d[4].split(".").map((p) => {
                  if (/^[0-9]+$/.test(p)) {
                    let f = +p;
                    if (f >= 0 && f < a)
                      return f;
                  }
                  return p;
                }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
              }
              format() {
                return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
              }
              toString() {
                return this.version;
              }
              compare(v) {
                if (t("SemVer.compare", this.version, this.options, v), !(v instanceof c)) {
                  if (typeof v == "string" && v === this.version)
                    return 0;
                  v = new c(v, this.options);
                }
                return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);
              }
              compareMain(v) {
                return v instanceof c || (v = new c(v, this.options)), o(this.major, v.major) || o(this.minor, v.minor) || o(this.patch, v.patch);
              }
              comparePre(v) {
                if (v instanceof c || (v = new c(v, this.options)), this.prerelease.length && !v.prerelease.length)
                  return -1;
                if (!this.prerelease.length && v.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !v.prerelease.length)
                  return 0;
                let m = 0;
                do {
                  let d = this.prerelease[m], p = v.prerelease[m];
                  if (t("prerelease compare", m, d, p), d === void 0 && p === void 0)
                    return 0;
                  if (p === void 0)
                    return 1;
                  if (d === void 0)
                    return -1;
                  if (d === p)
                    continue;
                  return o(d, p);
                } while (++m);
              }
              compareBuild(v) {
                v instanceof c || (v = new c(v, this.options));
                let m = 0;
                do {
                  let d = this.build[m], p = v.build[m];
                  if (t("prerelease compare", m, d, p), d === void 0 && p === void 0)
                    return 0;
                  if (p === void 0)
                    return 1;
                  if (d === void 0)
                    return -1;
                  if (d === p)
                    continue;
                  return o(d, p);
                } while (++m);
              }
              inc(v, m) {
                switch (v) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", m), this.inc("pre", m);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", m), this.inc("pre", m);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let d = this.prerelease.length;
                      for (; --d >= 0; )
                        typeof this.prerelease[d] == "number" && (this.prerelease[d]++, d = -2);
                      d === -1 && this.prerelease.push(0);
                    }
                    m && (o(this.prerelease[0], m) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m, 0]) : this.prerelease = [m, 0]);
                    break;
                  default:
                    throw new Error("invalid increment argument: ".concat(v));
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            n.exports = c;
          } }), qn = Z({ "node_modules/semver/functions/compare.js"(e, n) {
            re();
            var t = SD(), s = (a, r, u) => new t(a, u).compare(new t(r, u));
            n.exports = s;
          } }), xD = Z({ "node_modules/semver/functions/lt.js"(e, n) {
            re();
            var t = qn(), s = (a, r, u) => t(a, r, u) < 0;
            n.exports = s;
          } }), bD = Z({ "node_modules/semver/functions/gte.js"(e, n) {
            re();
            var t = qn(), s = (a, r, u) => t(a, r, u) >= 0;
            n.exports = s;
          } }), TD = Z({ "src/utils/arrayify.js"(e, n) {
            "use strict";
            re(), n.exports = (t, s) => Object.entries(t).map((a) => {
              let [r, u] = a;
              return Object.assign({ [s]: r }, u);
            });
          } }), BD = Z({ "node_modules/outdent/lib/index.js"(e, n) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function t() {
              for (var A = [], S = 0; S < arguments.length; S++)
                A[S] = arguments[S];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
            }
            function a() {
              return { add: t, delete: t, get: t, set: t, has: function(A) {
                return false;
              } };
            }
            var r = Object.prototype.hasOwnProperty, u = function(A, S) {
              return r.call(A, S);
            };
            function i(A, S) {
              for (var B in S)
                u(S, B) && (A[B] = S[B]);
              return A;
            }
            var o = /^[ \t]*(?:\r\n|\r|\n)/, c = /(?:\r\n|\r|\n)[ \t]*$/, v = /^(?:[\r\n]|$)/, m = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, d = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function p(A, S, B) {
              var I = 0, k = A[0].match(m);
              k && (I = k[1].length);
              var P = "(\\r\\n|\\r|\\n).{0," + I + "}", C = new RegExp(P, "g");
              S && (A = A.slice(1));
              var D = B.newline, g = B.trimLeadingNewline, F = B.trimTrailingNewline, l = typeof D == "string", E = A.length, y = A.map(function(N, x) {
                return N = N.replace(C, "$1"), x === 0 && g && (N = N.replace(o, "")), x === E - 1 && F && (N = N.replace(c, "")), l && (N = N.replace(/\r\n|\n|\r/g, function(b) {
                  return D;
                })), N;
              });
              return y;
            }
            function f(A, S) {
              for (var B = "", I = 0, k = A.length; I < k; I++)
                B += A[I], I < k - 1 && (B += S[I]);
              return B;
            }
            function h(A) {
              return u(A, "raw") && u(A, "length");
            }
            function w(A) {
              var S = s(), B = s();
              function I(P) {
                for (var C = [], D = 1; D < arguments.length; D++)
                  C[D - 1] = arguments[D];
                if (h(P)) {
                  var g = P, F = (C[0] === I || C[0] === T) && d.test(g[0]) && v.test(g[1]), l = F ? B : S, E = l.get(g);
                  if (E || (E = p(g, F, A), l.set(g, E)), C.length === 0)
                    return E[0];
                  var y = f(E, F ? C.slice(1) : C);
                  return y;
                } else
                  return w(i(i({}, A), P || {}));
              }
              var k = i(I, { string: function(P) {
                return p([P], false, A)[0];
              } });
              return k;
            }
            var T = w({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = T, e.default = T, typeof n < "u")
              try {
                n.exports = T, Object.defineProperty(T, "__esModule", { value: true }), T.default = T, T.outdent = T;
              } catch {
              }
          } }), ND = Z({ "src/main/core-options.js"(e, n) {
            "use strict";
            re();
            var { outdent: t } = BD(), s = "Config", a = "Editor", r = "Format", u = "Other", i = "Output", o = "Global", c = "Special", v = { cursorOffset: { since: "1.4.0", category: c, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(sa || (sa = Pt([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: a }, endOfLine: { since: "1.15.0", category: o, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(ia || (ia = Pt([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: c, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: o, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (m) => typeof m == "string" || typeof m == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: o, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (m) => typeof m == "string" || typeof m == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: o, description: t(aa || (aa = Pt([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (m) => typeof m == "string" || typeof m == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: o, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(oa || (oa = Pt([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a }, rangeStart: { since: "1.4.0", category: c, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(la || (la = Pt([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a }, requirePragma: { since: "1.7.0", category: c, type: "boolean", default: false, description: t(ca || (ca = Pt([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: u }, tabWidth: { type: "int", category: o, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: o, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: o, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            n.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: o, CATEGORY_SPECIAL: c, options: v };
          } }), Mn = Z({ "src/main/support.js"(e, n) {
            "use strict";
            re();
            var t = { compare: qn(), lt: xD(), gte: bD() }, s = TD(), a = ya().version, r = ND().options;
            function u() {
              let { plugins: o = [], showUnreleased: c = false, showDeprecated: v = false, showInternal: m = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d = a.split("-", 1)[0], p = o.flatMap((A) => A.languages || []).filter(h), f = s(Object.assign({}, ...o.map((A) => {
                let { options: S } = A;
                return S;
              }), r), "name").filter((A) => h(A) && w(A)).sort((A, S) => A.name === S.name ? 0 : A.name < S.name ? -1 : 1).map(T).map((A) => {
                A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h).sort((B, I) => t.compare(I.since, B.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter((B) => h(B) && w(B)), A.name === "parser" && i(A, p, o));
                let S = Object.fromEntries(o.filter((B) => B.defaultOptions && B.defaultOptions[A.name] !== void 0).map((B) => [B.name, B.defaultOptions[A.name]]));
                return Object.assign(Object.assign({}, A), {}, { pluginDefaults: S });
              });
              return { languages: p, options: f };
              function h(A) {
                return c || !("since" in A) || A.since && t.gte(d, A.since);
              }
              function w(A) {
                return v || !("deprecated" in A) || A.deprecated && t.lt(d, A.deprecated);
              }
              function T(A) {
                if (m)
                  return A;
                let { cliName: S, cliCategory: B, cliDescription: I } = A;
                return kn(A, Yf);
              }
            }
            function i(o, c, v) {
              let m = new Set(o.choices.map((d) => d.value));
              for (let d of c)
                if (d.parsers) {
                  for (let p of d.parsers)
                    if (!m.has(p)) {
                      m.add(p);
                      let f = v.find((w) => w.parsers && w.parsers[p]), h = d.name;
                      f && f.name && (h += " (plugin: ".concat(f.name, ")")), o.choices.push({ value: p, description: h });
                    }
                }
            }
            n.exports = { getSupportInfo: u };
          } }), Rn = Z({ "src/utils/is-non-empty-array.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              return Array.isArray(s) && s.length > 0;
            }
            n.exports = t;
          } }), Nr = Z({ "src/utils/text/skip.js"(e, n) {
            "use strict";
            re();
            function t(i) {
              return (o, c, v) => {
                let m = v && v.backwards;
                if (c === false)
                  return false;
                let { length: d } = o, p = c;
                for (; p >= 0 && p < d; ) {
                  let f = o.charAt(p);
                  if (i instanceof RegExp) {
                    if (!i.test(f))
                      return p;
                  } else if (!i.includes(f))
                    return p;
                  m ? p-- : p++;
                }
                return p === -1 || p === d ? p : false;
              };
            }
            var s = t(/\s/), a = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
            n.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: r, skipEverythingButNewLine: u };
          } }), Sa = Z({ "src/utils/text/skip-inline-comment.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              if (a === false)
                return false;
              if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
                for (let r = a + 2; r < s.length; ++r)
                  if (s.charAt(r) === "*" && s.charAt(r + 1) === "/")
                    return r + 2;
              }
              return a;
            }
            n.exports = t;
          } }), xa = Z({ "src/utils/text/skip-trailing-comment.js"(e, n) {
            "use strict";
            re();
            var { skipEverythingButNewLine: t } = Nr();
            function s(a, r) {
              return r === false ? false : a.charAt(r) === "/" && a.charAt(r + 1) === "/" ? t(a, r) : r;
            }
            n.exports = s;
          } }), ba = Z({ "src/utils/text/skip-newline.js"(e, n) {
            "use strict";
            re();
            function t(s, a, r) {
              let u = r && r.backwards;
              if (a === false)
                return false;
              let i = s.charAt(a);
              if (u) {
                if (s.charAt(a - 1) === "\r" && i === `
`)
                  return a - 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a - 1;
              } else {
                if (i === "\r" && s.charAt(a + 1) === `
`)
                  return a + 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a + 1;
              }
              return a;
            }
            n.exports = t;
          } }), wD = Z({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
            "use strict";
            re();
            var t = Sa(), s = ba(), a = xa(), { skipSpaces: r } = Nr();
            function u(i, o) {
              let c = null, v = o;
              for (; v !== c; )
                c = v, v = r(i, v), v = t(i, v), v = a(i, v), v = s(i, v);
              return v;
            }
            n.exports = u;
          } }), Ue = Z({ "src/common/util.js"(e, n) {
            "use strict";
            re();
            var { default: t } = (CD(), lt(Ea)), s = it(), { getSupportInfo: a } = Mn(), r = Rn(), u = Ca(), { skipWhitespace: i, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: v } = Nr(), m = Sa(), d = xa(), p = ba(), f = wD(), h = (H) => H[H.length - 2];
            function w(H) {
              return (R, Q, ee) => {
                let te = ee && ee.backwards;
                if (Q === false)
                  return false;
                let { length: oe } = R, W = Q;
                for (; W >= 0 && W < oe; ) {
                  let X = R.charAt(W);
                  if (H instanceof RegExp) {
                    if (!H.test(X))
                      return W;
                  } else if (!H.includes(X))
                    return W;
                  te ? W-- : W++;
                }
                return W === -1 || W === oe ? W : false;
              };
            }
            function T(H, R) {
              let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ee = o(H, Q.backwards ? R - 1 : R, Q), te = p(H, ee, Q);
              return ee !== te;
            }
            function A(H, R, Q) {
              for (let ee = R; ee < Q; ++ee)
                if (H.charAt(ee) === `
`)
                  return true;
              return false;
            }
            function S(H, R, Q) {
              let ee = Q(R) - 1;
              ee = o(H, ee, { backwards: true }), ee = p(H, ee, { backwards: true }), ee = o(H, ee, { backwards: true });
              let te = p(H, ee, { backwards: true });
              return ee !== te;
            }
            function B(H, R) {
              let Q = null, ee = R;
              for (; ee !== Q; )
                Q = ee, ee = c(H, ee), ee = m(H, ee), ee = o(H, ee);
              return ee = d(H, ee), ee = p(H, ee), ee !== false && T(H, ee);
            }
            function I(H, R, Q) {
              return B(H, Q(R));
            }
            function k(H, R, Q) {
              return f(H, Q(R));
            }
            function P(H, R, Q) {
              return H.charAt(k(H, R, Q));
            }
            function C(H, R) {
              let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return o(H, Q.backwards ? R - 1 : R, Q) !== R;
            }
            function D(H, R) {
              let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ee = 0;
              for (let te = Q; te < H.length; ++te)
                H[te] === "	" ? ee = ee + R - ee % R : ee++;
              return ee;
            }
            function g(H, R) {
              let Q = H.lastIndexOf(`
`);
              return Q === -1 ? 0 : D(H.slice(Q + 1).match(/^[\t ]*/)[0], R);
            }
            function F(H, R) {
              let Q = { quote: '"', regex: /"/g, escaped: "&quot;" }, ee = { quote: "'", regex: /'/g, escaped: "&apos;" }, te = R === "'" ? ee : Q, oe = te === ee ? Q : ee, W = te;
              if (H.includes(te.quote) || H.includes(oe.quote)) {
                let X = (H.match(te.regex) || []).length, ue = (H.match(oe.regex) || []).length;
                W = X > ue ? oe : te;
              }
              return W;
            }
            function l(H, R) {
              let Q = H.slice(1, -1), ee = R.parser === "json" || R.parser === "json5" && R.quoteProps === "preserve" && !R.singleQuote ? '"' : R.__isInHtmlAttribute ? "'" : F(Q, R.singleQuote ? "'" : '"').quote;
              return E(Q, ee, !(R.parser === "css" || R.parser === "less" || R.parser === "scss" || R.__embeddedInHtml));
            }
            function E(H, R, Q) {
              let ee = R === '"' ? "'" : '"', te = /\\(.)|(["'])/gs, oe = H.replace(te, (W, X, ue) => X === ee ? X : ue === R ? "\\" + ue : ue || (Q && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X) ? X : "\\" + X));
              return R + oe + R;
            }
            function y(H) {
              return H.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function N(H, R) {
              let Q = H.match(new RegExp("(".concat(t(R), ")+"), "g"));
              return Q === null ? 0 : Q.reduce((ee, te) => Math.max(ee, te.length / R.length), 0);
            }
            function x(H, R) {
              let Q = H.match(new RegExp("(".concat(t(R), ")+"), "g"));
              if (Q === null)
                return 0;
              let ee = /* @__PURE__ */ new Map(), te = 0;
              for (let oe of Q) {
                let W = oe.length / R.length;
                ee.set(W, true), W > te && (te = W);
              }
              for (let oe = 1; oe < te; oe++)
                if (!ee.get(oe))
                  return oe;
              return te + 1;
            }
            function b(H, R) {
              (H.comments || (H.comments = [])).push(R), R.printed = false, R.nodeDescription = Y(H);
            }
            function L(H, R) {
              R.leading = true, R.trailing = false, b(H, R);
            }
            function M(H, R, Q) {
              R.leading = false, R.trailing = false, Q && (R.marker = Q), b(H, R);
            }
            function j(H, R) {
              R.leading = false, R.trailing = true, b(H, R);
            }
            function $(H, R) {
              let { languages: Q } = a({ plugins: R.plugins }), ee = Q.find((te) => {
                let { name: oe } = te;
                return oe.toLowerCase() === H;
              }) || Q.find((te) => {
                let { aliases: oe } = te;
                return Array.isArray(oe) && oe.includes(H);
              }) || Q.find((te) => {
                let { extensions: oe } = te;
                return Array.isArray(oe) && oe.includes(".".concat(H));
              });
              return ee && ee.parsers[0];
            }
            function V(H) {
              return H && H.type === "front-matter";
            }
            function q(H) {
              let R = /* @__PURE__ */ new WeakMap();
              return function(Q) {
                return R.has(Q) || R.set(Q, Symbol(H)), R.get(Q);
              };
            }
            function Y(H) {
              let R = H.type || H.kind || "(unknown type)", Q = String(H.name || H.id && (typeof H.id == "object" ? H.id.name : H.id) || H.key && (typeof H.key == "object" ? H.key.name : H.key) || H.value && (typeof H.value == "object" ? "" : String(H.value)) || H.operator || "");
              return Q.length > 20 && (Q = Q.slice(0, 19) + "\u2026"), R + (Q ? " " + Q : "");
            }
            n.exports = { inferParserByLanguage: $, getStringWidth: u, getMaxContinuousCount: N, getMinNotPresentContinuousCount: x, getPenultimate: h, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: k, getNextNonSpaceNonCommentCharacter: P, skip: w, skipWhitespace: i, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: v, skipInlineComment: m, skipTrailingComment: d, skipNewline: p, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I, isPreviousLineEmpty: S, hasNewline: T, hasNewlineInRange: A, hasSpaces: C, getAlignmentSize: D, getIndentSize: g, getPreferredQuote: F, printString: l, printNumber: y, makeString: E, addLeadingComment: L, addDanglingComment: M, addTrailingComment: j, isFrontMatterNode: V, isNonEmptyArray: r, createGroupIdMapper: q };
          } }), Ta = {};
          Ut(Ta, { basename: () => Pa, default: () => Ia, delimiter: () => Bn, dirname: () => _a3, extname: () => ka, isAbsolute: () => Wn, join: () => Na, normalize: () => Vn, relative: () => wa, resolve: () => Tr, sep: () => Tn });
          function Ba(e, n) {
            for (var t = 0, s = e.length - 1; s >= 0; s--) {
              var a = e[s];
              a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
            }
            if (n)
              for (; t--; t)
                e.unshift("..");
            return e;
          }
          function Tr() {
            for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
              var s = t >= 0 ? arguments[t] : "/";
              if (typeof s != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!s)
                continue;
              e = s + "/" + e, n = s.charAt(0) === "/";
            }
            return e = Ba($n(e.split("/"), function(a) {
              return !!a;
            }), !n).join("/"), (n ? "/" : "") + e || ".";
          }
          function Vn(e) {
            var n = Wn(e), t = La(e, -1) === "/";
            return e = Ba($n(e.split("/"), function(s) {
              return !!s;
            }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
          }
          function Wn(e) {
            return e.charAt(0) === "/";
          }
          function Na() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Vn($n(e, function(n, t) {
              if (typeof n != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return n;
            }).join("/"));
          }
          function wa(e, n) {
            e = Tr(e).substr(1), n = Tr(n).substr(1);
            function t(c) {
              for (var v = 0; v < c.length && c[v] === ""; v++)
                ;
              for (var m = c.length - 1; m >= 0 && c[m] === ""; m--)
                ;
              return v > m ? [] : c.slice(v, m - v + 1);
            }
            for (var s = t(e.split("/")), a = t(n.split("/")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++)
              if (s[i] !== a[i]) {
                u = i;
                break;
              }
            for (var o = [], i = u; i < s.length; i++)
              o.push("..");
            return o = o.concat(a.slice(u)), o.join("/");
          }
          function _a3(e) {
            var n = wr(e), t = n[0], s = n[1];
            return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
          }
          function Pa(e, n) {
            var t = wr(e)[2];
            return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
          }
          function ka(e) {
            return wr(e)[3];
          }
          function $n(e, n) {
            if (e.filter)
              return e.filter(n);
            for (var t = [], s = 0; s < e.length; s++)
              n(e[s], s, e) && t.push(e[s]);
            return t;
          }
          var Da, wr, Tn, Bn, Ia, La, _D = mt({ "node-modules-polyfills:path"() {
            re(), Da = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, wr = function(e) {
              return Da.exec(e).slice(1);
            }, Tn = "/", Bn = ":", Ia = { extname: ka, basename: Pa, dirname: _a3, sep: Tn, delimiter: Bn, relative: wa, join: Na, isAbsolute: Wn, normalize: Vn, resolve: Tr }, La = "ab".substr(-1) === "b" ? function(e, n, t) {
              return e.substr(n, t);
            } : function(e, n, t) {
              return n < 0 && (n = e.length + n), e.substr(n, t);
            };
          } }), PD = Z({ "node-modules-polyfills-commonjs:path"(e, n) {
            re();
            var t = (_D(), lt(Ta));
            if (t && t.default) {
              n.exports = t.default;
              for (let s in t)
                n.exports[s] = t[s];
            } else
              t && (n.exports = t);
          } }), zt = Z({ "src/common/errors.js"(e, n) {
            "use strict";
            re();
            var t = class extends Error {
            }, s = class extends Error {
            }, a = class extends Error {
            }, r = class extends Error {
            };
            n.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: r };
          } }), dt = {};
          Ut(dt, { __assign: () => br, __asyncDelegator: () => GD, __asyncGenerator: () => HD, __asyncValues: () => JD, __await: () => Jt, __awaiter: () => qD, __classPrivateFieldGet: () => KD, __classPrivateFieldSet: () => YD, __createBinding: () => RD, __decorate: () => LD, __exportStar: () => VD, __extends: () => kD, __generator: () => MD, __importDefault: () => XD, __importStar: () => zD, __makeTemplateObject: () => UD, __metadata: () => OD, __param: () => jD, __read: () => ja, __rest: () => ID, __spread: () => WD, __spreadArrays: () => $D, __values: () => Nn });
          function kD(e, n) {
            xr(e, n);
            function t() {
              this.constructor = e;
            }
            e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
          }
          function ID(e, n) {
            var t = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
                n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
            return t;
          }
          function LD(e, n, t, s) {
            var a = arguments.length, r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              r = Reflect.decorate(e, n, t, s);
            else
              for (var i = e.length - 1; i >= 0; i--)
                (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);
            return a > 3 && r && Object.defineProperty(n, t, r), r;
          }
          function jD(e, n) {
            return function(t, s) {
              n(t, s, e);
            };
          }
          function OD(e, n) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(e, n);
          }
          function qD(e, n, t, s) {
            function a(r) {
              return r instanceof t ? r : new t(function(u) {
                u(r);
              });
            }
            return new (t || (t = Promise))(function(r, u) {
              function i(v) {
                try {
                  c(s.next(v));
                } catch (m) {
                  u(m);
                }
              }
              function o(v) {
                try {
                  c(s.throw(v));
                } catch (m) {
                  u(m);
                }
              }
              function c(v) {
                v.done ? r(v.value) : a(v.value).then(i, o);
              }
              c((s = s.apply(e, n || [])).next());
            });
          }
          function MD(e, n) {
            var t = { label: 0, sent: function() {
              if (r[0] & 1)
                throw r[1];
              return r[1];
            }, trys: [], ops: [] }, s, a, r, u;
            return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
              return this;
            }), u;
            function i(c) {
              return function(v) {
                return o([c, v]);
              };
            }
            function o(c) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; t; )
                try {
                  if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done)
                    return r;
                  switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
                    case 0:
                    case 1:
                      r = c;
                      break;
                    case 4:
                      return t.label++, { value: c[1], done: false };
                    case 5:
                      t.label++, a = c[1], c = [0];
                      continue;
                    case 7:
                      c = t.ops.pop(), t.trys.pop();
                      continue;
                    default:
                      if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                      }
                      if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                        t.label = c[1];
                        break;
                      }
                      if (c[0] === 6 && t.label < r[1]) {
                        t.label = r[1], r = c;
                        break;
                      }
                      if (r && t.label < r[2]) {
                        t.label = r[2], t.ops.push(c);
                        break;
                      }
                      r[2] && t.ops.pop(), t.trys.pop();
                      continue;
                  }
                  c = n.call(e, t);
                } catch (v) {
                  c = [6, v], a = 0;
                } finally {
                  s = r = 0;
                }
              if (c[0] & 5)
                throw c[1];
              return { value: c[0] ? c[1] : void 0, done: true };
            }
          }
          function RD(e, n, t, s) {
            s === void 0 && (s = t), e[s] = n[t];
          }
          function VD(e, n) {
            for (var t in e)
              t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
          }
          function Nn(e) {
            var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s = 0;
            if (t)
              return t.call(e);
            if (e && typeof e.length == "number")
              return { next: function() {
                return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
              } };
            throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function ja(e, n) {
            var t = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t)
              return e;
            var s = t.call(e), a, r = [], u;
            try {
              for (; (n === void 0 || n-- > 0) && !(a = s.next()).done; )
                r.push(a.value);
            } catch (i) {
              u = { error: i };
            } finally {
              try {
                a && !a.done && (t = s.return) && t.call(s);
              } finally {
                if (u)
                  throw u.error;
              }
            }
            return r;
          }
          function WD() {
            for (var e = [], n = 0; n < arguments.length; n++)
              e = e.concat(ja(arguments[n]));
            return e;
          }
          function $D() {
            for (var e = 0, n = 0, t = arguments.length; n < t; n++)
              e += arguments[n].length;
            for (var s = Array(e), a = 0, n = 0; n < t; n++)
              for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++)
                s[a] = r[u];
            return s;
          }
          function Jt(e) {
            return this instanceof Jt ? (this.v = e, this) : new Jt(e);
          }
          function HD(e, n, t) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t.apply(e, n || []), a, r = [];
            return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
              return this;
            }, a;
            function u(d) {
              s[d] && (a[d] = function(p) {
                return new Promise(function(f, h) {
                  r.push([d, p, f, h]) > 1 || i(d, p);
                });
              });
            }
            function i(d, p) {
              try {
                o(s[d](p));
              } catch (f) {
                m(r[0][3], f);
              }
            }
            function o(d) {
              d.value instanceof Jt ? Promise.resolve(d.value.v).then(c, v) : m(r[0][2], d);
            }
            function c(d) {
              i("next", d);
            }
            function v(d) {
              i("throw", d);
            }
            function m(d, p) {
              d(p), r.shift(), r.length && i(r[0][0], r[0][1]);
            }
          }
          function GD(e) {
            var n, t;
            return n = {}, s("next"), s("throw", function(a) {
              throw a;
            }), s("return"), n[Symbol.iterator] = function() {
              return this;
            }, n;
            function s(a, r) {
              n[a] = e[a] ? function(u) {
                return (t = !t) ? { value: Jt(e[a](u)), done: a === "return" } : r ? r(u) : u;
              } : r;
            }
          }
          function JD(e) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var n = e[Symbol.asyncIterator], t;
            return n ? n.call(e) : (e = typeof Nn == "function" ? Nn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
              return this;
            }, t);
            function s(r) {
              t[r] = e[r] && function(u) {
                return new Promise(function(i, o) {
                  u = e[r](u), a(i, o, u.done, u.value);
                });
              };
            }
            function a(r, u, i, o) {
              Promise.resolve(o).then(function(c) {
                r({ value: c, done: i });
              }, u);
            }
          }
          function UD(e, n) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
          }
          function zD(e) {
            if (e && e.__esModule)
              return e;
            var n = {};
            if (e != null)
              for (var t in e)
                Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
            return n.default = e, n;
          }
          function XD(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function KD(e, n) {
            if (!n.has(e))
              throw new TypeError("attempted to get private field on non-instance");
            return n.get(e);
          }
          function YD(e, n, t) {
            if (!n.has(e))
              throw new TypeError("attempted to set private field on non-instance");
            return n.set(e, t), t;
          }
          var xr, br, ht = mt({ "node_modules/tslib/tslib.es6.js"() {
            re(), xr = function(e, n) {
              return xr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
                t.__proto__ = s;
              } || function(t, s) {
                for (var a in s)
                  s.hasOwnProperty(a) && (t[a] = s[a]);
              }, xr(e, n);
            }, br = function() {
              return br = Object.assign || function(n) {
                for (var t, s = 1, a = arguments.length; s < a; s++) {
                  t = arguments[s];
                  for (var r in t)
                    Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }, br.apply(this, arguments);
            };
          } }), Oa = Z({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
              if (n === null || typeof n != "object")
                return JSON.stringify(n);
              if (Array.isArray(n))
                return "[".concat(n.map((s) => e.apiDescriptor.value(s)).join(", "), "]");
              let t = Object.keys(n);
              return t.length === 0 ? "{}" : "{ ".concat(t.map((s) => "".concat(e.apiDescriptor.key(s), ": ").concat(e.apiDescriptor.value(n[s]))).join(", "), " }");
            }, pair: (n) => {
              let { key: t, value: s } = n;
              return e.apiDescriptor.value({ [t]: s });
            } };
          } }), QD = Z({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(Oa(), e);
          } }), _r = Z({ "scripts/build/shims/chalk.cjs"(e, n) {
            "use strict";
            re();
            var t = (s) => s;
            t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
          } }), qa = Z({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = _r();
            e.commonDeprecatedHandler = (t, s, a) => {
              let { descriptor: r } = a, u = ["".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")];
              return s && u.push("we now treat it as ".concat(n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s)))), u.join("; ") + ".";
            };
          } }), ZD = Z({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(qa(), e);
          } }), em = Z({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = _r();
            e.commonInvalidHandler = (t, s, a) => ["Invalid ".concat(n.default.red(a.descriptor.key(t)), " value."), "Expected ".concat(n.default.blue(a.schemas[t].expected(a)), ","), "but received ".concat(n.default.red(a.descriptor.value(s)), ".")].join(" ");
          } }), Ma = Z({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(em(), e);
          } }), tm = Z({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
            "use strict";
            re();
            var t = [], s = [];
            n.exports = function(a, r) {
              if (a === r)
                return 0;
              var u = a;
              a.length > r.length && (a = r, r = u);
              var i = a.length, o = r.length;
              if (i === 0)
                return o;
              if (o === 0)
                return i;
              for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-o); )
                i--, o--;
              if (i === 0)
                return o;
              for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c); )
                c++;
              if (i -= c, o -= c, i === 0)
                return o;
              for (var v, m, d, p, f = 0, h = 0; f < i; )
                s[c + f] = a.charCodeAt(c + f), t[f] = ++f;
              for (; h < o; )
                for (v = r.charCodeAt(c + h), d = h++, m = h, f = 0; f < i; f++)
                  p = v === s[c + f] ? d : d + 1, d = t[f], m = t[f] = d > m ? p > m ? m + 1 : p : p > d ? d + 1 : p;
              return m;
            };
          } }), Ra = Z({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = _r(), t = tm();
            e.levenUnknownHandler = (s, a, r) => {
              let { descriptor: u, logger: i, schemas: o } = r, c = ["Ignored unknown option ".concat(n.default.yellow(u.pair({ key: s, value: a })), ".")], v = Object.keys(o).sort().find((m) => t(s, m) < 3);
              v && c.push("Did you mean ".concat(n.default.blue(u.key(v)), "?")), i.warn(c.join(" "));
            };
          } }), rm = Z({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(Ra(), e);
          } }), nm = Z({ "node_modules/vnopts/lib/handlers/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(ZD(), e), n.__exportStar(Ma(), e), n.__exportStar(rm(), e);
          } }), vt = Z({ "node_modules/vnopts/lib/schema.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
            function t(r, u) {
              let i = new r(u), o = Object.create(i);
              for (let c of n)
                c in u && (o[c] = a(u[c], i, s.prototype[c].length));
              return o;
            }
            e.createSchema = t;
            var s = class {
              constructor(r) {
                this.name = r.name;
              }
              static create(r) {
                return t(this, r);
              }
              default(r) {
              }
              expected(r) {
                return "nothing";
              }
              validate(r, u) {
                return false;
              }
              deprecated(r, u) {
                return false;
              }
              forward(r, u) {
              }
              redirect(r, u) {
              }
              overlap(r, u, i) {
                return r;
              }
              preprocess(r, u) {
                return r;
              }
              postprocess(r, u) {
                return r;
              }
            };
            e.Schema = s;
            function a(r, u, i) {
              return typeof r == "function" ? function() {
                for (var o = arguments.length, c = new Array(o), v = 0; v < o; v++)
                  c[v] = arguments[v];
                return r(...c.slice(0, i - 1), u, ...c.slice(i - 1));
              } : () => r;
            }
          } }), um = Z({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = vt(), t = class extends n.Schema {
              constructor(s) {
                super(s), this._sourceName = s.sourceName;
              }
              expected(s) {
                return s.schemas[this._sourceName].expected(s);
              }
              validate(s, a) {
                return a.schemas[this._sourceName].validate(s, a);
              }
              redirect(s, a) {
                return this._sourceName;
              }
            };
            e.AliasSchema = t;
          } }), sm = Z({ "node_modules/vnopts/lib/schemas/any.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = vt(), t = class extends n.Schema {
              expected() {
                return "anything";
              }
              validate() {
                return true;
              }
            };
            e.AnySchema = t;
          } }), im = Z({ "node_modules/vnopts/lib/schemas/array.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt)), t = vt(), s = class extends t.Schema {
              constructor(r) {
                var { valueSchema: u, name: i = u.name } = r, o = n.__rest(r, ["valueSchema", "name"]);
                super(Object.assign({}, o, { name: i })), this._valueSchema = u;
              }
              expected(r) {
                return "an array of ".concat(this._valueSchema.expected(r));
              }
              validate(r, u) {
                if (!Array.isArray(r))
                  return false;
                let i = [];
                for (let o of r) {
                  let c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
                  c !== true && i.push(c.value);
                }
                return i.length === 0 ? true : { value: i };
              }
              deprecated(r, u) {
                let i = [];
                for (let o of r) {
                  let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
                  c !== false && i.push(...c.map((v) => {
                    let { value: m } = v;
                    return { value: [m] };
                  }));
                }
                return i;
              }
              forward(r, u) {
                let i = [];
                for (let o of r) {
                  let c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
                  i.push(...c.map(a));
                }
                return i;
              }
              redirect(r, u) {
                let i = [], o = [];
                for (let c of r) {
                  let v = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
                  "remain" in v && i.push(v.remain), o.push(...v.redirect.map(a));
                }
                return i.length === 0 ? { redirect: o } : { redirect: o, remain: i };
              }
              overlap(r, u) {
                return r.concat(u);
              }
            };
            e.ArraySchema = s;
            function a(r) {
              let { from: u, to: i } = r;
              return { from: [u], to: i };
            }
          } }), am = Z({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = vt(), t = class extends n.Schema {
              expected() {
                return "true or false";
              }
              validate(s) {
                return typeof s == "boolean";
              }
            };
            e.BooleanSchema = t;
          } }), Hn = Z({ "node_modules/vnopts/lib/utils.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            function n(p, f) {
              let h = /* @__PURE__ */ Object.create(null);
              for (let w of p) {
                let T = w[f];
                if (h[T])
                  throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                h[T] = w;
              }
              return h;
            }
            e.recordFromArray = n;
            function t(p, f) {
              let h = /* @__PURE__ */ new Map();
              for (let w of p) {
                let T = w[f];
                if (h.has(T))
                  throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                h.set(T, w);
              }
              return h;
            }
            e.mapFromArray = t;
            function s() {
              let p = /* @__PURE__ */ Object.create(null);
              return (f) => {
                let h = JSON.stringify(f);
                return p[h] ? true : (p[h] = true, false);
              };
            }
            e.createAutoChecklist = s;
            function a(p, f) {
              let h = [], w = [];
              for (let T of p)
                f(T) ? h.push(T) : w.push(T);
              return [h, w];
            }
            e.partition = a;
            function r(p) {
              return p === Math.floor(p);
            }
            e.isInt = r;
            function u(p, f) {
              if (p === f)
                return 0;
              let h = typeof p, w = typeof f, T = ["undefined", "object", "boolean", "number", "string"];
              return h !== w ? T.indexOf(h) - T.indexOf(w) : h !== "string" ? Number(p) - Number(f) : p.localeCompare(f);
            }
            e.comparePrimitive = u;
            function i(p) {
              return p === void 0 ? {} : p;
            }
            e.normalizeDefaultResult = i;
            function o(p, f) {
              return p === true ? true : p === false ? { value: f } : p;
            }
            e.normalizeValidateResult = o;
            function c(p, f) {
              let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return p === false ? false : p === true ? h ? true : [{ value: f }] : "value" in p ? [p] : p.length === 0 ? false : p;
            }
            e.normalizeDeprecatedResult = c;
            function v(p, f) {
              return typeof p == "string" || "key" in p ? { from: f, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: f, to: p.to };
            }
            e.normalizeTransferResult = v;
            function m(p, f) {
              return p === void 0 ? [] : Array.isArray(p) ? p.map((h) => v(h, f)) : [v(p, f)];
            }
            e.normalizeForwardResult = m;
            function d(p, f) {
              let h = m(typeof p == "object" && "redirect" in p ? p.redirect : p, f);
              return h.length === 0 ? { remain: f, redirect: h } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: h } : { redirect: h };
            }
            e.normalizeRedirectResult = d;
          } }), om = Z({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = vt(), t = Hn(), s = class extends n.Schema {
              constructor(a) {
                super(a), this._choices = t.mapFromArray(a.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
              }
              expected(a) {
                let { descriptor: r } = a, u = Array.from(this._choices.keys()).map((c) => this._choices.get(c)).filter((c) => !c.deprecated).map((c) => c.value).sort(t.comparePrimitive).map(r.value), i = u.slice(0, -2), o = u.slice(-2);
                return i.concat(o.join(" or ")).join(", ");
              }
              validate(a) {
                return this._choices.has(a);
              }
              deprecated(a) {
                let r = this._choices.get(a);
                return r && r.deprecated ? { value: a } : false;
              }
              forward(a) {
                let r = this._choices.get(a);
                return r ? r.forward : void 0;
              }
              redirect(a) {
                let r = this._choices.get(a);
                return r ? r.redirect : void 0;
              }
            };
            e.ChoiceSchema = s;
          } }), Va = Z({ "node_modules/vnopts/lib/schemas/number.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = vt(), t = class extends n.Schema {
              expected() {
                return "a number";
              }
              validate(s, a) {
                return typeof s == "number";
              }
            };
            e.NumberSchema = t;
          } }), lm = Z({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Hn(), t = Va(), s = class extends t.NumberSchema {
              expected() {
                return "an integer";
              }
              validate(a, r) {
                return r.normalizeValidateResult(super.validate(a, r), a) === true && n.isInt(a);
              }
            };
            e.IntegerSchema = s;
          } }), cm = Z({ "node_modules/vnopts/lib/schemas/string.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = vt(), t = class extends n.Schema {
              expected() {
                return "a string";
              }
              validate(s) {
                return typeof s == "string";
              }
            };
            e.StringSchema = t;
          } }), pm = Z({ "node_modules/vnopts/lib/schemas/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(um(), e), n.__exportStar(sm(), e), n.__exportStar(im(), e), n.__exportStar(am(), e), n.__exportStar(om(), e), n.__exportStar(lm(), e), n.__exportStar(Va(), e), n.__exportStar(cm(), e);
          } }), fm = Z({ "node_modules/vnopts/lib/defaults.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Oa(), t = qa(), s = Ma(), a = Ra();
            e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
          } }), Dm = Z({ "node_modules/vnopts/lib/normalize.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = fm(), t = Hn();
            e.normalize = (a, r, u) => new s(r, u).normalize(a);
            var s = class {
              constructor(a, r) {
                let { logger: u = console, descriptor: i = n.defaultDescriptor, unknown: o = n.defaultUnknownHandler, invalid: c = n.defaultInvalidHandler, deprecated: v = n.defaultDeprecatedHandler } = r || {};
                this._utils = { descriptor: i, logger: u || { warn: () => {
                } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = v, this.cleanHistory();
              }
              cleanHistory() {
                this._hasDeprecationWarned = t.createAutoChecklist();
              }
              normalize(a) {
                let r = {}, u = [a], i = () => {
                  for (; u.length !== 0; ) {
                    let o = u.shift(), c = this._applyNormalization(o, r);
                    u.push(...c);
                  }
                };
                i();
                for (let o of Object.keys(this._utils.schemas)) {
                  let c = this._utils.schemas[o];
                  if (!(o in r)) {
                    let v = t.normalizeDefaultResult(c.default(this._utils));
                    "value" in v && u.push({ [o]: v.value });
                  }
                }
                i();
                for (let o of Object.keys(this._utils.schemas)) {
                  let c = this._utils.schemas[o];
                  o in r && (r[o] = c.postprocess(r[o], this._utils));
                }
                return r;
              }
              _applyNormalization(a, r) {
                let u = [], [i, o] = t.partition(Object.keys(a), (c) => c in this._utils.schemas);
                for (let c of i) {
                  let v = this._utils.schemas[c], m = v.preprocess(a[c], this._utils), d = t.normalizeValidateResult(v.validate(m, this._utils), m);
                  if (d !== true) {
                    let { value: T } = d, A = this._invalidHandler(c, T, this._utils);
                    throw typeof A == "string" ? new Error(A) : A;
                  }
                  let p = (T) => {
                    let { from: A, to: S } = T;
                    u.push(typeof S == "string" ? { [S]: A } : { [S.key]: S.value });
                  }, f = (T) => {
                    let { value: A, redirectTo: S } = T, B = t.normalizeDeprecatedResult(v.deprecated(A, this._utils), m, true);
                    if (B !== false)
                      if (B === true)
                        this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, S, this._utils));
                      else
                        for (let { value: I } of B) {
                          let k = { key: c, value: I };
                          if (!this._hasDeprecationWarned(k)) {
                            let P = typeof S == "string" ? { key: S, value: I } : S;
                            this._utils.logger.warn(this._deprecatedHandler(k, P, this._utils));
                          }
                        }
                  };
                  t.normalizeForwardResult(v.forward(m, this._utils), m).forEach(p);
                  let w = t.normalizeRedirectResult(v.redirect(m, this._utils), m);
                  if (w.redirect.forEach(p), "remain" in w) {
                    let T = w.remain;
                    r[c] = c in r ? v.overlap(r[c], T, this._utils) : T, f({ value: T });
                  }
                  for (let { from: T, to: A } of w.redirect)
                    f({ value: T, redirectTo: A });
                }
                for (let c of o) {
                  let v = a[c], m = this._unknownHandler(c, v, this._utils);
                  if (m)
                    for (let d of Object.keys(m)) {
                      let p = { [d]: m[d] };
                      d in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                    }
                }
                return u;
              }
            };
            e.Normalizer = s;
          } }), mm = Z({ "node_modules/vnopts/lib/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (ht(), lt(dt));
            n.__exportStar(QD(), e), n.__exportStar(nm(), e), n.__exportStar(pm(), e), n.__exportStar(Dm(), e), n.__exportStar(vt(), e);
          } }), dm = Z({ "src/main/options-normalizer.js"(e, n) {
            "use strict";
            re();
            var t = mm(), s = it(), a = { key: (d) => d.length === 1 ? "-".concat(d) : "--".concat(d), value: (d) => t.apiDescriptor.value(d), pair: (d) => {
              let { key: p, value: f } = d;
              return f === false ? "--no-".concat(p) : f === true ? a.key(p) : f === "" ? "".concat(a.key(p), " without an argument") : "".concat(a.key(p), "=").concat(f);
            } }, r = (d) => {
              let { colorsModule: p, levenshteinDistance: f } = d;
              return class extends t.ChoiceSchema {
                constructor(w) {
                  let { name: T, flags: A } = w;
                  super({ name: T, choices: A }), this._flags = [...A].sort();
                }
                preprocess(w, T) {
                  if (typeof w == "string" && w.length > 0 && !this._flags.includes(w)) {
                    let A = this._flags.find((S) => f(S, w) < 3);
                    if (A)
                      return T.logger.warn(["Unknown flag ".concat(p.yellow(T.descriptor.value(w)), ","), "did you mean ".concat(p.blue(T.descriptor.value(A)), "?")].join(" ")), A;
                  }
                  return w;
                }
                expected() {
                  return "a flag";
                }
              };
            }, u;
            function i(d, p) {
              let { logger: f = false, isCLI: h = false, passThrough: w = false, colorsModule: T = null, levenshteinDistance: A = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, S = w ? Array.isArray(w) ? (D, g) => w.includes(D) ? { [D]: g } : void 0 : (D, g) => ({ [D]: g }) : (D, g, F) => {
                let l = F.schemas, { _: E } = l, y = kn(l, Qf);
                return t.levenUnknownHandler(D, g, Object.assign(Object.assign({}, F), {}, { schemas: y }));
              }, B = h ? a : t.apiDescriptor, I = o(p, { isCLI: h, colorsModule: T, levenshteinDistance: A }), k = new t.Normalizer(I, { logger: f, unknown: S, descriptor: B }), P = f !== false;
              P && u && (k._hasDeprecationWarned = u);
              let C = k.normalize(d);
              return P && (u = k._hasDeprecationWarned), h && C["plugin-search"] === false && (C["plugin-search-dir"] = false), C;
            }
            function o(d, p) {
              let { isCLI: f, colorsModule: h, levenshteinDistance: w } = p, T = [];
              f && T.push(t.AnySchema.create({ name: "_" }));
              for (let A of d)
                T.push(c(A, { isCLI: f, optionInfos: d, colorsModule: h, levenshteinDistance: w })), A.alias && f && T.push(t.AliasSchema.create({ name: A.alias, sourceName: A.name }));
              return T;
            }
            function c(d, p) {
              let { isCLI: f, optionInfos: h, colorsModule: w, levenshteinDistance: T } = p, { name: A } = d;
              if (A === "plugin-search-dir" || A === "pluginSearchDirs")
                return t.AnySchema.create({ name: A, preprocess(k) {
                  return k === false || (k = Array.isArray(k) ? k : [k]), k;
                }, validate(k) {
                  return k === false ? true : k.every((P) => typeof P == "string");
                }, expected() {
                  return "false or paths to plugin search dir";
                } });
              let S = { name: A }, B, I = {};
              switch (d.type) {
                case "int":
                  B = t.IntegerSchema, f && (S.preprocess = Number);
                  break;
                case "string":
                  B = t.StringSchema;
                  break;
                case "choice":
                  B = t.ChoiceSchema, S.choices = d.choices.map((k) => typeof k == "object" && k.redirect ? Object.assign(Object.assign({}, k), {}, { redirect: { to: { key: d.name, value: k.redirect } } }) : k);
                  break;
                case "boolean":
                  B = t.BooleanSchema;
                  break;
                case "flag":
                  B = r({ colorsModule: w, levenshteinDistance: T }), S.flags = h.flatMap((k) => [k.alias, k.description && k.name, k.oppositeDescription && "no-".concat(k.name)].filter(Boolean));
                  break;
                case "path":
                  B = t.StringSchema;
                  break;
                default:
                  throw new Error("Unexpected type ".concat(d.type));
              }
              if (d.exception ? S.validate = (k, P, C) => d.exception(k) || P.validate(k, C) : S.validate = (k, P, C) => k === void 0 || P.validate(k, C), d.redirect && (I.redirect = (k) => k ? { to: { key: d.redirect.option, value: d.redirect.value } } : void 0), d.deprecated && (I.deprecated = true), f && !d.array) {
                let k = S.preprocess || ((P) => P);
                S.preprocess = (P, C, D) => C.preprocess(k(Array.isArray(P) ? s(P) : P), D);
              }
              return d.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (k) => Array.isArray(k) ? k : [k] } : {}), I), {}, { valueSchema: B.create(S) })) : B.create(Object.assign(Object.assign({}, S), I));
            }
            function v(d, p, f) {
              return i(d, p, f);
            }
            function m(d, p, f) {
              return i(d, p, Object.assign({ isCLI: true }, f));
            }
            n.exports = { normalizeApiOptions: v, normalizeCliOptions: m };
          } }), st = Z({ "src/language-js/loc.js"(e, n) {
            "use strict";
            re();
            var t = Rn();
            function s(o, c) {
              let { ignoreDecorators: v } = c || {};
              if (!v) {
                let m = o.declaration && o.declaration.decorators || o.decorators;
                if (t(m))
                  return s(m[0]);
              }
              return o.range ? o.range[0] : o.start;
            }
            function a(o) {
              return o.range ? o.range[1] : o.end;
            }
            function r(o, c) {
              let v = s(o);
              return Number.isInteger(v) && v === s(c);
            }
            function u(o, c) {
              let v = a(o);
              return Number.isInteger(v) && v === a(c);
            }
            function i(o, c) {
              return r(o, c) && u(o, c);
            }
            n.exports = { locStart: s, locEnd: a, hasSameLocStart: r, hasSameLoc: i };
          } }), gm = Z({ "src/main/load-parser.js"(e, n) {
            re(), n.exports = () => {
            };
          } }), ym = Z({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
            "use strict";
            re();
            var t = _r(), s = { shouldHighlight: () => false, getChalk: () => t };
            n.exports = s;
          } }), hm = Z({ "node_modules/@babel/code-frame/lib/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
            var n = ym(), t = false;
            function s(o) {
              return { gutter: o.grey, marker: o.red.bold, message: o.red.bold };
            }
            var a = /\r\n|[\n\r\u2028\u2029]/;
            function r(o, c, v) {
              let m = Object.assign({ column: 0, line: -1 }, o.start), d = Object.assign({}, m, o.end), { linesAbove: p = 2, linesBelow: f = 3 } = v || {}, h = m.line, w = m.column, T = d.line, A = d.column, S = Math.max(h - (p + 1), 0), B = Math.min(c.length, T + f);
              h === -1 && (S = 0), T === -1 && (B = c.length);
              let I = T - h, k = {};
              if (I)
                for (let P = 0; P <= I; P++) {
                  let C = P + h;
                  if (!w)
                    k[C] = true;
                  else if (P === 0) {
                    let D = c[C - 1].length;
                    k[C] = [w, D - w + 1];
                  } else if (P === I)
                    k[C] = [0, A];
                  else {
                    let D = c[C - P].length;
                    k[C] = [0, D];
                  }
                }
              else
                w === A ? w ? k[h] = [w, 0] : k[h] = true : k[h] = [w, A - w];
              return { start: S, end: B, markerLines: k };
            }
            function u(o, c) {
              let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m = (v.highlightCode || v.forceColor) && (0, n.shouldHighlight)(v), d = (0, n.getChalk)(v), p = s(d), f = (P, C) => m ? P(C) : C, h = o.split(a), { start: w, end: T, markerLines: A } = r(c, h, v), S = c.start && typeof c.start.column == "number", B = String(T).length, k = (m ? (0, n.default)(o, v) : o).split(a, T).slice(w, T).map((P, C) => {
                let D = w + 1 + C, g = " ".concat(D).slice(-B), F = " ".concat(g, " |"), l = A[D], E = !A[D + 1];
                if (l) {
                  let y = "";
                  if (Array.isArray(l)) {
                    let N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\t]/g, " "), x = l[1] || 1;
                    y = [`
 `, f(p.gutter, F.replace(/\d/g, " ")), " ", N, f(p.marker, "^").repeat(x)].join(""), E && v.message && (y += " " + f(p.message, v.message));
                  }
                  return [f(p.marker, ">"), f(p.gutter, F), P.length > 0 ? " ".concat(P) : "", y].join("");
                } else
                  return " ".concat(f(p.gutter, F)).concat(P.length > 0 ? " ".concat(P) : "");
              }).join(`
`);
              return v.message && !S && (k = "".concat(" ".repeat(B + 1)).concat(v.message, `
`).concat(k)), m ? d.reset(k) : k;
            }
            function i(o, c, v) {
              let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              if (!t) {
                t = true;
                let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                if (Tt.emitWarning)
                  Tt.emitWarning(p, "DeprecationWarning");
                else {
                  let f = new Error(p);
                  f.name = "DeprecationWarning", console.warn(new Error(p));
                }
              }
              return v = Math.max(v, 0), u(o, { start: { column: v, line: c } }, m);
            }
          } }), Gn = Z({ "src/main/parser.js"(e, n) {
            "use strict";
            re();
            var { ConfigError: t } = zt(), s = st(), a = gm(), { locStart: r, locEnd: u } = s, i = Object.getOwnPropertyNames, o = Object.getOwnPropertyDescriptor;
            function c(d) {
              let p = {};
              for (let f of d.plugins)
                if (!!f.parsers)
                  for (let h of i(f.parsers))
                    Object.defineProperty(p, h, o(f.parsers, h));
              return p;
            }
            function v(d) {
              let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d);
              if (typeof d.parser == "function")
                return { parse: d.parser, astFormat: "estree", locStart: r, locEnd: u };
              if (typeof d.parser == "string") {
                if (Object.prototype.hasOwnProperty.call(p, d.parser))
                  return p[d.parser];
                throw new t(`Couldn't resolve parser "`.concat(d.parser, '". Parsers must be explicitly added to the standalone bundle.'));
              }
            }
            function m(d, p) {
              let f = c(p), h = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((T) => [T, { enumerable: true, get() {
                return f[T].parse;
              } }]))), w = v(p, f);
              try {
                return w.preprocess && (d = w.preprocess(d, p)), { text: d, ast: w.parse(d, h, p) };
              } catch (T) {
                let { loc: A } = T;
                if (A) {
                  let { codeFrameColumns: S } = hm();
                  throw T.codeFrame = S(d, A, { highlightCode: true }), T.message += `
` + T.codeFrame, T;
                }
                throw T.stack;
              }
            }
            n.exports = { parse: m, resolveParser: v };
          } }), Wa = Z({ "src/main/options.js"(e, n) {
            "use strict";
            re();
            var t = PD(), { UndefinedParserError: s } = zt(), { getSupportInfo: a } = Mn(), r = dm(), { resolveParser: u } = Gn(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
            function o(m) {
              let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, m), f = a({ plugins: m.plugins, showUnreleased: true, showDeprecated: true }).options, h = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
              if (!p.parser) {
                if (!p.filepath)
                  (d.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
                else if (p.parser = v(p.filepath, p.plugins), !p.parser)
                  throw new s("No parser could be inferred for file: ".concat(p.filepath));
              }
              let w = u(r.normalizeApiOptions(p, [f.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
              p.astFormat = w.astFormat, p.locEnd = w.locEnd, p.locStart = w.locStart;
              let T = c(p);
              p.printer = T.printers[p.astFormat];
              let A = Object.fromEntries(f.filter((B) => B.pluginDefaults && B.pluginDefaults[T.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T.name]])), S = Object.assign(Object.assign({}, h), A);
              for (let [B, I] of Object.entries(S))
                (p[B] === null || p[B] === void 0) && (p[B] = I);
              return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, f, Object.assign({ passThrough: Object.keys(i) }, d));
            }
            function c(m) {
              let { astFormat: d } = m;
              if (!d)
                throw new Error("getPlugin() requires astFormat to be set");
              let p = m.plugins.find((f) => f.printers && f.printers[d]);
              if (!p)
                throw new Error(`Couldn't find plugin for AST format "`.concat(d, '"'));
              return p;
            }
            function v(m, d) {
              let p = t.basename(m).toLowerCase(), h = a({ plugins: d }).languages.filter((w) => w.since !== null).find((w) => w.extensions && w.extensions.some((T) => p.endsWith(T)) || w.filenames && w.filenames.some((T) => T.toLowerCase() === p));
              return h && h.parsers[0];
            }
            n.exports = { normalize: o, hiddenDefaults: i, inferParser: v };
          } }), vm = Z({ "src/main/massage-ast.js"(e, n) {
            "use strict";
            re();
            function t(s, a, r) {
              if (Array.isArray(s))
                return s.map((c) => t(c, a, r)).filter(Boolean);
              if (!s || typeof s != "object")
                return s;
              let u = a.printer.massageAstNode, i;
              u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
              let o = {};
              for (let [c, v] of Object.entries(s))
                !i.has(c) && typeof v != "function" && (o[c] = t(v, a, s));
              if (u) {
                let c = u(s, o, r);
                if (c === null)
                  return;
                if (c)
                  return c;
              }
              return o;
            }
            n.exports = t;
          } }), Xt = Z({ "scripts/build/shims/assert.cjs"(e, n) {
            "use strict";
            re();
            var t = () => {
            };
            t.ok = t, t.strictEqual = t, n.exports = t;
          } }), et = Z({ "src/main/comments.js"(e, n) {
            "use strict";
            re();
            var t = Xt(), { builders: { line: s, hardline: a, breakParent: r, indent: u, lineSuffix: i, join: o, cursor: c } } = Oe(), { hasNewline: v, skipNewline: m, skipSpaces: d, isPreviousLineEmpty: p, addLeadingComment: f, addDanglingComment: h, addTrailingComment: w } = Ue(), T = /* @__PURE__ */ new WeakMap();
            function A(L, M, j) {
              if (!L)
                return;
              let { printer: $, locStart: V, locEnd: q } = M;
              if (j) {
                if ($.canAttachComment && $.canAttachComment(L)) {
                  let H;
                  for (H = j.length - 1; H >= 0 && !(V(j[H]) <= V(L) && q(j[H]) <= q(L)); --H)
                    ;
                  j.splice(H + 1, 0, L);
                  return;
                }
              } else if (T.has(L))
                return T.get(L);
              let Y = $.getCommentChildNodes && $.getCommentChildNodes(L, M) || typeof L == "object" && Object.entries(L).filter((H) => {
                let [R] = H;
                return R !== "enclosingNode" && R !== "precedingNode" && R !== "followingNode" && R !== "tokens" && R !== "comments" && R !== "parent";
              }).map((H) => {
                let [, R] = H;
                return R;
              });
              if (!!Y) {
                j || (j = [], T.set(L, j));
                for (let H of Y)
                  A(H, M, j);
                return j;
              }
            }
            function S(L, M, j, $) {
              let { locStart: V, locEnd: q } = j, Y = V(M), H = q(M), R = A(L, j), Q, ee, te = 0, oe = R.length;
              for (; te < oe; ) {
                let W = te + oe >> 1, X = R[W], ue = V(X), De = q(X);
                if (ue <= Y && H <= De)
                  return S(X, M, j, X);
                if (De <= Y) {
                  Q = X, te = W + 1;
                  continue;
                }
                if (H <= ue) {
                  ee = X, oe = W;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if ($ && $.type === "TemplateLiteral") {
                let { quasis: W } = $, X = F(W, M, j);
                Q && F(W, Q, j) !== X && (Q = null), ee && F(W, ee, j) !== X && (ee = null);
              }
              return { enclosingNode: $, precedingNode: Q, followingNode: ee };
            }
            var B = () => false;
            function I(L, M, j, $) {
              if (!Array.isArray(L))
                return;
              let V = [], { locStart: q, locEnd: Y, printer: { handleComments: H = {} } } = $, { avoidAstMutation: R, ownLine: Q = B, endOfLine: ee = B, remaining: te = B } = H, oe = L.map((W, X) => Object.assign(Object.assign({}, S(M, W, $)), {}, { comment: W, text: j, options: $, ast: M, isLastComment: L.length - 1 === X }));
              for (let [W, X] of oe.entries()) {
                let { comment: ue, precedingNode: De, enclosingNode: ie, followingNode: G, text: z, options: U, ast: le, isLastComment: ge } = X;
                if (U.parser === "json" || U.parser === "json5" || U.parser === "__js_expression" || U.parser === "__vue_expression" || U.parser === "__vue_ts_expression") {
                  if (q(ue) - q(le) <= 0) {
                    f(le, ue);
                    continue;
                  }
                  if (Y(ue) - Y(le) >= 0) {
                    w(le, ue);
                    continue;
                  }
                }
                let Ae;
                if (R ? Ae = [X] : (ue.enclosingNode = ie, ue.precedingNode = De, ue.followingNode = G, Ae = [ue, z, U, le, ge]), P(z, U, oe, W))
                  ue.placement = "ownLine", Q(...Ae) || (G ? f(G, ue) : De ? w(De, ue) : h(ie || le, ue));
                else if (C(z, U, oe, W))
                  ue.placement = "endOfLine", ee(...Ae) || (De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue));
                else if (ue.placement = "remaining", !te(...Ae))
                  if (De && G) {
                    let Ne = V.length;
                    Ne > 0 && V[Ne - 1].followingNode !== G && D(V, z, U), V.push(X);
                  } else
                    De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue);
              }
              if (D(V, j, $), !R)
                for (let W of L)
                  delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
            }
            var k = (L) => !/[\S\n\u2028\u2029]/.test(L);
            function P(L, M, j, $) {
              let { comment: V, precedingNode: q } = j[$], { locStart: Y, locEnd: H } = M, R = Y(V);
              if (q)
                for (let Q = $ - 1; Q >= 0; Q--) {
                  let { comment: ee, precedingNode: te } = j[Q];
                  if (te !== q || !k(L.slice(H(ee), R)))
                    break;
                  R = Y(ee);
                }
              return v(L, R, { backwards: true });
            }
            function C(L, M, j, $) {
              let { comment: V, followingNode: q } = j[$], { locStart: Y, locEnd: H } = M, R = H(V);
              if (q)
                for (let Q = $ + 1; Q < j.length; Q++) {
                  let { comment: ee, followingNode: te } = j[Q];
                  if (te !== q || !k(L.slice(R, Y(ee))))
                    break;
                  R = H(ee);
                }
              return v(L, R);
            }
            function D(L, M, j) {
              let $ = L.length;
              if ($ === 0)
                return;
              let { precedingNode: V, followingNode: q, enclosingNode: Y } = L[0], H = j.printer.getGapRegex && j.printer.getGapRegex(Y) || /^[\s(]*$/, R = j.locStart(q), Q;
              for (Q = $; Q > 0; --Q) {
                let { comment: ee, precedingNode: te, followingNode: oe } = L[Q - 1];
                t.strictEqual(te, V), t.strictEqual(oe, q);
                let W = M.slice(j.locEnd(ee), R);
                if (H.test(W))
                  R = j.locStart(ee);
                else
                  break;
              }
              for (let [ee, { comment: te }] of L.entries())
                ee < Q ? w(V, te) : f(q, te);
              for (let ee of [V, q])
                ee.comments && ee.comments.length > 1 && ee.comments.sort((te, oe) => j.locStart(te) - j.locStart(oe));
              L.length = 0;
            }
            function g(L, M) {
              let j = L.getValue();
              return j.printed = true, M.printer.printComment(L, M);
            }
            function F(L, M, j) {
              let $ = j.locStart(M) - 1;
              for (let V = 1; V < L.length; ++V)
                if ($ < j.locStart(L[V]))
                  return V - 1;
              return 0;
            }
            function l(L, M) {
              let j = L.getValue(), $ = [g(L, M)], { printer: V, originalText: q, locStart: Y, locEnd: H } = M;
              if (V.isBlockComment && V.isBlockComment(j)) {
                let ee = v(q, H(j)) ? v(q, Y(j), { backwards: true }) ? a : s : " ";
                $.push(ee);
              } else
                $.push(a);
              let Q = m(q, d(q, H(j)));
              return Q !== false && v(q, Q) && $.push(a), $;
            }
            function E(L, M) {
              let j = L.getValue(), $ = g(L, M), { printer: V, originalText: q, locStart: Y } = M, H = V.isBlockComment && V.isBlockComment(j);
              if (v(q, Y(j), { backwards: true })) {
                let Q = p(q, j, Y);
                return i([a, Q ? a : "", $]);
              }
              let R = [" ", $];
              return H || (R = [i(R), r]), R;
            }
            function y(L, M, j, $) {
              let V = [], q = L.getValue();
              return !q || !q.comments || (L.each(() => {
                let Y = L.getValue();
                !Y.leading && !Y.trailing && (!$ || $(Y)) && V.push(g(L, M));
              }, "comments"), V.length === 0) ? "" : j ? o(a, V) : u([a, o(a, V)]);
            }
            function N(L, M, j) {
              let $ = L.getValue();
              if (!$)
                return {};
              let V = $.comments || [];
              j && (V = V.filter((R) => !j.has(R)));
              let q = $ === M.cursorNode;
              if (V.length === 0) {
                let R = q ? c : "";
                return { leading: R, trailing: R };
              }
              let Y = [], H = [];
              return L.each(() => {
                let R = L.getValue();
                if (j && j.has(R))
                  return;
                let { leading: Q, trailing: ee } = R;
                Q ? Y.push(l(L, M)) : ee && H.push(E(L, M));
              }, "comments"), q && (Y.unshift(c), H.push(c)), { leading: Y, trailing: H };
            }
            function x(L, M, j, $) {
              let { leading: V, trailing: q } = N(L, j, $);
              return !V && !q ? M : [V, M, q];
            }
            function b(L) {
              if (!!L)
                for (let M of L) {
                  if (!M.printed)
                    throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                  delete M.printed;
                }
            }
            n.exports = { attach: I, printComments: x, printCommentsSeparately: N, printDanglingComments: y, getSortedChildNodes: A, ensureAllCommentsPrinted: b };
          } }), Cm = Z({ "src/common/ast-path.js"(e, n) {
            "use strict";
            re();
            var t = it();
            function s(u, i) {
              let o = a(u.stack, i);
              return o === -1 ? null : u.stack[o];
            }
            function a(u, i) {
              for (let o = u.length - 1; o >= 0; o -= 2) {
                let c = u[o];
                if (c && !Array.isArray(c) && --i < 0)
                  return o;
              }
              return -1;
            }
            var r = class {
              constructor(u) {
                this.stack = [u];
              }
              getName() {
                let { stack: u } = this, { length: i } = u;
                return i > 1 ? u[i - 2] : null;
              }
              getValue() {
                return t(this.stack);
              }
              getNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
              getParentNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
              call(u) {
                let { stack: i } = this, { length: o } = i, c = t(i);
                for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++)
                  m[d - 1] = arguments[d];
                for (let f of m)
                  c = c[f], i.push(f, c);
                let p = u(this);
                return i.length = o, p;
              }
              callParent(u) {
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = a(this.stack, i + 1), c = this.stack.splice(o + 1), v = u(this);
                return this.stack.push(...c), v;
              }
              each(u) {
                let { stack: i } = this, { length: o } = i, c = t(i);
                for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++)
                  m[d - 1] = arguments[d];
                for (let p of m)
                  c = c[p], i.push(p, c);
                for (let p = 0; p < c.length; ++p)
                  i.push(p, c[p]), u(this, p, c), i.length -= 2;
                i.length = o;
              }
              map(u) {
                let i = [];
                for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), v = 1; v < o; v++)
                  c[v - 1] = arguments[v];
                return this.each((m, d, p) => {
                  i[d] = u(m, d, p);
                }, ...c), i;
              }
              try(u) {
                let { stack: i } = this, o = [...i];
                try {
                  return u();
                } finally {
                  i.length = 0, i.push(...o);
                }
              }
              match() {
                let u = this.stack.length - 1, i = null, o = this.stack[u--];
                for (var c = arguments.length, v = new Array(c), m = 0; m < c; m++)
                  v[m] = arguments[m];
                for (let d of v) {
                  if (o === void 0)
                    return false;
                  let p = null;
                  if (typeof i == "number" && (p = i, i = this.stack[u--], o = this.stack[u--]), d && !d(o, i, p))
                    return false;
                  i = this.stack[u--], o = this.stack[u--];
                }
                return true;
              }
              findAncestor(u) {
                let i = this.stack.length - 1, o = null, c = this.stack[i--];
                for (; c; ) {
                  let v = null;
                  if (typeof o == "number" && (v = o, o = this.stack[i--], c = this.stack[i--]), o !== null && u(c, o, v))
                    return c;
                  o = this.stack[i--], c = this.stack[i--];
                }
              }
            };
            n.exports = r;
          } }), Em = Z({ "src/main/multiparser.js"(e, n) {
            "use strict";
            re();
            var { utils: { stripTrailingHardline: t } } = Oe(), { normalize: s } = Wa(), a = et();
            function r(i, o, c, v) {
              if (c.printer.embed && c.embeddedLanguageFormatting === "auto")
                return c.printer.embed(i, o, (m, d, p) => u(m, d, c, v, p), c);
            }
            function u(i, o, c, v) {
              let { stripTrailingHardline: m = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, d = s(Object.assign(Object.assign(Object.assign({}, c), o), {}, { parentParser: c.parser, originalText: i }), { passThrough: true }), p = Gn().parse(i, d), { ast: f } = p;
              i = p.text;
              let h = f.comments;
              delete f.comments, a.attach(h, f, i, d), d[Symbol.for("comments")] = h || [], d[Symbol.for("tokens")] = f.tokens || [];
              let w = v(f, d);
              return a.ensureAllCommentsPrinted(h), m ? typeof w == "string" ? w.replace(/(?:\r?\n)*$/, "") : t(w) : w;
            }
            n.exports = { printSubtree: r };
          } }), Fm = Z({ "src/main/ast-to-doc.js"(e, n) {
            "use strict";
            re();
            var t = Cm(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: r } } = Oe(), { printComments: u } = et(), i = Em();
            function o(m, d) {
              let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = d;
              f.preprocess && (m = f.preprocess(m, d));
              let h = /* @__PURE__ */ new Map(), w = new t(m), T = A();
              return p > 0 && (T = a([s, T], p, d.tabWidth)), r(T), T;
              function A(B, I) {
                return B === void 0 || B === w ? S(I) : Array.isArray(B) ? w.call(() => S(I), ...B) : w.call(() => S(I), B);
              }
              function S(B) {
                let I = w.getValue(), k = I && typeof I == "object" && B === void 0;
                if (k && h.has(I))
                  return h.get(I);
                let P = v(w, d, A, B);
                return k && h.set(I, P), P;
              }
            }
            function c(m, d) {
              let { originalText: p, [Symbol.for("comments")]: f, locStart: h, locEnd: w } = d, T = h(m), A = w(m), S = /* @__PURE__ */ new Set();
              for (let B of f)
                h(B) >= T && w(B) <= A && (B.printed = true, S.add(B));
              return { doc: p.slice(T, A), printedComments: S };
            }
            function v(m, d, p, f) {
              let h = m.getValue(), { printer: w } = d, T, A;
              if (w.hasPrettierIgnore && w.hasPrettierIgnore(m))
                ({ doc: T, printedComments: A } = c(h, d));
              else {
                if (h)
                  try {
                    T = i.printSubtree(m, p, d, o);
                  } catch (S) {
                    if (globalThis.PRETTIER_DEBUG)
                      throw S;
                  }
                T || (T = w.print(m, d, p, f));
              }
              return (!w.willPrintOwnComments || !w.willPrintOwnComments(m, d)) && (T = u(m, T, d, A)), T;
            }
            n.exports = o;
          } }), Am = Z({ "src/main/range-util.js"(e, n) {
            "use strict";
            re();
            var t = Xt(), s = et(), a = (f) => {
              let { parser: h } = f;
              return h === "json" || h === "json5" || h === "json-stringify";
            };
            function r(f, h) {
              let w = [f.node, ...f.parentNodes], T = /* @__PURE__ */ new Set([h.node, ...h.parentNodes]);
              return w.find((A) => v.has(A.type) && T.has(A));
            }
            function u(f) {
              let h = f.length - 1;
              for (; ; ) {
                let w = f[h];
                if (w && (w.type === "Program" || w.type === "File"))
                  h--;
                else
                  break;
              }
              return f.slice(0, h + 1);
            }
            function i(f, h, w) {
              let { locStart: T, locEnd: A } = w, S = f.node, B = h.node;
              if (S === B)
                return { startNode: S, endNode: B };
              let I = T(f.node);
              for (let P of u(h.parentNodes))
                if (T(P) >= I)
                  B = P;
                else
                  break;
              let k = A(h.node);
              for (let P of u(f.parentNodes))
                if (A(P) <= k)
                  S = P;
                else
                  break;
              return { startNode: S, endNode: B };
            }
            function o(f, h, w, T) {
              let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], S = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I } = w, k = B(f), P = I(f);
              if (!(h > P || h < k || S === "rangeEnd" && h === k || S === "rangeStart" && h === P)) {
                for (let C of s.getSortedChildNodes(f, w)) {
                  let D = o(C, h, w, T, [f, ...A], S);
                  if (D)
                    return D;
                }
                if (!T || T(f, A[0]))
                  return { node: f, parentNodes: A };
              }
            }
            function c(f, h) {
              return h !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
            }
            var v = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), m = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
            function d(f, h, w) {
              if (!h)
                return false;
              switch (f.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript":
                case "acorn":
                case "espree":
                case "meriyah":
                case "__babel_estree":
                  return c(h.type, w && w.type);
                case "json":
                case "json5":
                case "json-stringify":
                  return v.has(h.type);
                case "graphql":
                  return m.has(h.kind);
                case "vue":
                  return h.tag !== "root";
              }
              return false;
            }
            function p(f, h, w) {
              let { rangeStart: T, rangeEnd: A, locStart: S, locEnd: B } = h;
              t.ok(A > T);
              let I = f.slice(T, A).search(/\S/), k = I === -1;
              if (!k)
                for (T += I; A > T && !/\S/.test(f[A - 1]); --A)
                  ;
              let P = o(w, T, h, (F, l) => d(h, F, l), [], "rangeStart"), C = k ? P : o(w, A, h, (F) => d(h, F), [], "rangeEnd");
              if (!P || !C)
                return { rangeStart: 0, rangeEnd: 0 };
              let D, g;
              if (a(h)) {
                let F = r(P, C);
                D = F, g = F;
              } else
                ({ startNode: D, endNode: g } = i(P, C, h));
              return { rangeStart: Math.min(S(D), S(g)), rangeEnd: Math.max(B(D), B(g)) };
            }
            n.exports = { calculateRange: p, findNodeAtOffset: o };
          } }), Sm = Z({ "src/main/core.js"(e, n) {
            "use strict";
            re();
            var { diffArrays: t } = aD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = Oe(), { getAlignmentSize: r } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: o, normalizeEndOfLine: c } = jn(), v = Wa().normalize, m = vm(), d = et(), p = Gn(), f = Fm(), h = Am(), w = "\uFEFF", T = Symbol("cursor");
            function A(g, F, l) {
              let E = F.comments;
              return E && (delete F.comments, d.attach(E, F, g, l)), l[Symbol.for("comments")] = E || [], l[Symbol.for("tokens")] = F.tokens || [], l.originalText = g, E;
            }
            function S(g, F) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              if (!g || g.trim().length === 0)
                return { formatted: "", cursorOffset: -1, comments: [] };
              let { ast: E, text: y } = p.parse(g, F);
              if (F.cursorOffset >= 0) {
                let L = h.findNodeAtOffset(E, F.cursorOffset, F);
                L && L.node && (F.cursorNode = L.node);
              }
              let N = A(y, E, F), x = f(E, F, l), b = s(x, F);
              if (d.ensureAllCommentsPrinted(N), l > 0) {
                let L = b.formatted.trim();
                b.cursorNodeStart !== void 0 && (b.cursorNodeStart -= b.formatted.indexOf(L)), b.formatted = L + i(F.endOfLine);
              }
              if (F.cursorOffset >= 0) {
                let L, M, j, $, V;
                if (F.cursorNode && b.cursorNodeText ? (L = F.locStart(F.cursorNode), M = y.slice(L, F.locEnd(F.cursorNode)), j = F.cursorOffset - L, $ = b.cursorNodeStart, V = b.cursorNodeText) : (L = 0, M = y, j = F.cursorOffset, $ = 0, V = b.formatted), M === V)
                  return { formatted: b.formatted, cursorOffset: $ + j, comments: N };
                let q = [...M];
                q.splice(j, 0, T);
                let Y = [...V], H = t(q, Y), R = $;
                for (let Q of H)
                  if (Q.removed) {
                    if (Q.value.includes(T))
                      break;
                  } else
                    R += Q.count;
                return { formatted: b.formatted, cursorOffset: R, comments: N };
              }
              return { formatted: b.formatted, cursorOffset: -1, comments: N };
            }
            function B(g, F) {
              let { ast: l, text: E } = p.parse(g, F), { rangeStart: y, rangeEnd: N } = h.calculateRange(E, F, l), x = E.slice(y, N), b = Math.min(y, E.lastIndexOf(`
`, y) + 1), L = E.slice(b, y).match(/^\s*/)[0], M = r(L, F.tabWidth), j = S(x, Object.assign(Object.assign({}, F), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: F.cursorOffset > y && F.cursorOffset <= N ? F.cursorOffset - y : -1, endOfLine: "lf" }), M), $ = j.formatted.trimEnd(), { cursorOffset: V } = F;
              V > N ? V += $.length - x.length : j.cursorOffset >= 0 && (V = j.cursorOffset + y);
              let q = E.slice(0, y) + $ + E.slice(N);
              if (F.endOfLine !== "lf") {
                let Y = i(F.endOfLine);
                V >= 0 && Y === `\r
` && (V += o(q.slice(0, V), `
`)), q = q.replace(/\n/g, Y);
              }
              return { formatted: q, cursorOffset: V, comments: j.comments };
            }
            function I(g, F, l) {
              return typeof F != "number" || Number.isNaN(F) || F < 0 || F > g.length ? l : F;
            }
            function k(g, F) {
              let { cursorOffset: l, rangeStart: E, rangeEnd: y } = F;
              return l = I(g, l, -1), E = I(g, E, 0), y = I(g, y, g.length), Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: y });
            }
            function P(g, F) {
              let { cursorOffset: l, rangeStart: E, rangeEnd: y, endOfLine: N } = k(g, F), x = g.charAt(0) === w;
              if (x && (g = g.slice(1), l--, E--, y--), N === "auto" && (N = u(g)), g.includes("\r")) {
                let b = (L) => o(g.slice(0, Math.max(L, 0)), `\r
`);
                l -= b(l), E -= b(E), y -= b(y), g = c(g);
              }
              return { hasBOM: x, text: g, options: k(g, Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: y, endOfLine: N })) };
            }
            function C(g, F) {
              let l = p.resolveParser(F);
              return !l.hasPragma || l.hasPragma(g);
            }
            function D(g, F) {
              let { hasBOM: l, text: E, options: y } = P(g, v(F));
              if (y.rangeStart >= y.rangeEnd && E !== "" || y.requirePragma && !C(E, y))
                return { formatted: g, cursorOffset: F.cursorOffset, comments: [] };
              let N;
              return y.rangeStart > 0 || y.rangeEnd < E.length ? N = B(E, y) : (!y.requirePragma && y.insertPragma && y.printer.insertPragma && !C(E, y) && (E = y.printer.insertPragma(E)), N = S(E, y)), l && (N.formatted = w + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;
            }
            n.exports = { formatWithCursor: D, parse(g, F, l) {
              let { text: E, options: y } = P(g, v(F)), N = p.parse(E, y);
              return l && (N.ast = m(N.ast, y)), N;
            }, formatAST(g, F) {
              F = v(F);
              let l = f(g, F);
              return s(l, F);
            }, formatDoc(g, F) {
              return D(a(g), Object.assign(Object.assign({}, F), {}, { parser: "__js_expression" })).formatted;
            }, printToDoc(g, F) {
              F = v(F);
              let { ast: l, text: E } = p.parse(g, F);
              return A(E, l, F), f(l, F);
            }, printDocToString(g, F) {
              return s(g, v(F));
            } };
          } }), xm = Z({ "src/common/util-shared.js"(e, n) {
            "use strict";
            re();
            var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: o, skipNewline: c, skipToLineEnd: v, skipEverythingButNewLine: m, skipInlineComment: d, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: S, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: k, addDanglingComment: P, addTrailingComment: C } = Ue();
            n.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: o, skipNewline: c, skipToLineEnd: v, skipEverythingButNewLine: m, skipInlineComment: d, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: S, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: k, addDanglingComment: P, addTrailingComment: C };
          } }), Bt = Z({ "src/utils/create-language.js"(e, n) {
            "use strict";
            re(), n.exports = function(t, s) {
              let { languageId: a } = t, r = kn(t, Zf);
              return Object.assign(Object.assign({ linguistLanguageId: a }, r), s(t));
            };
          } }), bm = Z({ "node_modules/esutils/lib/ast.js"(e, n) {
            re(), function() {
              "use strict";
              function t(o) {
                if (o == null)
                  return false;
                switch (o.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return true;
                }
                return false;
              }
              function s(o) {
                if (o == null)
                  return false;
                switch (o.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return true;
                }
                return false;
              }
              function a(o) {
                if (o == null)
                  return false;
                switch (o.type) {
                  case "BlockStatement":
                  case "BreakStatement":
                  case "ContinueStatement":
                  case "DebuggerStatement":
                  case "DoWhileStatement":
                  case "EmptyStatement":
                  case "ExpressionStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "IfStatement":
                  case "LabeledStatement":
                  case "ReturnStatement":
                  case "SwitchStatement":
                  case "ThrowStatement":
                  case "TryStatement":
                  case "VariableDeclaration":
                  case "WhileStatement":
                  case "WithStatement":
                    return true;
                }
                return false;
              }
              function r(o) {
                return a(o) || o != null && o.type === "FunctionDeclaration";
              }
              function u(o) {
                switch (o.type) {
                  case "IfStatement":
                    return o.alternate != null ? o.alternate : o.consequent;
                  case "LabeledStatement":
                  case "ForStatement":
                  case "ForInStatement":
                  case "WhileStatement":
                  case "WithStatement":
                    return o.body;
                }
                return null;
              }
              function i(o) {
                var c;
                if (o.type !== "IfStatement" || o.alternate == null)
                  return false;
                c = o.consequent;
                do {
                  if (c.type === "IfStatement" && c.alternate == null)
                    return true;
                  c = u(c);
                } while (c);
                return false;
              }
              n.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: r, isProblematicIfStatement: i, trailingStatement: u };
            }();
          } }), $a = Z({ "node_modules/esutils/lib/code.js"(e, n) {
            re(), function() {
              "use strict";
              var t, s, a, r, u, i;
              s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
              function o(A) {
                return 48 <= A && A <= 57;
              }
              function c(A) {
                return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;
              }
              function v(A) {
                return A >= 48 && A <= 55;
              }
              a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
              function m(A) {
                return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && a.indexOf(A) >= 0;
              }
              function d(A) {
                return A === 10 || A === 13 || A === 8232 || A === 8233;
              }
              function p(A) {
                if (A <= 65535)
                  return String.fromCharCode(A);
                var S = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296), B = String.fromCharCode((A - 65536) % 1024 + 56320);
                return S + B;
              }
              for (r = new Array(128), i = 0; i < 128; ++i)
                r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
              for (u = new Array(128), i = 0; i < 128; ++i)
                u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
              function f(A) {
                return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p(A));
              }
              function h(A) {
                return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p(A));
              }
              function w(A) {
                return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p(A));
              }
              function T(A) {
                return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p(A));
              }
              n.exports = { isDecimalDigit: o, isHexDigit: c, isOctalDigit: v, isWhiteSpace: m, isLineTerminator: d, isIdentifierStartES5: f, isIdentifierPartES5: h, isIdentifierStartES6: w, isIdentifierPartES6: T };
            }();
          } }), Tm = Z({ "node_modules/esutils/lib/keyword.js"(e, n) {
            re(), function() {
              "use strict";
              var t = $a();
              function s(f) {
                switch (f) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }
              function a(f, h) {
                return !h && f === "yield" ? false : r(f, h);
              }
              function r(f, h) {
                if (h && s(f))
                  return true;
                switch (f.length) {
                  case 2:
                    return f === "if" || f === "in" || f === "do";
                  case 3:
                    return f === "var" || f === "for" || f === "new" || f === "try";
                  case 4:
                    return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                  case 5:
                    return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                  case 6:
                    return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                  case 7:
                    return f === "default" || f === "finally" || f === "extends";
                  case 8:
                    return f === "function" || f === "continue" || f === "debugger";
                  case 10:
                    return f === "instanceof";
                  default:
                    return false;
                }
              }
              function u(f, h) {
                return f === "null" || f === "true" || f === "false" || a(f, h);
              }
              function i(f, h) {
                return f === "null" || f === "true" || f === "false" || r(f, h);
              }
              function o(f) {
                return f === "eval" || f === "arguments";
              }
              function c(f) {
                var h, w, T;
                if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T)))
                  return false;
                for (h = 1, w = f.length; h < w; ++h)
                  if (T = f.charCodeAt(h), !t.isIdentifierPartES5(T))
                    return false;
                return true;
              }
              function v(f, h) {
                return (f - 55296) * 1024 + (h - 56320) + 65536;
              }
              function m(f) {
                var h, w, T, A, S;
                if (f.length === 0)
                  return false;
                for (S = t.isIdentifierStartES6, h = 0, w = f.length; h < w; ++h) {
                  if (T = f.charCodeAt(h), 55296 <= T && T <= 56319) {
                    if (++h, h >= w || (A = f.charCodeAt(h), !(56320 <= A && A <= 57343)))
                      return false;
                    T = v(T, A);
                  }
                  if (!S(T))
                    return false;
                  S = t.isIdentifierPartES6;
                }
                return true;
              }
              function d(f, h) {
                return c(f) && !u(f, h);
              }
              function p(f, h) {
                return m(f) && !i(f, h);
              }
              n.exports = { isKeywordES5: a, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: o, isIdentifierNameES5: c, isIdentifierNameES6: m, isIdentifierES5: d, isIdentifierES6: p };
            }();
          } }), Bm = Z({ "node_modules/esutils/lib/utils.js"(e) {
            re(), function() {
              "use strict";
              e.ast = bm(), e.code = $a(), e.keyword = Tm();
            }();
          } }), It = Z({ "src/language-js/utils/is-block-comment.js"(e, n) {
            "use strict";
            re();
            var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
            n.exports = s;
          } }), Nm = Z({ "src/language-js/utils/is-node-matches.js"(e, n) {
            "use strict";
            re();
            function t(a, r) {
              let u = r.split(".");
              for (let i = u.length - 1; i >= 0; i--) {
                let o = u[i];
                if (i === 0)
                  return a.type === "Identifier" && a.name === o;
                if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== o)
                  return false;
                a = a.object;
              }
            }
            function s(a, r) {
              return r.some((u) => t(a, u));
            }
            n.exports = s;
          } }), Ke = Z({ "src/language-js/utils/index.js"(e, n) {
            "use strict";
            re();
            var t = Bm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: o } = Ue(), { locStart: c, locEnd: v, hasSameLocStart: m } = st(), d = It(), p = Nm(), f = "(?:(?=.)\\s)", h = new RegExp("^".concat(f, "*:")), w = new RegExp("^".concat(f, "*::"));
            function T(O) {
              var fe, Te;
              return ((fe = O.extra) === null || fe === void 0 ? void 0 : fe.parenthesized) && d((Te = O.trailingComments) === null || Te === void 0 ? void 0 : Te[0]) && h.test(O.trailingComments[0].value);
            }
            function A(O) {
              let fe = O == null ? void 0 : O[0];
              return d(fe) && w.test(fe.value);
            }
            function S(O, fe) {
              if (!O || typeof O != "object")
                return false;
              if (Array.isArray(O))
                return O.some(($e) => S($e, fe));
              let Te = fe(O);
              return typeof Te == "boolean" ? Te : Object.values(O).some(($e) => S($e, fe));
            }
            function B(O) {
              return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || ue(O) || De(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || O.type === "TSAsExpression" || O.type === "TSNonNullExpression";
            }
            function I(O) {
              var fe, Te, $e, Je, Ze, ut;
              return O.expressions ? O.expressions[0] : (fe = (Te = ($e = (Je = (Ze = (ut = O.left) !== null && ut !== void 0 ? ut : O.test) !== null && Ze !== void 0 ? Ze : O.callee) !== null && Je !== void 0 ? Je : O.object) !== null && $e !== void 0 ? $e : O.tag) !== null && Te !== void 0 ? Te : O.argument) !== null && fe !== void 0 ? fe : O.expression;
            }
            function k(O, fe) {
              if (fe.expressions)
                return ["expressions", 0];
              if (fe.left)
                return ["left"];
              if (fe.test)
                return ["test"];
              if (fe.object)
                return ["object"];
              if (fe.callee)
                return ["callee"];
              if (fe.tag)
                return ["tag"];
              if (fe.argument)
                return ["argument"];
              if (fe.expression)
                return ["expression"];
              throw new Error("Unexpected node has no left side.");
            }
            function P(O) {
              return O = new Set(O), (fe) => O.has(fe == null ? void 0 : fe.type);
            }
            var C = P(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), D = P(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
            function g(O) {
              let fe = O.getParentNode();
              return O.getName() === "declaration" && D(fe) ? fe : null;
            }
            var F = P(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
            function l(O) {
              return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
            }
            function E(O) {
              return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && l(O.argument);
            }
            function y(O) {
              return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
            }
            var N = P(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), x = P(["FunctionExpression", "ArrowFunctionExpression"]);
            function b(O) {
              return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
            }
            function L(O) {
              return ue(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
            }
            var M = P(["JSXElement", "JSXFragment"]);
            function j(O, fe) {
              if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
                return false;
              let Te = fe.getNode();
              if (!Te.expression || !M(Te.expression))
                return false;
              let $e = fe.getParentNode();
              return $e.type === "Program" && $e.body.length === 1;
            }
            function $(O) {
              return O.kind === "get" || O.kind === "set";
            }
            function V(O) {
              return $(O) || m(O, O.value);
            }
            function q(O) {
              return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !V(O);
            }
            function Y(O) {
              return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !m(O, O.typeAnnotation);
            }
            var H = P(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
            function R(O) {
              return De(O) || O.type === "BindExpression" && Boolean(O.object);
            }
            var Q = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
            function ee(O) {
              return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Q.has(O.type)) : false;
            }
            function te(O) {
              let fe = /^(?:before|after)(?:Each|All)$/;
              return O.callee.type === "Identifier" && fe.test(O.callee.name) && O.arguments.length === 1;
            }
            var oe = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
            function W(O) {
              return p(O, oe);
            }
            function X(O, fe) {
              if (O.type !== "CallExpression")
                return false;
              if (O.arguments.length === 1) {
                if (L(O) && fe && X(fe))
                  return x(O.arguments[0]);
                if (te(O))
                  return L(O.arguments[0]);
              } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || y(O.arguments[0])) && W(O.callee))
                return O.arguments[2] && !l(O.arguments[2]) ? false : (O.arguments.length === 2 ? x(O.arguments[1]) : b(O.arguments[1]) && Se(O.arguments[1]).length <= 1) || L(O.arguments[1]);
              return false;
            }
            var ue = P(["CallExpression", "OptionalCallExpression"]), De = P(["MemberExpression", "OptionalMemberExpression"]);
            function ie(O) {
              let fe = "expressions";
              O.type === "TSTemplateLiteralType" && (fe = "types");
              let Te = O[fe];
              return Te.length === 0 ? false : Te.every(($e) => {
                if (se($e))
                  return false;
                if ($e.type === "Identifier" || $e.type === "ThisExpression")
                  return true;
                if (De($e)) {
                  let Je = $e;
                  for (; De(Je); )
                    if (Je.property.type !== "Identifier" && Je.property.type !== "Literal" && Je.property.type !== "StringLiteral" && Je.property.type !== "NumericLiteral" || (Je = Je.object, se(Je)))
                      return false;
                  return Je.type === "Identifier" || Je.type === "ThisExpression";
                }
                return false;
              });
            }
            function G(O, fe) {
              return O === "+" || O === "-" ? O + fe : fe;
            }
            function z(O, fe) {
              let Te = c(fe), $e = r(O, v(fe));
              return $e !== false && O.slice(Te, Te + 2) === "/*" && O.slice($e, $e + 2) === "*/";
            }
            function U(O, fe) {
              return M(fe) ? Re(fe) : se(fe, Le.Leading, (Te) => a(O, v(Te)));
            }
            function le(O, fe) {
              return fe.parser !== "json" && y(O.key) && ve(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(fe.parser === "babel-ts" && O.type === "ClassProperty" || fe.parser === "typescript" && O.type === "PropertyDefinition") || ge(O.key.value) && String(Number(O.key.value)) === O.key.value && (fe.parser === "babel" || fe.parser === "acorn" || fe.parser === "espree" || fe.parser === "meriyah" || fe.parser === "__babel_estree"));
            }
            function ge(O) {
              return /^(?:\d+|\d+\.\d+)$/.test(O);
            }
            function Ae(O, fe) {
              let Te = /^[fx]?(?:describe|it|test)$/;
              return fe.type === "TaggedTemplateExpression" && fe.quasi === O && fe.tag.type === "MemberExpression" && fe.tag.property.type === "Identifier" && fe.tag.property.name === "each" && (fe.tag.object.type === "Identifier" && Te.test(fe.tag.object.name) || fe.tag.object.type === "MemberExpression" && fe.tag.object.property.type === "Identifier" && (fe.tag.object.property.name === "only" || fe.tag.object.property.name === "skip") && fe.tag.object.object.type === "Identifier" && Te.test(fe.tag.object.object.name));
            }
            function Ne(O) {
              return O.quasis.some((fe) => fe.value.raw.includes(`
`));
            }
            function ke(O, fe) {
              return (O.type === "TemplateLiteral" && Ne(O) || O.type === "TaggedTemplateExpression" && Ne(O.quasi)) && !a(fe, c(O), { backwards: true });
            }
            function ce(O) {
              if (!se(O))
                return false;
              let fe = s(He(O, Le.Dangling));
              return fe && !d(fe);
            }
            function pe(O) {
              if (O.length <= 1)
                return false;
              let fe = 0;
              for (let Te of O)
                if (x(Te)) {
                  if (fe += 1, fe > 1)
                    return true;
                } else if (ue(Te)) {
                  for (let $e of Te.arguments)
                    if (x($e))
                      return true;
                }
              return false;
            }
            function de(O) {
              let fe = O.getValue(), Te = O.getParentNode();
              return ue(fe) && ue(Te) && Te.callee === fe && fe.arguments.length > Te.arguments.length && Te.arguments.length > 0;
            }
            function ae(O, fe) {
              if (fe >= 2)
                return false;
              let Te = (Je) => ae(Je, fe + 1), $e = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
              return $e && o($e) > 5 ? false : O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import" ? true : O.type === "TemplateLiteral" ? O.quasis.every((Je) => !Je.value.raw.includes(`
`)) && O.expressions.every(Te) : O.type === "ObjectExpression" ? O.properties.every((Je) => !Je.computed && (Je.shorthand || Je.value && Te(Je.value))) : O.type === "ArrayExpression" ? O.elements.every((Je) => Je === null || Te(Je)) : ze(O) ? (O.type === "ImportExpression" || ae(O.callee, fe)) && Xe(O).every(Te) : De(O) ? ae(O.object, fe) && ae(O.property, fe) : O.type === "UnaryExpression" && (O.operator === "!" || O.operator === "-") ? ae(O.argument, fe) : O.type === "TSNonNullExpression" ? ae(O.expression, fe) : false;
            }
            function ve(O) {
              var fe, Te;
              return (fe = (Te = O.extra) === null || Te === void 0 ? void 0 : Te.raw) !== null && fe !== void 0 ? fe : O.raw;
            }
            function K(O) {
              return O;
            }
            function he(O) {
              return O.filepath && /\.tsx$/i.test(O.filepath);
            }
            function ye(O) {
              let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
              return O.trailingComma === "es5" && fe === "es5" || O.trailingComma === "all" && (fe === "all" || fe === "es5");
            }
            function Ce(O, fe) {
              switch (O = Ee(O), O.type) {
                case "FunctionExpression":
                case "ClassExpression":
                case "DoExpression":
                  return fe;
                case "ObjectExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return Ce(O.object, fe);
                case "TaggedTemplateExpression":
                  return O.tag.type === "FunctionExpression" ? false : Ce(O.tag, fe);
                case "CallExpression":
                case "OptionalCallExpression":
                  return O.callee.type === "FunctionExpression" ? false : Ce(O.callee, fe);
                case "ConditionalExpression":
                  return Ce(O.test, fe);
                case "UpdateExpression":
                  return !O.prefix && Ce(O.argument, fe);
                case "BindExpression":
                  return O.object && Ce(O.object, fe);
                case "SequenceExpression":
                  return Ce(O.expressions[0], fe);
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return Ce(O.expression, fe);
                default:
                  return false;
              }
            }
            var Ie = { "==": true, "!=": true, "===": true, "!==": true }, Fe = { "*": true, "/": true, "%": true }, me = { ">>": true, ">>>": true, "<<": true };
            function _(O, fe) {
              return !(ne(fe) !== ne(O) || O === "**" || Ie[O] && Ie[fe] || fe === "%" && Fe[O] || O === "%" && Fe[fe] || fe !== O && Fe[fe] && Fe[O] || me[O] && me[fe]);
            }
            var J = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, fe) => O.map((Te) => [Te, fe])));
            function ne(O) {
              return J.get(O);
            }
            function Ee(O) {
              for (; O.left; )
                O = O.left;
              return O;
            }
            function We(O) {
              return Boolean(me[O]) || O === "|" || O === "^" || O === "&";
            }
            function Be(O) {
              var fe;
              if (O.rest)
                return true;
              let Te = Se(O);
              return ((fe = s(Te)) === null || fe === void 0 ? void 0 : fe.type) === "RestElement";
            }
            var Pe = /* @__PURE__ */ new WeakMap();
            function Se(O) {
              if (Pe.has(O))
                return Pe.get(O);
              let fe = [];
              return O.this && fe.push(O.this), Array.isArray(O.parameters) ? fe.push(...O.parameters) : Array.isArray(O.params) && fe.push(...O.params), O.rest && fe.push(O.rest), Pe.set(O, fe), fe;
            }
            function Qe(O, fe) {
              let Te = O.getValue(), $e = 0, Je = (Ze) => fe(Ze, $e++);
              Te.this && O.call(Je, "this"), Array.isArray(Te.parameters) ? O.each(Je, "parameters") : Array.isArray(Te.params) && O.each(Je, "params"), Te.rest && O.call(Je, "rest");
            }
            var xe = /* @__PURE__ */ new WeakMap();
            function Xe(O) {
              if (xe.has(O))
                return xe.get(O);
              let fe = O.arguments;
              return O.type === "ImportExpression" && (fe = [O.source], O.attributes && fe.push(O.attributes)), xe.set(O, fe), fe;
            }
            function _e(O, fe) {
              let Te = O.getValue();
              Te.type === "ImportExpression" ? (O.call(($e) => fe($e, 0), "source"), Te.attributes && O.call(($e) => fe($e, 1), "attributes")) : O.each(fe, "arguments");
            }
            function je(O) {
              return O.value.trim() === "prettier-ignore" && !O.unignore;
            }
            function Re(O) {
              return O && (O.prettierIgnore || se(O, Le.PrettierIgnore));
            }
            function be(O) {
              let fe = O.getValue();
              return Re(fe);
            }
            var Le = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, qe = (O, fe) => {
              if (typeof O == "function" && (fe = O, O = 0), O || fe)
                return (Te, $e, Je) => !(O & Le.Leading && !Te.leading || O & Le.Trailing && !Te.trailing || O & Le.Dangling && (Te.leading || Te.trailing) || O & Le.Block && !d(Te) || O & Le.Line && !C(Te) || O & Le.First && $e !== 0 || O & Le.Last && $e !== Je.length - 1 || O & Le.PrettierIgnore && !je(Te) || fe && !fe(Te));
            };
            function se(O, fe, Te) {
              if (!u(O == null ? void 0 : O.comments))
                return false;
              let $e = qe(fe, Te);
              return $e ? O.comments.some($e) : true;
            }
            function He(O, fe, Te) {
              if (!Array.isArray(O == null ? void 0 : O.comments))
                return [];
              let $e = qe(fe, Te);
              return $e ? O.comments.filter($e) : O.comments;
            }
            var Me = (O, fe) => {
              let { originalText: Te } = fe;
              return i(Te, v(O));
            };
            function ze(O) {
              return ue(O) || O.type === "NewExpression" || O.type === "ImportExpression";
            }
            function nt(O) {
              return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
            }
            function tt(O) {
              return Boolean(O.__isUsingHackPipeline);
            }
            var pt = Symbol("ifWithoutBlockAndSameLineComment");
            n.exports = { getFunctionParameters: Se, iterateFunctionParametersPath: Qe, getCallArguments: Xe, iterateCallArgumentsPath: _e, hasRestParameter: Be, getLeftSide: I, getLeftSidePathName: k, getParentExportDeclaration: g, getTypeScriptMappedTypeModifier: G, hasFlowAnnotationComment: A, hasFlowShorthandAnnotationComment: T, hasLeadingOwnLineComment: U, hasNakedLeftSide: B, hasNode: S, hasIgnoreComment: be, hasNodeIgnoreComment: Re, identity: K, isBinaryish: H, isCallLikeExpression: ze, isEnabledHackPipeline: tt, isLineComment: C, isPrettierIgnoreComment: je, isCallExpression: ue, isMemberExpression: De, isExportDeclaration: D, isFlowAnnotationComment: z, isFunctionCompositionArgs: pe, isFunctionNotation: V, isFunctionOrArrowExpression: x, isGetterOrSetter: $, isJestEachTemplateLiteral: Ae, isJsxNode: M, isLiteral: F, isLongCurriedCallExpression: de, isSimpleCallArgument: ae, isMemberish: R, isNumericLiteral: l, isSignedNumericLiteral: E, isObjectProperty: nt, isObjectType: N, isObjectTypePropertyAFunction: q, isSimpleType: ee, isSimpleNumber: ge, isSimpleTemplateLiteral: ie, isStringLiteral: y, isStringPropSafeToUnquote: le, isTemplateOnItsOwnLine: ke, isTestCall: X, isTheOnlyJsxElementInMarkdown: j, isTSXFile: he, isTypeAnnotationAFunction: Y, isNextLineEmpty: Me, needsHardlineAfterDanglingComment: ce, rawText: ve, shouldPrintComma: ye, isBitwiseOperator: We, shouldFlatten: _, startsWithNoLookaheadToken: Ce, getPrecedence: ne, hasComment: se, getComments: He, CommentCheckFlags: Le, markerForIfWithoutBlockAndSameLineComment: pt };
          } }), Lt = Z({ "src/language-js/print/template-literal.js"(e, n) {
            "use strict";
            re();
            var t = it(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: r, hardline: u, softline: i, group: o, indent: c, align: v, lineSuffixBoundary: m, addAlignmentToDoc: d }, printer: { printDocToString: p }, utils: { mapDoc: f } } = Oe(), { isBinaryish: h, isJestEachTemplateLiteral: w, isSimpleTemplateLiteral: T, hasComment: A, isMemberExpression: S } = Ke();
            function B(g, F, l) {
              let E = g.getValue();
              if (E.type === "TemplateLiteral" && w(E, g.getParentNode())) {
                let M = I(g, l, F);
                if (M)
                  return M;
              }
              let N = "expressions";
              E.type === "TSTemplateLiteralType" && (N = "types");
              let x = [], b = g.map(F, N), L = T(E);
              return L && (b = b.map((M) => p(M, Object.assign(Object.assign({}, l), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), x.push(m, "`"), g.each((M) => {
                let j = M.getName();
                if (x.push(F()), j < b.length) {
                  let { tabWidth: $ } = l, V = M.getValue(), q = a(V.value.raw, $), Y = b[j];
                  if (!L) {
                    let R = E[N][j];
                    (A(R) || S(R) || R.type === "ConditionalExpression" || R.type === "SequenceExpression" || R.type === "TSAsExpression" || h(R)) && (Y = [c([i, Y]), i]);
                  }
                  let H = q === 0 && V.value.raw.endsWith(`
`) ? v(Number.NEGATIVE_INFINITY, Y) : d(Y, q, $);
                  x.push(o(["${", H, m, "}"]));
                }
              }, "quasis"), x.push("`"), x;
            }
            function I(g, F, l) {
              let E = g.getNode(), y = E.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (y.length > 1 || y.some((N) => N.length > 0)) {
                F.__inJestEach = true;
                let N = g.map(l, "expressions");
                F.__inJestEach = false;
                let x = [], b = N.map((V) => "${" + p(V, Object.assign(Object.assign({}, F), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), L = [{ hasLineBreak: false, cells: [] }];
                for (let V = 1; V < E.quasis.length; V++) {
                  let q = t(L), Y = b[V - 1];
                  q.cells.push(Y), Y.includes(`
`) && (q.hasLineBreak = true), E.quasis[V].value.raw.includes(`
`) && L.push({ hasLineBreak: false, cells: [] });
                }
                let M = Math.max(y.length, ...L.map((V) => V.cells.length)), j = Array.from({ length: M }).fill(0), $ = [{ cells: y }, ...L.filter((V) => V.cells.length > 0)];
                for (let { cells: V } of $.filter((q) => !q.hasLineBreak))
                  for (let [q, Y] of V.entries())
                    j[q] = Math.max(j[q], s(Y));
                return x.push(m, "`", c([u, r(u, $.map((V) => r(" | ", V.cells.map((q, Y) => V.hasLineBreak ? q : q + " ".repeat(j[Y] - s(q))))))]), u, "`"), x;
              }
            }
            function k(g, F) {
              let l = g.getValue(), E = F();
              return A(l) && (E = o([c([i, E]), i])), ["${", E, m, "}"];
            }
            function P(g, F) {
              return g.map((l) => k(l, F), "expressions");
            }
            function C(g, F) {
              return f(g, (l) => typeof l == "string" ? F ? l.replace(/(\\*)`/g, "$1$1\\`") : D(l) : l);
            }
            function D(g) {
              return g.replace(/([\\`]|\${)/g, "\\$1");
            }
            n.exports = { printTemplateLiteral: B, printTemplateExpressions: P, escapeTemplateCharacters: C, uncookTemplateElementValue: D };
          } }), wm = Z({ "src/language-js/embed/markdown.js"(e, n) {
            "use strict";
            re();
            var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: r } } = Oe(), { escapeTemplateCharacters: u } = Lt();
            function i(c, v, m) {
              let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T, A) => "\\".repeat(A.length / 2) + "`"), f = o(p), h = f !== "";
              h && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
              let w = u(m(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
              return ["`", h ? t([s, w]) : [a, r(w)], s, "`"];
            }
            function o(c) {
              let v = c.match(/^([^\S\n]*)\S/m);
              return v === null ? "" : v[1];
            }
            n.exports = i;
          } }), _m = Z({ "src/language-js/embed/css.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a, softline: r }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: o } } = Oe(), { printTemplateExpressions: c } = Lt();
            function v(p, f, h) {
              let w = p.getValue(), T = w.quasis.map((k) => k.value.raw), A = 0, S = T.reduce((k, P, C) => C === 0 ? P : k + "@prettier-placeholder-" + A++ + "-id" + P, ""), B = h(S, { parser: "scss" }, { stripTrailingHardline: true }), I = c(p, f);
              return m(B, w, I);
            }
            function m(p, f, h) {
              if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
                return "``";
              let T = d(p, h);
              if (!T)
                throw new Error("Couldn't insert all the expressions");
              return ["`", s([a, T]), r, "`"];
            }
            function d(p, f) {
              if (!t(f))
                return p;
              let h = 0, w = u(o(p), (T) => typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map((A, S) => S % 2 === 0 ? i(A) : (h++, f[A])));
              return f.length === h ? w : null;
            }
            n.exports = v;
          } }), Pm = Z({ "src/language-js/embed/graphql.js"(e, n) {
            "use strict";
            re();
            var { builders: { indent: t, join: s, hardline: a } } = Oe(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = Lt();
            function i(c, v, m) {
              let d = c.getValue(), p = d.quasis.length;
              if (p === 1 && d.quasis[0].value.raw.trim() === "")
                return "``";
              let f = u(c, v), h = [];
              for (let w = 0; w < p; w++) {
                let T = d.quasis[w], A = w === 0, S = w === p - 1, B = T.value.cooked, I = B.split(`
`), k = I.length, P = f[w], C = k > 2 && I[0].trim() === "" && I[1].trim() === "", D = k > 2 && I[k - 1].trim() === "" && I[k - 2].trim() === "", g = I.every((l) => /^\s*(?:#[^\n\r]*)?$/.test(l));
                if (!S && /#[^\n\r]*$/.test(I[k - 1]))
                  return null;
                let F = null;
                g ? F = o(I) : F = m(B, { parser: "graphql" }, { stripTrailingHardline: true }), F ? (F = r(F, false), !A && C && h.push(""), h.push(F), !S && D && h.push("")) : !A && !S && C && h.push(""), P && h.push(P);
              }
              return ["`", t([a, s(a, h)]), a, "`"];
            }
            function o(c) {
              let v = [], m = false, d = c.map((p) => p.trim());
              for (let [p, f] of d.entries())
                f !== "" && (d[p - 1] === "" && m ? v.push([a, f]) : v.push(f), m = true);
              return v.length === 0 ? null : s(a, v);
            }
            n.exports = i;
          } }), km = Z({ "src/language-js/embed/html.js"(e, n) {
            "use strict";
            re();
            var { builders: { indent: t, line: s, hardline: a, group: r }, utils: { mapDoc: u } } = Oe(), { printTemplateExpressions: i, uncookTemplateElementValue: o } = Lt(), c = 0;
            function v(m, d, p, f, h) {
              let { parser: w } = h, T = m.getValue(), A = c;
              c = c + 1 >>> 0;
              let S = (E) => "PRETTIER_HTML_PLACEHOLDER_".concat(E, "_").concat(A, "_IN_JS"), B = T.quasis.map((E, y, N) => y === N.length - 1 ? E.value.cooked : E.value.cooked + S(y)).join(""), I = i(m, d);
              if (I.length === 0 && B.trim().length === 0)
                return "``";
              let k = new RegExp(S("(\\d+)"), "g"), P = 0, C = p(B, { parser: w, __onHtmlRoot(E) {
                P = E.children.length;
              } }, { stripTrailingHardline: true }), D = u(C, (E) => {
                if (typeof E != "string")
                  return E;
                let y = [], N = E.split(k);
                for (let x = 0; x < N.length; x++) {
                  let b = N[x];
                  if (x % 2 === 0) {
                    b && (b = o(b), f.__embeddedInHtml && (b = b.replace(/<\/(script)\b/gi, "<\\/$1")), y.push(b));
                    continue;
                  }
                  let L = Number(b);
                  y.push(I[L]);
                }
                return y;
              }), g = /^\s/.test(B) ? " " : "", F = /\s$/.test(B) ? " " : "", l = f.htmlWhitespaceSensitivity === "ignore" ? a : g && F ? s : null;
              return r(l ? ["`", t([l, r(D)]), l, "`"] : ["`", g, P > 1 ? t(r(D)) : r(D), F, "`"]);
            }
            n.exports = v;
          } }), Im = Z({ "src/language-js/embed.js"(e, n) {
            "use strict";
            re();
            var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), r = wm(), u = _m(), i = Pm(), o = km();
            function c(C) {
              if (d(C) || w(C) || T(C) || p(C))
                return "css";
              if (B(C))
                return "graphql";
              if (k(C))
                return "html";
              if (f(C))
                return "angular";
              if (m(C))
                return "markdown";
            }
            function v(C, D, g, F) {
              let l = C.getValue();
              if (l.type !== "TemplateLiteral" || P(l))
                return;
              let E = c(C);
              if (!!E) {
                if (E === "markdown")
                  return r(C, D, g);
                if (E === "css")
                  return u(C, D, g);
                if (E === "graphql")
                  return i(C, D, g);
                if (E === "html" || E === "angular")
                  return o(C, D, g, F, { parser: E });
              }
            }
            function m(C) {
              let D = C.getValue(), g = C.getParentNode();
              return g && g.type === "TaggedTemplateExpression" && D.quasis.length === 1 && g.tag.type === "Identifier" && (g.tag.name === "md" || g.tag.name === "markdown");
            }
            function d(C) {
              let D = C.getValue(), g = C.getParentNode(), F = C.getParentNode(1);
              return F && D.quasis && g.type === "JSXExpressionContainer" && F.type === "JSXElement" && F.openingElement.name.name === "style" && F.openingElement.attributes.some((l) => l.name.name === "jsx") || g && g.type === "TaggedTemplateExpression" && g.tag.type === "Identifier" && g.tag.name === "css" || g && g.type === "TaggedTemplateExpression" && g.tag.type === "MemberExpression" && g.tag.object.name === "css" && (g.tag.property.name === "global" || g.tag.property.name === "resolve");
            }
            function p(C) {
              return C.match((D) => D.type === "TemplateLiteral", (D, g) => D.type === "ArrayExpression" && g === "elements", (D, g) => a(D) && D.key.type === "Identifier" && D.key.name === "styles" && g === "value", ...h);
            }
            function f(C) {
              return C.match((D) => D.type === "TemplateLiteral", (D, g) => a(D) && D.key.type === "Identifier" && D.key.name === "template" && g === "value", ...h);
            }
            var h = [(C, D) => C.type === "ObjectExpression" && D === "properties", (C, D) => C.type === "CallExpression" && C.callee.type === "Identifier" && C.callee.name === "Component" && D === "arguments", (C, D) => C.type === "Decorator" && D === "expression"];
            function w(C) {
              let D = C.getParentNode();
              if (!D || D.type !== "TaggedTemplateExpression")
                return false;
              let g = D.tag.type === "ParenthesizedExpression" ? D.tag.expression : D.tag;
              switch (g.type) {
                case "MemberExpression":
                  return A(g.object) || S(g);
                case "CallExpression":
                  return A(g.callee) || g.callee.type === "MemberExpression" && (g.callee.object.type === "MemberExpression" && (A(g.callee.object.object) || S(g.callee.object)) || g.callee.object.type === "CallExpression" && A(g.callee.object.callee));
                case "Identifier":
                  return g.name === "css";
                default:
                  return false;
              }
            }
            function T(C) {
              let D = C.getParentNode(), g = C.getParentNode(1);
              return g && D.type === "JSXExpressionContainer" && g.type === "JSXAttribute" && g.name.type === "JSXIdentifier" && g.name.name === "css";
            }
            function A(C) {
              return C.type === "Identifier" && C.name === "styled";
            }
            function S(C) {
              return /^[A-Z]/.test(C.object.name) && C.property.name === "extend";
            }
            function B(C) {
              let D = C.getValue(), g = C.getParentNode();
              return I(D, "GraphQL") || g && (g.type === "TaggedTemplateExpression" && (g.tag.type === "MemberExpression" && g.tag.object.name === "graphql" && g.tag.property.name === "experimental" || g.tag.type === "Identifier" && (g.tag.name === "gql" || g.tag.name === "graphql")) || g.type === "CallExpression" && g.callee.type === "Identifier" && g.callee.name === "graphql");
            }
            function I(C, D) {
              return t(C, s.Block | s.Leading, (g) => {
                let { value: F } = g;
                return F === " ".concat(D, " ");
              });
            }
            function k(C) {
              return I(C.getValue(), "HTML") || C.match((D) => D.type === "TemplateLiteral", (D, g) => D.type === "TaggedTemplateExpression" && D.tag.type === "Identifier" && D.tag.name === "html" && g === "quasi");
            }
            function P(C) {
              let { quasis: D } = C;
              return D.some((g) => {
                let { value: { cooked: F } } = g;
                return F === null;
              });
            }
            n.exports = v;
          } }), Lm = Z({ "src/language-js/clean.js"(e, n) {
            "use strict";
            re();
            var t = It(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
              for (let i of u.quasis)
                delete i.value;
            };
            function r(u, i, o) {
              if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
                return null;
              if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((m) => m.name.name === "jsx"))
                for (let { type: m, expression: d } of i.children)
                  m === "JSXExpressionContainer" && d.type === "TemplateLiteral" && a(d);
              u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
              let c = u.expression || u.callee;
              if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
                let m = u.expression.arguments[0].properties;
                for (let [d, p] of i.expression.arguments[0].properties.entries())
                  switch (m[d].key.name) {
                    case "styles":
                      p.value.type === "ArrayExpression" && a(p.value.elements[0]);
                      break;
                    case "template":
                      p.value.type === "TemplateLiteral" && a(p.value);
                      break;
                  }
              }
              if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
                var v;
                (((v = u.leadingComments) === null || v === void 0 ? void 0 : v.some((d) => t(d) && ["GraphQL", "HTML"].some((p) => d.value === " ".concat(p, " ")))) || o.type === "CallExpression" && o.callee.name === "graphql" || !u.leadingComments) && a(i);
              }
              if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
                return i.types[0];
            }
            r.ignoredProperties = s, n.exports = r;
          } }), Ha = {};
          Ut(Ha, { EOL: () => Pn, arch: () => jm, cpus: () => Ya, default: () => ro, endianness: () => Ga, freemem: () => Xa, getNetworkInterfaces: () => to, hostname: () => Ja, loadavg: () => Ua, networkInterfaces: () => eo, platform: () => Om, release: () => Za, tmpDir: () => wn, tmpdir: () => _n, totalmem: () => Ka, type: () => Qa, uptime: () => za });
          function Ga() {
            if (typeof Sr > "u") {
              var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
              if (n[0] = 1, n[1] = 2, t[0] === 258)
                Sr = "BE";
              else if (t[0] === 513)
                Sr = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return Sr;
          }
          function Ja() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function Ua() {
            return [];
          }
          function za() {
            return 0;
          }
          function Xa() {
            return Number.MAX_VALUE;
          }
          function Ka() {
            return Number.MAX_VALUE;
          }
          function Ya() {
            return [];
          }
          function Qa() {
            return "Browser";
          }
          function Za() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function eo() {
          }
          function to() {
          }
          function jm() {
            return "javascript";
          }
          function Om() {
            return "browser";
          }
          function wn() {
            return "/tmp";
          }
          var Sr, _n, Pn, ro, qm = mt({ "node-modules-polyfills:os"() {
            re(), _n = wn, Pn = `
`, ro = { EOL: Pn, tmpdir: _n, tmpDir: wn, networkInterfaces: eo, getNetworkInterfaces: to, release: Za, type: Qa, cpus: Ya, totalmem: Ka, freemem: Xa, uptime: za, loadavg: Ua, hostname: Ja, endianness: Ga };
          } }), Mm = Z({ "node-modules-polyfills-commonjs:os"(e, n) {
            re();
            var t = (qm(), lt(Ha));
            if (t && t.default) {
              n.exports = t.default;
              for (let s in t)
                n.exports[s] = t[s];
            } else
              t && (n.exports = t);
          } }), Rm = Z({ "node_modules/detect-newline/index.js"(e, n) {
            "use strict";
            re();
            var t = (s) => {
              if (typeof s != "string")
                throw new TypeError("Expected a string");
              let a = s.match(/(?:\r?\n)/g) || [];
              if (a.length === 0)
                return;
              let r = a.filter((i) => i === `\r
`).length, u = a.length - r;
              return r > u ? `\r
` : `
`;
            };
            n.exports = t, n.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
          } }), Vm = Z({ "node_modules/jest-docblock/build/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p, e.parse = h, e.parseWithComments = w, e.print = T, e.strip = f;
            function n() {
              let S = Mm();
              return n = function() {
                return S;
              }, S;
            }
            function t() {
              let S = s(Rm());
              return t = function() {
                return S;
              }, S;
            }
            function s(S) {
              return S && S.__esModule ? S : { default: S };
            }
            var a = /\*\/$/, r = /^\/\*\*/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, o = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, v = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, m = /(\r?\n|^) *\* ?/g, d = [];
            function p(S) {
              let B = S.match(u);
              return B ? B[0].trimLeft() : "";
            }
            function f(S) {
              let B = S.match(u);
              return B && B[0] ? S.substring(B[0].length) : S;
            }
            function h(S) {
              return w(S).pragmas;
            }
            function w(S) {
              let B = (0, t().default)(S) || n().EOL;
              S = S.replace(r, "").replace(a, "").replace(m, "$1");
              let I = "";
              for (; I !== S; )
                I = S, S = S.replace(c, "".concat(B, "$1 $2").concat(B));
              S = S.replace(o, "").trimRight();
              let k = /* @__PURE__ */ Object.create(null), P = S.replace(v, "").replace(o, "").trimRight(), C;
              for (; C = v.exec(S); ) {
                let D = C[2].replace(i, "");
                typeof k[C[1]] == "string" || Array.isArray(k[C[1]]) ? k[C[1]] = d.concat(k[C[1]], D) : k[C[1]] = D;
              }
              return { comments: P, pragmas: k };
            }
            function T(S) {
              let { comments: B = "", pragmas: I = {} } = S, k = (0, t().default)(B) || n().EOL, P = "/**", C = " *", D = " */", g = Object.keys(I), F = g.map((E) => A(E, I[E])).reduce((E, y) => E.concat(y), []).map((E) => C + " " + E + k).join("");
              if (!B) {
                if (g.length === 0)
                  return "";
                if (g.length === 1 && !Array.isArray(I[g[0]])) {
                  let E = I[g[0]];
                  return "".concat(P, " ").concat(A(g[0], E)[0]).concat(D);
                }
              }
              let l = B.split(k).map((E) => "".concat(C, " ").concat(E)).join(k) + k;
              return P + k + (B ? l : "") + (B && g.length ? C + k : "") + F + D;
            }
            function A(S, B) {
              return d.concat(B).map((I) => "@".concat(S, " ").concat(I).trim());
            }
          } }), Wm = Z({ "src/language-js/utils/get-shebang.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              if (!s.startsWith("#!"))
                return "";
              let a = s.indexOf(`
`);
              return a === -1 ? s : s.slice(0, a);
            }
            n.exports = t;
          } }), no = Z({ "src/language-js/pragma.js"(e, n) {
            "use strict";
            re();
            var { parseWithComments: t, strip: s, extract: a, print: r } = Vm(), { normalizeEndOfLine: u } = jn(), i = Wm();
            function o(m) {
              let d = i(m);
              d && (m = m.slice(d.length + 1));
              let p = a(m), { pragmas: f, comments: h } = t(p);
              return { shebang: d, text: m, pragmas: f, comments: h };
            }
            function c(m) {
              let d = Object.keys(o(m).pragmas);
              return d.includes("prettier") || d.includes("format");
            }
            function v(m) {
              let { shebang: d, text: p, pragmas: f, comments: h } = o(m), w = s(p), T = r({ pragmas: Object.assign({ format: "" }, f), comments: h.trimStart() });
              return (d ? "".concat(d, `
`) : "") + u(T) + (w.startsWith(`
`) ? `
` : `

`) + w;
            }
            n.exports = { hasPragma: c, insertPragma: v };
          } }), uo = Z({ "src/language-js/comments.js"(e, n) {
            "use strict";
            re();
            var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: o, addDanglingComment: c, getNextNonSpaceNonCommentCharacterIndex: v, isNonEmptyArray: m } = Ue(), { getFunctionParameters: d, isPrettierIgnoreComment: p, isJsxNode: f, hasFlowShorthandAnnotationComment: h, hasFlowAnnotationComment: w, hasIgnoreComment: T, isCallLikeExpression: A, getCallArguments: S, isCallExpression: B, isMemberExpression: I, isObjectProperty: k, isLineComment: P, getComments: C, CommentCheckFlags: D, markerForIfWithoutBlockAndSameLineComment: g } = Ke(), { locStart: F, locEnd: l } = st(), E = It();
            function y(me) {
              return [ve, De, q, j, $, V, Q, Ae, U, ge, Ne, ke, te, ie, G].some((_) => _(me));
            }
            function N(me) {
              return [M, De, Y, Ne, j, $, V, Q, ie, z, le, ge, de, G, he].some((_) => _(me));
            }
            function x(me) {
              return [ve, j, $, H, ue, te, ge, X, W, K, G, ae].some((_) => _(me));
            }
            function b(me, _) {
              let J = (me.body || me.properties).find((ne) => {
                let { type: Ee } = ne;
                return Ee !== "EmptyStatement";
              });
              J ? i(J, _) : c(me, _);
            }
            function L(me, _) {
              me.type === "BlockStatement" ? b(me, _) : i(me, _);
            }
            function M(me) {
              let { comment: _, followingNode: J } = me;
              return J && Ie(_) ? (i(J, _), true) : false;
            }
            function j(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me;
              if ((ne == null ? void 0 : ne.type) !== "IfStatement" || !Ee)
                return false;
              if (r(We, _, l) === ")")
                return o(J, _), true;
              if (J === ne.consequent && Ee === ne.alternate) {
                if (J.type === "BlockStatement")
                  o(J, _);
                else {
                  let Pe = _.type === "SingleLine" || _.loc.start.line === _.loc.end.line, Se = _.loc.start.line === J.loc.start.line;
                  Pe && Se ? c(J, _, g) : c(ne, _);
                }
                return true;
              }
              return Ee.type === "BlockStatement" ? (b(Ee, _), true) : Ee.type === "IfStatement" ? (L(Ee.consequent, _), true) : ne.consequent === Ee ? (i(Ee, _), true) : false;
            }
            function $(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me;
              return (ne == null ? void 0 : ne.type) !== "WhileStatement" || !Ee ? false : r(We, _, l) === ")" ? (o(J, _), true) : Ee.type === "BlockStatement" ? (b(Ee, _), true) : ne.body === Ee ? (i(Ee, _), true) : false;
            }
            function V(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
              return (ne == null ? void 0 : ne.type) !== "TryStatement" && (ne == null ? void 0 : ne.type) !== "CatchClause" || !Ee ? false : ne.type === "CatchClause" && J ? (o(J, _), true) : Ee.type === "BlockStatement" ? (b(Ee, _), true) : Ee.type === "TryStatement" ? (L(Ee.finalizer, _), true) : Ee.type === "CatchClause" ? (L(Ee.body, _), true) : false;
            }
            function q(me) {
              let { comment: _, enclosingNode: J, followingNode: ne } = me;
              return I(J) && (ne == null ? void 0 : ne.type) === "Identifier" ? (i(J, _), true) : false;
            }
            function Y(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me, Be = J && !u(We, l(J), F(_));
              return (!J || !Be) && ((ne == null ? void 0 : ne.type) === "ConditionalExpression" || (ne == null ? void 0 : ne.type) === "TSConditionalType") && Ee ? (i(Ee, _), true) : false;
            }
            function H(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne } = me;
              return k(ne) && ne.shorthand && ne.key === J && ne.value.type === "AssignmentPattern" ? (o(ne.value.left, _), true) : false;
            }
            var R = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
            function Q(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
              if (R.has(ne == null ? void 0 : ne.type)) {
                if (m(ne.decorators) && !(Ee && Ee.type === "Decorator"))
                  return o(t(ne.decorators), _), true;
                if (ne.body && Ee === ne.body)
                  return b(ne.body, _), true;
                if (Ee) {
                  if (ne.superClass && Ee === ne.superClass && J && (J === ne.id || J === ne.typeParameters))
                    return o(J, _), true;
                  for (let We of ["implements", "extends", "mixins"])
                    if (ne[We] && Ee === ne[We][0])
                      return J && (J === ne.id || J === ne.typeParameters || J === ne.superClass) ? o(J, _) : c(ne, _, We), true;
                }
              }
              return false;
            }
            var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
            function te(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, text: Ee } = me;
              return ne && J && r(Ee, _, l) === "(" && (ne.type === "Property" || ne.type === "TSDeclareMethod" || ne.type === "TSAbstractMethodDefinition") && J.type === "Identifier" && ne.key === J && r(Ee, J, l) !== ":" || (J == null ? void 0 : J.type) === "Decorator" && ee.has(ne == null ? void 0 : ne.type) ? (o(J, _), true) : false;
            }
            var oe = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
            function W(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, text: Ee } = me;
              return r(Ee, _, l) !== "(" ? false : J && oe.has(ne == null ? void 0 : ne.type) ? (o(J, _), true) : false;
            }
            function X(me) {
              let { comment: _, enclosingNode: J, text: ne } = me;
              if ((J == null ? void 0 : J.type) !== "ArrowFunctionExpression")
                return false;
              let Ee = v(ne, _, l);
              return Ee !== false && ne.slice(Ee, Ee + 2) === "=>" ? (c(J, _), true) : false;
            }
            function ue(me) {
              let { comment: _, enclosingNode: J, text: ne } = me;
              return r(ne, _, l) !== ")" ? false : J && (ye(J) && d(J).length === 0 || A(J) && S(J).length === 0) ? (c(J, _), true) : ((J == null ? void 0 : J.type) === "MethodDefinition" || (J == null ? void 0 : J.type) === "TSAbstractMethodDefinition") && d(J.value).length === 0 ? (c(J.value, _), true) : false;
            }
            function De(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me;
              if ((J == null ? void 0 : J.type) === "FunctionTypeParam" && (ne == null ? void 0 : ne.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((J == null ? void 0 : J.type) === "Identifier" || (J == null ? void 0 : J.type) === "AssignmentPattern") && ne && ye(ne) && r(We, _, l) === ")")
                return o(J, _), true;
              if ((ne == null ? void 0 : ne.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
                let Be = (() => {
                  let Pe = d(ne);
                  if (Pe.length > 0)
                    return a(We, l(t(Pe)));
                  let Se = a(We, l(ne.id));
                  return Se !== false && a(We, Se + 1);
                })();
                if (F(_) > Be)
                  return b(Ee, _), true;
              }
              return false;
            }
            function ie(me) {
              let { comment: _, enclosingNode: J } = me;
              return (J == null ? void 0 : J.type) === "LabeledStatement" ? (i(J, _), true) : false;
            }
            function G(me) {
              let { comment: _, enclosingNode: J } = me;
              return ((J == null ? void 0 : J.type) === "ContinueStatement" || (J == null ? void 0 : J.type) === "BreakStatement") && !J.label ? (o(J, _), true) : false;
            }
            function z(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne } = me;
              return B(ne) && J && ne.callee === J && ne.arguments.length > 0 ? (i(ne.arguments[0], _), true) : false;
            }
            function U(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
              return (ne == null ? void 0 : ne.type) === "UnionTypeAnnotation" || (ne == null ? void 0 : ne.type) === "TSUnionType" ? (p(_) && (Ee.prettierIgnore = true, _.unignore = true), J ? (o(J, _), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p(_) && (Ee.types[0].prettierIgnore = true, _.unignore = true), false);
            }
            function le(me) {
              let { comment: _, enclosingNode: J } = me;
              return k(J) ? (i(J, _), true) : false;
            }
            function ge(me) {
              let { comment: _, enclosingNode: J, followingNode: ne, ast: Ee, isLastComment: We } = me;
              return Ee && Ee.body && Ee.body.length === 0 ? (We ? c(Ee, _) : i(Ee, _), true) : (J == null ? void 0 : J.type) === "Program" && (J == null ? void 0 : J.body.length) === 0 && !m(J.directives) ? (We ? c(J, _) : i(J, _), true) : (ne == null ? void 0 : ne.type) === "Program" && (ne == null ? void 0 : ne.body.length) === 0 && (J == null ? void 0 : J.type) === "ModuleExpression" ? (c(ne, _), true) : false;
            }
            function Ae(me) {
              let { comment: _, enclosingNode: J } = me;
              return (J == null ? void 0 : J.type) === "ForInStatement" || (J == null ? void 0 : J.type) === "ForOfStatement" ? (i(J, _), true) : false;
            }
            function Ne(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, text: Ee } = me;
              if ((ne == null ? void 0 : ne.type) === "ImportSpecifier" || (ne == null ? void 0 : ne.type) === "ExportSpecifier")
                return i(ne, _), true;
              let We = (J == null ? void 0 : J.type) === "ImportSpecifier" && (ne == null ? void 0 : ne.type) === "ImportDeclaration", Be = (J == null ? void 0 : J.type) === "ExportSpecifier" && (ne == null ? void 0 : ne.type) === "ExportNamedDeclaration";
              return (We || Be) && s(Ee, l(_)) ? (o(J, _), true) : false;
            }
            function ke(me) {
              let { comment: _, enclosingNode: J } = me;
              return (J == null ? void 0 : J.type) === "AssignmentPattern" ? (i(J, _), true) : false;
            }
            var ce = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
            function de(me) {
              let { comment: _, enclosingNode: J, followingNode: ne } = me;
              return ce.has(J == null ? void 0 : J.type) && ne && (pe.has(ne.type) || E(_)) ? (i(ne, _), true) : false;
            }
            function ae(me) {
              let { comment: _, enclosingNode: J, followingNode: ne, text: Ee } = me;
              return !ne && ((J == null ? void 0 : J.type) === "TSMethodSignature" || (J == null ? void 0 : J.type) === "TSDeclareFunction" || (J == null ? void 0 : J.type) === "TSAbstractMethodDefinition") && r(Ee, _, l) === ";" ? (o(J, _), true) : false;
            }
            function ve(me) {
              let { comment: _, enclosingNode: J, followingNode: ne } = me;
              if (p(_) && (J == null ? void 0 : J.type) === "TSMappedType" && (ne == null ? void 0 : ne.type) === "TSTypeParameter" && ne.constraint)
                return J.prettierIgnore = true, _.unignore = true, true;
            }
            function K(me) {
              let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
              return (ne == null ? void 0 : ne.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i(Ee.name, _), true) : (J == null ? void 0 : J.type) === "TSTypeParameter" && J.constraint ? (o(J.constraint, _), true) : false;
            }
            function he(me) {
              let { comment: _, enclosingNode: J, followingNode: ne } = me;
              return !J || J.type !== "SwitchCase" || J.test ? false : (ne.type === "BlockStatement" && P(_) ? b(ne, _) : c(J, _), true);
            }
            function ye(me) {
              return me.type === "ArrowFunctionExpression" || me.type === "FunctionExpression" || me.type === "FunctionDeclaration" || me.type === "ObjectMethod" || me.type === "ClassMethod" || me.type === "TSDeclareFunction" || me.type === "TSCallSignatureDeclaration" || me.type === "TSConstructSignatureDeclaration" || me.type === "TSMethodSignature" || me.type === "TSConstructorType" || me.type === "TSFunctionType" || me.type === "TSDeclareMethod";
            }
            function Ce(me, _) {
              if ((_.parser === "typescript" || _.parser === "flow" || _.parser === "acorn" || _.parser === "espree" || _.parser === "meriyah" || _.parser === "__babel_estree") && me.type === "MethodDefinition" && me.value && me.value.type === "FunctionExpression" && d(me.value).length === 0 && !me.value.returnType && !m(me.value.typeParameters) && me.value.body)
                return [...me.decorators || [], me.key, me.value.body];
            }
            function Ie(me) {
              return E(me) && me.value[0] === "*" && /@type\b/.test(me.value);
            }
            function Fe(me) {
              let _ = me.getValue(), J = me.getParentNode(), ne = (Ee) => w(C(Ee, D.Leading)) || w(C(Ee, D.Trailing));
              return (_ && (f(_) || h(_) || B(J) && ne(_)) || J && (J.type === "JSXSpreadAttribute" || J.type === "JSXSpreadChild" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || (J.type === "ClassDeclaration" || J.type === "ClassExpression") && J.superClass === _)) && (!T(me) || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType");
            }
            n.exports = { handleOwnLineComment: y, handleEndOfLineComment: N, handleRemainingComment: x, isTypeCastComment: Ie, getCommentChildNodes: Ce, willPrintOwnComments: Fe };
          } }), jt = Z({ "src/language-js/needs-parens.js"(e, n) {
            "use strict";
            re();
            var t = it(), s = Rn(), { getFunctionParameters: a, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: o, isBitwiseOperator: c, startsWithNoLookaheadToken: v, shouldFlatten: m, getPrecedence: d, isCallExpression: p, isMemberExpression: f, isObjectProperty: h } = Ke();
            function w(P, C) {
              let D = P.getParentNode();
              if (!D)
                return false;
              let g = P.getName(), F = P.getNode();
              if (C.__isInHtmlInterpolation && !C.bracketSpacing && B(F) && I(P))
                return true;
              if (T(F))
                return false;
              if (C.parser !== "flow" && u(P.getValue()))
                return true;
              if (F.type === "Identifier")
                return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(F.name) || g === "left" && F.name === "async" && D.type === "ForOfStatement" && !D.await);
              switch (D.type) {
                case "ParenthesizedExpression":
                  return false;
                case "ClassDeclaration":
                case "ClassExpression": {
                  if (g === "superClass" && (F.type === "ArrowFunctionExpression" || F.type === "AssignmentExpression" || F.type === "AwaitExpression" || F.type === "BinaryExpression" || F.type === "ConditionalExpression" || F.type === "LogicalExpression" || F.type === "NewExpression" || F.type === "ObjectExpression" || F.type === "SequenceExpression" || F.type === "TaggedTemplateExpression" || F.type === "UnaryExpression" || F.type === "UpdateExpression" || F.type === "YieldExpression" || F.type === "TSNonNullExpression"))
                    return true;
                  break;
                }
                case "ExportDefaultDeclaration":
                  return k(P, C) || F.type === "SequenceExpression";
                case "Decorator": {
                  if (g === "expression") {
                    let l = false, E = false, y = F;
                    for (; y; )
                      switch (y.type) {
                        case "MemberExpression":
                          E = true, y = y.object;
                          break;
                        case "CallExpression":
                          if (E || l)
                            return C.parser !== "typescript";
                          l = true, y = y.callee;
                          break;
                        case "Identifier":
                          return false;
                        case "TaggedTemplateExpression":
                          return C.parser !== "typescript";
                        default:
                          return true;
                      }
                    return true;
                  }
                  break;
                }
                case "ExpressionStatement": {
                  if (v(F, true))
                    return true;
                  break;
                }
                case "ArrowFunctionExpression": {
                  if (g === "body" && F.type !== "SequenceExpression" && v(F, false))
                    return true;
                  break;
                }
              }
              switch (F.type) {
                case "UpdateExpression":
                  if (D.type === "UnaryExpression")
                    return F.prefix && (F.operator === "++" && D.operator === "+" || F.operator === "--" && D.operator === "-");
                case "UnaryExpression":
                  switch (D.type) {
                    case "UnaryExpression":
                      return F.operator === D.operator && (F.operator === "+" || F.operator === "-");
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return g === "object";
                    case "TaggedTemplateExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return g === "callee";
                    case "BinaryExpression":
                      return g === "left" && D.operator === "**";
                    case "TSNonNullExpression":
                      return true;
                    default:
                      return false;
                  }
                case "BinaryExpression": {
                  if (D.type === "UpdateExpression" || F.operator === "in" && A(P))
                    return true;
                  if (F.operator === "|>" && F.extra && F.extra.parenthesized) {
                    let l = P.getParentNode(1);
                    if (l.type === "BinaryExpression" && l.operator === "|>")
                      return true;
                  }
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "LogicalExpression":
                  switch (D.type) {
                    case "TSAsExpression":
                      return F.type !== "TSAsExpression";
                    case "ConditionalExpression":
                      return F.type === "TSAsExpression";
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                      return g === "callee";
                    case "ClassExpression":
                    case "ClassDeclaration":
                      return g === "superClass";
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return g === "object";
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                      return g === "left" && (F.type === "TSTypeAssertion" || F.type === "TSAsExpression");
                    case "LogicalExpression":
                      if (F.type === "LogicalExpression")
                        return D.operator !== F.operator;
                    case "BinaryExpression": {
                      let { operator: l, type: E } = F;
                      if (!l && E !== "TSTypeAssertion")
                        return true;
                      let y = d(l), N = D.operator, x = d(N);
                      return x > y || g === "right" && x === y || x === y && !m(N, l) ? true : x < y && l === "%" ? N === "+" || N === "-" : !!c(N);
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (D.type) {
                    case "ReturnStatement":
                      return false;
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return g !== "expression";
                    case "ArrowFunctionExpression":
                      return g !== "body";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  if (D.type === "UnaryExpression" || D.type === "AwaitExpression" || D.type === "TSAsExpression" || D.type === "TSNonNullExpression")
                    return true;
                case "AwaitExpression":
                  switch (D.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return g === "object";
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return g === "callee";
                    case "ConditionalExpression":
                      return g === "test";
                    case "BinaryExpression":
                      return !(!F.argument && D.operator === "|>");
                    default:
                      return false;
                  }
                case "TSConditionalType":
                  if (g === "extendsType" && D.type === "TSConditionalType")
                    return true;
                case "TSFunctionType":
                case "TSConstructorType":
                  if (g === "checkType" && D.type === "TSConditionalType")
                    return true;
                case "TSUnionType":
                case "TSIntersectionType":
                  if ((D.type === "TSUnionType" || D.type === "TSIntersectionType") && D.types.length > 1 && (!F.types || F.types.length > 1))
                    return true;
                case "TSInferType":
                  if (F.type === "TSInferType" && D.type === "TSRestType")
                    return false;
                case "TSTypeOperator":
                  return D.type === "TSArrayType" || D.type === "TSOptionalType" || D.type === "TSRestType" || g === "objectType" && D.type === "TSIndexedAccessType" || D.type === "TSTypeOperator" || D.type === "TSTypeAnnotation" && P.getParentNode(1).type.startsWith("TSJSDoc");
                case "ArrayTypeAnnotation":
                  return D.type === "NullableTypeAnnotation";
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation":
                  return D.type === "ArrayTypeAnnotation" || D.type === "NullableTypeAnnotation" || D.type === "IntersectionTypeAnnotation" || D.type === "UnionTypeAnnotation" || g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                case "NullableTypeAnnotation":
                  return D.type === "ArrayTypeAnnotation" || g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                case "FunctionTypeAnnotation": {
                  let l = D.type === "NullableTypeAnnotation" ? P.getParentNode(1) : D;
                  return l.type === "UnionTypeAnnotation" || l.type === "IntersectionTypeAnnotation" || l.type === "ArrayTypeAnnotation" || g === "objectType" && (l.type === "IndexedAccessType" || l.type === "OptionalIndexedAccessType") || l.type === "NullableTypeAnnotation" || D.type === "FunctionTypeParam" && D.name === null && a(F).some((E) => E.typeAnnotation && E.typeAnnotation.type === "NullableTypeAnnotation");
                }
                case "OptionalIndexedAccessType":
                  return g === "objectType" && D.type === "IndexedAccessType";
                case "TypeofTypeAnnotation":
                  return g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                  if (typeof F.value == "string" && D.type === "ExpressionStatement" && !D.directive) {
                    let l = P.getParentNode(1);
                    return l.type === "Program" || l.type === "BlockStatement";
                  }
                  return g === "object" && D.type === "MemberExpression" && typeof F.value == "number";
                case "AssignmentExpression": {
                  let l = P.getParentNode(1);
                  return g === "body" && D.type === "ArrowFunctionExpression" ? true : g === "key" && (D.type === "ClassProperty" || D.type === "PropertyDefinition") && D.computed || (g === "init" || g === "update") && D.type === "ForStatement" ? false : D.type === "ExpressionStatement" ? F.left.type === "ObjectPattern" : !(g === "key" && D.type === "TSPropertySignature" || D.type === "AssignmentExpression" || D.type === "SequenceExpression" && l && l.type === "ForStatement" && (l.init === D || l.update === D) || g === "value" && D.type === "Property" && l && l.type === "ObjectPattern" && l.properties.includes(D) || D.type === "NGChainedExpression");
                }
                case "ConditionalExpression":
                  switch (D.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return g === "callee";
                    case "ConditionalExpression":
                      return g === "test";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return g === "object";
                    default:
                      return false;
                  }
                case "FunctionExpression":
                  switch (D.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return g === "callee";
                    case "TaggedTemplateExpression":
                      return true;
                    default:
                      return false;
                  }
                case "ArrowFunctionExpression":
                  switch (D.type) {
                    case "BinaryExpression":
                      return D.operator !== "|>" || F.extra && F.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return g === "callee";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return g === "object";
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                      return true;
                    case "ConditionalExpression":
                      return g === "test";
                    default:
                      return false;
                  }
                case "ClassExpression":
                  if (s(F.decorators))
                    return true;
                  switch (D.type) {
                    case "NewExpression":
                      return g === "callee";
                    default:
                      return false;
                  }
                case "OptionalMemberExpression":
                case "OptionalCallExpression": {
                  let l = P.getParentNode(1);
                  if (g === "object" && D.type === "MemberExpression" || g === "callee" && (D.type === "CallExpression" || D.type === "NewExpression") || D.type === "TSNonNullExpression" && l.type === "MemberExpression" && l.object === D)
                    return true;
                }
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  if (g === "callee" && (D.type === "BindExpression" || D.type === "NewExpression")) {
                    let l = F;
                    for (; l; )
                      switch (l.type) {
                        case "CallExpression":
                        case "OptionalCallExpression":
                          return true;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                          l = l.object;
                          break;
                        case "TaggedTemplateExpression":
                          l = l.tag;
                          break;
                        case "TSNonNullExpression":
                          l = l.expression;
                          break;
                        default:
                          return false;
                      }
                  }
                  return false;
                case "BindExpression":
                  return g === "callee" && (D.type === "BindExpression" || D.type === "NewExpression") || g === "object" && f(D);
                case "NGPipeExpression":
                  return !(D.type === "NGRoot" || D.type === "NGMicrosyntaxExpression" || D.type === "ObjectProperty" && !(F.extra && F.extra.parenthesized) || D.type === "ArrayExpression" || p(D) && D.arguments[g] === F || g === "right" && D.type === "NGPipeExpression" || g === "property" && D.type === "MemberExpression" || D.type === "AssignmentExpression");
                case "JSXFragment":
                case "JSXElement":
                  return g === "callee" || g === "left" && D.type === "BinaryExpression" && D.operator === "<" || D.type !== "ArrayExpression" && D.type !== "ArrowFunctionExpression" && D.type !== "AssignmentExpression" && D.type !== "AssignmentPattern" && D.type !== "BinaryExpression" && D.type !== "NewExpression" && D.type !== "ConditionalExpression" && D.type !== "ExpressionStatement" && D.type !== "JsExpressionRoot" && D.type !== "JSXAttribute" && D.type !== "JSXElement" && D.type !== "JSXExpressionContainer" && D.type !== "JSXFragment" && D.type !== "LogicalExpression" && !p(D) && !h(D) && D.type !== "ReturnStatement" && D.type !== "ThrowStatement" && D.type !== "TypeCastExpression" && D.type !== "VariableDeclarator" && D.type !== "YieldExpression";
                case "TypeAnnotation":
                  return g === "returnType" && D.type === "ArrowFunctionExpression" && S(F);
              }
              return false;
            }
            function T(P) {
              return P.type === "BlockStatement" || P.type === "BreakStatement" || P.type === "ClassBody" || P.type === "ClassDeclaration" || P.type === "ClassMethod" || P.type === "ClassProperty" || P.type === "PropertyDefinition" || P.type === "ClassPrivateProperty" || P.type === "ContinueStatement" || P.type === "DebuggerStatement" || P.type === "DeclareClass" || P.type === "DeclareExportAllDeclaration" || P.type === "DeclareExportDeclaration" || P.type === "DeclareFunction" || P.type === "DeclareInterface" || P.type === "DeclareModule" || P.type === "DeclareModuleExports" || P.type === "DeclareVariable" || P.type === "DoWhileStatement" || P.type === "EnumDeclaration" || P.type === "ExportAllDeclaration" || P.type === "ExportDefaultDeclaration" || P.type === "ExportNamedDeclaration" || P.type === "ExpressionStatement" || P.type === "ForInStatement" || P.type === "ForOfStatement" || P.type === "ForStatement" || P.type === "FunctionDeclaration" || P.type === "IfStatement" || P.type === "ImportDeclaration" || P.type === "InterfaceDeclaration" || P.type === "LabeledStatement" || P.type === "MethodDefinition" || P.type === "ReturnStatement" || P.type === "SwitchStatement" || P.type === "ThrowStatement" || P.type === "TryStatement" || P.type === "TSDeclareFunction" || P.type === "TSEnumDeclaration" || P.type === "TSImportEqualsDeclaration" || P.type === "TSInterfaceDeclaration" || P.type === "TSModuleDeclaration" || P.type === "TSNamespaceExportDeclaration" || P.type === "TypeAlias" || P.type === "VariableDeclaration" || P.type === "WhileStatement" || P.type === "WithStatement";
            }
            function A(P) {
              let C = 0, D = P.getValue();
              for (; D; ) {
                let g = P.getParentNode(C++);
                if (g && g.type === "ForStatement" && g.init === D)
                  return true;
                D = g;
              }
              return false;
            }
            function S(P) {
              return o(P, (C) => C.type === "ObjectTypeAnnotation" && o(C, (D) => D.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }
            function B(P) {
              switch (P.type) {
                case "ObjectExpression":
                  return true;
                default:
                  return false;
              }
            }
            function I(P) {
              let C = P.getValue(), D = P.getParentNode(), g = P.getName();
              switch (D.type) {
                case "NGPipeExpression":
                  if (typeof g == "number" && D.arguments[g] === C && D.arguments.length - 1 === g)
                    return P.callParent(I);
                  break;
                case "ObjectProperty":
                  if (g === "value") {
                    let F = P.getParentNode(1);
                    return t(F.properties) === D;
                  }
                  break;
                case "BinaryExpression":
                case "LogicalExpression":
                  if (g === "right")
                    return P.callParent(I);
                  break;
                case "ConditionalExpression":
                  if (g === "alternate")
                    return P.callParent(I);
                  break;
                case "UnaryExpression":
                  if (D.prefix)
                    return P.callParent(I);
                  break;
              }
              return false;
            }
            function k(P, C) {
              let D = P.getValue(), g = P.getParentNode();
              return D.type === "FunctionExpression" || D.type === "ClassExpression" ? g.type === "ExportDefaultDeclaration" || !w(P, C) : !i(D) || g.type !== "ExportDefaultDeclaration" && w(P, C) ? false : P.call((F) => k(F, C), ...r(P, D));
            }
            n.exports = w;
          } }), so = Z({ "src/language-js/print-preprocess.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              switch (a.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression":
                case "__vue_ts_expression":
                  return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
                default:
                  return s;
              }
            }
            n.exports = t;
          } }), $m = Z({ "src/language-js/print/html-binding.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, line: s, group: a, softline: r, indent: u } } = Oe();
            function i(c, v, m) {
              let d = c.getValue();
              if (v.__onHtmlBindingRoot && c.getName() === null && v.__onHtmlBindingRoot(d, v), d.type === "File") {
                if (v.__isVueForBindingLeft)
                  return c.call((p) => {
                    let f = t([",", s], p.map(m, "params")), { params: h } = p.getValue();
                    return h.length === 1 ? f : ["(", u([r, a(f)]), r, ")"];
                  }, "program", "body", 0);
                if (v.__isVueBindings)
                  return c.call((p) => t([",", s], p.map(m, "params")), "program", "body", 0);
              }
            }
            function o(c) {
              switch (c.type) {
                case "MemberExpression":
                  switch (c.property.type) {
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                      return o(c.object);
                  }
                  return false;
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = { isVueEventBindingExpression: o, printHtmlBinding: i };
          } }), Jn = Z({ "src/language-js/print/binaryish.js"(e, n) {
            "use strict";
            re();
            var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a, line: r, softline: u, group: i, indent: o, align: c, ifBreak: v, indentIfBreak: m }, utils: { cleanDoc: d, getDocParts: p, isConcat: f } } = Oe(), { hasLeadingOwnLineComment: h, isBinaryish: w, isJsxNode: T, shouldFlatten: A, hasComment: S, CommentCheckFlags: B, isCallExpression: I, isMemberExpression: k, isObjectProperty: P, isEnabledHackPipeline: C } = Ke(), D = 0;
            function g(E, y, N) {
              let x = E.getValue(), b = E.getParentNode(), L = E.getParentNode(1), M = x !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), j = C(y) && x.operator === "|>", $ = F(E, N, y, false, M);
              if (M)
                return $;
              if (j)
                return i($);
              if (I(b) && b.callee === x || b.type === "UnaryExpression" || k(b) && !b.computed)
                return i([o([u, ...$]), u]);
              let V = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && L.type === "JSXAttribute" || x.operator !== "|" && b.type === "JsExpressionRoot" || x.type !== "NGPipeExpression" && (b.type === "NGRoot" && y.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && L.type === "NGMicrosyntax" && L.body.length === 1) || x === b.body && b.type === "ArrowFunctionExpression" || x !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && L.type !== "ReturnStatement" && L.type !== "ThrowStatement" && !I(L) || b.type === "TemplateLiteral", q = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), Y = w(x.left) && A(x.operator, x.left.operator);
              if (V || l(x) && !Y || !l(x) && q)
                return i($);
              if ($.length === 0)
                return "";
              let H = T(x.right), R = $.findIndex((X) => typeof X != "string" && !Array.isArray(X) && X.type === "group"), Q = $.slice(0, R === -1 ? 1 : R + 1), ee = $.slice(Q.length, H ? -1 : void 0), te = Symbol("logicalChain-" + ++D), oe = i([...Q, o(ee)], { id: te });
              if (!H)
                return oe;
              let W = s($);
              return i([oe, m(W, { groupId: te })]);
            }
            function F(E, y, N, x, b) {
              let L = E.getValue();
              if (!w(L))
                return [i(y())];
              let M = [];
              A(L.operator, L.left.operator) ? M = E.call((ee) => F(ee, y, N, true, b), "left") : M.push(i(y("left")));
              let j = l(L), $ = (L.operator === "|>" || L.type === "NGPipeExpression" || L.operator === "|" && N.parser === "__vue_expression") && !h(N.originalText, L.right), V = L.type === "NGPipeExpression" ? "|" : L.operator, q = L.type === "NGPipeExpression" && L.arguments.length > 0 ? i(o([u, ": ", a([u, ":", v(" ")], E.map(y, "arguments").map((ee) => c(2, i(ee))))])) : "", Y;
              if (j)
                Y = [V, " ", y("right"), q];
              else {
                let te = C(N) && V === "|>" ? E.call((oe) => F(oe, y, N, true, b), "right") : y("right");
                Y = [$ ? r : "", V, $ ? " " : r, te, q];
              }
              let H = E.getParentNode(), R = S(L.left, B.Trailing | B.Line), Q = R || !(b && L.type === "LogicalExpression") && H.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;
              if (M.push($ ? "" : " ", Q ? i(Y, { shouldBreak: R }) : Y), x && S(L)) {
                let ee = d(t(E, M, N));
                return f(ee) || ee.type === "fill" ? p(ee) : [ee];
              }
              return M;
            }
            function l(E) {
              return E.type !== "LogicalExpression" ? false : !!(E.right.type === "ObjectExpression" && E.right.properties.length > 0 || E.right.type === "ArrayExpression" && E.right.elements.length > 0 || T(E.right));
            }
            n.exports = { printBinaryishExpression: g, shouldInlineLogicalExpression: l };
          } }), Hm = Z({ "src/language-js/print/angular.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, line: s, group: a } } = Oe(), { hasNode: r, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: o } = Jn();
            function c(d, p, f) {
              let h = d.getValue();
              if (!!h.type.startsWith("NG"))
                switch (h.type) {
                  case "NGRoot":
                    return [f("node"), u(h.node) ? " //" + i(h.node)[0].value.trimEnd() : ""];
                  case "NGPipeExpression":
                    return o(d, p, f);
                  case "NGChainedExpression":
                    return a(t([";", s], d.map((w) => m(w) ? f() : ["(", f(), ")"], "expressions")));
                  case "NGEmptyExpression":
                    return "";
                  case "NGQuotedExpression":
                    return [h.prefix, ": ", h.value.trim()];
                  case "NGMicrosyntax":
                    return d.map((w, T) => [T === 0 ? "" : v(w.getValue(), T, h) ? " " : [";", s], f()], "body");
                  case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h.name) ? h.name : JSON.stringify(h.name);
                  case "NGMicrosyntaxExpression":
                    return [f("expression"), h.alias === null ? "" : [" as ", f("alias")]];
                  case "NGMicrosyntaxKeyedExpression": {
                    let w = d.getName(), T = d.getParentNode(), A = v(h, w, T) || (w === 1 && (h.key.name === "then" || h.key.name === "else") || w === 2 && h.key.name === "else" && T.body[w - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[w - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                    return [f("key"), A ? " " : ": ", f("expression")];
                  }
                  case "NGMicrosyntaxLet":
                    return ["let ", f("key"), h.value === null ? "" : [" = ", f("value")]];
                  case "NGMicrosyntaxAs":
                    return [f("key"), " as ", f("alias")];
                  default:
                    throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h.type), "."));
                }
            }
            function v(d, p, f) {
              return d.type === "NGMicrosyntaxKeyedExpression" && d.key.name === "of" && p === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
            }
            function m(d) {
              return r(d.getValue(), (p) => {
                switch (p.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }
            n.exports = { printAngular: c };
          } }), Gm = Z({ "src/language-js/print/jsx.js"(e, n) {
            "use strict";
            re();
            var { printComments: t, printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: o, conditionalGroup: c, fill: v, ifBreak: m, lineSuffixBoundary: d, join: p }, utils: { willBreak: f } } = Oe(), { getLast: h, getPreferredQuote: w } = Ue(), { isJsxNode: T, rawText: A, isLiteral: S, isCallExpression: B, isStringLiteral: I, isBinaryish: k, hasComment: P, CommentCheckFlags: C, hasNodeIgnoreComment: D } = Ke(), g = jt(), { willPrintOwnComments: F } = uo(), l = (ie) => ie === "" || ie === a || ie === r || ie === u;
            function E(ie, G, z) {
              let U = ie.getValue();
              if (U.type === "JSXElement" && W(U))
                return [z("openingElement"), z("closingElement")];
              let le = U.type === "JSXElement" ? z("openingElement") : z("openingFragment"), ge = U.type === "JSXElement" ? z("closingElement") : z("closingFragment");
              if (U.children.length === 1 && U.children[0].type === "JSXExpressionContainer" && (U.children[0].expression.type === "TemplateLiteral" || U.children[0].expression.type === "TaggedTemplateExpression"))
                return [le, ...ie.map(z, "children"), ge];
              U.children = U.children.map((Fe) => ue(Fe) ? { type: "JSXText", value: " ", raw: " " } : Fe);
              let Ae = U.children.some(T), Ne = U.children.filter((Fe) => Fe.type === "JSXExpressionContainer").length > 1, ke = U.type === "JSXElement" && U.openingElement.attributes.length > 1, ce = f(le) || Ae || ke || Ne, pe = ie.getParentNode().rootMarker === "mdx", de = G.singleQuote ? "{' '}" : '{" "}', ae = pe ? " " : m([de, u], " "), ve = U.openingElement && U.openingElement.name && U.openingElement.name.name === "fbt", K = y(ie, G, z, ae, ve), he = U.children.some((Fe) => X(Fe));
              for (let Fe = K.length - 2; Fe >= 0; Fe--) {
                let me = K[Fe] === "" && K[Fe + 1] === "", _ = K[Fe] === r && K[Fe + 1] === "" && K[Fe + 2] === r, J = (K[Fe] === u || K[Fe] === r) && K[Fe + 1] === "" && K[Fe + 2] === ae, ne = K[Fe] === ae && K[Fe + 1] === "" && (K[Fe + 2] === u || K[Fe + 2] === r), Ee = K[Fe] === ae && K[Fe + 1] === "" && K[Fe + 2] === ae, We = K[Fe] === u && K[Fe + 1] === "" && K[Fe + 2] === r || K[Fe] === r && K[Fe + 1] === "" && K[Fe + 2] === u;
                _ && he || me || J || Ee || We ? K.splice(Fe, 2) : ne && K.splice(Fe + 1, 2);
              }
              for (; K.length > 0 && l(h(K)); )
                K.pop();
              for (; K.length > 1 && l(K[0]) && l(K[1]); )
                K.shift(), K.shift();
              let ye = [];
              for (let [Fe, me] of K.entries()) {
                if (me === ae) {
                  if (Fe === 1 && K[Fe - 1] === "") {
                    if (K.length === 2) {
                      ye.push(de);
                      continue;
                    }
                    ye.push([de, r]);
                    continue;
                  } else if (Fe === K.length - 1) {
                    ye.push(de);
                    continue;
                  } else if (K[Fe - 1] === "" && K[Fe - 2] === r) {
                    ye.push(de);
                    continue;
                  }
                }
                ye.push(me), f(me) && (ce = true);
              }
              let Ce = he ? v(ye) : i(ye, { shouldBreak: true });
              if (pe)
                return Ce;
              let Ie = i([le, o([r, Ce]), r, ge]);
              return ce ? Ie : c([i([le, ...K, ge]), Ie]);
            }
            function y(ie, G, z, U, le) {
              let ge = [];
              return ie.each((Ae, Ne, ke) => {
                let ce = Ae.getValue();
                if (S(ce)) {
                  let pe = A(ce);
                  if (X(ce)) {
                    let de = pe.split(ee);
                    if (de[0] === "") {
                      if (ge.push(""), de.shift(), /\n/.test(de[0])) {
                        let ve = ke[Ne + 1];
                        ge.push(x(le, de[1], ce, ve));
                      } else
                        ge.push(U);
                      de.shift();
                    }
                    let ae;
                    if (h(de) === "" && (de.pop(), ae = de.pop()), de.length === 0)
                      return;
                    for (let [ve, K] of de.entries())
                      ve % 2 === 1 ? ge.push(a) : ge.push(K);
                    if (ae !== void 0)
                      if (/\n/.test(ae)) {
                        let ve = ke[Ne + 1];
                        ge.push(x(le, h(ge), ce, ve));
                      } else
                        ge.push(U);
                    else {
                      let ve = ke[Ne + 1];
                      ge.push(N(le, h(ge), ce, ve));
                    }
                  } else
                    /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge.push("", r) : ge.push("", U);
                } else {
                  let pe = z();
                  ge.push(pe);
                  let de = ke[Ne + 1];
                  if (de && X(de)) {
                    let ve = oe(A(de)).split(ee)[0];
                    ge.push(N(le, ve, ce, de));
                  } else
                    ge.push(r);
                }
              }, "children"), ge;
            }
            function N(ie, G, z, U) {
              return ie ? "" : z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? G.length === 1 ? u : r : u;
            }
            function x(ie, G, z, U) {
              return ie ? r : G.length === 1 ? z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? r : u : r;
            }
            function b(ie, G, z) {
              let U = ie.getParentNode();
              if (!U || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[U.type])
                return G;
              let ge = ie.match(void 0, (Ne) => Ne.type === "ArrowFunctionExpression", B, (Ne) => Ne.type === "JSXExpressionContainer"), Ae = g(ie, z);
              return i([Ae ? "" : m("("), o([u, G]), u, Ae ? "" : m(")")], { shouldBreak: ge });
            }
            function L(ie, G, z) {
              let U = ie.getValue(), le = [];
              if (le.push(z("name")), U.value) {
                let ge;
                if (I(U.value)) {
                  let Ne = A(U.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: ke, quote: ce, regex: pe } = w(Ne, G.jsxSingleQuote ? "'" : '"');
                  Ne = Ne.replace(pe, ke), ge = [ce, Ne, ce];
                } else
                  ge = z("value");
                le.push("=", ge);
              }
              return le;
            }
            function M(ie, G, z) {
              let U = ie.getValue(), le = (ge, Ae) => ge.type === "JSXEmptyExpression" || !P(ge) && (ge.type === "ArrayExpression" || ge.type === "ObjectExpression" || ge.type === "ArrowFunctionExpression" || ge.type === "AwaitExpression" && (le(ge.argument, ge) || ge.argument.type === "JSXElement") || B(ge) || ge.type === "FunctionExpression" || ge.type === "TemplateLiteral" || ge.type === "TaggedTemplateExpression" || ge.type === "DoExpression" || T(Ae) && (ge.type === "ConditionalExpression" || k(ge)));
              return le(U.expression, ie.getParentNode(0)) ? i(["{", z("expression"), d, "}"]) : i(["{", o([u, z("expression")]), u, d, "}"]);
            }
            function j(ie, G, z) {
              let U = ie.getValue(), le = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);
              if (U.selfClosing && U.attributes.length === 0 && !le)
                return ["<", z("name"), z("typeParameters"), " />"];
              if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I(U.attributes[0].value) && !U.attributes[0].value.value.includes(`
`) && !le && !P(U.attributes[0]))
                return i(["<", z("name"), z("typeParameters"), " ", ...ie.map(z, "attributes"), U.selfClosing ? " />" : ">"]);
              let ge = U.attributes.length > 0 && P(h(U.attributes), C.Trailing), Ae = U.attributes.length === 0 && !le || (G.bracketSameLine || G.jsxBracketSameLine) && (!le || U.attributes.length > 0) && !ge, Ne = U.attributes && U.attributes.some((ce) => ce.value && I(ce.value) && ce.value.value.includes(`
`)), ke = G.singleAttributePerLine && U.attributes.length > 1 ? r : a;
              return i(["<", z("name"), z("typeParameters"), o(ie.map(() => [ke, z()], "attributes")), U.selfClosing ? a : Ae ? ">" : u, U.selfClosing ? "/>" : Ae ? "" : ">"], { shouldBreak: Ne });
            }
            function $(ie, G, z) {
              let U = ie.getValue(), le = [];
              le.push("</");
              let ge = z("name");
              return P(U.name, C.Leading | C.Line) ? le.push(o([r, ge]), r) : P(U.name, C.Leading | C.Block) ? le.push(" ", ge) : le.push(ge), le.push(">"), le;
            }
            function V(ie, G) {
              let z = ie.getValue(), U = P(z), le = P(z, C.Line), ge = z.type === "JSXOpeningFragment";
              return [ge ? "<" : "</", o([le ? r : U && !ge ? " " : "", s(ie, G, true)]), le ? r : "", ">"];
            }
            function q(ie, G, z) {
              let U = t(ie, E(ie, G, z), G);
              return b(ie, U, G);
            }
            function Y(ie, G) {
              let z = ie.getValue(), U = P(z, C.Line);
              return [s(ie, G, !U), U ? r : ""];
            }
            function H(ie, G, z) {
              let U = ie.getValue();
              return ["{", ie.call((le) => {
                let ge = ["...", z()], Ae = le.getValue();
                return !P(Ae) || !F(le) ? ge : [o([u, t(le, ge, G)]), u];
              }, U.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
            }
            function R(ie, G, z) {
              let U = ie.getValue();
              if (!!U.type.startsWith("JSX"))
                switch (U.type) {
                  case "JSXAttribute":
                    return L(ie, G, z);
                  case "JSXIdentifier":
                    return String(U.name);
                  case "JSXNamespacedName":
                    return p(":", [z("namespace"), z("name")]);
                  case "JSXMemberExpression":
                    return p(".", [z("object"), z("property")]);
                  case "JSXSpreadAttribute":
                    return H(ie, G, z);
                  case "JSXSpreadChild":
                    return H(ie, G, z);
                  case "JSXExpressionContainer":
                    return M(ie, G, z);
                  case "JSXFragment":
                  case "JSXElement":
                    return q(ie, G, z);
                  case "JSXOpeningElement":
                    return j(ie, G, z);
                  case "JSXClosingElement":
                    return $(ie, G, z);
                  case "JSXOpeningFragment":
                  case "JSXClosingFragment":
                    return V(ie, G);
                  case "JSXEmptyExpression":
                    return Y(ie, G);
                  case "JSXText":
                    throw new Error("JSXTest should be handled by JSXElement");
                  default:
                    throw new Error("Unknown JSX node type: ".concat(JSON.stringify(U.type), "."));
                }
            }
            var Q = ` 
\r	`, ee = new RegExp("([" + Q + "]+)"), te = new RegExp("[^" + Q + "]"), oe = (ie) => ie.replace(new RegExp("(?:^" + ee.source + "|" + ee.source + "$)"), "");
            function W(ie) {
              if (ie.children.length === 0)
                return true;
              if (ie.children.length > 1)
                return false;
              let G = ie.children[0];
              return S(G) && !X(G);
            }
            function X(ie) {
              return S(ie) && (te.test(A(ie)) || !/\n/.test(A(ie)));
            }
            function ue(ie) {
              return ie.type === "JSXExpressionContainer" && S(ie.expression) && ie.expression.value === " " && !P(ie.expression);
            }
            function De(ie) {
              let G = ie.getValue(), z = ie.getParentNode();
              if (!z || !G || !T(G) || !T(z))
                return false;
              let U = z.children.indexOf(G), le = null;
              for (let ge = U; ge > 0; ge--) {
                let Ae = z.children[ge - 1];
                if (!(Ae.type === "JSXText" && !X(Ae))) {
                  le = Ae;
                  break;
                }
              }
              return le && le.type === "JSXExpressionContainer" && le.expression.type === "JSXEmptyExpression" && D(le.expression);
            }
            n.exports = { hasJsxIgnoreComment: De, printJsx: R };
          } }), ct = Z({ "src/language-js/print/misc.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a, line: r } } = Oe(), { isFlowAnnotationComment: u } = Ke();
            function i(h) {
              let w = h.getValue();
              return !w.optional || w.type === "Identifier" && w === h.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
            }
            function o(h) {
              return h.getValue().definite || h.match(void 0, (w, T) => T === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
            }
            function c(h, w, T) {
              let A = h.getValue();
              return A.typeArguments ? T("typeArguments") : A.typeParameters ? T("typeParameters") : "";
            }
            function v(h, w, T) {
              let A = h.getValue();
              if (!A.typeAnnotation)
                return "";
              let S = h.getParentNode(), B = S.type === "DeclareFunction" && S.id === A;
              return u(w.originalText, A.typeAnnotation) ? [" /*: ", T("typeAnnotation"), " */"] : [B ? "" : ": ", T("typeAnnotation")];
            }
            function m(h, w, T) {
              return ["::", T("callee")];
            }
            function d(h, w, T) {
              let A = h.getValue();
              return t(A.modifiers) ? [a(" ", h.map(T, "modifiers")), " "] : "";
            }
            function p(h, w, T) {
              return h.type === "EmptyStatement" ? ";" : h.type === "BlockStatement" || T ? [" ", w] : s([r, w]);
            }
            function f(h, w, T) {
              return ["...", T("argument"), v(h, w, T)];
            }
            n.exports = { printOptionalToken: i, printDefiniteToken: o, printFunctionTypeParameters: c, printBindExpressionCallee: m, printTypeScriptModifiers: d, printTypeAnnotation: v, printRestSpread: f, adjustClause: p };
          } }), Kt = Z({ "src/language-js/print/array.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: r, group: u, indent: i, ifBreak: o, fill: c } } = Oe(), { getLast: v, hasNewline: m } = Ue(), { shouldPrintComma: d, hasComment: p, CommentCheckFlags: f, isNextLineEmpty: h, isNumericLiteral: w, isSignedNumericLiteral: T } = Ke(), { locStart: A } = st(), { printOptionalToken: S, printTypeAnnotation: B } = ct();
            function I(D, g, F) {
              let l = D.getValue(), E = [], y = l.type === "TupleExpression" ? "#[" : "[", N = "]";
              if (l.elements.length === 0)
                p(l, f.Dangling) ? E.push(u([y, t(D, g), a, N])) : E.push(y, N);
              else {
                let x = v(l.elements), b = !(x && x.type === "RestElement"), L = x === null, M = Symbol("array"), j = !g.__inJestEach && l.elements.length > 1 && l.elements.every((q, Y, H) => {
                  let R = q && q.type;
                  if (R !== "ArrayExpression" && R !== "ObjectExpression")
                    return false;
                  let Q = H[Y + 1];
                  if (Q && R !== Q.type)
                    return false;
                  let ee = R === "ArrayExpression" ? "elements" : "properties";
                  return q[ee] && q[ee].length > 1;
                }), $ = k(l, g), V = b ? L ? "," : d(g) ? $ ? o(",", "", { groupId: M }) : o(",") : "" : "";
                E.push(u([y, i([a, $ ? C(D, g, F, V) : [P(D, g, "elements", F), V], t(D, g, true)]), a, N], { shouldBreak: j, id: M }));
              }
              return E.push(S(D), B(D, g, F)), E;
            }
            function k(D, g) {
              return D.elements.length > 1 && D.elements.every((F) => F && (w(F) || T(F) && !p(F.argument)) && !p(F, f.Trailing | f.Line, (l) => !m(g.originalText, A(l), { backwards: true })));
            }
            function P(D, g, F, l) {
              let E = [], y = [];
              return D.each((N) => {
                E.push(y, u(l())), y = [",", s], N.getValue() && h(N.getValue(), g) && y.push(a);
              }, F), E;
            }
            function C(D, g, F, l) {
              let E = [];
              return D.each((y, N, x) => {
                let b = N === x.length - 1;
                E.push([F(), b ? l : ","]), b || E.push(h(y.getValue(), g) ? [r, r] : p(x[N + 1], f.Leading | f.Line) ? r : s);
              }, "elements"), c(E);
            }
            n.exports = { printArray: I, printArrayItems: P, isConciselyPrintedArray: k };
          } }), io = Z({ "src/language-js/print/call-arguments.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: o, isJsxNode: c, isLongCurriedCallExpression: v, shouldPrintComma: m, getCallArguments: d, iterateCallArgumentsPath: p, isNextLineEmpty: f, isCallExpression: h, isStringLiteral: w, isObjectProperty: T } = Ke(), { builders: { line: A, hardline: S, softline: B, group: I, indent: k, conditionalGroup: P, ifBreak: C, breakParent: D }, utils: { willBreak: g } } = Oe(), { ArgExpansionBailout: F } = zt(), { isConciselyPrintedArray: l } = Kt();
            function E(j, $, V) {
              let q = j.getValue(), Y = q.type === "ImportExpression", H = d(q);
              if (H.length === 0)
                return ["(", t(j, $, true), ")"];
              if (b(H))
                return ["(", V(["arguments", 0]), ", ", V(["arguments", 1]), ")"];
              let R = false, Q = false, ee = H.length - 1, te = [];
              p(j, (ie, G) => {
                let z = ie.getNode(), U = [V()];
                G === ee || (f(z, $) ? (G === 0 && (Q = true), R = true, U.push(",", S, S)) : U.push(",", A)), te.push(U);
              });
              let oe = !(Y || q.callee && q.callee.type === "Import") && m($, "all") ? "," : "";
              function W() {
                return I(["(", k([A, ...te]), oe, A, ")"], { shouldBreak: true });
              }
              if (R || j.getParentNode().type !== "Decorator" && o(H))
                return W();
              let X = x(H), ue = N(H, $);
              if (X || ue) {
                if (X ? te.slice(1).some(g) : te.slice(0, -1).some(g))
                  return W();
                let ie = [];
                try {
                  j.try(() => {
                    p(j, (G, z) => {
                      X && z === 0 && (ie = [[V([], { expandFirstArg: true }), te.length > 1 ? "," : "", Q ? S : A, Q ? S : ""], ...te.slice(1)]), ue && z === ee && (ie = [...te.slice(0, -1), V([], { expandLastArg: true })]);
                    });
                  });
                } catch (G) {
                  if (G instanceof F)
                    return W();
                  throw G;
                }
                return [te.some(g) ? D : "", P([["(", ...ie, ")"], X ? ["(", I(ie[0], { shouldBreak: true }), ...ie.slice(1), ")"] : ["(", ...te.slice(0, -1), I(s(ie), { shouldBreak: true }), ")"], W()])];
              }
              let De = ["(", k([B, ...te]), C(oe), B, ")"];
              return v(j) ? De : I(De, { shouldBreak: te.some(g) || R });
            }
            function y(j) {
              let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return j.type === "ObjectExpression" && (j.properties.length > 0 || u(j)) || j.type === "ArrayExpression" && (j.elements.length > 0 || u(j)) || j.type === "TSTypeAssertion" && y(j.expression) || j.type === "TSAsExpression" && y(j.expression) || j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== "TSTypeReference" || L(j.body)) && (j.body.type === "BlockStatement" || j.body.type === "ArrowFunctionExpression" && y(j.body, true) || j.body.type === "ObjectExpression" || j.body.type === "ArrayExpression" || !$ && (h(j.body) || j.body.type === "ConditionalExpression") || c(j.body)) || j.type === "DoExpression" || j.type === "ModuleExpression";
            }
            function N(j, $) {
              let V = s(j), q = a(j);
              return !u(V, i.Leading) && !u(V, i.Trailing) && y(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== "ArrowFunctionExpression" || V.type !== "ArrayExpression") && !(j.length > 1 && V.type === "ArrayExpression" && l(V, $));
            }
            function x(j) {
              if (j.length !== 2)
                return false;
              let [$, V] = j;
              return $.type === "ModuleExpression" && M(V) ? true : !u($) && ($.type === "FunctionExpression" || $.type === "ArrowFunctionExpression" && $.body.type === "BlockStatement") && V.type !== "FunctionExpression" && V.type !== "ArrowFunctionExpression" && V.type !== "ConditionalExpression" && !y(V);
            }
            function b(j) {
              return j.length === 2 && j[0].type === "ArrowFunctionExpression" && r(j[0]).length === 0 && j[0].body.type === "BlockStatement" && j[1].type === "ArrayExpression" && !j.some(($) => u($));
            }
            function L(j) {
              return j.type === "BlockStatement" && (j.body.some(($) => $.type !== "EmptyStatement") || u(j, i.Dangling));
            }
            function M(j) {
              return j.type === "ObjectExpression" && j.properties.length === 1 && T(j.properties[0]) && j.properties[0].key.type === "Identifier" && j.properties[0].key.name === "type" && w(j.properties[0].value) && j.properties[0].value.value === "module";
            }
            n.exports = E;
          } }), ao = Z({ "src/language-js/print/member.js"(e, n) {
            "use strict";
            re();
            var { builders: { softline: t, group: s, indent: a, label: r } } = Oe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: o } = Ke(), { printOptionalToken: c } = ct();
            function v(d, p, f) {
              let h = d.getValue(), w = d.getParentNode(), T, A = 0;
              do
                T = d.getParentNode(A), A++;
              while (T && (i(T) || T.type === "TSNonNullExpression"));
              let S = f("object"), B = m(d, p, f), I = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || h.computed || h.object.type === "Identifier" && h.property.type === "Identifier" && !i(w) || (w.type === "AssignmentExpression" || w.type === "VariableDeclarator") && (o(h.object) && h.object.arguments.length > 0 || h.object.type === "TSNonNullExpression" && o(h.object.expression) && h.object.expression.arguments.length > 0 || S.label === "member-chain");
              return r(S.label === "member-chain" ? "member-chain" : "member", [S, I ? B : s(a([t, B]))]);
            }
            function m(d, p, f) {
              let h = f("property"), w = d.getValue(), T = c(d);
              return w.computed ? !w.property || u(w.property) ? [T, "[", h, "]"] : s([T, "[", a([t, h]), t, "]"]) : [T, ".", h];
            }
            n.exports = { printMemberExpression: v, printMemberLookup: m };
          } }), Jm = Z({ "src/language-js/print/member-chain.js"(e, n) {
            "use strict";
            re();
            var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: r } = Ue(), u = jt(), { isCallExpression: i, isMemberExpression: o, isFunctionOrArrowExpression: c, isLongCurriedCallExpression: v, isMemberish: m, isNumericLiteral: d, isSimpleCallArgument: p, hasComment: f, CommentCheckFlags: h, isNextLineEmpty: w } = Ke(), { locEnd: T } = st(), { builders: { join: A, hardline: S, group: B, indent: I, conditionalGroup: k, breakParent: P, label: C }, utils: { willBreak: D } } = Oe(), g = io(), { printMemberLookup: F } = ao(), { printOptionalToken: l, printFunctionTypeParameters: E, printBindExpressionCallee: y } = ct();
            function N(x, b, L) {
              let M = x.getParentNode(), j = !M || M.type === "ExpressionStatement", $ = [];
              function V(de) {
                let { originalText: ae } = b, ve = r(ae, de, T);
                return ae.charAt(ve) === ")" ? ve !== false && a(ae, ve + 1) : w(de, b);
              }
              function q(de) {
                let ae = de.getValue();
                i(ae) && (m(ae.callee) || i(ae.callee)) ? ($.unshift({ node: ae, printed: [t(de, [l(de), E(de, b, L), g(de, b, L)], b), V(ae) ? S : ""] }), de.call((ve) => q(ve), "callee")) : m(ae) ? ($.unshift({ node: ae, needsParens: u(de, b), printed: t(de, o(ae) ? F(de, b, L) : y(de, b, L), b) }), de.call((ve) => q(ve), "object")) : ae.type === "TSNonNullExpression" ? ($.unshift({ node: ae, printed: t(de, "!", b) }), de.call((ve) => q(ve), "expression")) : $.unshift({ node: ae, printed: L() });
              }
              let Y = x.getValue();
              $.unshift({ node: Y, printed: [l(x), E(x, b, L), g(x, b, L)] }), Y.callee && x.call((de) => q(de), "callee");
              let H = [], R = [$[0]], Q = 1;
              for (; Q < $.length && ($[Q].node.type === "TSNonNullExpression" || i($[Q].node) || o($[Q].node) && $[Q].node.computed && d($[Q].node.property)); ++Q)
                R.push($[Q]);
              if (!i($[0].node))
                for (; Q + 1 < $.length && (m($[Q].node) && m($[Q + 1].node)); ++Q)
                  R.push($[Q]);
              H.push(R), R = [];
              let ee = false;
              for (; Q < $.length; ++Q) {
                if (ee && m($[Q].node)) {
                  if ($[Q].node.computed && d($[Q].node.property)) {
                    R.push($[Q]);
                    continue;
                  }
                  H.push(R), R = [], ee = false;
                }
                (i($[Q].node) || $[Q].node.type === "ImportExpression") && (ee = true), R.push($[Q]), f($[Q].node, h.Trailing) && (H.push(R), R = [], ee = false);
              }
              R.length > 0 && H.push(R);
              function te(de) {
                return /^[A-Z]|^[$_]+$/.test(de);
              }
              function oe(de) {
                return de.length <= b.tabWidth;
              }
              function W(de) {
                let ae = de[1].length > 0 && de[1][0].node.computed;
                if (de[0].length === 1) {
                  let K = de[0][0].node;
                  return K.type === "ThisExpression" || K.type === "Identifier" && (te(K.name) || j && oe(K.name) || ae);
                }
                let ve = s(de[0]).node;
                return o(ve) && ve.property.type === "Identifier" && (te(ve.property.name) || ae);
              }
              let X = H.length >= 2 && !f(H[1][0].node) && W(H);
              function ue(de) {
                let ae = de.map((ve) => ve.printed);
                return de.length > 0 && s(de).needsParens ? ["(", ...ae, ")"] : ae;
              }
              function De(de) {
                return de.length === 0 ? "" : I(B([S, A(S, de.map(ue))]));
              }
              let ie = H.map(ue), G = ie, z = X ? 3 : 2, U = H.flat(), le = U.slice(1, -1).some((de) => f(de.node, h.Leading)) || U.slice(0, -1).some((de) => f(de.node, h.Trailing)) || H[z] && f(H[z][0].node, h.Leading);
              if (H.length <= z && !le)
                return v(x) ? G : B(G);
              let ge = s(H[X ? 1 : 0]).node, Ae = !i(ge) && V(ge), Ne = [ue(H[0]), X ? H.slice(1, 2).map(ue) : "", Ae ? S : "", De(H.slice(X ? 2 : 1))], ke = $.map((de) => {
                let { node: ae } = de;
                return ae;
              }).filter(i);
              function ce() {
                let de = s(s(H)).node, ae = s(ie);
                return i(de) && D(ae) && ke.slice(0, -1).some((ve) => ve.arguments.some(c));
              }
              let pe;
              return le || ke.length > 2 && ke.some((de) => !de.arguments.every((ae) => p(ae, 0))) || ie.slice(0, -1).some(D) || ce() ? pe = B(Ne) : pe = [D(G) || Ae ? P : "", k([G, Ne])], C("member-chain", pe);
            }
            n.exports = N;
          } }), oo = Z({ "src/language-js/print/call-expression.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, group: s } } = Oe(), a = jt(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: o, isStringLiteral: c, isTemplateOnItsOwnLine: v, isTestCall: m, iterateCallArgumentsPath: d } = Ke(), p = Jm(), f = io(), { printOptionalToken: h, printFunctionTypeParameters: w } = ct();
            function T(S, B, I) {
              let k = S.getValue(), P = S.getParentNode(), C = k.type === "NewExpression", D = k.type === "ImportExpression", g = h(S), F = r(k);
              if (F.length > 0 && (!D && !C && A(k, P) || F.length === 1 && v(F[0], B.originalText) || !C && m(k, P))) {
                let y = [];
                return d(S, () => {
                  y.push(I());
                }), [C ? "new " : "", I("callee"), g, w(S, B, I), "(", t(", ", y), ")"];
              }
              let l = (B.parser === "babel" || B.parser === "babel-flow") && k.callee && k.callee.type === "Identifier" && u(k.callee.trailingComments);
              if (l && (k.callee.trailingComments[0].printed = true), !D && !C && o(k.callee) && !S.call((y) => a(y, B), "callee"))
                return p(S, B, I);
              let E = [C ? "new " : "", D ? "import" : I("callee"), g, l ? "/*:: ".concat(k.callee.trailingComments[0].value.slice(2).trim(), " */") : "", w(S, B, I), f(S, B, I)];
              return D || i(k.callee) ? s(E) : E;
            }
            function A(S, B) {
              if (S.callee.type !== "Identifier")
                return false;
              if (S.callee.name === "require")
                return true;
              if (S.callee.name === "define") {
                let I = r(S);
                return B.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && c(I[0]) && I[1].type === "ArrayExpression");
              }
              return false;
            }
            n.exports = { printCallExpression: T };
          } }), Yt = Z({ "src/language-js/print/assignment.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a, group: r, indent: u, indentIfBreak: i, lineSuffixBoundary: o }, utils: { cleanDoc: c, willBreak: v, canBreak: m } } = Oe(), { hasLeadingOwnLineComment: d, isBinaryish: p, isStringLiteral: f, isLiteral: h, isNumericLiteral: w, isCallExpression: T, isMemberExpression: A, getCallArguments: S, rawText: B, hasComment: I, isSignedNumericLiteral: k, isObjectProperty: P } = Ke(), { shouldInlineLogicalExpression: C } = Jn(), { printCallExpression: D } = oo();
            function g(W, X, ue, De, ie, G) {
              let z = E(W, X, ue, De, G), U = ue(G, { assignmentLayout: z });
              switch (z) {
                case "break-after-operator":
                  return r([r(De), ie, r(u([a, U]))]);
                case "never-break-after-operator":
                  return r([r(De), ie, " ", U]);
                case "fluid": {
                  let le = Symbol("assignment");
                  return r([r(De), ie, r(u(a), { id: le }), o, i(U, { groupId: le })]);
                }
                case "break-lhs":
                  return r([De, ie, " ", r(U)]);
                case "chain":
                  return [r(De), ie, a, U];
                case "chain-tail":
                  return [r(De), ie, u([a, U])];
                case "chain-tail-arrow-chain":
                  return [r(De), ie, U];
                case "only-left":
                  return De;
              }
            }
            function F(W, X, ue) {
              let De = W.getValue();
              return g(W, X, ue, ue("left"), [" ", De.operator], "right");
            }
            function l(W, X, ue) {
              return g(W, X, ue, ue("id"), " =", "init");
            }
            function E(W, X, ue, De, ie) {
              let G = W.getValue(), z = G[ie];
              if (!z)
                return "only-left";
              let U = !x(z);
              if (W.match(x, b, (Ne) => !U || Ne.type !== "ExpressionStatement" && Ne.type !== "VariableDeclaration"))
                return U ? z.type === "ArrowFunctionExpression" && z.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
              if (!U && x(z.right) || d(X.originalText, z))
                return "break-after-operator";
              if (z.type === "CallExpression" && z.callee.name === "require" || X.parser === "json5" || X.parser === "json")
                return "never-break-after-operator";
              if (N(G) || L(G) || $(G) || V(G) && m(De))
                return "break-lhs";
              let Ae = ee(G, De, X);
              return W.call(() => y(W, X, ue, Ae), ie) ? "break-after-operator" : Ae || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "BooleanLiteral" || w(z) || z.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
            }
            function y(W, X, ue, De) {
              let ie = W.getValue();
              if (p(ie) && !C(ie))
                return true;
              switch (ie.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  let { test: U } = ie;
                  return p(U) && !C(U);
                }
                case "ClassExpression":
                  return t(ie.decorators);
              }
              if (De)
                return false;
              let G = ie, z = [];
              for (; ; )
                if (G.type === "UnaryExpression")
                  G = G.argument, z.push("argument");
                else if (G.type === "TSNonNullExpression")
                  G = G.expression, z.push("expression");
                else
                  break;
              return !!(f(G) || W.call(() => H(W, X, ue), ...z));
            }
            function N(W) {
              if (b(W)) {
                let X = W.left || W.id;
                return X.type === "ObjectPattern" && X.properties.length > 2 && X.properties.some((ue) => P(ue) && (!ue.shorthand || ue.value && ue.value.type === "AssignmentPattern"));
              }
              return false;
            }
            function x(W) {
              return W.type === "AssignmentExpression";
            }
            function b(W) {
              return x(W) || W.type === "VariableDeclarator";
            }
            function L(W) {
              let X = M(W);
              if (t(X)) {
                let ue = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (X.length > 1 && X.some((De) => De[ue] || De.default))
                  return true;
              }
              return false;
            }
            function M(W) {
              return j(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function j(W) {
              return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
            }
            function $(W) {
              if (W.type !== "VariableDeclarator")
                return false;
              let { typeAnnotation: X } = W.id;
              if (!X || !X.typeAnnotation)
                return false;
              let ue = q(X.typeAnnotation);
              return t(ue) && ue.length > 1 && ue.some((De) => t(q(De)) || De.type === "TSConditionalType");
            }
            function V(W) {
              return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
            }
            function q(W) {
              return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function Y(W) {
              return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
            }
            function H(W, X, ue) {
              let De = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, ie = W.getValue(), G = () => H(W, X, ue, true);
              if (ie.type === "TSNonNullExpression")
                return W.call(G, "expression");
              if (T(ie)) {
                if (D(W, X, ue).label === "member-chain")
                  return false;
                let U = S(ie);
                return !(U.length === 0 || U.length === 1 && Q(U[0], X)) || te(ie, ue) ? false : W.call(G, "callee");
              }
              return A(ie) ? W.call(G, "object") : De && (ie.type === "Identifier" || ie.type === "ThisExpression");
            }
            var R = 0.25;
            function Q(W, X) {
              let { printWidth: ue } = X;
              if (I(W))
                return false;
              let De = ue * R;
              if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= De || k(W) && !I(W.argument))
                return true;
              let ie = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
              return ie ? ie.length <= De : f(W) ? B(W).length <= De : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= De && !W.quasis[0].value.raw.includes(`
`) : h(W);
            }
            function ee(W, X, ue) {
              if (!P(W))
                return false;
              X = c(X);
              let De = 3;
              return typeof X == "string" && s(X) < ue.tabWidth + De;
            }
            function te(W, X) {
              let ue = oe(W);
              if (t(ue)) {
                if (ue.length > 1)
                  return true;
                if (ue.length === 1) {
                  let ie = ue[0];
                  if (ie.type === "TSUnionType" || ie.type === "UnionTypeAnnotation" || ie.type === "TSIntersectionType" || ie.type === "IntersectionTypeAnnotation" || ie.type === "TSTypeLiteral" || ie.type === "ObjectTypeAnnotation")
                    return true;
                }
                let De = W.typeParameters ? "typeParameters" : "typeArguments";
                if (v(X(De)))
                  return true;
              }
              return false;
            }
            function oe(W) {
              return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
            }
            n.exports = { printVariableDeclarator: l, printAssignmentExpression: F, printAssignment: g, isArrowFunctionVariableDeclarator: V };
          } }), Pr = Z({ "src/language-js/print/function-parameters.js"(e, n) {
            "use strict";
            re();
            var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: o, ifBreak: c }, utils: { removeLines: v, willBreak: m } } = Oe(), { getFunctionParameters: d, iterateFunctionParametersPath: p, isSimpleType: f, isTestCall: h, isTypeAnnotationAFunction: w, isObjectType: T, isObjectTypePropertyAFunction: A, hasRestParameter: S, shouldPrintComma: B, hasComment: I, isNextLineEmpty: k } = Ke(), { locEnd: P } = st(), { ArgExpansionBailout: C } = zt(), { printFunctionTypeParameters: D } = ct();
            function g(y, N, x, b, L) {
              let M = y.getValue(), j = d(M), $ = L ? D(y, x, N) : "";
              if (j.length === 0)
                return [$, "(", s(y, x, true, (ee) => t(x.originalText, ee, P) === ")"), ")"];
              let V = y.getParentNode(), q = h(V), Y = F(M), H = [];
              if (p(y, (ee, te) => {
                let oe = te === j.length - 1;
                oe && M.rest && H.push("..."), H.push(N()), !oe && (H.push(","), q || Y ? H.push(" ") : k(j[te], x) ? H.push(r, r) : H.push(a));
              }), b) {
                if (m($) || m(H))
                  throw new C();
                return i([v($), "(", v(H), ")"]);
              }
              let R = j.every((ee) => !ee.decorators);
              return Y && R ? [$, "(", ...H, ")"] : q ? [$, "(", ...H, ")"] : (A(V) || w(V) || V.type === "TypeAlias" || V.type === "UnionTypeAnnotation" || V.type === "TSUnionType" || V.type === "IntersectionTypeAnnotation" || V.type === "FunctionTypeAnnotation" && V.returnType === M) && j.length === 1 && j[0].name === null && M.this !== j[0] && j[0].typeAnnotation && M.typeParameters === null && f(j[0].typeAnnotation) && !M.rest ? x.arrowParens === "always" ? ["(", ...H, ")"] : H : [$, "(", o([u, ...H]), c(!S(M) && B(x, "all") ? "," : ""), u, ")"];
            }
            function F(y) {
              if (!y)
                return false;
              let N = d(y);
              if (N.length !== 1)
                return false;
              let [x] = N;
              return !I(x) && (x.type === "ObjectPattern" || x.type === "ArrayPattern" || x.type === "Identifier" && x.typeAnnotation && (x.typeAnnotation.type === "TypeAnnotation" || x.typeAnnotation.type === "TSTypeAnnotation") && T(x.typeAnnotation.typeAnnotation) || x.type === "FunctionTypeParam" && T(x.typeAnnotation) || x.type === "AssignmentPattern" && (x.left.type === "ObjectPattern" || x.left.type === "ArrayPattern") && (x.right.type === "Identifier" || x.right.type === "ObjectExpression" && x.right.properties.length === 0 || x.right.type === "ArrayExpression" && x.right.elements.length === 0));
            }
            function l(y) {
              let N;
              return y.returnType ? (N = y.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : y.typeAnnotation && (N = y.typeAnnotation), N;
            }
            function E(y, N) {
              let x = l(y);
              if (!x)
                return false;
              let b = y.typeParameters && y.typeParameters.params;
              if (b) {
                if (b.length > 1)
                  return false;
                if (b.length === 1) {
                  let L = b[0];
                  if (L.constraint || L.default)
                    return false;
                }
              }
              return d(y).length === 1 && (T(x) || m(N));
            }
            n.exports = { printFunctionParameters: g, shouldHugFunctionParameters: F, shouldGroupFunctionParameters: E };
          } }), kr = Z({ "src/language-js/print/type-annotation.js"(e, n) {
            "use strict";
            re();
            var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: r, join: u, line: i, softline: o, indent: c, align: v, ifBreak: m } } = Oe(), d = jt(), { locStart: p } = st(), { isSimpleType: f, isObjectType: h, hasLeadingOwnLineComment: w, isObjectTypePropertyAFunction: T, shouldPrintComma: A } = Ke(), { printAssignment: S } = Yt(), { printFunctionParameters: B, shouldGroupFunctionParameters: I } = Pr(), { printArrayItems: k } = Kt();
            function P(x) {
              if (f(x) || h(x))
                return true;
              if (x.type === "UnionTypeAnnotation" || x.type === "TSUnionType") {
                let b = x.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, L = x.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
                if (x.types.length - 1 === b && L)
                  return true;
              }
              return false;
            }
            function C(x, b, L) {
              let M = b.semi ? ";" : "", j = x.getValue(), $ = [];
              return $.push("opaque type ", L("id"), L("typeParameters")), j.supertype && $.push(": ", L("supertype")), j.impltype && $.push(" = ", L("impltype")), $.push(M), $;
            }
            function D(x, b, L) {
              let M = b.semi ? ";" : "", j = x.getValue(), $ = [];
              j.declare && $.push("declare "), $.push("type ", L("id"), L("typeParameters"));
              let V = j.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
              return [S(x, b, L, $, " =", V), M];
            }
            function g(x, b, L) {
              let M = x.getValue(), j = x.map(L, "types"), $ = [], V = false;
              for (let q = 0; q < j.length; ++q)
                q === 0 ? $.push(j[q]) : h(M.types[q - 1]) && h(M.types[q]) ? $.push([" & ", V ? c(j[q]) : j[q]]) : !h(M.types[q - 1]) && !h(M.types[q]) ? $.push(c([" &", i, j[q]])) : (q > 1 && (V = true), $.push(" & ", q > 1 ? c(j[q]) : j[q]));
              return r($);
            }
            function F(x, b, L) {
              let M = x.getValue(), j = x.getParentNode(), $ = j.type !== "TypeParameterInstantiation" && j.type !== "TSTypeParameterInstantiation" && j.type !== "GenericTypeAnnotation" && j.type !== "TSTypeReference" && j.type !== "TSTypeAssertion" && j.type !== "TupleTypeAnnotation" && j.type !== "TSTupleType" && !(j.type === "FunctionTypeParam" && !j.name && x.getParentNode(1).this !== j) && !((j.type === "TypeAlias" || j.type === "VariableDeclarator" || j.type === "TSTypeAliasDeclaration") && w(b.originalText, M)), V = P(M), q = x.map((R) => {
                let Q = L();
                return V || (Q = v(2, Q)), t(R, Q, b);
              }, "types");
              if (V)
                return u(" | ", q);
              let Y = $ && !w(b.originalText, M), H = [m([Y ? i : "", "| "]), u([i, "| "], q)];
              return d(x, b) ? r([c(H), o]) : j.type === "TupleTypeAnnotation" && j.types.length > 1 || j.type === "TSTupleType" && j.elementTypes.length > 1 ? r([c([m(["(", o]), H]), o, m(")")]) : r($ ? c(H) : H);
            }
            function l(x, b, L) {
              let M = x.getValue(), j = [], $ = x.getParentNode(0), V = x.getParentNode(1), q = x.getParentNode(2), Y = M.type === "TSFunctionType" || !(($.type === "ObjectTypeProperty" || $.type === "ObjectTypeInternalSlot") && !$.variance && !$.optional && p($) === p(M) || $.type === "ObjectTypeCallProperty" || q && q.type === "DeclareFunction"), H = Y && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation"), R = H && Y && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation") && V.type === "ArrowFunctionExpression";
              T($) && (Y = true, H = true), R && j.push("(");
              let Q = B(x, L, b, false, true), ee = M.returnType || M.predicate || M.typeAnnotation ? [Y ? " => " : ": ", L("returnType"), L("predicate"), L("typeAnnotation")] : "", te = I(M, ee);
              return j.push(te ? r(Q) : Q), ee && j.push(ee), R && j.push(")"), r(j);
            }
            function E(x, b, L) {
              let M = x.getValue(), j = M.type === "TSTupleType" ? "elementTypes" : "types", $ = M[j], V = a($), q = V ? o : "";
              return r(["[", c([q, k(x, b, j, L)]), m(V && A(b, "all") ? "," : ""), s(x, b, true), q, "]"]);
            }
            function y(x, b, L) {
              let M = x.getValue(), j = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
              return [L("objectType"), j, L("indexType"), "]"];
            }
            function N(x, b, L) {
              let M = x.getValue();
              return [M.postfix ? "" : L, b("typeAnnotation"), M.postfix ? L : ""];
            }
            n.exports = { printOpaqueType: C, printTypeAlias: D, printIntersectionType: g, printUnionType: F, printFunctionType: l, printTupleType: E, printIndexedAccessType: y, shouldHugType: P, printJSDocType: N };
          } }), Ir = Z({ "src/language-js/print/type-parameters.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: r, softline: u, group: i, indent: o, ifBreak: c } } = Oe(), { isTestCall: v, hasComment: m, CommentCheckFlags: d, isTSXFile: p, shouldPrintComma: f, getFunctionParameters: h, isObjectType: w } = Ke(), { createGroupIdMapper: T } = Ue(), { shouldHugType: A } = kr(), { isArrowFunctionVariableDeclarator: S } = Yt(), B = T("typeParameters");
            function I(C, D, g, F) {
              let l = C.getValue();
              if (!l[F])
                return "";
              if (!Array.isArray(l[F]))
                return g(F);
              let E = C.getNode(2), y = E && v(E);
              if (!C.match((L) => !(L[F].length === 1 && w(L[F][0])), void 0, (L, M) => M === "typeAnnotation", (L) => L.type === "Identifier", S) && (y || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === "NullableTypeAnnotation" || A(l[F][0]))))
                return ["<", s(", ", C.map(g, F)), k(C, D), ">"];
              let b = l.type === "TSTypeParameterInstantiation" ? "" : h(l).length === 1 && p(D) && !l[F][0].constraint && C.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D, "all") ? c(",") : "";
              return i(["<", o([u, s([",", a], C.map(g, F))]), b, u, ">"], { id: B(l) });
            }
            function k(C, D) {
              let g = C.getValue();
              if (!m(g, d.Dangling))
                return "";
              let F = !m(g, d.Line), l = t(C, D, F);
              return F ? l : [l, r];
            }
            function P(C, D, g) {
              let F = C.getValue(), l = [], E = C.getParentNode();
              return E.type === "TSMappedType" ? (l.push("[", g("name")), F.constraint && l.push(" in ", g("constraint")), E.nameType && l.push(" as ", C.callParent(() => g("nameType"))), l.push("]"), l) : (F.variance && l.push(g("variance")), F.in && l.push("in "), F.out && l.push("out "), l.push(g("name")), F.bound && l.push(": ", g("bound")), F.constraint && l.push(" extends ", g("constraint")), F.default && l.push(" = ", g("default")), l);
            }
            n.exports = { printTypeParameter: P, printTypeParameters: I, getTypeParametersGroupId: B };
          } }), Qt = Z({ "src/language-js/print/property.js"(e, n) {
            "use strict";
            re();
            var { printComments: t } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: o, rawText: c } = Ke(), { printAssignment: v } = Yt(), m = /* @__PURE__ */ new WeakMap();
            function d(f, h, w) {
              let T = f.getNode();
              if (T.computed)
                return ["[", w("key"), "]"];
              let A = f.getParentNode(), { key: S } = T;
              if (T.type === "ClassPrivateProperty" && S.type === "Identifier")
                return ["#", w("key")];
              if (h.quoteProps === "consistent" && !m.has(A)) {
                let B = (A.properties || A.body || A.members).some((I) => !I.computed && I.key && i(I.key) && !o(I, h));
                m.set(A, B);
              }
              if ((S.type === "Identifier" || r(S) && u(a(c(S))) && String(S.value) === a(c(S)) && !(h.parser === "typescript" || h.parser === "babel-ts")) && (h.parser === "json" || h.quoteProps === "consistent" && m.get(A))) {
                let B = s(JSON.stringify(S.type === "Identifier" ? S.name : S.value.toString()), h);
                return f.call((I) => t(I, B, h), "key");
              }
              return o(T, h) && (h.quoteProps === "as-needed" || h.quoteProps === "consistent" && !m.get(A)) ? f.call((B) => t(B, /^\d/.test(S.value) ? a(S.value) : S.value, h), "key") : w("key");
            }
            function p(f, h, w) {
              return f.getValue().shorthand ? w("value") : v(f, h, w, d(f, h, w), ":", "value");
            }
            n.exports = { printProperty: p, printPropertyKey: d };
          } }), Lr = Z({ "src/language-js/print/function.js"(e, n) {
            "use strict";
            re();
            var t = Xt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), r = it(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: o, group: c, indent: v, ifBreak: m, hardline: d, join: p, indentIfBreak: f }, utils: { removeLines: h, willBreak: w } } = Oe(), { ArgExpansionBailout: T } = zt(), { getFunctionParameters: A, hasLeadingOwnLineComment: S, isFlowAnnotationComment: B, isJsxNode: I, isTemplateOnItsOwnLine: k, shouldPrintComma: P, startsWithNoLookaheadToken: C, isBinaryish: D, isLineComment: g, hasComment: F, getComments: l, CommentCheckFlags: E, isCallLikeExpression: y, isCallExpression: N, getCallArguments: x, hasNakedLeftSide: b, getLeftSide: L } = Ke(), { locEnd: M } = st(), { printFunctionParameters: j, shouldGroupFunctionParameters: $ } = Pr(), { printPropertyKey: V } = Qt(), { printFunctionTypeParameters: q } = ct();
            function Y(z, U, le, ge) {
              let Ae = z.getValue(), Ne = false;
              if ((Ae.type === "FunctionDeclaration" || Ae.type === "FunctionExpression") && ge && ge.expandLastArg) {
                let ae = z.getParentNode();
                N(ae) && x(ae).length > 1 && (Ne = true);
              }
              let ke = [];
              Ae.type === "TSDeclareFunction" && Ae.declare && ke.push("declare "), Ae.async && ke.push("async "), Ae.generator ? ke.push("function* ") : ke.push("function "), Ae.id && ke.push(U("id"));
              let ce = j(z, U, le, Ne), pe = X(z, U, le), de = $(Ae, pe);
              return ke.push(q(z, le, U), c([de ? c(ce) : ce, pe]), Ae.body ? " " : "", U("body")), le.semi && (Ae.declare || !Ae.body) && ke.push(";"), ke;
            }
            function H(z, U, le) {
              let ge = z.getNode(), { kind: Ae } = ge, Ne = ge.value || ge, ke = [];
              return !Ae || Ae === "init" || Ae === "method" || Ae === "constructor" ? Ne.async && ke.push("async ") : (t.ok(Ae === "get" || Ae === "set"), ke.push(Ae, " ")), Ne.generator && ke.push("*"), ke.push(V(z, U, le), ge.optional || ge.key.optional ? "?" : ""), ge === Ne ? ke.push(R(z, U, le)) : Ne.type === "FunctionExpression" ? ke.push(z.call((ce) => R(ce, U, le), "value")) : ke.push(le("value")), ke;
            }
            function R(z, U, le) {
              let ge = z.getNode(), Ae = j(z, le, U), Ne = X(z, le, U), ke = $(ge, Ne), ce = [q(z, U, le), c([ke ? c(Ae) : Ae, Ne])];
              return ge.body ? ce.push(" ", le("body")) : ce.push(U.semi ? ";" : ""), ce;
            }
            function Q(z, U, le, ge) {
              let Ae = z.getValue(), Ne = [];
              if (Ae.async && Ne.push("async "), W(z, U))
                Ne.push(le(["params", 0]));
              else {
                let ce = ge && (ge.expandLastArg || ge.expandFirstArg), pe = X(z, le, U);
                if (ce) {
                  if (w(pe))
                    throw new T();
                  pe = c(h(pe));
                }
                Ne.push(c([j(z, le, U, ce, true), pe]));
              }
              let ke = s(z, U, true, (ce) => {
                let pe = u(U.originalText, ce, M);
                return pe !== false && U.originalText.slice(pe, pe + 2) === "=>";
              });
              return ke && Ne.push(" ", ke), Ne;
            }
            function ee(z, U, le, ge, Ae, Ne) {
              let ke = z.getName(), ce = z.getParentNode(), pe = y(ce) && ke === "callee", de = Boolean(U && U.assignmentLayout), ae = Ne.body.type !== "BlockStatement" && Ne.body.type !== "ObjectExpression" && Ne.body.type !== "SequenceExpression", ve = pe && ae || U && U.assignmentLayout === "chain-tail-arrow-chain", K = Symbol("arrow-chain");
              return Ne.body.type === "SequenceExpression" && (Ae = c(["(", v([o, Ae]), o, ")"])), c([c(v([pe || de ? o : "", c(p([" =>", i], le), { shouldBreak: ge })]), { id: K, shouldBreak: ve }), " =>", f(ae ? v([i, Ae]) : [" ", Ae], { groupId: K }), pe ? m(o, "", { groupId: K }) : ""]);
            }
            function te(z, U, le, ge) {
              let Ae = z.getValue(), Ne = [], ke = [], ce = false;
              if (function K() {
                let he = Q(z, U, le, ge);
                if (Ne.length === 0)
                  Ne.push(he);
                else {
                  let { leading: ye, trailing: Ce } = a(z, U);
                  Ne.push([ye, he]), ke.unshift(Ce);
                }
                ce = ce || Ae.returnType && A(Ae).length > 0 || Ae.typeParameters || A(Ae).some((ye) => ye.type !== "Identifier"), Ae.body.type !== "ArrowFunctionExpression" || ge && ge.expandLastArg ? ke.unshift(le("body", ge)) : (Ae = Ae.body, z.call(K, "body"));
              }(), Ne.length > 1)
                return ee(z, ge, Ne, ce, ke, Ae);
              let pe = Ne;
              if (pe.push(" =>"), !S(U.originalText, Ae.body) && (Ae.body.type === "ArrayExpression" || Ae.body.type === "ObjectExpression" || Ae.body.type === "BlockStatement" || I(Ae.body) || k(Ae.body, U.originalText) || Ae.body.type === "ArrowFunctionExpression" || Ae.body.type === "DoExpression"))
                return c([...pe, " ", ke]);
              if (Ae.body.type === "SequenceExpression")
                return c([...pe, c([" (", v([o, ke]), o, ")"])]);
              let de = (ge && ge.expandLastArg || z.getParentNode().type === "JSXExpressionContainer") && !F(Ae), ae = ge && ge.expandLastArg && P(U, "all"), ve = Ae.body.type === "ConditionalExpression" && !C(Ae.body, false);
              return c([...pe, c([v([i, ve ? m("", "(") : "", ke, ve ? m("", ")") : ""]), de ? [m(ae ? "," : ""), o] : ""])]);
            }
            function oe(z) {
              let U = A(z);
              return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === "Identifier" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;
            }
            function W(z, U) {
              if (U.arrowParens === "always")
                return false;
              if (U.arrowParens === "avoid") {
                let le = z.getValue();
                return oe(le);
              }
              return false;
            }
            function X(z, U, le) {
              let ge = z.getValue(), Ae = U("returnType");
              if (ge.returnType && B(le.originalText, ge.returnType))
                return [" /*: ", Ae, " */"];
              let Ne = [Ae];
              return ge.returnType && ge.returnType.typeAnnotation && Ne.unshift(": "), ge.predicate && Ne.push(ge.returnType ? " " : ": ", U("predicate")), Ne;
            }
            function ue(z, U, le) {
              let ge = z.getValue(), Ae = U.semi ? ";" : "", Ne = [];
              ge.argument && (G(U, ge.argument) ? Ne.push([" (", v([d, le("argument")]), d, ")"]) : D(ge.argument) || ge.argument.type === "SequenceExpression" ? Ne.push(c([m(" (", " "), v([o, le("argument")]), o, m(")")])) : Ne.push(" ", le("argument")));
              let ke = l(ge), ce = r(ke), pe = ce && g(ce);
              return pe && Ne.push(Ae), F(ge, E.Dangling) && Ne.push(" ", s(z, U, true)), pe || Ne.push(Ae), Ne;
            }
            function De(z, U, le) {
              return ["return", ue(z, U, le)];
            }
            function ie(z, U, le) {
              return ["throw", ue(z, U, le)];
            }
            function G(z, U) {
              if (S(z.originalText, U))
                return true;
              if (b(U)) {
                let le = U, ge;
                for (; ge = L(le); )
                  if (le = ge, S(z.originalText, le))
                    return true;
              }
              return false;
            }
            n.exports = { printFunction: Y, printArrowFunction: te, printMethod: H, printReturnStatement: De, printThrowStatement: ie, printMethodInternal: R, shouldPrintParamsWithoutParens: W };
          } }), Un = Z({ "src/language-js/print/decorators.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a, hardline: r, join: u, breakParent: i, group: o } } = Oe(), { locStart: c, locEnd: v } = st(), { getParentExportDeclaration: m } = Ke();
            function d(T, A, S) {
              let B = T.getValue();
              return o([u(a, T.map(S, "decorators")), h(B, A) ? r : a]);
            }
            function p(T, A, S) {
              return [u(r, T.map(S, "declaration", "decorators")), r];
            }
            function f(T, A, S) {
              let B = T.getValue(), { decorators: I } = B;
              if (!t(I) || w(T.getParentNode()))
                return;
              let k = B.type === "ClassExpression" || B.type === "ClassDeclaration" || h(B, A);
              return [m(T) ? r : k ? i : "", u(a, T.map(S, "decorators")), a];
            }
            function h(T, A) {
              return T.decorators.some((S) => s(A.originalText, v(S)));
            }
            function w(T) {
              if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration")
                return false;
              let A = T.declaration && T.declaration.decorators;
              return t(A) && c(T, { ignoreDecorators: true }) > c(A[0]);
            }
            n.exports = { printDecorators: f, printClassMemberDecorators: d, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: w };
          } }), Zt = Z({ "src/language-js/print/class.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: r } = et(), { builders: { join: u, line: i, hardline: o, softline: c, group: v, indent: m, ifBreak: d } } = Oe(), { hasComment: p, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: h } = Ir(), { printMethod: w } = Lr(), { printOptionalToken: T, printTypeAnnotation: A, printDefiniteToken: S } = ct(), { printPropertyKey: B } = Qt(), { printAssignment: I } = Yt(), { printClassMemberDecorators: k } = Un();
            function P(x, b, L) {
              let M = x.getValue(), j = [];
              M.declare && j.push("declare "), M.abstract && j.push("abstract "), j.push("class");
              let $ = M.id && p(M.id, f.Trailing) || M.typeParameters && p(M.typeParameters, f.Trailing) || M.superClass && p(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), V = [], q = [];
              if (M.id && V.push(" ", L("id")), V.push(L("typeParameters")), M.superClass) {
                let Y = [E(x, b, L), L("superTypeParameters")], H = x.call((R) => ["extends ", a(R, Y, b)], "superClass");
                $ ? q.push(i, v(H)) : q.push(" ", H);
              } else
                q.push(l(x, b, L, "extends"));
              if (q.push(l(x, b, L, "mixins"), l(x, b, L, "implements")), $) {
                let Y;
                F(M) ? Y = [...V, m(q)] : Y = m([...V, q]), j.push(v(Y, { id: C(M) }));
              } else
                j.push(...V, ...q);
              return j.push(" ", L("body")), j;
            }
            var C = s("heritageGroup");
            function D(x) {
              return d(o, "", { groupId: C(x) });
            }
            function g(x) {
              return ["superClass", "extends", "mixins", "implements"].filter((b) => Boolean(x[b])).length > 1;
            }
            function F(x) {
              return x.typeParameters && !p(x.typeParameters, f.Trailing | f.Line) && !g(x);
            }
            function l(x, b, L, M) {
              let j = x.getValue();
              if (!t(j[M]))
                return "";
              let $ = r(x, b, true, (V) => {
                let { marker: q } = V;
                return q === M;
              });
              return [F(j) ? d(" ", i, { groupId: h(j.typeParameters) }) : i, $, $ && o, M, v(m([i, u([",", i], x.map(L, M))]))];
            }
            function E(x, b, L) {
              let M = L("superClass");
              return x.getParentNode().type === "AssignmentExpression" ? v(d(["(", m([c, M]), c, ")"], M)) : M;
            }
            function y(x, b, L) {
              let M = x.getValue(), j = [];
              return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + " "), M.readonly && j.push("readonly "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), j.push(w(x, b, L)), j;
            }
            function N(x, b, L) {
              let M = x.getValue(), j = [], $ = b.semi ? ";" : "";
              return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + " "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), M.readonly && j.push("readonly "), M.variance && j.push(L("variance")), M.type === "ClassAccessorProperty" && j.push("accessor "), j.push(B(x, b, L), T(x), S(x), A(x, b, L)), [I(x, b, L, j, " =", "value"), $];
            }
            n.exports = { printClass: P, printClassMethod: y, printClassProperty: N, printHardlineAfterHeritage: D };
          } }), lo = Z({ "src/language-js/print/interface.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a, group: r, indent: u, ifBreak: i } } = Oe(), { hasComment: o, identity: c, CommentCheckFlags: v } = Ke(), { getTypeParametersGroupId: m } = Ir(), { printTypeScriptModifiers: d } = ct();
            function p(f, h, w) {
              let T = f.getValue(), A = [];
              T.declare && A.push("declare "), T.type === "TSInterfaceDeclaration" && A.push(T.abstract ? "abstract " : "", d(f, h, w)), A.push("interface");
              let S = [], B = [];
              T.type !== "InterfaceTypeAnnotation" && S.push(" ", w("id"), w("typeParameters"));
              let I = T.typeParameters && !o(T.typeParameters, v.Trailing | v.Line);
              return t(T.extends) && B.push(I ? i(" ", a, { groupId: m(T.typeParameters) }) : a, "extends ", (T.extends.length === 1 ? c : u)(s([",", a], f.map(w, "extends")))), T.id && o(T.id, v.Trailing) || t(T.extends) ? I ? A.push(r([...S, u(B)])) : A.push(r(u([...S, ...B]))) : A.push(...S, ...B), A.push(" ", w("body")), r(A);
            }
            n.exports = { printInterface: p };
          } }), co = Z({ "src/language-js/print/module.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a, indent: r, join: u, line: i, ifBreak: o, hardline: c } } = Oe(), { printDanglingComments: v } = et(), { hasComment: m, CommentCheckFlags: d, shouldPrintComma: p, needsHardlineAfterDanglingComment: f, isStringLiteral: h, rawText: w } = Ke(), { locStart: T, hasSameLoc: A } = st(), { hasDecoratorsBeforeExport: S, printDecoratorsBeforeExport: B } = Un();
            function I(N, x, b) {
              let L = N.getValue(), M = x.semi ? ";" : "", j = [], { importKind: $ } = L;
              return j.push("import"), $ && $ !== "value" && j.push(" ", $), j.push(g(N, x, b), D(N, x, b), l(N, x, b), M), j;
            }
            function k(N, x, b) {
              let L = N.getValue(), M = [];
              S(L) && M.push(B(N, x, b));
              let { type: j, exportKind: $, declaration: V } = L;
              return M.push("export"), (L.default || j === "ExportDefaultDeclaration") && M.push(" default"), m(L, d.Dangling) && (M.push(" ", v(N, x, true)), f(L) && M.push(c)), V ? M.push(" ", b("declaration")) : M.push($ === "type" ? " type" : "", g(N, x, b), D(N, x, b), l(N, x, b)), C(L, x) && M.push(";"), M;
            }
            function P(N, x, b) {
              let L = N.getValue(), M = x.semi ? ";" : "", j = [], { exportKind: $, exported: V } = L;
              return j.push("export"), $ === "type" && j.push(" type"), j.push(" *"), V && j.push(" as ", b("exported")), j.push(D(N, x, b), l(N, x, b), M), j;
            }
            function C(N, x) {
              if (!x.semi)
                return false;
              let { type: b, declaration: L } = N, M = N.default || b === "ExportDefaultDeclaration";
              if (!L)
                return true;
              let { type: j } = L;
              return !!(M && j !== "ClassDeclaration" && j !== "FunctionDeclaration" && j !== "TSInterfaceDeclaration" && j !== "DeclareClass" && j !== "DeclareFunction" && j !== "TSDeclareFunction" && j !== "EnumDeclaration");
            }
            function D(N, x, b) {
              let L = N.getValue();
              if (!L.source)
                return "";
              let M = [];
              return F(L, x) || M.push(" from"), M.push(" ", b("source")), M;
            }
            function g(N, x, b) {
              let L = N.getValue();
              if (F(L, x))
                return "";
              let M = [" "];
              if (t(L.specifiers)) {
                let j = [], $ = [];
                N.each(() => {
                  let V = N.getValue().type;
                  if (V === "ExportNamespaceSpecifier" || V === "ExportDefaultSpecifier" || V === "ImportNamespaceSpecifier" || V === "ImportDefaultSpecifier")
                    j.push(b());
                  else if (V === "ExportSpecifier" || V === "ImportSpecifier")
                    $.push(b());
                  else
                    throw new Error("Unknown specifier type ".concat(JSON.stringify(V)));
                }, "specifiers"), M.push(u(", ", j)), $.length > 0 && (j.length > 0 && M.push(", "), $.length > 1 || j.length > 0 || L.specifiers.some((q) => m(q)) ? M.push(a(["{", r([x.bracketSpacing ? i : s, u([",", i], $)]), o(p(x) ? "," : ""), x.bracketSpacing ? i : s, "}"])) : M.push(["{", x.bracketSpacing ? " " : "", ...$, x.bracketSpacing ? " " : "", "}"]));
              } else
                M.push("{}");
              return M;
            }
            function F(N, x) {
              let { type: b, importKind: L, source: M, specifiers: j } = N;
              return b !== "ImportDeclaration" || t(j) || L === "type" ? false : !/{\s*}/.test(x.originalText.slice(T(N), T(M)));
            }
            function l(N, x, b) {
              let L = N.getNode();
              return t(L.assertions) ? [" assert {", x.bracketSpacing ? " " : "", u(", ", N.map(b, "assertions")), x.bracketSpacing ? " " : "", "}"] : "";
            }
            function E(N, x, b) {
              let L = N.getNode(), { type: M } = L, j = [], $ = M === "ImportSpecifier" ? L.importKind : L.exportKind;
              $ && $ !== "value" && j.push($, " ");
              let V = M.startsWith("Import"), q = V ? "imported" : "local", Y = V ? "local" : "exported", H = L[q], R = L[Y], Q = "", ee = "";
              return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Q = "*" : H && (Q = b(q)), R && !y(L) && (ee = b(Y)), j.push(Q, Q && ee ? " as " : "", ee), j;
            }
            function y(N) {
              if (N.type !== "ImportSpecifier" && N.type !== "ExportSpecifier")
                return false;
              let { local: x, [N.type === "ImportSpecifier" ? "imported" : "exported"]: b } = N;
              if (x.type !== b.type || !A(x, b))
                return false;
              if (h(x))
                return x.value === b.value && w(x) === w(b);
              switch (x.type) {
                case "Identifier":
                  return x.name === b.name;
                default:
                  return false;
              }
            }
            n.exports = { printImportDeclaration: I, printExportDeclaration: k, printExportAllDeclaration: P, printModuleSpecifier: E };
          } }), zn = Z({ "src/language-js/print/object.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: r, indent: u, ifBreak: i, hardline: o } } = Oe(), { getLast: c, hasNewlineInRange: v, hasNewline: m, isNonEmptyArray: d } = Ue(), { shouldPrintComma: p, hasComment: f, getComments: h, CommentCheckFlags: w, isNextLineEmpty: T } = Ke(), { locStart: A, locEnd: S } = st(), { printOptionalToken: B, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: k } = Pr(), { shouldHugType: P } = kr(), { printHardlineAfterHeritage: C } = Zt();
            function D(g, F, l) {
              let E = F.semi ? ";" : "", y = g.getValue(), N;
              y.type === "TSTypeLiteral" ? N = "members" : y.type === "TSInterfaceBody" ? N = "body" : N = "properties";
              let x = y.type === "ObjectTypeAnnotation", b = [N];
              x && b.push("indexers", "callProperties", "internalSlots");
              let L = b.map((W) => y[W][0]).sort((W, X) => A(W) - A(X))[0], M = g.getParentNode(0), j = x && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && g.getName() === "body", $ = y.type === "TSInterfaceBody" || j || y.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && y.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || y.type !== "ObjectPattern" && L && v(F.originalText, A(y), A(L)), V = j ? ";" : y.type === "TSInterfaceBody" || y.type === "TSTypeLiteral" ? i(E, ";") : ",", q = y.type === "RecordExpression" ? "#{" : y.exact ? "{|" : "{", Y = y.exact ? "|}" : "}", H = [];
              for (let W of b)
                g.each((X) => {
                  let ue = X.getValue();
                  H.push({ node: ue, printed: l(), loc: A(ue) });
                }, W);
              b.length > 1 && H.sort((W, X) => W.loc - X.loc);
              let R = [], Q = H.map((W) => {
                let X = [...R, r(W.printed)];
                return R = [V, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, w.PrettierIgnore) && R.shift(), T(W.node, F) && R.push(o), X;
              });
              if (y.inexact) {
                let W;
                if (f(y, w.Dangling)) {
                  let X = f(y, w.Line);
                  W = [t(g, F, true), X || m(F.originalText, S(c(h(y)))) ? o : s, "..."];
                } else
                  W = ["..."];
                Q.push([...R, ...W]);
              }
              let ee = c(y[N]), te = !(y.inexact || ee && ee.type === "RestElement" || ee && (ee.type === "TSPropertySignature" || ee.type === "TSCallSignatureDeclaration" || ee.type === "TSMethodSignature" || ee.type === "TSConstructSignatureDeclaration") && f(ee, w.PrettierIgnore)), oe;
              if (Q.length === 0) {
                if (!f(y, w.Dangling))
                  return [q, Y, I(g, F, l)];
                oe = r([q, t(g, F), a, Y, B(g), I(g, F, l)]);
              } else
                oe = [j && d(y.properties) ? C(M) : "", q, u([F.bracketSpacing ? s : a, ...Q]), i(te && (V !== "," || p(F)) ? V : ""), F.bracketSpacing ? s : a, Y, B(g), I(g, F, l)];
              return g.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, X, ue) => k(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && ue === 0) || g.match(P, (W, X) => X === "typeAnnotation", (W, X) => X === "typeAnnotation", (W, X, ue) => k(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && ue === 0) || !$ && g.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? oe : r(oe, { shouldBreak: $ });
            }
            n.exports = { printObject: D };
          } }), Um = Z({ "src/language-js/print/flow.js"(e, n) {
            "use strict";
            re();
            var t = Xt(), { printDanglingComments: s } = et(), { printString: a, printNumber: r } = Ue(), { builders: { hardline: u, softline: i, group: o, indent: c } } = Oe(), { getParentExportDeclaration: v, isFunctionNotation: m, isGetterOrSetter: d, rawText: p, shouldPrintComma: f } = Ke(), { locStart: h, locEnd: w } = st(), { printClass: T } = Zt(), { printOpaqueType: A, printTypeAlias: S, printIntersectionType: B, printUnionType: I, printFunctionType: k, printTupleType: P, printIndexedAccessType: C } = kr(), { printInterface: D } = lo(), { printTypeParameter: g, printTypeParameters: F } = Ir(), { printExportDeclaration: l, printExportAllDeclaration: E } = co(), { printArrayItems: y } = Kt(), { printObject: N } = zn(), { printPropertyKey: x } = Qt(), { printOptionalToken: b, printTypeAnnotation: L, printRestSpread: M } = ct();
            function j(V, q, Y) {
              let H = V.getValue(), R = q.semi ? ";" : "", Q = [];
              switch (H.type) {
                case "DeclareClass":
                  return $(V, T(V, q, Y));
                case "DeclareFunction":
                  return $(V, ["function ", Y("id"), H.predicate ? " " : "", Y("predicate"), R]);
                case "DeclareModule":
                  return $(V, ["module ", Y("id"), " ", Y("body")]);
                case "DeclareModuleExports":
                  return $(V, ["module.exports", ": ", Y("typeAnnotation"), R]);
                case "DeclareVariable":
                  return $(V, ["var ", Y("id"), R]);
                case "DeclareOpaqueType":
                  return $(V, A(V, q, Y));
                case "DeclareInterface":
                  return $(V, D(V, q, Y));
                case "DeclareTypeAlias":
                  return $(V, S(V, q, Y));
                case "DeclareExportDeclaration":
                  return $(V, l(V, q, Y));
                case "DeclareExportAllDeclaration":
                  return $(V, E(V, q, Y));
                case "OpaqueType":
                  return A(V, q, Y);
                case "TypeAlias":
                  return S(V, q, Y);
                case "IntersectionTypeAnnotation":
                  return B(V, q, Y);
                case "UnionTypeAnnotation":
                  return I(V, q, Y);
                case "FunctionTypeAnnotation":
                  return k(V, q, Y);
                case "TupleTypeAnnotation":
                  return P(V, q, Y);
                case "GenericTypeAnnotation":
                  return [Y("id"), F(V, q, Y, "typeParameters")];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                  return C(V, q, Y);
                case "TypeAnnotation":
                  return Y("typeAnnotation");
                case "TypeParameter":
                  return g(V, q, Y);
                case "TypeofTypeAnnotation":
                  return ["typeof ", Y("argument")];
                case "ExistsTypeAnnotation":
                  return "*";
                case "EmptyTypeAnnotation":
                  return "empty";
                case "MixedTypeAnnotation":
                  return "mixed";
                case "ArrayTypeAnnotation":
                  return [Y("elementType"), "[]"];
                case "BooleanLiteralTypeAnnotation":
                  return String(H.value);
                case "EnumDeclaration":
                  return ["enum ", Y("id"), " ", Y("body")];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if (H.type === "EnumSymbolBody" || H.explicitType) {
                    let ee = null;
                    switch (H.type) {
                      case "EnumBooleanBody":
                        ee = "boolean";
                        break;
                      case "EnumNumberBody":
                        ee = "number";
                        break;
                      case "EnumStringBody":
                        ee = "string";
                        break;
                      case "EnumSymbolBody":
                        ee = "symbol";
                        break;
                    }
                    Q.push("of ", ee, " ");
                  }
                  if (H.members.length === 0 && !H.hasUnknownMembers)
                    Q.push(o(["{", s(V, q), i, "}"]));
                  else {
                    let ee = H.members.length > 0 ? [u, y(V, q, "members", Y), H.hasUnknownMembers || f(q) ? "," : ""] : [];
                    Q.push(o(["{", c([...ee, ...H.hasUnknownMembers ? [u, "..."] : []]), s(V, q, true), u, "}"]));
                  }
                  return Q;
                }
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return [Y("id"), " = ", typeof H.init == "object" ? Y("init") : String(H.init)];
                case "EnumDefaultedMember":
                  return Y("id");
                case "FunctionTypeParam": {
                  let ee = H.name ? Y("name") : V.getParentNode().this === H ? "this" : "";
                  return [ee, b(V), ee ? ": " : "", Y("typeAnnotation")];
                }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                  return D(V, q, Y);
                case "ClassImplements":
                case "InterfaceExtends":
                  return [Y("id"), Y("typeParameters")];
                case "NullableTypeAnnotation":
                  return ["?", Y("typeAnnotation")];
                case "Variance": {
                  let { kind: ee } = H;
                  return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
                }
                case "ObjectTypeCallProperty":
                  return H.static && Q.push("static "), Q.push(Y("value")), Q;
                case "ObjectTypeIndexer":
                  return [H.static ? "static " : "", H.variance ? Y("variance") : "", "[", Y("id"), H.id ? ": " : "", Y("key"), "]: ", Y("value")];
                case "ObjectTypeProperty": {
                  let ee = "";
                  return H.proto ? ee = "proto " : H.static && (ee = "static "), [ee, d(H) ? H.kind + " " : "", H.variance ? Y("variance") : "", x(V, q, Y), b(V), m(H) ? "" : ": ", Y("value")];
                }
                case "ObjectTypeAnnotation":
                  return N(V, q, Y);
                case "ObjectTypeInternalSlot":
                  return [H.static ? "static " : "", "[[", Y("id"), "]]", b(V), H.method ? "" : ": ", Y("value")];
                case "ObjectTypeSpreadProperty":
                  return M(V, q, Y);
                case "QualifiedTypeofIdentifier":
                case "QualifiedTypeIdentifier":
                  return [Y("qualification"), ".", Y("id")];
                case "StringLiteralTypeAnnotation":
                  return a(p(H), q);
                case "NumberLiteralTypeAnnotation":
                  t.strictEqual(typeof H.value, "number");
                case "BigIntLiteralTypeAnnotation":
                  return H.extra ? r(H.extra.raw) : r(H.raw);
                case "TypeCastExpression":
                  return ["(", Y("expression"), L(V, q, Y), ")"];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation": {
                  let ee = F(V, q, Y, "params");
                  if (q.parser === "flow") {
                    let te = h(H), oe = w(H), W = q.originalText.lastIndexOf("/*", te), X = q.originalText.indexOf("*/", oe);
                    if (W !== -1 && X !== -1) {
                      let ue = q.originalText.slice(W + 2, X).trim();
                      if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                        return ["/*:: ", ee, " */"];
                    }
                  }
                  return ee;
                }
                case "InferredPredicate":
                  return "%checks";
                case "DeclaredPredicate":
                  return ["%checks(", Y("value"), ")"];
                case "AnyTypeAnnotation":
                  return "any";
                case "BooleanTypeAnnotation":
                  return "boolean";
                case "BigIntTypeAnnotation":
                  return "bigint";
                case "NullLiteralTypeAnnotation":
                  return "null";
                case "NumberTypeAnnotation":
                  return "number";
                case "SymbolTypeAnnotation":
                  return "symbol";
                case "StringTypeAnnotation":
                  return "string";
                case "VoidTypeAnnotation":
                  return "void";
                case "ThisTypeAnnotation":
                  return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                  throw new Error("unprintable type: " + JSON.stringify(H.type));
              }
            }
            function $(V, q) {
              let Y = v(V);
              return Y ? (t.strictEqual(Y.type, "DeclareExportDeclaration"), q) : ["declare ", q];
            }
            n.exports = { printFlow: j };
          } }), zm = Z({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              let { type: a } = s;
              return a.startsWith("TS") && a.endsWith("Keyword");
            }
            n.exports = t;
          } }), po = Z({ "src/language-js/print/ternary.js"(e, n) {
            "use strict";
            re();
            var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: r, isMemberExpression: u } = Ke(), { locStart: i, locEnd: o } = st(), c = It(), { builders: { line: v, softline: m, group: d, indent: p, align: f, ifBreak: h, dedent: w, breakParent: T } } = Oe();
            function A(P) {
              let C = [P];
              for (let D = 0; D < C.length; D++) {
                let g = C[D];
                for (let F of ["test", "consequent", "alternate"]) {
                  let l = g[F];
                  if (s(l))
                    return true;
                  l.type === "ConditionalExpression" && C.push(l);
                }
              }
              return false;
            }
            function S(P, C, D) {
              let g = P.getValue(), F = g.type === "ConditionalExpression", l = F ? "alternate" : "falseType", E = P.getParentNode(), y = F ? D("test") : [D("checkType"), " ", "extends", " ", D("extendsType")];
              return E.type === g.type && E[l] === g ? f(2, y) : y;
            }
            var B = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
            function I(P) {
              let C = P.getValue();
              if (C.type !== "ConditionalExpression")
                return false;
              let D, g = C;
              for (let F = 0; !D; F++) {
                let l = P.getParentNode(F);
                if (r(l) && l.callee === g || u(l) && l.object === g || l.type === "TSNonNullExpression" && l.expression === g) {
                  g = l;
                  continue;
                }
                l.type === "NewExpression" && l.callee === g || l.type === "TSAsExpression" && l.expression === g ? (D = P.getParentNode(F + 1), g = l) : D = l;
              }
              return g === C ? false : D[B.get(D.type)] === g;
            }
            function k(P, C, D) {
              let g = P.getValue(), F = g.type === "ConditionalExpression", l = F ? "consequent" : "trueType", E = F ? "alternate" : "falseType", y = F ? ["test"] : ["checkType", "extendsType"], N = g[l], x = g[E], b = [], L = false, M = P.getParentNode(), j = M.type === g.type && y.some((ue) => M[ue] === g), $ = M.type === g.type && !j, V, q, Y = 0;
              do
                q = V || g, V = P.getParentNode(Y), Y++;
              while (V && V.type === g.type && y.every((ue) => V[ue] !== q));
              let H = V || M, R = q;
              if (F && (s(g[y[0]]) || s(N) || s(x) || A(R))) {
                L = true, $ = true;
                let ue = (ie) => [h("("), p([m, ie]), m, h(")")], De = (ie) => ie.type === "NullLiteral" || ie.type === "Literal" && ie.value === null || ie.type === "Identifier" && ie.name === "undefined";
                b.push(" ? ", De(N) ? D(l) : ue(D(l)), " : ", x.type === g.type || De(x) ? D(E) : ue(D(E)));
              } else {
                let ue = [v, "? ", N.type === g.type ? h("", "(") : "", f(2, D(l)), N.type === g.type ? h("", ")") : "", v, ": ", x.type === g.type ? D(E) : f(2, D(E))];
                b.push(M.type !== g.type || M[E] === g || j ? ue : C.useTabs ? w(p(ue)) : f(Math.max(0, C.tabWidth - 2), ue));
              }
              let ee = [...y.map((ue) => a(g[ue])), a(N), a(x)].flat().some((ue) => c(ue) && t(C.originalText, i(ue), o(ue))), te = (ue) => M === H ? d(ue, { shouldBreak: ee }) : ee ? [ue, T] : ue, oe = !L && (u(M) || M.type === "NGPipeExpression" && M.left === g) && !M.computed, W = I(P), X = te([S(P, C, D), $ ? b : p(b), F && oe && !W ? m : ""]);
              return j || W ? d([p([m, X]), m]) : X;
            }
            n.exports = { printTernary: k };
          } }), fo = Z({ "src/language-js/print/statement.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t } } = Oe(), s = jt(), { getLeftSidePathName: a, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: o, CommentCheckFlags: c, isNextLineEmpty: v } = Ke(), { shouldPrintParamsWithoutParens: m } = Lr();
            function d(B, I, k, P) {
              let C = B.getValue(), D = [], g = C.type === "ClassBody", F = p(C[P]);
              return B.each((l, E, y) => {
                let N = l.getValue();
                if (N.type === "EmptyStatement")
                  return;
                let x = k();
                !I.semi && !g && !i(I, l) && f(l, I) ? o(N, c.Leading) ? D.push(k([], { needsSemi: true })) : D.push(";", x) : D.push(x), !I.semi && g && A(N) && S(N, y[E + 1]) && D.push(";"), N !== F && (D.push(t), v(N, I) && D.push(t));
              }, P), D;
            }
            function p(B) {
              for (let I = B.length - 1; I >= 0; I--) {
                let k = B[I];
                if (k.type !== "EmptyStatement")
                  return k;
              }
            }
            function f(B, I) {
              return B.getNode().type !== "ExpressionStatement" ? false : B.call((P) => h(P, I), "expression");
            }
            function h(B, I) {
              let k = B.getValue();
              switch (k.type) {
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                case "ArrayExpression":
                case "ArrayPattern":
                case "TemplateLiteral":
                case "TemplateElement":
                case "RegExpLiteral":
                  return true;
                case "ArrowFunctionExpression": {
                  if (!m(B, I))
                    return true;
                  break;
                }
                case "UnaryExpression": {
                  let { prefix: P, operator: C } = k;
                  if (P && (C === "+" || C === "-"))
                    return true;
                  break;
                }
                case "BindExpression": {
                  if (!k.object)
                    return true;
                  break;
                }
                case "Literal": {
                  if (k.regex)
                    return true;
                  break;
                }
                default:
                  if (u(k))
                    return true;
              }
              return s(B, I) ? true : r(k) ? B.call((P) => h(P, I), ...a(B, k)) : false;
            }
            function w(B, I, k) {
              return d(B, I, k, "body");
            }
            function T(B, I, k) {
              return d(B, I, k, "consequent");
            }
            var A = (B) => {
              let { type: I } = B;
              return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty";
            };
            function S(B, I) {
              let k = B.key && B.key.name;
              if ((k === "static" || k === "get" || k === "set") && !B.value && !B.typeAnnotation)
                return true;
              if (!I || I.static || I.accessibility)
                return false;
              if (!I.computed) {
                let P = I.key && I.key.name;
                if (P === "in" || P === "instanceof")
                  return true;
              }
              if (A(I) && I.variance && !I.static && !I.declare)
                return true;
              switch (I.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return I.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                    return false;
                  let C = I.value ? I.value.generator : I.generator;
                  return !!(I.computed || C);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }
            n.exports = { printBody: w, printSwitchCaseConsequent: T };
          } }), Do = Z({ "src/language-js/print/block.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: r } } = Oe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: o } = Ke(), { printHardlineAfterHeritage: c } = Zt(), { printBody: v } = fo();
            function m(p, f, h) {
              let w = p.getValue(), T = [];
              if (w.type === "StaticBlock" && T.push("static "), w.type === "ClassBody" && s(w.body)) {
                let S = p.getParentNode();
                T.push(c(S));
              }
              T.push("{");
              let A = d(p, f, h);
              if (A)
                T.push(r([a, A]), a);
              else {
                let S = p.getParentNode(), B = p.getParentNode(1);
                S.type === "ArrowFunctionExpression" || S.type === "FunctionExpression" || S.type === "FunctionDeclaration" || S.type === "ObjectMethod" || S.type === "ClassMethod" || S.type === "ClassPrivateMethod" || S.type === "ForStatement" || S.type === "WhileStatement" || S.type === "DoWhileStatement" || S.type === "DoExpression" || S.type === "CatchClause" && !B.finalizer || S.type === "TSModuleDeclaration" || S.type === "TSDeclareFunction" || w.type === "StaticBlock" || w.type === "ClassBody" || T.push(a);
              }
              return T.push("}"), T;
            }
            function d(p, f, h) {
              let w = p.getValue(), T = s(w.directives), A = w.body.some((I) => I.type !== "EmptyStatement"), S = u(w, i.Dangling);
              if (!T && !A && !S)
                return "";
              let B = [];
              if (T && p.each((I, k, P) => {
                B.push(h()), (k < P.length - 1 || A || S) && (B.push(a), o(I.getValue(), f) && B.push(a));
              }, "directives"), A && B.push(v(p, f, h)), S && B.push(t(p, f, true)), w.type === "Program") {
                let I = p.getParentNode();
                (!I || I.type !== "ModuleExpression") && B.push(a);
              }
              return B;
            }
            n.exports = { printBlock: m, printBlockBody: d };
          } }), Xm = Z({ "src/language-js/print/typescript.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: r, hardline: u, softline: i, group: o, indent: c, conditionalGroup: v, ifBreak: m } } = Oe(), { isLiteral: d, getTypeScriptMappedTypeModifier: p, shouldPrintComma: f, isCallExpression: h, isMemberExpression: w } = Ke(), T = zm(), { locStart: A, locEnd: S } = st(), { printOptionalToken: B, printTypeScriptModifiers: I } = ct(), { printTernary: k } = po(), { printFunctionParameters: P, shouldGroupFunctionParameters: C } = Pr(), { printTemplateLiteral: D } = Lt(), { printArrayItems: g } = Kt(), { printObject: F } = zn(), { printClassProperty: l, printClassMethod: E } = Zt(), { printTypeParameter: y, printTypeParameters: N } = Ir(), { printPropertyKey: x } = Qt(), { printFunction: b, printMethodInternal: L } = Lr(), { printInterface: M } = lo(), { printBlock: j } = Do(), { printTypeAlias: $, printIntersectionType: V, printUnionType: q, printFunctionType: Y, printTupleType: H, printIndexedAccessType: R, printJSDocType: Q } = kr();
            function ee(te, oe, W) {
              let X = te.getValue();
              if (!X.type.startsWith("TS"))
                return;
              if (T(X))
                return X.type.slice(2, -7).toLowerCase();
              let ue = oe.semi ? ";" : "", De = [];
              switch (X.type) {
                case "TSThisType":
                  return "this";
                case "TSTypeAssertion": {
                  let ie = !(X.expression.type === "ArrayExpression" || X.expression.type === "ObjectExpression"), G = o(["<", c([i, W("typeAnnotation")]), i, ">"]), z = [m("("), c([i, W("expression")]), i, m(")")];
                  return ie ? v([[G, W("expression")], [G, o(z, { shouldBreak: true })], [G, W("expression")]]) : o([G, W("expression")]);
                }
                case "TSDeclareFunction":
                  return b(te, W, oe);
                case "TSExportAssignment":
                  return ["export = ", W("expression"), ue];
                case "TSModuleBlock":
                  return j(te, oe, W);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                  return F(te, oe, W);
                case "TSTypeAliasDeclaration":
                  return $(te, oe, W);
                case "TSQualifiedName":
                  return a(".", [W("left"), W("right")]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                  return E(te, oe, W);
                case "TSAbstractPropertyDefinition":
                  return l(te, oe, W);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                  return De.push(W("expression")), X.typeParameters && De.push(W("typeParameters")), De;
                case "TSTemplateLiteralType":
                  return D(te, W, oe);
                case "TSNamedTupleMember":
                  return [W("label"), X.optional ? "?" : "", ": ", W("elementType")];
                case "TSRestType":
                  return ["...", W("typeAnnotation")];
                case "TSOptionalType":
                  return [W("typeAnnotation"), "?"];
                case "TSInterfaceDeclaration":
                  return M(te, oe, W);
                case "TSClassImplements":
                  return [W("expression"), W("typeParameters")];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return N(te, oe, W, "params");
                case "TSTypeParameter":
                  return y(te, oe, W);
                case "TSAsExpression": {
                  De.push(W("expression"), " as ", W("typeAnnotation"));
                  let ie = te.getParentNode();
                  return h(ie) && ie.callee === X || w(ie) && ie.object === X ? o([c([i, ...De]), i]) : De;
                }
                case "TSArrayType":
                  return [W("elementType"), "[]"];
                case "TSPropertySignature":
                  return X.readonly && De.push("readonly "), De.push(x(te, oe, W), B(te)), X.typeAnnotation && De.push(": ", W("typeAnnotation")), X.initializer && De.push(" = ", W("initializer")), De;
                case "TSParameterProperty":
                  return X.accessibility && De.push(X.accessibility + " "), X.export && De.push("export "), X.static && De.push("static "), X.override && De.push("override "), X.readonly && De.push("readonly "), De.push(W("parameter")), De;
                case "TSTypeQuery":
                  return ["typeof ", W("exprName"), W("typeParameters")];
                case "TSIndexSignature": {
                  let ie = te.getParentNode(), G = X.parameters.length > 1 ? m(f(oe) ? "," : "") : "", z = o([c([i, a([", ", i], te.map(W, "parameters"))]), G, i]);
                  return [X.export ? "export " : "", X.accessibility ? [X.accessibility, " "] : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.declare ? "declare " : "", "[", X.parameters ? z : "", X.typeAnnotation ? "]: " : "]", X.typeAnnotation ? W("typeAnnotation") : "", ie.type === "ClassBody" ? ue : ""];
                }
                case "TSTypePredicate":
                  return [X.asserts ? "asserts " : "", W("parameterName"), X.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
                case "TSNonNullExpression":
                  return [W("expression"), "!"];
                case "TSImportType":
                  return [X.isTypeOf ? "typeof " : "", "import(", W(X.parameter ? "parameter" : "argument"), ")", X.qualifier ? [".", W("qualifier")] : "", N(te, oe, W, "typeParameters")];
                case "TSLiteralType":
                  return W("literal");
                case "TSIndexedAccessType":
                  return R(te, oe, W);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType": {
                  if (X.type === "TSConstructorType" && X.abstract && De.push("abstract "), X.type !== "TSCallSignatureDeclaration" && De.push("new "), De.push(o(P(te, W, oe, false, true))), X.returnType || X.typeAnnotation) {
                    let ie = X.type === "TSConstructorType";
                    De.push(ie ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                  }
                  return De;
                }
                case "TSTypeOperator":
                  return [X.operator, " ", W("typeAnnotation")];
                case "TSMappedType": {
                  let ie = s(oe.originalText, A(X), S(X));
                  return o(["{", c([oe.bracketSpacing ? r : i, X.readonly ? [p(X.readonly, "readonly"), " "] : "", I(te, oe, W), W("typeParameter"), X.optional ? p(X.optional, "?") : "", X.typeAnnotation ? ": " : "", W("typeAnnotation"), m(ue)]), t(te, oe, true), oe.bracketSpacing ? r : i, "}"], { shouldBreak: ie });
                }
                case "TSMethodSignature": {
                  let ie = X.kind && X.kind !== "method" ? "".concat(X.kind, " ") : "";
                  De.push(X.accessibility ? [X.accessibility, " "] : "", ie, X.export ? "export " : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.abstract ? "abstract " : "", X.declare ? "declare " : "", X.computed ? "[" : "", W("key"), X.computed ? "]" : "", B(te));
                  let G = P(te, W, oe, false, true), z = X.returnType ? "returnType" : "typeAnnotation", U = X[z], le = U ? W(z) : "", ge = C(X, le);
                  return De.push(ge ? o(G) : G), U && De.push(": ", o(le)), o(De);
                }
                case "TSNamespaceExportDeclaration":
                  return De.push("export as namespace ", W("id")), oe.semi && De.push(";"), o(De);
                case "TSEnumDeclaration":
                  return X.declare && De.push("declare "), X.modifiers && De.push(I(te, oe, W)), X.const && De.push("const "), De.push("enum ", W("id"), " "), X.members.length === 0 ? De.push(o(["{", t(te, oe), i, "}"])) : De.push(o(["{", c([u, g(te, oe, "members", W), f(oe, "es5") ? "," : ""]), t(te, oe, true), u, "}"])), De;
                case "TSEnumMember":
                  return X.computed ? De.push("[", W("id"), "]") : De.push(W("id")), X.initializer && De.push(" = ", W("initializer")), De;
                case "TSImportEqualsDeclaration":
                  return X.isExport && De.push("export "), De.push("import "), X.importKind && X.importKind !== "value" && De.push(X.importKind, " "), De.push(W("id"), " = ", W("moduleReference")), oe.semi && De.push(";"), o(De);
                case "TSExternalModuleReference":
                  return ["require(", W("expression"), ")"];
                case "TSModuleDeclaration": {
                  let ie = te.getParentNode(), G = d(X.id), z = ie.type === "TSModuleDeclaration", U = X.body && X.body.type === "TSModuleDeclaration";
                  if (z)
                    De.push(".");
                  else {
                    X.declare && De.push("declare "), De.push(I(te, oe, W));
                    let le = oe.originalText.slice(A(X), A(X.id));
                    X.id.type === "Identifier" && X.id.name === "global" && !/namespace|module/.test(le) || De.push(G || /(?:^|\s)module(?:\s|$)/.test(le) ? "module " : "namespace ");
                  }
                  return De.push(W("id")), U ? De.push(W("body")) : X.body ? De.push(" ", o(W("body"))) : De.push(ue), De;
                }
                case "TSConditionalType":
                  return k(te, oe, W);
                case "TSInferType":
                  return ["infer", " ", W("typeParameter")];
                case "TSIntersectionType":
                  return V(te, oe, W);
                case "TSUnionType":
                  return q(te, oe, W);
                case "TSFunctionType":
                  return Y(te, oe, W);
                case "TSTupleType":
                  return H(te, oe, W);
                case "TSTypeReference":
                  return [W("typeName"), N(te, oe, W, "typeParameters")];
                case "TSTypeAnnotation":
                  return W("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                  return L(te, oe, W);
                case "TSJSDocAllType":
                  return "*";
                case "TSJSDocUnknownType":
                  return "?";
                case "TSJSDocNullableType":
                  return Q(te, W, "?");
                case "TSJSDocNonNullableType":
                  return Q(te, W, "!");
                case "TSInstantiationExpression":
                  return [W("expression"), W("typeParameters")];
                default:
                  throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(X.type), "."));
              }
            }
            n.exports = { printTypescript: ee };
          } }), Km = Z({ "src/language-js/print/comment.js"(e, n) {
            "use strict";
            re();
            var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: r } } = Oe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: o } = st(), c = It();
            function v(p, f) {
              let h = p.getValue();
              if (u(h))
                return f.originalText.slice(i(h), o(h)).trimEnd();
              if (c(h)) {
                if (m(h)) {
                  let A = d(h);
                  return h.trailing && !t(f.originalText, i(h), { backwards: true }) ? [a, A] : A;
                }
                let w = o(h), T = f.originalText.slice(w - 3, w) === "*-/";
                return ["/*", r(h.value), T ? "*-/" : "*/"];
              }
              throw new Error("Not a comment: " + JSON.stringify(h));
            }
            function m(p) {
              let f = "*".concat(p.value, "*").split(`
`);
              return f.length > 1 && f.every((h) => h.trim()[0] === "*");
            }
            function d(p) {
              let f = p.value.split(`
`);
              return ["/*", s(a, f.map((h, w) => w === 0 ? h.trimEnd() : " " + (w < f.length - 1 ? h.trim() : h.trimStart()))), "*/"];
            }
            n.exports = { printComment: v };
          } }), Ym = Z({ "src/language-js/print/literal.js"(e, n) {
            "use strict";
            re();
            var { printString: t, printNumber: s } = Ue();
            function a(i, o) {
              let c = i.getNode();
              switch (c.type) {
                case "RegExpLiteral":
                  return u(c);
                case "BigIntLiteral":
                  return r(c.bigint || c.extra.raw);
                case "NumericLiteral":
                  return s(c.extra.raw);
                case "StringLiteral":
                  return t(c.extra.raw, o);
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return String(c.value);
                case "DecimalLiteral":
                  return s(c.value) + "m";
                case "Literal": {
                  if (c.regex)
                    return u(c.regex);
                  if (c.bigint)
                    return r(c.raw);
                  if (c.decimal)
                    return s(c.decimal) + "m";
                  let { value: v } = c;
                  return typeof v == "number" ? s(c.raw) : typeof v == "string" ? t(c.raw, o) : String(v);
                }
              }
            }
            function r(i) {
              return i.toLowerCase();
            }
            function u(i) {
              let { pattern: o, flags: c } = i;
              return c = [...c].sort().join(""), "/".concat(o, "/").concat(c);
            }
            n.exports = { printLiteral: a };
          } }), Qm = Z({ "src/language-js/printer-estree.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: r, hardline: u, softline: i, group: o, indent: c }, utils: { replaceTextEndOfLine: v } } = Oe(), m = Im(), d = Lm(), { insertPragma: p } = no(), f = uo(), h = jt(), w = so(), { hasFlowShorthandAnnotationComment: T, hasComment: A, CommentCheckFlags: S, isTheOnlyJsxElementInMarkdown: B, isLineComment: I, isNextLineEmpty: k, needsHardlineAfterDanglingComment: P, rawText: C, hasIgnoreComment: D, isCallExpression: g, isMemberExpression: F, markerForIfWithoutBlockAndSameLineComment: l } = Ke(), { locStart: E, locEnd: y } = st(), N = It(), { printHtmlBinding: x, isVueEventBindingExpression: b } = $m(), { printAngular: L } = Hm(), { printJsx: M, hasJsxIgnoreComment: j } = Gm(), { printFlow: $ } = Um(), { printTypescript: V } = Xm(), { printOptionalToken: q, printBindExpressionCallee: Y, printTypeAnnotation: H, adjustClause: R, printRestSpread: Q, printDefiniteToken: ee } = ct(), { printImportDeclaration: te, printExportDeclaration: oe, printExportAllDeclaration: W, printModuleSpecifier: X } = co(), { printTernary: ue } = po(), { printTemplateLiteral: De } = Lt(), { printArray: ie } = Kt(), { printObject: G } = zn(), { printClass: z, printClassMethod: U, printClassProperty: le } = Zt(), { printProperty: ge } = Qt(), { printFunction: Ae, printArrowFunction: Ne, printMethod: ke, printReturnStatement: ce, printThrowStatement: pe } = Lr(), { printCallExpression: de } = oo(), { printVariableDeclarator: ae, printAssignmentExpression: ve } = Yt(), { printBinaryishExpression: K } = Jn(), { printSwitchCaseConsequent: he } = fo(), { printMemberExpression: ye } = ao(), { printBlock: Ce, printBlockBody: Ie } = Do(), { printComment: Fe } = Km(), { printLiteral: me } = Ym(), { printDecorators: _ } = Un();
            function J(Be, Pe, Se, Qe) {
              let xe = ne(Be, Pe, Se, Qe);
              if (!xe)
                return "";
              let Xe = Be.getValue(), { type: _e } = Xe;
              if (_e === "ClassMethod" || _e === "ClassPrivateMethod" || _e === "ClassProperty" || _e === "ClassAccessorProperty" || _e === "PropertyDefinition" || _e === "TSAbstractPropertyDefinition" || _e === "ClassPrivateProperty" || _e === "MethodDefinition" || _e === "TSAbstractMethodDefinition" || _e === "TSDeclareMethod")
                return xe;
              let je = [xe], Re = _(Be, Pe, Se), be = Xe.type === "ClassExpression" && Re;
              if (Re && (je = [...Re, xe], !be))
                return o(je);
              if (!h(Be, Pe))
                return Qe && Qe.needsSemi && je.unshift(";"), je.length === 1 && je[0] === xe ? xe : je;
              if (be && (je = [c([r, ...je])]), je.unshift("("), Qe && Qe.needsSemi && je.unshift(";"), T(Xe)) {
                let [qe] = Xe.trailingComments;
                je.push(" /*", qe.value.trimStart(), "*/"), qe.printed = true;
              }
              return be && je.push(r), je.push(")"), je;
            }
            function ne(Be, Pe, Se, Qe) {
              let xe = Be.getValue(), Xe = Pe.semi ? ";" : "";
              if (!xe)
                return "";
              if (typeof xe == "string")
                return xe;
              for (let je of [me, x, L, M, $, V]) {
                let Re = je(Be, Pe, Se);
                if (typeof Re < "u")
                  return Re;
              }
              let _e = [];
              switch (xe.type) {
                case "JsExpressionRoot":
                  return Se("node");
                case "JsonRoot":
                  return [Se("node"), u];
                case "File":
                  return xe.program && xe.program.interpreter && _e.push(Se(["program", "interpreter"])), _e.push(Se("program")), _e;
                case "Program":
                  return Ie(Be, Pe, Se);
                case "EmptyStatement":
                  return "";
                case "ExpressionStatement": {
                  if (xe.directive)
                    return [Ee(xe.expression, Pe), Xe];
                  if (Pe.parser === "__vue_event_binding" || Pe.parser === "__vue_ts_event_binding") {
                    let Re = Be.getParentNode();
                    if (Re.type === "Program" && Re.body.length === 1 && Re.body[0] === xe)
                      return [Se("expression"), b(xe.expression) ? ";" : ""];
                  }
                  let je = t(Be, Pe, true, (Re) => {
                    let { marker: be } = Re;
                    return be === l;
                  });
                  return [Se("expression"), B(Pe, Be) ? "" : Xe, je ? [" ", je] : ""];
                }
                case "ParenthesizedExpression":
                  return !A(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", Se("expression"), ")"] : o(["(", c([i, Se("expression")]), i, ")"]);
                case "AssignmentExpression":
                  return ve(Be, Pe, Se);
                case "VariableDeclarator":
                  return ae(Be, Pe, Se);
                case "BinaryExpression":
                case "LogicalExpression":
                  return K(Be, Pe, Se);
                case "AssignmentPattern":
                  return [Se("left"), " = ", Se("right")];
                case "OptionalMemberExpression":
                case "MemberExpression":
                  return ye(Be, Pe, Se);
                case "MetaProperty":
                  return [Se("meta"), ".", Se("property")];
                case "BindExpression":
                  return xe.object && _e.push(Se("object")), _e.push(o(c([i, Y(Be, Pe, Se)]))), _e;
                case "Identifier":
                  return [xe.name, q(Be), ee(Be), H(Be, Pe, Se)];
                case "V8IntrinsicIdentifier":
                  return ["%", xe.name];
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                  return Q(Be, Pe, Se);
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return Ae(Be, Se, Pe, Qe);
                case "ArrowFunctionExpression":
                  return Ne(Be, Pe, Se, Qe);
                case "YieldExpression":
                  return _e.push("yield"), xe.delegate && _e.push("*"), xe.argument && _e.push(" ", Se("argument")), _e;
                case "AwaitExpression": {
                  if (_e.push("await"), xe.argument) {
                    _e.push(" ", Se("argument"));
                    let je = Be.getParentNode();
                    if (g(je) && je.callee === xe || F(je) && je.object === xe) {
                      _e = [c([i, ..._e]), i];
                      let Re = Be.findAncestor((be) => be.type === "AwaitExpression" || be.type === "BlockStatement");
                      if (!Re || Re.type !== "AwaitExpression")
                        return o(_e);
                    }
                  }
                  return _e;
                }
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return oe(Be, Pe, Se);
                case "ExportAllDeclaration":
                  return W(Be, Pe, Se);
                case "ImportDeclaration":
                  return te(Be, Pe, Se);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                  return X(Be, Pe, Se);
                case "ImportAttribute":
                  return [Se("key"), ": ", Se("value")];
                case "Import":
                  return "import";
                case "BlockStatement":
                case "StaticBlock":
                case "ClassBody":
                  return Ce(Be, Pe, Se);
                case "ThrowStatement":
                  return pe(Be, Pe, Se);
                case "ReturnStatement":
                  return ce(Be, Pe, Se);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                  return de(Be, Pe, Se);
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  return G(Be, Pe, Se);
                case "ObjectProperty":
                case "Property":
                  return xe.method || xe.kind === "get" || xe.kind === "set" ? ke(Be, Pe, Se) : ge(Be, Pe, Se);
                case "ObjectMethod":
                  return ke(Be, Pe, Se);
                case "Decorator":
                  return ["@", Se("expression")];
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  return ie(Be, Pe, Se);
                case "SequenceExpression": {
                  let je = Be.getParentNode(0);
                  if (je.type === "ExpressionStatement" || je.type === "ForStatement") {
                    let Re = [];
                    return Be.each((be, Le) => {
                      Le === 0 ? Re.push(Se()) : Re.push(",", c([r, Se()]));
                    }, "expressions"), o(Re);
                  }
                  return o(a([",", r], Be.map(Se, "expressions")));
                }
                case "ThisExpression":
                  return "this";
                case "Super":
                  return "super";
                case "Directive":
                  return [Se("value"), Xe];
                case "DirectiveLiteral":
                  return Ee(xe, Pe);
                case "UnaryExpression":
                  return _e.push(xe.operator), /[a-z]$/.test(xe.operator) && _e.push(" "), A(xe.argument) ? _e.push(o(["(", c([i, Se("argument")]), i, ")"])) : _e.push(Se("argument")), _e;
                case "UpdateExpression":
                  return _e.push(Se("argument"), xe.operator), xe.prefix && _e.reverse(), _e;
                case "ConditionalExpression":
                  return ue(Be, Pe, Se);
                case "VariableDeclaration": {
                  let je = Be.map(Se, "declarations"), Re = Be.getParentNode(), be = Re.type === "ForStatement" || Re.type === "ForInStatement" || Re.type === "ForOfStatement", Le = xe.declarations.some((se) => se.init), qe;
                  return je.length === 1 && !A(xe.declarations[0]) ? qe = je[0] : je.length > 0 && (qe = c(je[0])), _e = [xe.declare ? "declare " : "", xe.kind, qe ? [" ", qe] : "", c(je.slice(1).map((se) => [",", Le && !be ? u : r, se]))], be && Re.body !== xe || _e.push(Xe), o(_e);
                }
                case "WithStatement":
                  return o(["with (", Se("object"), ")", R(xe.body, Se("body"))]);
                case "IfStatement": {
                  let je = R(xe.consequent, Se("consequent")), Re = o(["if (", o([c([i, Se("test")]), i]), ")", je]);
                  if (_e.push(Re), xe.alternate) {
                    let be = A(xe.consequent, S.Trailing | S.Line) || P(xe), Le = xe.consequent.type === "BlockStatement" && !be;
                    _e.push(Le ? " " : u), A(xe, S.Dangling) && _e.push(t(Be, Pe, true), be ? u : " "), _e.push("else", o(R(xe.alternate, Se("alternate"), xe.alternate.type === "IfStatement")));
                  }
                  return _e;
                }
                case "ForStatement": {
                  let je = R(xe.body, Se("body")), Re = t(Be, Pe, true), be = Re ? [Re, i] : "";
                  return !xe.init && !xe.test && !xe.update ? [be, o(["for (;;)", je])] : [be, o(["for (", o([c([i, Se("init"), ";", r, Se("test"), ";", r, Se("update")]), i]), ")", je])];
                }
                case "WhileStatement":
                  return o(["while (", o([c([i, Se("test")]), i]), ")", R(xe.body, Se("body"))]);
                case "ForInStatement":
                  return o(["for (", Se("left"), " in ", Se("right"), ")", R(xe.body, Se("body"))]);
                case "ForOfStatement":
                  return o(["for", xe.await ? " await" : "", " (", Se("left"), " of ", Se("right"), ")", R(xe.body, Se("body"))]);
                case "DoWhileStatement": {
                  let je = R(xe.body, Se("body"));
                  return _e = [o(["do", je])], xe.body.type === "BlockStatement" ? _e.push(" ") : _e.push(u), _e.push("while (", o([c([i, Se("test")]), i]), ")", Xe), _e;
                }
                case "DoExpression":
                  return [xe.async ? "async " : "", "do ", Se("body")];
                case "BreakStatement":
                  return _e.push("break"), xe.label && _e.push(" ", Se("label")), _e.push(Xe), _e;
                case "ContinueStatement":
                  return _e.push("continue"), xe.label && _e.push(" ", Se("label")), _e.push(Xe), _e;
                case "LabeledStatement":
                  return xe.body.type === "EmptyStatement" ? [Se("label"), ":;"] : [Se("label"), ": ", Se("body")];
                case "TryStatement":
                  return ["try ", Se("block"), xe.handler ? [" ", Se("handler")] : "", xe.finalizer ? [" finally ", Se("finalizer")] : ""];
                case "CatchClause":
                  if (xe.param) {
                    let je = A(xe.param, (be) => !N(be) || be.leading && s(Pe.originalText, y(be)) || be.trailing && s(Pe.originalText, E(be), { backwards: true })), Re = Se("param");
                    return ["catch ", je ? ["(", c([i, Re]), i, ") "] : ["(", Re, ") "], Se("body")];
                  }
                  return ["catch ", Se("body")];
                case "SwitchStatement":
                  return [o(["switch (", c([i, Se("discriminant")]), i, ")"]), " {", xe.cases.length > 0 ? c([u, a(u, Be.map((je, Re, be) => {
                    let Le = je.getValue();
                    return [Se(), Re !== be.length - 1 && k(Le, Pe) ? u : ""];
                  }, "cases"))]) : "", u, "}"];
                case "SwitchCase": {
                  xe.test ? _e.push("case ", Se("test"), ":") : _e.push("default:"), A(xe, S.Dangling) && _e.push(" ", t(Be, Pe, true));
                  let je = xe.consequent.filter((Re) => Re.type !== "EmptyStatement");
                  if (je.length > 0) {
                    let Re = he(Be, Pe, Se);
                    _e.push(je.length === 1 && je[0].type === "BlockStatement" ? [" ", Re] : c([u, Re]));
                  }
                  return _e;
                }
                case "DebuggerStatement":
                  return ["debugger", Xe];
                case "ClassDeclaration":
                case "ClassExpression":
                  return z(Be, Pe, Se);
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                  return U(Be, Pe, Se);
                case "ClassProperty":
                case "PropertyDefinition":
                case "ClassPrivateProperty":
                case "ClassAccessorProperty":
                  return le(Be, Pe, Se);
                case "TemplateElement":
                  return v(xe.value.raw);
                case "TemplateLiteral":
                  return De(Be, Se, Pe);
                case "TaggedTemplateExpression":
                  return [Se("tag"), Se("typeParameters"), Se("quasi")];
                case "PrivateIdentifier":
                  return ["#", Se("name")];
                case "PrivateName":
                  return ["#", Se("id")];
                case "InterpreterDirective":
                  return _e.push("#!", xe.value, u), k(xe, Pe) && _e.push(u), _e;
                case "TopicReference":
                  return "%";
                case "ArgumentPlaceholder":
                  return "?";
                case "ModuleExpression": {
                  _e.push("module {");
                  let je = Se("body");
                  return je && _e.push(c([u, je]), u), _e.push("}"), _e;
                }
                default:
                  throw new Error("unknown type: " + JSON.stringify(xe.type));
              }
            }
            function Ee(Be, Pe) {
              let Se = C(Be), Qe = Se.slice(1, -1);
              if (Qe.includes('"') || Qe.includes("'"))
                return Se;
              let xe = Pe.singleQuote ? "'" : '"';
              return xe + Qe + xe;
            }
            function We(Be) {
              return Be.type && !N(Be) && !I(Be) && Be.type !== "EmptyStatement" && Be.type !== "TemplateElement" && Be.type !== "Import" && Be.type !== "TSEmptyBodyFunctionExpression";
            }
            n.exports = { preprocess: w, print: J, embed: m, insertPragma: p, massageAstNode: d, hasPrettierIgnore(Be) {
              return D(Be) || j(Be);
            }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: We, printComment: Fe, isBlockComment: N, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
          } }), Zm = Z({ "src/language-js/printer-estree-json.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t, indent: s, join: a } } = Oe(), r = so();
            function u(c, v, m) {
              let d = c.getValue();
              switch (d.type) {
                case "JsonRoot":
                  return [m("node"), t];
                case "ArrayExpression": {
                  if (d.elements.length === 0)
                    return "[]";
                  let p = c.map(() => c.getValue() === null ? "null" : m(), "elements");
                  return ["[", s([t, a([",", t], p)]), t, "]"];
                }
                case "ObjectExpression":
                  return d.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], c.map(m, "properties"))]), t, "}"];
                case "ObjectProperty":
                  return [m("key"), ": ", m("value")];
                case "UnaryExpression":
                  return [d.operator === "+" ? "" : d.operator, m("argument")];
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return d.value ? "true" : "false";
                case "StringLiteral":
                case "NumericLiteral":
                  return JSON.stringify(d.value);
                case "Identifier": {
                  let p = c.getParentNode();
                  return p && p.type === "ObjectProperty" && p.key === d ? JSON.stringify(d.name) : d.name;
                }
                case "TemplateLiteral":
                  return m(["quasis", 0]);
                case "TemplateElement":
                  return JSON.stringify(d.value.cooked);
                default:
                  throw new Error("unknown type: " + JSON.stringify(d.type));
              }
            }
            var i = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
            function o(c, v) {
              let { type: m } = c;
              if (m === "ObjectProperty" && c.key.type === "Identifier") {
                v.key = { type: "StringLiteral", value: c.key.name };
                return;
              }
              if (m === "UnaryExpression" && c.operator === "+")
                return v.argument;
              if (m === "ArrayExpression") {
                for (let [d, p] of c.elements.entries())
                  p === null && v.elements.splice(d, 0, { type: "NullLiteral" });
                return;
              }
              if (m === "TemplateLiteral")
                return { type: "StringLiteral", value: c.quasis[0].value.cooked };
            }
            o.ignoredProperties = i, n.exports = { preprocess: r, print: u, massageAstNode: o };
          } }), Ot = Z({ "src/common/common-options.js"(e, n) {
            "use strict";
            re();
            var t = "Common";
            n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
          } }), ed = Z({ "src/language-js/options.js"(e, n) {
            "use strict";
            re();
            var t = Ot(), s = "JavaScript";
            n.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
          } }), td = Z({ "src/language-js/parse/parsers.js"() {
            re();
          } }), Sn = Z({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
            n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
          } }), rd = Z({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
            n.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
          } }), nd = Z({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
            n.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
          } }), ma = Z({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
            n.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
          } }), ud = Z({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
            n.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
          } }), sd = Z({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
            n.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
          } }), id = Z({ "src/language-js/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = Qm(), a = Zm(), r = ed(), u = td(), i = [t(Sn(), (c) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c.interpreters, "zx"], extensions: [...c.extensions.filter((v) => v !== ".jsx"), ".wxs"] })), t(Sn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Sn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(rd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(nd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(ma(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(ma(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c.extensions.filter((v) => v !== ".jsonl") })), t(ud(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c.filenames, ".eslintrc", ".swcrc"] })), t(sd(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], o = { estree: s, "estree-json": a };
            n.exports = { languages: i, options: r, printers: o, parsers: u };
          } }), ad = Z({ "src/language-css/clean.js"(e, n) {
            "use strict";
            re();
            var { isFrontMatterNode: t } = Ue(), s = it(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
            function r(i, o, c) {
              if (t(i) && i.lang === "yaml" && delete o.value, i.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete o.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || c.type === "css-root" && s(c.nodes) === i))
                return null;
              if (i.type === "value-root" && delete o.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete o.value, i.type === "css-rule" && delete o.params, i.type === "selector-combinator" && (o.value = o.value.replace(/\s+/g, " ")), i.type === "media-feature" && (o.value = o.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(o.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (o.value = o.value.toLowerCase()), i.type === "css-decl" && (o.prop = o.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (o.name = o.name.toLowerCase()), i.type === "value-number" && (o.unit = o.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && o.value && (o.value = u(o.value)), i.type === "selector-attribute" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == "string" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = true)), o.value && (o.value = o.value.trim().replace(/^["']|["']$/g, ""), delete o.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && o.value && (o.value = o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (v, m, d) => {
                let p = Number(m);
                return Number.isNaN(p) ? v : p + d.toLowerCase();
              })), i.type === "selector-tag") {
                let v = i.value.toLowerCase();
                ["from", "to"].includes(v) && (o.value = v);
              }
              if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete o.value, i.type === "selector-unknown" && delete o.value, i.type === "value-comma_group") {
                let v = i.groups.findIndex((m) => m.type === "value-number" && m.unit === "...");
                v !== -1 && (o.groups[v].unit = "", o.groups.splice(v + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
              }
            }
            r.ignoredProperties = a;
            function u(i) {
              return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
            }
            n.exports = r;
          } }), Xn = Z({ "src/utils/front-matter/print.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t, markAsRoot: s } } = Oe();
            function a(r, u) {
              if (r.lang === "yaml") {
                let i = r.value.trim(), o = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
                return s([r.startDelimiter, t, o, o ? t : "", r.endDelimiter]);
              }
            }
            n.exports = a;
          } }), od = Z({ "src/language-css/embed.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t } } = Oe(), s = Xn();
            function a(r, u, i) {
              let o = r.getValue();
              if (o.type === "front-matter") {
                let c = s(o, i);
                return c ? [c, t] : "";
              }
            }
            n.exports = a;
          } }), mo = Z({ "src/utils/front-matter/parse.js"(e, n) {
            "use strict";
            re();
            var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(a) {
              let r = a.match(t);
              if (!r)
                return { content: a };
              let { startDelimiter: u, language: i, value: o = "", endDelimiter: c } = r.groups, v = i.trim() || "yaml";
              if (u === "+++" && (v = "toml"), v !== "yaml" && u !== c)
                return { content: a };
              let [m] = r;
              return { frontMatter: { type: "front-matter", lang: v, value: o, startDelimiter: u, endDelimiter: c, raw: m.replace(/\n$/, "") }, content: m.replace(/[^\n]/g, " ") + a.slice(m.length) };
            }
            n.exports = s;
          } }), ld = Z({ "src/language-css/pragma.js"(e, n) {
            "use strict";
            re();
            var t = no(), s = mo();
            function a(u) {
              return t.hasPragma(s(u).content);
            }
            function r(u) {
              let { frontMatter: i, content: o } = s(u);
              return (i ? i.raw + `

` : "") + t.insertPragma(o);
            }
            n.exports = { hasPragma: a, insertPragma: r };
          } }), cd = Z({ "src/language-css/utils/index.js"(e, n) {
            "use strict";
            re();
            var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
            function s(G, z) {
              let U = Array.isArray(z) ? z : [z], le = -1, ge;
              for (; ge = G.getParentNode(++le); )
                if (U.includes(ge.type))
                  return le;
              return -1;
            }
            function a(G, z) {
              let U = s(G, z);
              return U === -1 ? null : G.getParentNode(U);
            }
            function r(G) {
              var z;
              let U = a(G, "css-decl");
              return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();
            }
            var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
            function i(G) {
              return u.has(G.toLowerCase());
            }
            function o(G, z) {
              let U = a(G, "css-atrule");
              return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(z.toLowerCase());
            }
            function c(G) {
              return G.includes("$") || G.includes("@") || G.includes("#") || G.startsWith("%") || G.startsWith("--") || G.startsWith(":--") || G.includes("(") && G.includes(")") ? G : G.toLowerCase();
            }
            function v(G, z) {
              var U;
              let le = a(G, "value-func");
              return (le == null || (U = le.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;
            }
            function m(G) {
              var z;
              let U = a(G, "css-rule"), le = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;
              return le && (le.startsWith(":import") || le.startsWith(":export"));
            }
            function d(G, z) {
              let U = Array.isArray(z) ? z : [z], le = a(G, "css-atrule");
              return le && U.includes(le.name.toLowerCase());
            }
            function p(G) {
              let z = G.getValue(), U = a(G, "css-atrule");
              return (U == null ? void 0 : U.name) === "import" && z.groups[0].value === "url" && z.groups.length === 2;
            }
            function f(G) {
              return G.type === "value-func" && G.value.toLowerCase() === "url";
            }
            function h(G, z) {
              var U;
              let le = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;
              return le && le.indexOf(z) === le.length - 1;
            }
            function w(G) {
              let { selector: z } = G;
              return z ? typeof z == "string" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : false;
            }
            function T(G) {
              return G.type === "value-word" && ["from", "through", "end"].includes(G.value);
            }
            function A(G) {
              return G.type === "value-word" && ["and", "or", "not"].includes(G.value);
            }
            function S(G) {
              return G.type === "value-word" && G.value === "in";
            }
            function B(G) {
              return G.type === "value-operator" && G.value === "*";
            }
            function I(G) {
              return G.type === "value-operator" && G.value === "/";
            }
            function k(G) {
              return G.type === "value-operator" && G.value === "+";
            }
            function P(G) {
              return G.type === "value-operator" && G.value === "-";
            }
            function C(G) {
              return G.type === "value-operator" && G.value === "%";
            }
            function D(G) {
              return B(G) || I(G) || k(G) || P(G) || C(G);
            }
            function g(G) {
              return G.type === "value-word" && ["==", "!="].includes(G.value);
            }
            function F(G) {
              return G.type === "value-word" && ["<", ">", "<=", ">="].includes(G.value);
            }
            function l(G) {
              return G.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(G.name);
            }
            function E(G) {
              var z;
              return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\(\s*\)$/.test(G.raws.params);
            }
            function y(G) {
              return G.name.startsWith("prettier-placeholder");
            }
            function N(G) {
              return G.prop.startsWith("@prettier-placeholder");
            }
            function x(G, z) {
              return G.value === "$$" && G.type === "value-func" && (z == null ? void 0 : z.type) === "value-word" && !z.raws.before;
            }
            function b(G) {
              var z, U;
              return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === "value-root" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === "value-value" && G.prop.toLowerCase() === "composes";
            }
            function L(G) {
              var z, U, le;
              return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le = U.group) === null || le === void 0 ? void 0 : le.type) === "value-paren_group" && G.value.group.group.open !== null && G.value.group.group.close !== null;
            }
            function M(G) {
              var z;
              return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === "";
            }
            function j(G) {
              var z, U;
              return G.type === "value-comma_group" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === "value-colon";
            }
            function $(G) {
              var z;
              return G.type === "value-paren_group" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);
            }
            function V(G) {
              var z;
              let U = G.getValue();
              if (U.groups.length === 0)
                return false;
              let le = G.getParentNode(1);
              if (!$(U) && !(le && $(le)))
                return false;
              let ge = a(G, "css-decl");
              return !!(ge != null && (z = ge.prop) !== null && z !== void 0 && z.startsWith("$") || $(le) || le.type === "value-func");
            }
            function q(G) {
              return G.type === "value-comment" && G.inline;
            }
            function Y(G) {
              return G.type === "value-word" && G.value === "#";
            }
            function H(G) {
              return G.type === "value-word" && G.value === "{";
            }
            function R(G) {
              return G.type === "value-word" && G.value === "}";
            }
            function Q(G) {
              return ["value-word", "value-atword"].includes(G.type);
            }
            function ee(G) {
              return (G == null ? void 0 : G.type) === "value-colon";
            }
            function te(G, z) {
              if (!j(z))
                return false;
              let { groups: U } = z, le = U.indexOf(G);
              return le === -1 ? false : ee(U[le + 1]);
            }
            function oe(G) {
              return G.value && ["not", "and", "or"].includes(G.value.toLowerCase());
            }
            function W(G) {
              return G.type !== "value-func" ? false : t.has(G.value.toLowerCase());
            }
            function X(G) {
              return /\/\//.test(G.split(/[\n\r]/).pop());
            }
            function ue(G) {
              return (G == null ? void 0 : G.type) === "value-atword" && G.value.startsWith("prettier-placeholder-");
            }
            function De(G, z) {
              var U, le;
              if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== "(" || ((le = G.close) === null || le === void 0 ? void 0 : le.value) !== ")" || G.groups.some((ge) => ge.type !== "value-comma_group"))
                return false;
              if (z.type === "value-comma_group") {
                let ge = z.groups.indexOf(G) - 1, Ae = z.groups[ge];
                if ((Ae == null ? void 0 : Ae.type) === "value-word" && Ae.value === "with")
                  return true;
              }
              return false;
            }
            function ie(G) {
              var z, U;
              return G.type === "value-paren_group" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === "(" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === ")";
            }
            n.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: v, insideICSSRuleNode: m, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: p, isKeyframeAtRuleKeywords: o, isWideKeywords: i, isLastNode: h, isSCSSControlDirectiveNode: l, isDetachedRulesetDeclarationNode: w, isRelationalOperatorNode: F, isEqualityOperatorNode: g, isMultiplicationNode: B, isDivisionNode: I, isAdditionNode: k, isSubtractionNode: P, isModuloNode: C, isMathOperatorNode: D, isEachKeywordNode: S, isForKeywordNode: T, isURLFunctionNode: f, isIfElseKeywordNode: A, hasComposesNode: b, hasParensAroundNode: L, hasEmptyRawBefore: M, isDetachedRulesetCallNode: E, isTemplatePlaceholderNode: y, isTemplatePropNode: N, isPostcssSimpleVarNode: x, isKeyValuePairNode: j, isKeyValuePairInParenGroupNode: $, isKeyInValuePairNode: te, isSCSSMapItemNode: V, isInlineValueCommentNode: q, isHashNode: Y, isLeftCurlyBraceNode: H, isRightCurlyBraceNode: R, isWordNode: Q, isColonNode: ee, isMediaAndSupportsKeywords: oe, isColorAdjusterFuncNode: W, lastLineHasInlineComment: X, isAtWordPlaceholderNode: ue, isConfigurationNode: De, isParenGroupNode: ie };
          } }), pd = Z({ "src/utils/line-column-to-index.js"(e, n) {
            "use strict";
            re(), n.exports = function(t, s) {
              let a = 0;
              for (let r = 0; r < t.line - 1; ++r)
                a = s.indexOf(`
`, a) + 1;
              return a + t.column;
            };
          } }), fd = Z({ "src/language-css/loc.js"(e, n) {
            "use strict";
            re();
            var { skipEverythingButNewLine: t } = Nr(), s = it(), a = pd();
            function r(p, f) {
              return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? a(p.source.start, f) - 1 : null;
            }
            function u(p, f) {
              if (p.type === "css-comment" && p.inline)
                return t(f, p.source.startOffset);
              let h = p.nodes && s(p.nodes);
              return h && p.source && !p.source.end && (p = h), p.source && p.source.end ? a(p.source.end, f) : null;
            }
            function i(p, f) {
              p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));
              for (let h in p) {
                let w = p[h];
                h === "source" || !w || typeof w != "object" || (w.type === "value-root" || w.type === "value-unknown" ? o(w, c(p), w.text || w.value) : i(w, f));
              }
            }
            function o(p, f, h) {
              p.source && (p.source.startOffset = r(p, h) + f, p.source.endOffset = u(p, h) + f);
              for (let w in p) {
                let T = p[w];
                w === "source" || !T || typeof T != "object" || o(T, f, h);
              }
            }
            function c(p) {
              let f = p.source.startOffset;
              return typeof p.prop == "string" && (f += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (f += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (f += p.raws.between.length), f;
            }
            function v(p) {
              let f = "initial", h = "initial", w, T = false, A = [];
              for (let S = 0; S < p.length; S++) {
                let B = p[S];
                switch (f) {
                  case "initial":
                    if (B === "'") {
                      f = "single-quotes";
                      continue;
                    }
                    if (B === '"') {
                      f = "double-quotes";
                      continue;
                    }
                    if ((B === "u" || B === "U") && p.slice(S, S + 4).toLowerCase() === "url(") {
                      f = "url", S += 3;
                      continue;
                    }
                    if (B === "*" && p[S - 1] === "/") {
                      f = "comment-block";
                      continue;
                    }
                    if (B === "/" && p[S - 1] === "/") {
                      f = "comment-inline", w = S - 1;
                      continue;
                    }
                    continue;
                  case "single-quotes":
                    if (B === "'" && p[S - 1] !== "\\" && (f = h, h = "initial"), B === `
` || B === "\r")
                      return p;
                    continue;
                  case "double-quotes":
                    if (B === '"' && p[S - 1] !== "\\" && (f = h, h = "initial"), B === `
` || B === "\r")
                      return p;
                    continue;
                  case "url":
                    if (B === ")" && (f = "initial"), B === `
` || B === "\r")
                      return p;
                    if (B === "'") {
                      f = "single-quotes", h = "url";
                      continue;
                    }
                    if (B === '"') {
                      f = "double-quotes", h = "url";
                      continue;
                    }
                    continue;
                  case "comment-block":
                    B === "/" && p[S - 1] === "*" && (f = "initial");
                    continue;
                  case "comment-inline":
                    (B === '"' || B === "'" || B === "*") && (T = true), (B === `
` || B === "\r") && (T && A.push([w, S]), f = "initial", T = false);
                    continue;
                }
              }
              for (let [S, B] of A)
                p = p.slice(0, S) + p.slice(S, B).replace(/["'*]/g, " ") + p.slice(B);
              return p;
            }
            function m(p) {
              return p.source.startOffset;
            }
            function d(p) {
              return p.source.endOffset;
            }
            n.exports = { locStart: m, locEnd: d, calculateLoc: i, replaceQuotesInInlineComments: v };
          } }), Dd = Z({ "src/language-css/utils/is-less-parser.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              return s.parser === "css" || s.parser === "less";
            }
            n.exports = t;
          } }), md = Z({ "src/language-css/utils/is-scss.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
            }
            n.exports = t;
          } }), dd = Z({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
            n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
          } }), gd = Z({ "src/language-css/utils/print-unit.js"(e, n) {
            "use strict";
            re();
            var t = dd();
            function s(a) {
              let r = a.toLowerCase();
              return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;
            }
            n.exports = s;
          } }), yd = Z({ "src/language-css/printer-postcss.js"(e, n) {
            "use strict";
            re();
            var t = it(), { printNumber: s, printString: a, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: o } = Ue(), { builders: { join: c, line: v, hardline: m, softline: d, group: p, fill: f, indent: h, dedent: w, ifBreak: T, breakParent: A }, utils: { removeLines: S, getDocParts: B } } = Oe(), I = ad(), k = od(), { insertPragma: P } = ld(), { getAncestorNode: C, getPropOfDeclNode: D, maybeToLowerCase: g, insideValueFunctionNode: F, insideICSSRuleNode: l, insideAtRuleNode: E, insideURLFunctionInImportAtRuleNode: y, isKeyframeAtRuleKeywords: N, isWideKeywords: x, isLastNode: b, isSCSSControlDirectiveNode: L, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: j, isEqualityOperatorNode: $, isMultiplicationNode: V, isDivisionNode: q, isAdditionNode: Y, isSubtractionNode: H, isMathOperatorNode: R, isEachKeywordNode: Q, isForKeywordNode: ee, isURLFunctionNode: te, isIfElseKeywordNode: oe, hasComposesNode: W, hasParensAroundNode: X, hasEmptyRawBefore: ue, isKeyValuePairNode: De, isKeyInValuePairNode: ie, isDetachedRulesetCallNode: G, isTemplatePlaceholderNode: z, isTemplatePropNode: U, isPostcssSimpleVarNode: le, isSCSSMapItemNode: ge, isInlineValueCommentNode: Ae, isHashNode: Ne, isLeftCurlyBraceNode: ke, isRightCurlyBraceNode: ce, isWordNode: pe, isColonNode: de, isMediaAndSupportsKeywords: ae, isColorAdjusterFuncNode: ve, lastLineHasInlineComment: K, isAtWordPlaceholderNode: he, isConfigurationNode: ye, isParenGroupNode: Ce } = cd(), { locStart: Ie, locEnd: Fe } = fd(), me = Dd(), _ = md(), J = gd();
            function ne(be) {
              return be.trailingComma === "es5" || be.trailingComma === "all";
            }
            function Ee(be, Le, qe) {
              let se = be.getValue();
              if (!se)
                return "";
              if (typeof se == "string")
                return se;
              switch (se.type) {
                case "front-matter":
                  return [se.raw, m];
                case "css-root": {
                  let He = We(be, Le, qe), Me = se.raws.after.trim();
                  return [He, Me ? " ".concat(Me) : "", B(He).length > 0 ? m : ""];
                }
                case "css-comment": {
                  let He = se.inline || se.raws.inline, Me = Le.originalText.slice(Ie(se), Fe(se));
                  return He ? Me.trimEnd() : Me;
                }
                case "css-rule":
                  return [qe("selector"), se.important ? " !important" : "", se.nodes ? [se.selector && se.selector.type === "selector-unknown" && K(se.selector.value) ? v : " ", "{", se.nodes.length > 0 ? h([m, We(be, Le, qe)]) : "", m, "}", M(se) ? ";" : ""] : ";"];
                case "css-decl": {
                  let He = be.getParentNode(), { between: Me } = se.raws, ze = Me.trim(), nt = ze === ":", tt = W(se) ? S(qe("value")) : qe("value");
                  return !nt && K(ze) && (tt = h([m, w(tt)])), [se.raws.before.replace(/[\s;]/g, ""), l(be) ? se.prop : g(se.prop), ze.startsWith("//") ? " " : "", ze, se.extend ? "" : " ", me(Le) && se.extend && se.selector ? ["extend(", qe("selector"), ")"] : "", tt, se.raws.important ? se.raws.important.replace(/\s*!\s*important/i, " !important") : se.important ? " !important" : "", se.raws.scssDefault ? se.raws.scssDefault.replace(/\s*!default/i, " !default") : se.scssDefault ? " !default" : "", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\s*!global/i, " !global") : se.scssGlobal ? " !global" : "", se.nodes ? [" {", h([d, We(be, Le, qe)]), d, "}"] : U(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== ";" ? "" : Le.__isHTMLStyleAttribute && b(be, se) ? T(";") : ";"];
                }
                case "css-atrule": {
                  let He = be.getParentNode(), Me = z(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== ";";
                  if (me(Le)) {
                    if (se.mixin)
                      return [qe("selector"), se.important ? " !important" : "", Me ? "" : ";"];
                    if (se.function)
                      return [se.name, qe("params"), Me ? "" : ";"];
                    if (se.variable)
                      return ["@", se.name, ": ", se.value ? qe("value") : "", se.raws.between.trim() ? se.raws.between.trim() + " " : "", se.nodes ? ["{", h([se.nodes.length > 0 ? d : "", We(be, Le, qe)]), d, "}"] : "", Me ? "" : ";"];
                  }
                  return ["@", G(se) || se.name.endsWith(":") ? se.name : g(se.name), se.params ? [G(se) ? "" : z(se) ? se.raws.afterName === "" ? "" : se.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(se.raws.afterName) ? [m, m] : /^\s*\n/.test(se.raws.afterName) ? m : " " : " ", qe("params")] : "", se.selector ? h([" ", qe("selector")]) : "", se.value ? p([" ", qe("value"), L(se) ? X(se) ? " " : v : ""]) : se.name === "else" ? " " : "", se.nodes ? [L(se) ? "" : se.selector && !se.selector.nodes && typeof se.selector.value == "string" && K(se.selector.value) || !se.selector && typeof se.params == "string" && K(se.params) ? v : " ", "{", h([se.nodes.length > 0 ? d : "", We(be, Le, qe)]), d, "}"] : Me ? "" : ";"];
                }
                case "media-query-list": {
                  let He = [];
                  return be.each((Me) => {
                    let ze = Me.getValue();
                    ze.type === "media-query" && ze.value === "" || He.push(qe());
                  }, "nodes"), p(h(c(v, He)));
                }
                case "media-query":
                  return [c(" ", be.map(qe, "nodes")), b(be, se) ? "" : ","];
                case "media-type":
                  return je(Xe(se.value, Le));
                case "media-feature-expression":
                  return se.nodes ? ["(", ...be.map(qe, "nodes"), ")"] : se.value;
                case "media-feature":
                  return g(Xe(se.value.replace(/ +/g, " "), Le));
                case "media-colon":
                  return [se.value, " "];
                case "media-value":
                  return je(Xe(se.value, Le));
                case "media-keyword":
                  return Xe(se.value, Le);
                case "media-url":
                  return Xe(se.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Le);
                case "media-unknown":
                  return se.value;
                case "selector-root":
                  return p([E(be, "custom-selector") ? [C(be, "css-atrule").customSelector, v] : "", c([",", E(be, ["extend", "custom-selector", "nest"]) ? v : m], be.map(qe, "nodes"))]);
                case "selector-selector":
                  return p(h(be.map(qe, "nodes")));
                case "selector-comment":
                  return se.value;
                case "selector-string":
                  return Xe(se.value, Le);
                case "selector-tag": {
                  let He = be.getParentNode(), Me = He && He.nodes.indexOf(se), ze = Me && He.nodes[Me - 1];
                  return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", ze.type === "selector-nesting" ? se.value : je(N(be, se.value) ? se.value.toLowerCase() : se.value)];
                }
                case "selector-id":
                  return ["#", se.value];
                case "selector-class":
                  return [".", je(Xe(se.value, Le))];
                case "selector-attribute":
                  return ["[", se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.attribute.trim(), se.operator ? se.operator : "", se.value ? _e(Xe(se.value.trim(), Le), Le) : "", se.insensitive ? " i" : "", "]"];
                case "selector-combinator": {
                  if (se.value === "+" || se.value === ">" || se.value === "~" || se.value === ">>>") {
                    let ze = be.getParentNode();
                    return [ze.type === "selector-selector" && ze.nodes[0] === se ? "" : v, se.value, b(be, se) ? "" : " "];
                  }
                  let He = se.value.trim().startsWith("(") ? v : "", Me = je(Xe(se.value.trim(), Le)) || v;
                  return [He, Me];
                }
                case "selector-universal":
                  return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.value];
                case "selector-pseudo":
                  return [g(se.value), o(se.nodes) ? ["(", c(", ", be.map(qe, "nodes")), ")"] : ""];
                case "selector-nesting":
                  return se.value;
                case "selector-unknown": {
                  let He = C(be, "css-rule");
                  if (He && He.isSCSSNesterProperty)
                    return je(Xe(g(se.value), Le));
                  let Me = be.getParentNode();
                  if (Me.raws && Me.raws.selector) {
                    let nt = Ie(Me), tt = nt + Me.raws.selector.length;
                    return Le.originalText.slice(nt, tt).trim();
                  }
                  let ze = be.getParentNode(1);
                  if (Me.type === "value-paren_group" && ze && ze.type === "value-func" && ze.value === "selector") {
                    let nt = Fe(Me.open) + 1, tt = Ie(Me.close), pt = Le.originalText.slice(nt, tt).trim();
                    return K(pt) ? [A, pt] : pt;
                  }
                  return se.value;
                }
                case "value-value":
                case "value-root":
                  return qe("group");
                case "value-comment":
                  return Le.originalText.slice(Ie(se), Fe(se));
                case "value-comma_group": {
                  let He = be.getParentNode(), Me = be.getParentNode(1), ze = D(be), nt = ze && He.type === "value-value" && (ze === "grid" || ze.startsWith("grid-template")), tt = C(be, "css-atrule"), pt = tt && L(tt), O = se.groups.some((ut) => Ae(ut)), fe = be.map(qe, "groups"), Te = [], $e = F(be, "url"), Je = false, Ze = false;
                  for (let ut = 0; ut < se.groups.length; ++ut) {
                    Te.push(fe[ut]);
                    let rt = se.groups[ut - 1], Ve = se.groups[ut], Ge = se.groups[ut + 1], tr = se.groups[ut + 2];
                    if ($e) {
                      (Ge && Y(Ge) || Y(Ve)) && Te.push(" ");
                      continue;
                    }
                    if (E(be, "forward") && Ve.type === "value-word" && Ve.value && rt !== void 0 && rt.type === "value-word" && rt.value === "as" && Ge.type === "value-operator" && Ge.value === "*" || !Ge || Ve.type === "value-word" && Ve.value.endsWith("-") && he(Ge))
                      continue;
                    let Eo = Ve.type === "value-string" && Ve.value.startsWith("#{"), Fo = Je && Ge.type === "value-string" && Ge.value.endsWith("}");
                    if (Eo || Fo) {
                      Je = !Je;
                      continue;
                    }
                    if (Je || de(Ve) || de(Ge) || Ve.type === "value-atword" && Ve.value === "" || Ve.value === "~" || Ve.value && Ve.value.includes("\\") && Ge && Ge.type !== "value-comment" || rt && rt.value && rt.value.indexOf("\\") === rt.value.length - 1 && Ve.type === "value-operator" && Ve.value === "/" || Ve.value === "\\" || le(Ve, Ge) || Ne(Ve) || ke(Ve) || ce(Ge) || ke(Ge) && ue(Ge) || ce(Ve) && ue(Ge) || Ve.value === "--" && Ne(Ge))
                      continue;
                    let Qn = R(Ve), Zn = R(Ge);
                    if ((Qn && Ne(Ge) || Zn && ce(Ve)) && ue(Ge) || !rt && q(Ve) || F(be, "calc") && (Y(Ve) || Y(Ge) || H(Ve) || H(Ge)) && ue(Ge))
                      continue;
                    let Ao = (Y(Ve) || H(Ve)) && ut === 0 && (Ge.type === "value-number" || Ge.isHex) && Me && ve(Me) && !ue(Ge), eu = tr && tr.type === "value-func" || tr && pe(tr) || Ve.type === "value-func" || pe(Ve), tu = Ge.type === "value-func" || pe(Ge) || rt && rt.type === "value-func" || rt && pe(rt);
                    if (!(!(V(Ge) || V(Ve)) && !F(be, "calc") && !Ao && (q(Ge) && !eu || q(Ve) && !tu || Y(Ge) && !eu || Y(Ve) && !tu || H(Ge) || H(Ve)) && (ue(Ge) || Qn && (!rt || rt && R(rt))))) {
                      if (Ae(Ve)) {
                        if (He.type === "value-paren_group") {
                          Te.push(w(m));
                          continue;
                        }
                        Te.push(m);
                        continue;
                      }
                      if (pt && ($(Ge) || j(Ge) || oe(Ge) || Q(Ve) || ee(Ve))) {
                        Te.push(" ");
                        continue;
                      }
                      if (tt && tt.name.toLowerCase() === "namespace") {
                        Te.push(" ");
                        continue;
                      }
                      if (nt) {
                        Ve.source && Ge.source && Ve.source.start.line !== Ge.source.start.line ? (Te.push(m), Ze = true) : Te.push(" ");
                        continue;
                      }
                      if (Zn) {
                        Te.push(" ");
                        continue;
                      }
                      if (!(Ge && Ge.value === "...") && !(he(Ve) && he(Ge) && Fe(Ve) === Ie(Ge))) {
                        if (he(Ve) && Ce(Ge) && Fe(Ve) === Ie(Ge.open)) {
                          Te.push(d);
                          continue;
                        }
                        if (Ve.value === "with" && Ce(Ge)) {
                          Te.push(" ");
                          continue;
                        }
                        Te.push(v);
                      }
                    }
                  }
                  return O && Te.push(A), Ze && Te.unshift(m), pt ? p(h(Te)) : y(be) ? p(f(Te)) : p(h(f(Te)));
                }
                case "value-paren_group": {
                  let He = be.getParentNode();
                  if (He && te(He) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === "value-comma_group" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === "value-word" && se.groups[0].groups[0].value.startsWith("data:")))
                    return [se.open ? qe("open") : "", c(",", be.map(qe, "groups")), se.close ? qe("close") : ""];
                  if (!se.open) {
                    let $e = be.map(qe, "groups"), Je = [];
                    for (let Ze = 0; Ze < $e.length; Ze++)
                      Ze !== 0 && Je.push([",", v]), Je.push($e[Ze]);
                    return p(h(f(Je)));
                  }
                  let Me = ge(be), ze = t(se.groups), nt = ze && ze.type === "value-comment", tt = ie(se, He), pt = ye(se, He), O = pt || Me && !tt, fe = pt || tt, Te = p([se.open ? qe("open") : "", h([d, c([v], be.map(($e, Je) => {
                    let Ze = $e.getValue(), ut = Je === se.groups.length - 1, rt = [qe(), ut ? "" : ","];
                    if (De(Ze) && Ze.type === "value-comma_group" && Ze.groups && Ze.groups[0].type !== "value-paren_group" && Ze.groups[2] && Ze.groups[2].type === "value-paren_group") {
                      let Ve = B(rt[0].contents.contents);
                      return Ve[1] = p(Ve[1]), p(w(rt));
                    }
                    if (!ut && Ze.type === "value-comma_group" && o(Ze.groups)) {
                      let Ve = t(Ze.groups);
                      Ve.source && i(Le.originalText, Ve, Fe) && rt.push(m);
                    }
                    return rt;
                  }, "groups"))]), T(!nt && _(Le.parser, Le.originalText) && Me && ne(Le) ? "," : ""), d, se.close ? qe("close") : ""], { shouldBreak: O });
                  return fe ? w(Te) : Te;
                }
                case "value-func":
                  return [se.value, E(be, "supports") && ae(se) ? " " : "", qe("group")];
                case "value-paren":
                  return se.value;
                case "value-number":
                  return [Re(se.value), J(se.unit)];
                case "value-operator":
                  return se.value;
                case "value-word":
                  return se.isColor && se.isHex || x(se.value) ? se.value.toLowerCase() : se.value;
                case "value-colon": {
                  let He = be.getParentNode(), Me = He && He.groups.indexOf(se), ze = Me && He.groups[Me - 1];
                  return [se.value, ze && typeof ze.value == "string" && t(ze.value) === "\\" || F(be, "url") ? "" : v];
                }
                case "value-comma":
                  return [se.value, " "];
                case "value-string":
                  return a(se.raws.quote + se.value + se.raws.quote, Le);
                case "value-atword":
                  return ["@", se.value];
                case "value-unicode-range":
                  return se.value;
                case "value-unknown":
                  return se.value;
                default:
                  throw new Error("Unknown postcss type ".concat(JSON.stringify(se.type)));
              }
            }
            function We(be, Le, qe) {
              let se = [];
              return be.each((He, Me, ze) => {
                let nt = ze[Me - 1];
                if (nt && nt.type === "css-comment" && nt.text.trim() === "prettier-ignore") {
                  let tt = He.getValue();
                  se.push(Le.originalText.slice(Ie(tt), Fe(tt)));
                } else
                  se.push(qe());
                Me !== ze.length - 1 && (ze[Me + 1].type === "css-comment" && !r(Le.originalText, Ie(ze[Me + 1]), { backwards: true }) && !u(ze[Me]) || ze[Me + 1].type === "css-atrule" && ze[Me + 1].name === "else" && ze[Me].type !== "css-comment" ? se.push(" ") : (se.push(Le.__isHTMLStyleAttribute ? v : m), i(Le.originalText, He.getValue(), Fe) && !u(ze[Me]) && se.push(m)));
              }, "nodes"), se;
            }
            var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Se = /[A-Za-z]+/g, Qe = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe = new RegExp(Be.source + "|(".concat(Qe.source, ")?(").concat(Pe.source, ")(").concat(Se.source, ")?"), "g");
            function Xe(be, Le) {
              return be.replace(Be, (qe) => a(qe, Le));
            }
            function _e(be, Le) {
              let qe = Le.singleQuote ? "'" : '"';
              return be.includes('"') || be.includes("'") ? be : qe + be + qe;
            }
            function je(be) {
              return be.replace(xe, (Le, qe, se, He, Me) => !se && He ? Re(He) + g(Me || "") : Le);
            }
            function Re(be) {
              return s(be).replace(/\.0(?=$|e)/, "");
            }
            n.exports = { print: Ee, embed: k, insertPragma: P, massageAstNode: I };
          } }), hd = Z({ "src/language-css/options.js"(e, n) {
            "use strict";
            re();
            var t = Ot();
            n.exports = { singleQuote: t.singleQuote };
          } }), vd = Z({ "src/language-css/parsers.js"() {
            re();
          } }), Cd = Z({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
            n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
          } }), Ed = Z({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
            n.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
          } }), Fd = Z({ "node_modules/linguist-languages/data/Less.json"(e, n) {
            n.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
          } }), Ad = Z({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
            n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
          } }), Sd = Z({ "src/language-css/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = yd(), a = hd(), r = vd(), u = [t(Cd(), (o) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...o.extensions, ".wxss"] })), t(Ed(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Fd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Ad(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
            n.exports = { languages: u, options: a, printers: i, parsers: r };
          } }), xd = Z({ "src/language-handlebars/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.loc.start.offset;
            }
            function s(a) {
              return a.loc.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), bd = Z({ "src/language-handlebars/clean.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              if (s.type === "TextNode") {
                let r = s.chars.trim();
                if (!r)
                  return null;
                a.chars = r.replace(/[\t\n\f\r ]+/g, " ");
              }
              s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
            }
            t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
          } }), Td = Z({ "vendors/html-void-elements.json"(e, n) {
            n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
          } }), Bd = Z({ "src/language-handlebars/utils.js"(e, n) {
            "use strict";
            re();
            var { htmlVoidElements: t } = Td(), s = it();
            function a(S) {
              let B = S.getValue(), I = S.getParentNode(0);
              return !!(m(S, ["ElementNode"]) && s(I.children) === B || m(S, ["Block"]) && s(I.body) === B);
            }
            function r(S) {
              return S.toUpperCase() === S;
            }
            function u(S) {
              return v(S, ["ElementNode"]) && typeof S.tag == "string" && !S.tag.startsWith(":") && (r(S.tag[0]) || S.tag.includes("."));
            }
            var i = new Set(t);
            function o(S) {
              return i.has(S.tag) || u(S) && S.children.every((B) => c(B));
            }
            function c(S) {
              return v(S, ["TextNode"]) && !/\S/.test(S.chars);
            }
            function v(S, B) {
              return S && B.includes(S.type);
            }
            function m(S, B) {
              let I = S.getParentNode(0);
              return v(I, B);
            }
            function d(S, B) {
              let I = h(S);
              return v(I, B);
            }
            function p(S, B) {
              let I = w(S);
              return v(I, B);
            }
            function f(S, B) {
              var I, k, P, C;
              let D = S.getValue(), g = (I = S.getParentNode(0)) !== null && I !== void 0 ? I : {}, F = (k = (P = (C = g.children) !== null && C !== void 0 ? C : g.body) !== null && P !== void 0 ? P : g.parts) !== null && k !== void 0 ? k : [], l = F.indexOf(D);
              return l !== -1 && F[l + B];
            }
            function h(S) {
              let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              return f(S, -B);
            }
            function w(S) {
              return f(S, 1);
            }
            function T(S) {
              return v(S, ["MustacheCommentStatement"]) && typeof S.value == "string" && S.value.trim() === "prettier-ignore";
            }
            function A(S) {
              let B = S.getValue(), I = h(S, 2);
              return T(B) || T(I);
            }
            n.exports = { getNextNode: w, getPreviousNode: h, hasPrettierIgnore: A, isLastNodeOfSiblings: a, isNextNodeOfSomeType: p, isNodeOfSomeType: v, isParentOfSomeType: m, isPreviousNodeOfSomeType: d, isVoid: o, isWhitespaceNode: c };
          } }), Nd = Z({ "src/language-handlebars/printer-glimmer.js"(e, n) {
            "use strict";
            re();
            var { builders: { dedent: t, fill: s, group: a, hardline: r, ifBreak: u, indent: i, join: o, line: c, softline: v }, utils: { getDocParts: m, replaceTextEndOfLine: d } } = Oe(), { getPreferredQuote: p, isNonEmptyArray: f } = Ue(), { locStart: h, locEnd: w } = xd(), T = bd(), { getNextNode: A, getPreviousNode: S, hasPrettierIgnore: B, isLastNodeOfSiblings: I, isNextNodeOfSomeType: k, isNodeOfSomeType: P, isParentOfSomeType: C, isPreviousNodeOfSomeType: D, isVoid: g, isWhitespaceNode: F } = Bd(), l = 2;
            function E(K, he, ye) {
              let Ce = K.getValue();
              if (!Ce)
                return "";
              if (B(K))
                return he.originalText.slice(h(Ce), w(Ce));
              let Ie = he.singleQuote ? "'" : '"';
              switch (Ce.type) {
                case "Block":
                case "Program":
                case "Template":
                  return a(K.map(ye, "body"));
                case "ElementNode": {
                  let Fe = a(N(K, ye)), me = he.htmlWhitespaceSensitivity === "ignore" && k(K, ["ElementNode"]) ? v : "";
                  if (g(Ce))
                    return [Fe, me];
                  let _ = ["</", Ce.tag, ">"];
                  return Ce.children.length === 0 ? [Fe, i(_), me] : he.htmlWhitespaceSensitivity === "ignore" ? [Fe, i(x(K, he, ye)), r, i(_), me] : [Fe, i(a(x(K, he, ye))), i(_), me];
                }
                case "BlockStatement": {
                  let Fe = K.getParentNode(1);
                  return Fe && Fe.inverse && Fe.inverse.body.length === 1 && Fe.inverse.body[0] === Ce && Fe.inverse.body[0].path.parts[0] === "if" ? [ee(K, ye), ue(K, ye, he), De(K, ye, he)] : [R(K, ye), a([ue(K, ye, he), De(K, ye, he), te(K, ye, he)])];
                }
                case "ElementModifierStatement":
                  return a(["{{", pe(K, ye), "}}"]);
                case "MustacheStatement":
                  return a([L(Ce), pe(K, ye), M(Ce)]);
                case "SubExpression":
                  return a(["(", ce(K, ye), v, ")"]);
                case "AttrNode": {
                  let Fe = Ce.value.type === "TextNode";
                  if (Fe && Ce.value.chars === "" && h(Ce.value) === w(Ce.value))
                    return Ce.name;
                  let _ = Fe ? p(Ce.value.chars, Ie).quote : Ce.value.type === "ConcatStatement" ? p(Ce.value.parts.filter((ne) => ne.type === "TextNode").map((ne) => ne.chars).join(""), Ie).quote : "", J = ye("value");
                  return [Ce.name, "=", _, Ce.name === "class" && _ ? a(i(J)) : J, _];
                }
                case "ConcatStatement":
                  return K.map(ye, "parts");
                case "Hash":
                  return o(c, K.map(ye, "pairs"));
                case "HashPair":
                  return [Ce.key, "=", ye("value")];
                case "TextNode": {
                  let Fe = Ce.chars.replace(/{{/g, "\\{{"), me = z(K);
                  if (me) {
                    if (me === "class") {
                      let xe = Fe.trim().split(/\s+/).join(" "), Xe = false, _e = false;
                      return C(K, ["ConcatStatement"]) && (D(K, ["MustacheStatement"]) && /^\s/.test(Fe) && (Xe = true), k(K, ["MustacheStatement"]) && /\s$/.test(Fe) && xe !== "" && (_e = true)), [Xe ? c : "", xe, _e ? c : ""];
                    }
                    return d(Fe);
                  }
                  let J = /^[\t\n\f\r ]*$/.test(Fe), ne = !S(K), Ee = !A(K);
                  if (he.htmlWhitespaceSensitivity !== "ignore") {
                    let xe = /^[\t\n\f\r ]*/, Xe = /[\t\n\f\r ]*$/, _e = Ee && C(K, ["Template"]), je = ne && C(K, ["Template"]);
                    if (J) {
                      if (je || _e)
                        return "";
                      let se = [c], He = U(Fe);
                      return He && (se = Ae(He)), I(K) && (se = se.map((Me) => t(Me))), se;
                    }
                    let [Re] = Fe.match(xe), [be] = Fe.match(Xe), Le = [];
                    if (Re) {
                      Le = [c];
                      let se = U(Re);
                      se && (Le = Ae(se)), Fe = Fe.replace(xe, "");
                    }
                    let qe = [];
                    if (be) {
                      if (!_e) {
                        qe = [c];
                        let se = U(be);
                        se && (qe = Ae(se)), I(K) && (qe = qe.map((He) => t(He)));
                      }
                      Fe = Fe.replace(Xe, "");
                    }
                    return [...Le, s(ie(Fe)), ...qe];
                  }
                  let We = U(Fe), Be = le(Fe), Pe = ge(Fe);
                  if ((ne || Ee) && J && C(K, ["Block", "ElementNode", "Template"]))
                    return "";
                  J && We ? (Be = Math.min(We, l), Pe = 0) : (k(K, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), D(K, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                  let Se = "", Qe = "";
                  return Pe === 0 && k(K, ["MustacheStatement"]) && (Qe = " "), Be === 0 && D(K, ["MustacheStatement"]) && (Se = " "), ne && (Be = 0, Se = ""), Ee && (Pe = 0, Qe = ""), Fe = Fe.replace(/^[\t\n\f\r ]+/g, Se).replace(/[\t\n\f\r ]+$/, Qe), [...Ae(Be), s(ie(Fe)), ...Ae(Pe)];
                }
                case "MustacheCommentStatement": {
                  let Fe = h(Ce), me = w(Ce), _ = he.originalText.charAt(Fe + 2) === "~", J = he.originalText.charAt(me - 3) === "~", ne = Ce.value.includes("}}") ? "--" : "";
                  return ["{{", _ ? "~" : "", "!", ne, Ce.value, ne, J ? "~" : "", "}}"];
                }
                case "PathExpression":
                  return Ce.original;
                case "BooleanLiteral":
                  return String(Ce.value);
                case "CommentStatement":
                  return ["<!--", Ce.value, "-->"];
                case "StringLiteral": {
                  if (ke(K)) {
                    let Fe = he.singleQuote ? '"' : "'";
                    return Ne(Ce.value, Fe);
                  }
                  return Ne(Ce.value, Ie);
                }
                case "NumberLiteral":
                  return String(Ce.value);
                case "UndefinedLiteral":
                  return "undefined";
                case "NullLiteral":
                  return "null";
                default:
                  throw new Error("unknown glimmer type: " + JSON.stringify(Ce.type));
              }
            }
            function y(K, he) {
              return h(K) - h(he);
            }
            function N(K, he) {
              let ye = K.getValue(), Ce = ["attributes", "modifiers", "comments"].filter((Fe) => f(ye[Fe])), Ie = Ce.flatMap((Fe) => ye[Fe]).sort(y);
              for (let Fe of Ce)
                K.each((me) => {
                  let _ = Ie.indexOf(me.getValue());
                  Ie.splice(_, 1, [c, he()]);
                }, Fe);
              return f(ye.blockParams) && Ie.push(c, ve(ye)), ["<", ye.tag, i(Ie), b(ye)];
            }
            function x(K, he, ye) {
              let Ie = K.getValue().children.every((Fe) => F(Fe));
              return he.htmlWhitespaceSensitivity === "ignore" && Ie ? "" : K.map((Fe, me) => {
                let _ = ye();
                return me === 0 && he.htmlWhitespaceSensitivity === "ignore" ? [v, _] : _;
              }, "children");
            }
            function b(K) {
              return g(K) ? u([v, "/>"], [" />", v]) : u([v, ">"], ">");
            }
            function L(K) {
              let he = K.escaped === false ? "{{{" : "{{", ye = K.strip && K.strip.open ? "~" : "";
              return [he, ye];
            }
            function M(K) {
              let he = K.escaped === false ? "}}}" : "}}";
              return [K.strip && K.strip.close ? "~" : "", he];
            }
            function j(K) {
              let he = L(K), ye = K.openStrip.open ? "~" : "";
              return [he, ye, "#"];
            }
            function $(K) {
              let he = M(K);
              return [K.openStrip.close ? "~" : "", he];
            }
            function V(K) {
              let he = L(K), ye = K.closeStrip.open ? "~" : "";
              return [he, ye, "/"];
            }
            function q(K) {
              let he = M(K);
              return [K.closeStrip.close ? "~" : "", he];
            }
            function Y(K) {
              let he = L(K), ye = K.inverseStrip.open ? "~" : "";
              return [he, ye];
            }
            function H(K) {
              let he = M(K);
              return [K.inverseStrip.close ? "~" : "", he];
            }
            function R(K, he) {
              let ye = K.getValue(), Ce = j(ye), Ie = $(ye), Fe = [de(K, he)], me = ae(K, he);
              if (me && Fe.push(c, me), f(ye.program.blockParams)) {
                let _ = ve(ye.program);
                Fe.push(c, _);
              }
              return a([Ce, i(Fe), v, Ie]);
            }
            function Q(K, he) {
              return [he.htmlWhitespaceSensitivity === "ignore" ? r : "", Y(K), "else", H(K)];
            }
            function ee(K, he) {
              let ye = K.getParentNode(1);
              return [Y(ye), "else if ", ae(K, he), H(ye)];
            }
            function te(K, he, ye) {
              let Ce = K.getValue();
              return ye.htmlWhitespaceSensitivity === "ignore" ? [oe(Ce) ? v : r, V(Ce), he("path"), q(Ce)] : [V(Ce), he("path"), q(Ce)];
            }
            function oe(K) {
              return P(K, ["BlockStatement"]) && K.program.body.every((he) => F(he));
            }
            function W(K) {
              return X(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], ["BlockStatement"]) && K.inverse.body[0].path.parts[0] === "if";
            }
            function X(K) {
              return P(K, ["BlockStatement"]) && K.inverse;
            }
            function ue(K, he, ye) {
              let Ce = K.getValue();
              if (oe(Ce))
                return "";
              let Ie = he("program");
              return ye.htmlWhitespaceSensitivity === "ignore" ? i([r, Ie]) : i(Ie);
            }
            function De(K, he, ye) {
              let Ce = K.getValue(), Ie = he("inverse"), Fe = ye.htmlWhitespaceSensitivity === "ignore" ? [r, Ie] : Ie;
              return W(Ce) ? Fe : X(Ce) ? [Q(Ce, ye), i(Fe)] : "";
            }
            function ie(K) {
              return m(o(c, G(K)));
            }
            function G(K) {
              return K.split(/[\t\n\f\r ]+/);
            }
            function z(K) {
              for (let he = 0; he < 2; he++) {
                let ye = K.getParentNode(he);
                if (ye && ye.type === "AttrNode")
                  return ye.name.toLowerCase();
              }
            }
            function U(K) {
              return K = typeof K == "string" ? K : "", K.split(`
`).length - 1;
            }
            function le(K) {
              K = typeof K == "string" ? K : "";
              let he = (K.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
              return U(he);
            }
            function ge(K) {
              K = typeof K == "string" ? K : "";
              let he = (K.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
              return U(he);
            }
            function Ae() {
              let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return Array.from({ length: Math.min(K, l) }).fill(r);
            }
            function Ne(K, he) {
              let { quote: ye, regex: Ce } = p(K, he);
              return [ye, K.replace(Ce, "\\".concat(ye)), ye];
            }
            function ke(K) {
              let he = 0, ye = K.getParentNode(he);
              for (; ye && P(ye, ["SubExpression"]); )
                he++, ye = K.getParentNode(he);
              return !!(ye && P(K.getParentNode(he + 1), ["ConcatStatement"]) && P(K.getParentNode(he + 2), ["AttrNode"]));
            }
            function ce(K, he) {
              let ye = de(K, he), Ce = ae(K, he);
              return Ce ? i([ye, c, a(Ce)]) : ye;
            }
            function pe(K, he) {
              let ye = de(K, he), Ce = ae(K, he);
              return Ce ? [i([ye, c, Ce]), v] : ye;
            }
            function de(K, he) {
              return he("path");
            }
            function ae(K, he) {
              let ye = K.getValue(), Ce = [];
              if (ye.params.length > 0) {
                let Ie = K.map(he, "params");
                Ce.push(...Ie);
              }
              if (ye.hash && ye.hash.pairs.length > 0) {
                let Ie = he("hash");
                Ce.push(Ie);
              }
              return Ce.length === 0 ? "" : o(c, Ce);
            }
            function ve(K) {
              return ["as |", K.blockParams.join(" "), "|"];
            }
            n.exports = { print: E, massageAstNode: T };
          } }), wd = Z({ "src/language-handlebars/parsers.js"() {
            re();
          } }), _d = Z({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
            n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
          } }), Pd = Z({ "src/language-handlebars/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = Nd(), a = wd(), r = [t(_d(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
            n.exports = { languages: r, printers: u, parsers: a };
          } }), kd = Z({ "src/language-graphql/pragma.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
            }
            function s(a) {
              return `# @format

` + a;
            }
            n.exports = { hasPragma: t, insertPragma: s };
          } }), Id = Z({ "src/language-graphql/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
            }
            function s(a) {
              return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Ld = Z({ "src/language-graphql/printer-graphql.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, hardline: s, line: a, softline: r, group: u, indent: i, ifBreak: o } } = Oe(), { isNextLineEmpty: c, isNonEmptyArray: v } = Ue(), { insertPragma: m } = kd(), { locStart: d, locEnd: p } = Id();
            function f(k, P, C) {
              let D = k.getValue();
              if (!D)
                return "";
              if (typeof D == "string")
                return D;
              switch (D.kind) {
                case "Document": {
                  let g = [];
                  return k.each((F, l, E) => {
                    g.push(C()), l !== E.length - 1 && (g.push(s), c(P.originalText, F.getValue(), p) && g.push(s));
                  }, "definitions"), [...g, s];
                }
                case "OperationDefinition": {
                  let g = P.originalText[d(D)] !== "{", F = Boolean(D.name);
                  return [g ? D.operation : "", g && F ? [" ", C("name")] : "", g && !F && v(D.variableDefinitions) ? " " : "", v(D.variableDefinitions) ? u(["(", i([r, t([o("", ", "), r], k.map(C, "variableDefinitions"))]), r, ")"]) : "", h(k, C, D), D.selectionSet ? !g && !F ? "" : " " : "", C("selectionSet")];
                }
                case "FragmentDefinition":
                  return ["fragment ", C("name"), v(D.variableDefinitions) ? u(["(", i([r, t([o("", ", "), r], k.map(C, "variableDefinitions"))]), r, ")"]) : "", " on ", C("typeCondition"), h(k, C, D), " ", C("selectionSet")];
                case "SelectionSet":
                  return ["{", i([s, t(s, w(k, P, C, "selections"))]), s, "}"];
                case "Field":
                  return u([D.alias ? [C("alias"), ": "] : "", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", h(k, C, D), D.selectionSet ? " " : "", C("selectionSet")]);
                case "Name":
                  return D.value;
                case "StringValue": {
                  if (D.block) {
                    let g = D.value.replace(/"""/g, "\\$&").split(`
`);
                    return g.length === 1 && (g[0] = g[0].trim()), g.every((F) => F === "") && (g.length = 0), t(s, ['"""', ...g, '"""']);
                  }
                  return ['"', D.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                }
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                  return D.value;
                case "BooleanValue":
                  return D.value ? "true" : "false";
                case "NullValue":
                  return "null";
                case "Variable":
                  return ["$", C("name")];
                case "ListValue":
                  return u(["[", i([r, t([o("", ", "), r], k.map(C, "values"))]), r, "]"]);
                case "ObjectValue":
                  return u(["{", P.bracketSpacing && D.fields.length > 0 ? " " : "", i([r, t([o("", ", "), r], k.map(C, "fields"))]), r, o("", P.bracketSpacing && D.fields.length > 0 ? " " : ""), "}"]);
                case "ObjectField":
                case "Argument":
                  return [C("name"), ": ", C("value")];
                case "Directive":
                  return ["@", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : ""];
                case "NamedType":
                  return C("name");
                case "VariableDefinition":
                  return [C("variable"), ": ", C("type"), D.defaultValue ? [" = ", C("defaultValue")] : "", h(k, C, D)];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                  return [C("description"), D.description ? s : "", D.kind === "ObjectTypeExtension" ? "extend " : "", "type ", C("name"), D.interfaces.length > 0 ? [" implements ", ...S(k, P, C)] : "", h(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
                case "FieldDefinition":
                  return [C("description"), D.description ? s : "", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", ": ", C("type"), h(k, C, D)];
                case "DirectiveDefinition":
                  return [C("description"), D.description ? s : "", "directive ", "@", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", D.repeatable ? " repeatable" : "", " on ", t(" | ", k.map(C, "locations"))];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                  return [C("description"), D.description ? s : "", D.kind === "EnumTypeExtension" ? "extend " : "", "enum ", C("name"), h(k, C, D), D.values.length > 0 ? [" {", i([s, t(s, w(k, P, C, "values"))]), s, "}"] : ""];
                case "EnumValueDefinition":
                  return [C("description"), D.description ? s : "", C("name"), h(k, C, D)];
                case "InputValueDefinition":
                  return [C("description"), D.description ? D.description.block ? s : a : "", C("name"), ": ", C("type"), D.defaultValue ? [" = ", C("defaultValue")] : "", h(k, C, D)];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                  return [C("description"), D.description ? s : "", D.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", C("name"), h(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
                case "SchemaExtension":
                  return ["extend schema", h(k, C, D), ...D.operationTypes.length > 0 ? [" {", i([s, t(s, w(k, P, C, "operationTypes"))]), s, "}"] : []];
                case "SchemaDefinition":
                  return [C("description"), D.description ? s : "", "schema", h(k, C, D), " {", D.operationTypes.length > 0 ? i([s, t(s, w(k, P, C, "operationTypes"))]) : "", s, "}"];
                case "OperationTypeDefinition":
                  return [C("operation"), ": ", C("type")];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                  return [C("description"), D.description ? s : "", D.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", C("name"), D.interfaces.length > 0 ? [" implements ", ...S(k, P, C)] : "", h(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
                case "FragmentSpread":
                  return ["...", C("name"), h(k, C, D)];
                case "InlineFragment":
                  return ["...", D.typeCondition ? [" on ", C("typeCondition")] : "", h(k, C, D), " ", C("selectionSet")];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                  return u([C("description"), D.description ? s : "", u([D.kind === "UnionTypeExtension" ? "extend " : "", "union ", C("name"), h(k, C, D), D.types.length > 0 ? [" =", o("", " "), i([o([a, "  "]), t([a, "| "], k.map(C, "types"))])] : ""])]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                  return [C("description"), D.description ? s : "", D.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", C("name"), h(k, C, D)];
                case "NonNullType":
                  return [C("type"), "!"];
                case "ListType":
                  return ["[", C("type"), "]"];
                default:
                  throw new Error("unknown graphql type: " + JSON.stringify(D.kind));
              }
            }
            function h(k, P, C) {
              if (C.directives.length === 0)
                return "";
              let D = t(a, k.map(P, "directives"));
              return C.kind === "FragmentDefinition" || C.kind === "OperationDefinition" ? u([a, D]) : [" ", u(i([r, D]))];
            }
            function w(k, P, C, D) {
              return k.map((g, F, l) => {
                let E = C();
                return F < l.length - 1 && c(P.originalText, g.getValue(), p) ? [E, s] : E;
              }, D);
            }
            function T(k) {
              return k.kind && k.kind !== "Comment";
            }
            function A(k) {
              let P = k.getValue();
              if (P.kind === "Comment")
                return "#" + P.value.trimEnd();
              throw new Error("Not a comment: " + JSON.stringify(P));
            }
            function S(k, P, C) {
              let D = k.getNode(), g = [], { interfaces: F } = D, l = k.map((E) => C(E), "interfaces");
              for (let E = 0; E < F.length; E++) {
                let y = F[E];
                g.push(l[E]);
                let N = F[E + 1];
                if (N) {
                  let x = P.originalText.slice(y.loc.end, N.loc.start), b = x.includes("#"), L = x.replace(/#.*/g, "").trim();
                  g.push(L === "," ? "," : " &", b ? a : " ");
                }
              }
              return g;
            }
            function B(k, P) {
              k.kind === "StringValue" && k.block && !k.value.includes(`
`) && (P.value = P.value.trim());
            }
            B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
            function I(k) {
              var P;
              let C = k.getValue();
              return C == null || (P = C.comments) === null || P === void 0 ? void 0 : P.some((D) => D.value.trim() === "prettier-ignore");
            }
            n.exports = { print: f, massageAstNode: B, hasPrettierIgnore: I, insertPragma: m, printComment: A, canAttachComment: T };
          } }), jd = Z({ "src/language-graphql/options.js"(e, n) {
            "use strict";
            re();
            var t = Ot();
            n.exports = { bracketSpacing: t.bracketSpacing };
          } }), Od = Z({ "src/language-graphql/parsers.js"() {
            re();
          } }), qd = Z({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
            n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
          } }), Md = Z({ "src/language-graphql/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = Ld(), a = jd(), r = Od(), u = [t(qd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
            n.exports = { languages: u, options: a, printers: i, parsers: r };
          } }), go = Z({ "src/language-markdown/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Rd = Z({ "src/language-markdown/constants.evaluate.js"(e, n) {
            n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
          } }), Kn = Z({ "src/language-markdown/utils.js"(e, n) {
            "use strict";
            re();
            var { getLast: t } = Ue(), { locStart: s, locEnd: a } = go(), { cjkPattern: r, kPattern: u, punctuationPattern: i } = Rd(), o = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c = [...o, "tableCell", "paragraph", "heading"], v = new RegExp(u), m = new RegExp(i);
            function d(A, S) {
              let B = "non-cjk", I = "cj-letter", k = "k-letter", P = "cjk-punctuation", C = [], D = (S.proseWrap === "preserve" ? A : A.replace(new RegExp("(".concat(r, `)
(`).concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
              for (let [F, l] of D.entries()) {
                if (F % 2 === 1) {
                  C.push({ type: "whitespace", value: /\n/.test(l) ? `
` : " " });
                  continue;
                }
                if ((F === 0 || F === D.length - 1) && l === "")
                  continue;
                let E = l.split(new RegExp("(".concat(r, ")")));
                for (let [y, N] of E.entries())
                  if (!((y === 0 || y === E.length - 1) && N === "")) {
                    if (y % 2 === 0) {
                      N !== "" && g({ type: "word", value: N, kind: B, hasLeadingPunctuation: m.test(N[0]), hasTrailingPunctuation: m.test(t(N)) });
                      continue;
                    }
                    g(m.test(N) ? { type: "word", value: N, kind: P, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: N, kind: v.test(N) ? k : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                  }
              }
              return C;
              function g(F) {
                let l = t(C);
                l && l.type === "word" && (l.kind === B && F.kind === I && !l.hasTrailingPunctuation || l.kind === I && F.kind === B && !F.hasLeadingPunctuation ? C.push({ type: "whitespace", value: " " }) : !E(B, P) && ![l.value, F.value].some((y) => /\u3000/.test(y)) && C.push({ type: "whitespace", value: "" })), C.push(F);
                function E(y, N) {
                  return l.kind === y && F.kind === N || l.kind === N && F.kind === y;
                }
              }
            }
            function p(A, S) {
              let [, B, I, k] = S.slice(A.position.start.offset, A.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
              return { numberText: B, marker: I, leadingSpaces: k };
            }
            function f(A, S) {
              if (!A.ordered || A.children.length < 2)
                return false;
              let B = Number(p(A.children[0], S.originalText).numberText), I = Number(p(A.children[1], S.originalText).numberText);
              if (B === 0 && A.children.length > 2) {
                let k = Number(p(A.children[2], S.originalText).numberText);
                return I === 1 && k === 1;
              }
              return I === 1;
            }
            function h(A, S) {
              let { value: B } = A;
              return A.position.end.offset === S.length && B.endsWith(`
`) && S.endsWith(`
`) ? B.slice(0, -1) : B;
            }
            function w(A, S) {
              return function B(I, k, P) {
                let C = Object.assign({}, S(I, k, P));
                return C.children && (C.children = C.children.map((D, g) => B(D, g, [C, ...P]))), C;
              }(A, null, []);
            }
            function T(A) {
              if ((A == null ? void 0 : A.type) !== "link" || A.children.length !== 1)
                return false;
              let [S] = A.children;
              return s(A) === s(S) && a(A) === a(S);
            }
            n.exports = { mapAst: w, splitText: d, punctuationPattern: i, getFencedCodeBlockValue: h, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: o, INLINE_NODE_WRAPPER_TYPES: c, isAutolink: T };
          } }), Vd = Z({ "src/language-markdown/embed.js"(e, n) {
            "use strict";
            re();
            var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: r }, utils: { replaceEndOfLine: u } } = Oe(), i = Xn(), { getFencedCodeBlockValue: o } = Kn();
            function c(v, m, d, p) {
              let f = v.getValue();
              if (f.type === "code" && f.lang !== null) {
                let h = t(f.lang, p);
                if (h) {
                  let w = p.__inJsTemplate ? "~" : "`", T = w.repeat(Math.max(3, s(f.value, w) + 1)), A = { parser: h };
                  f.lang === "tsx" && (A.filepath = "dummy.tsx");
                  let S = d(o(f, p.originalText), A, { stripTrailingHardline: true });
                  return r([T, f.lang, f.meta ? " " + f.meta : "", a, u(S), a, T]);
                }
              }
              switch (f.type) {
                case "front-matter":
                  return i(f, d);
                case "importExport":
                  return [d(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
                case "jsx":
                  return d("<$>".concat(f.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
              }
              return null;
            }
            n.exports = c;
          } }), yo = Z({ "src/language-markdown/pragma.js"(e, n) {
            "use strict";
            re();
            var t = mo(), s = ["format", "prettier"];
            function a(r) {
              let u = "@(".concat(s.join("|"), ")"), i = new RegExp(["<!--\\s*".concat(u, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"), `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(u, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)].join("|"), "m"), o = r.match(i);
              return (o == null ? void 0 : o.index) === 0;
            }
            n.exports = { startWithPragma: a, hasPragma: (r) => a(t(r).content.trimStart()), insertPragma: (r) => {
              let u = t(r), i = "<!-- @".concat(s[0], " -->");
              return u.frontMatter ? "".concat(u.frontMatter.raw, `

`).concat(i, `

`).concat(u.content) : "".concat(i, `

`).concat(u.content);
            } };
          } }), Wd = Z({ "src/language-markdown/print-preprocess.js"(e, n) {
            "use strict";
            re();
            var t = it(), { getOrderedListItemInfo: s, mapAst: a, splitText: r } = Kn(), u = /^.$/su;
            function i(T, A) {
              return T = v(T, A), T = p(T), T = c(T), T = h(T, A), T = w(T, A), T = f(T, A), T = o(T), T = m(T), T;
            }
            function o(T) {
              return a(T, (A) => A.type !== "import" && A.type !== "export" ? A : Object.assign(Object.assign({}, A), {}, { type: "importExport" }));
            }
            function c(T) {
              return a(T, (A) => A.type !== "inlineCode" ? A : Object.assign(Object.assign({}, A), {}, { value: A.value.replace(/\s+/g, " ") }));
            }
            function v(T, A) {
              return a(T, (S) => S.type !== "text" || S.value === "*" || S.value === "_" || !u.test(S.value) || S.position.end.offset - S.position.start.offset === S.value.length ? S : Object.assign(Object.assign({}, S), {}, { value: A.originalText.slice(S.position.start.offset, S.position.end.offset) }));
            }
            function m(T) {
              return d(T, (A, S) => A.type === "importExport" && S.type === "importExport", (A, S) => ({ type: "importExport", value: A.value + `

` + S.value, position: { start: A.position.start, end: S.position.end } }));
            }
            function d(T, A, S) {
              return a(T, (B) => {
                if (!B.children)
                  return B;
                let I = B.children.reduce((k, P) => {
                  let C = t(k);
                  return C && A(C, P) ? k.splice(-1, 1, S(C, P)) : k.push(P), k;
                }, []);
                return Object.assign(Object.assign({}, B), {}, { children: I });
              });
            }
            function p(T) {
              return d(T, (A, S) => A.type === "text" && S.type === "text", (A, S) => ({ type: "text", value: A.value + S.value, position: { start: A.position.start, end: S.position.end } }));
            }
            function f(T, A) {
              return a(T, (S, B, I) => {
                let [k] = I;
                if (S.type !== "text")
                  return S;
                let { value: P } = S;
                return k.type === "paragraph" && (B === 0 && (P = P.trimStart()), B === k.children.length - 1 && (P = P.trimEnd())), { type: "sentence", position: S.position, children: r(P, A) };
              });
            }
            function h(T, A) {
              return a(T, (S, B, I) => {
                if (S.type === "code") {
                  let k = /^\n?(?: {4,}|\t)/.test(A.originalText.slice(S.position.start.offset, S.position.end.offset));
                  if (S.isIndented = k, k)
                    for (let P = 0; P < I.length; P++) {
                      let C = I[P];
                      if (C.hasIndentedCodeblock)
                        break;
                      C.type === "list" && (C.hasIndentedCodeblock = true);
                    }
                }
                return S;
              });
            }
            function w(T, A) {
              return a(T, (I, k, P) => {
                if (I.type === "list" && I.children.length > 0) {
                  for (let C = 0; C < P.length; C++) {
                    let D = P[C];
                    if (D.type === "list" && !D.isAligned)
                      return I.isAligned = false, I;
                  }
                  I.isAligned = B(I);
                }
                return I;
              });
              function S(I) {
                return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
              }
              function B(I) {
                if (!I.ordered)
                  return true;
                let [k, P] = I.children;
                if (s(k, A.originalText).leadingSpaces.length > 1)
                  return true;
                let D = S(k);
                if (D === -1)
                  return false;
                if (I.children.length === 1)
                  return D % A.tabWidth === 0;
                let g = S(P);
                return D !== g ? false : D % A.tabWidth === 0 ? true : s(P, A.originalText).leadingSpaces.length > 1;
              }
            }
            n.exports = i;
          } }), $d = Z({ "src/language-markdown/clean.js"(e, n) {
            "use strict";
            re();
            var { isFrontMatterNode: t } = Ue(), { startWithPragma: s } = yo(), a = /* @__PURE__ */ new Set(["position", "raw"]);
            function r(u, i, o) {
              if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i.value, u.type === "list" && delete i.isAligned, (u.type === "list" || u.type === "listItem") && (delete i.spread, delete i.loose), u.type === "text" || (u.type === "inlineCode" && (i.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i.title = u.title.replace(/\\(["')])/g, "$1")), o && o.type === "root" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === "html" && s(u.value)))
                return null;
            }
            r.ignoredProperties = a, n.exports = r;
          } }), Hd = Z({ "src/language-markdown/printer-markdown.js"(e, n) {
            "use strict";
            re();
            var { getLast: t, getMinNotPresentContinuousCount: s, getMaxContinuousCount: a, getStringWidth: r, isNonEmptyArray: u } = Ue(), { builders: { breakParent: i, join: o, line: c, literalline: v, markAsRoot: m, hardline: d, softline: p, ifBreak: f, fill: h, align: w, indent: T, group: A, hardlineWithoutBreakParent: S }, utils: { normalizeDoc: B, replaceTextEndOfLine: I }, printer: { printDocToString: k } } = Oe(), P = Vd(), { insertPragma: C } = yo(), { locStart: D, locEnd: g } = go(), F = Wd(), l = $d(), { getFencedCodeBlockValue: E, hasGitDiffFriendlyOrderedList: y, splitText: N, punctuationPattern: x, INLINE_NODE_TYPES: b, INLINE_NODE_WRAPPER_TYPES: L, isAutolink: M } = Kn(), j = /* @__PURE__ */ new Set(["importExport"]), $ = ["heading", "tableCell", "link", "wikiLink"], V = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
            function q(ce, pe, de) {
              let ae = ce.getValue();
              if (le(ce))
                return N(pe.originalText.slice(ae.position.start.offset, ae.position.end.offset), pe).map((ve) => ve.type === "word" ? ve.value : ve.value === "" ? "" : oe(ce, ve.value, pe));
              switch (ae.type) {
                case "front-matter":
                  return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);
                case "root":
                  return ae.children.length === 0 ? "" : [B(X(ce, pe, de)), j.has(De(ae).type) ? "" : d];
                case "paragraph":
                  return ue(ce, pe, de, { postprocessor: h });
                case "sentence":
                  return ue(ce, pe, de);
                case "word": {
                  let ve = ae.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(x, ")(_+)"), "(_+)(".concat(x, "|$)")].join("|"), "g"), (ye, Ce, Ie, Fe, me) => (Ie ? "".concat(Ce).concat(Ie) : "".concat(Fe).concat(me)).replace(/_/g, "\\_")), K = (ye, Ce, Ie) => ye.type === "sentence" && Ie === 0, he = (ye, Ce, Ie) => M(ye.children[Ie - 1]);
                  return ve !== ae.value && (ce.match(void 0, K, he) || ce.match(void 0, K, (ye, Ce, Ie) => ye.type === "emphasis" && Ie === 0, he)) && (ve = ve.replace(/^(\\?[*_])+/, (ye) => ye.replace(/\\/g, ""))), ve;
                }
                case "whitespace": {
                  let ve = ce.getParentNode(), K = ve.children.indexOf(ae), he = ve.children[K + 1], ye = he && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(he.value) ? "never" : pe.proseWrap;
                  return oe(ce, ae.value, { proseWrap: ye });
                }
                case "emphasis": {
                  let ve;
                  if (M(ae.children[0]))
                    ve = pe.originalText[ae.position.start.offset];
                  else {
                    let K = ce.getParentNode(), he = K.children.indexOf(ae), ye = K.children[he - 1], Ce = K.children[he + 1];
                    ve = ye && ye.type === "sentence" && ye.children.length > 0 && t(ye.children).type === "word" && !t(ye.children).hasTrailingPunctuation || Ce && Ce.type === "sentence" && Ce.children.length > 0 && Ce.children[0].type === "word" && !Ce.children[0].hasLeadingPunctuation || te(ce, "emphasis") ? "*" : "_";
                  }
                  return [ve, ue(ce, pe, de), ve];
                }
                case "strong":
                  return ["**", ue(ce, pe, de), "**"];
                case "delete":
                  return ["~~", ue(ce, pe, de), "~~"];
                case "inlineCode": {
                  let ve = s(ae.value, "`"), K = "`".repeat(ve || 1), he = ve && !/^\s/.test(ae.value) ? " " : "";
                  return [K, he, ae.value, he, K];
                }
                case "wikiLink": {
                  let ve = "";
                  return pe.proseWrap === "preserve" ? ve = ae.value : ve = ae.value.replace(/[\t\n]+/g, " "), ["[[", ve, "]]"];
                }
                case "link":
                  switch (pe.originalText[ae.position.start.offset]) {
                    case "<": {
                      let ve = "mailto:", K = ae.url.startsWith(ve) && pe.originalText.slice(ae.position.start.offset + 1, ae.position.start.offset + 1 + ve.length) !== ve ? ae.url.slice(ve.length) : ae.url;
                      return ["<", K, ">"];
                    }
                    case "[":
                      return ["[", ue(ce, pe, de), "](", ge(ae.url, ")"), Ae(ae.title, pe), ")"];
                    default:
                      return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);
                  }
                case "image":
                  return ["![", ae.alt || "", "](", ge(ae.url, ")"), Ae(ae.title, pe), ")"];
                case "blockquote":
                  return ["> ", w("> ", ue(ce, pe, de))];
                case "heading":
                  return ["#".repeat(ae.depth) + " ", ue(ce, pe, de)];
                case "code": {
                  if (ae.isIndented) {
                    let he = " ".repeat(4);
                    return w(he, [he, ...I(ae.value, d)]);
                  }
                  let ve = pe.__inJsTemplate ? "~" : "`", K = ve.repeat(Math.max(3, a(ae.value, ve) + 1));
                  return [K, ae.lang || "", ae.meta ? " " + ae.meta : "", d, ...I(E(ae, pe.originalText), d), d, K];
                }
                case "html": {
                  let ve = ce.getParentNode(), K = ve.type === "root" && t(ve.children) === ae ? ae.value.trimEnd() : ae.value, he = /^<!--.*-->$/s.test(K);
                  return I(K, he ? d : m(v));
                }
                case "list": {
                  let ve = R(ae, ce.getParentNode()), K = y(ae, pe);
                  return ue(ce, pe, de, { processor: (he, ye) => {
                    let Ce = Fe(), Ie = he.getValue();
                    if (Ie.children.length === 2 && Ie.children[1].type === "html" && Ie.children[0].position.start.column !== Ie.children[1].position.start.column)
                      return [Ce, Y(he, pe, de, Ce)];
                    return [Ce, w(" ".repeat(Ce.length), Y(he, pe, de, Ce))];
                    function Fe() {
                      let me = ae.ordered ? (ye === 0 ? ae.start : K ? 1 : ae.start + ye) + (ve % 2 === 0 ? ". " : ") ") : ve % 2 === 0 ? "- " : "* ";
                      return ae.isAligned || ae.hasIndentedCodeblock ? H(me, pe) : me;
                    }
                  } });
                }
                case "thematicBreak": {
                  let ve = ee(ce, "list");
                  return ve === -1 ? "---" : R(ce.getParentNode(ve), ce.getParentNode(ve + 1)) % 2 === 0 ? "***" : "---";
                }
                case "linkReference":
                  return ["[", ue(ce, pe, de), "]", ae.referenceType === "full" ? ["[", ae.identifier, "]"] : ae.referenceType === "collapsed" ? "[]" : ""];
                case "imageReference":
                  switch (ae.referenceType) {
                    case "full":
                      return ["![", ae.alt || "", "][", ae.identifier, "]"];
                    default:
                      return ["![", ae.alt, "]", ae.referenceType === "collapsed" ? "[]" : ""];
                  }
                case "definition": {
                  let ve = pe.proseWrap === "always" ? c : " ";
                  return A(["[", ae.identifier, "]:", T([ve, ge(ae.url), ae.title === null ? "" : [ve, Ae(ae.title, pe, false)]])]);
                }
                case "footnote":
                  return ["[^", ue(ce, pe, de), "]"];
                case "footnoteReference":
                  return ["[^", ae.identifier, "]"];
                case "footnoteDefinition": {
                  let ve = ce.getParentNode().children[ce.getName() + 1], K = ae.children.length === 1 && ae.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ae.children[0].position.start.line === ae.children[0].position.end.line);
                  return ["[^", ae.identifier, "]: ", K ? ue(ce, pe, de) : A([w(" ".repeat(4), ue(ce, pe, de, { processor: (he, ye) => ye === 0 ? A([p, de()]) : de() })), ve && ve.type === "footnoteDefinition" ? p : ""])];
                }
                case "table":
                  return W(ce, pe, de);
                case "tableCell":
                  return ue(ce, pe, de);
                case "break":
                  return /\s/.test(pe.originalText[ae.position.start.offset]) ? ["  ", m(v)] : ["\\", d];
                case "liquidNode":
                  return I(ae.value, d);
                case "importExport":
                  return [ae.value, d];
                case "esComment":
                  return ["{/* ", ae.value, " */}"];
                case "jsx":
                  return ae.value;
                case "math":
                  return ["$$", d, ae.value ? [...I(ae.value, d), d] : "", "$$"];
                case "inlineMath":
                  return pe.originalText.slice(D(ae), g(ae));
                case "tableRow":
                case "listItem":
                default:
                  throw new Error("Unknown markdown type ".concat(JSON.stringify(ae.type)));
              }
            }
            function Y(ce, pe, de, ae) {
              let ve = ce.getValue(), K = ve.checked === null ? "" : ve.checked ? "[x] " : "[ ] ";
              return [K, ue(ce, pe, de, { processor: (he, ye) => {
                if (ye === 0 && he.getValue().type !== "list")
                  return w(" ".repeat(K.length), de());
                let Ce = " ".repeat(Ne(pe.tabWidth - ae.length, 0, 3));
                return [Ce, w(Ce, de())];
              } })];
            }
            function H(ce, pe) {
              let de = ae();
              return ce + " ".repeat(de >= 4 ? 0 : de);
              function ae() {
                let ve = ce.length % pe.tabWidth;
                return ve === 0 ? 0 : pe.tabWidth - ve;
              }
            }
            function R(ce, pe) {
              return Q(ce, pe, (de) => de.ordered === ce.ordered);
            }
            function Q(ce, pe, de) {
              let ae = -1;
              for (let ve of pe.children)
                if (ve.type === ce.type && de(ve) ? ae++ : ae = -1, ve === ce)
                  return ae;
            }
            function ee(ce, pe) {
              let de = Array.isArray(pe) ? pe : [pe], ae = -1, ve;
              for (; ve = ce.getParentNode(++ae); )
                if (de.includes(ve.type))
                  return ae;
              return -1;
            }
            function te(ce, pe) {
              let de = ee(ce, pe);
              return de === -1 ? null : ce.getParentNode(de);
            }
            function oe(ce, pe, de) {
              if (de.proseWrap === "preserve" && pe === `
`)
                return d;
              let ae = de.proseWrap === "always" && !te(ce, $);
              return pe !== "" ? ae ? c : " " : ae ? p : "";
            }
            function W(ce, pe, de) {
              let ae = ce.getValue(), ve = [], K = ce.map((me) => me.map((_, J) => {
                let ne = k(de(), pe).formatted, Ee = r(ne);
                return ve[J] = Math.max(ve[J] || 3, Ee), { text: ne, width: Ee };
              }, "children"), "children"), he = Ce(false);
              if (pe.proseWrap !== "never")
                return [i, he];
              let ye = Ce(true);
              return [i, A(f(ye, he))];
              function Ce(me) {
                let _ = [Fe(K[0], me), Ie(me)];
                return K.length > 1 && _.push(o(S, K.slice(1).map((J) => Fe(J, me)))), o(S, _);
              }
              function Ie(me) {
                let _ = ve.map((J, ne) => {
                  let Ee = ae.align[ne], We = Ee === "center" || Ee === "left" ? ":" : "-", Be = Ee === "center" || Ee === "right" ? ":" : "-", Pe = me ? "-" : "-".repeat(J - 2);
                  return "".concat(We).concat(Pe).concat(Be);
                });
                return "| ".concat(_.join(" | "), " |");
              }
              function Fe(me, _) {
                let J = me.map((ne, Ee) => {
                  let { text: We, width: Be } = ne;
                  if (_)
                    return We;
                  let Pe = ve[Ee] - Be, Se = ae.align[Ee], Qe = 0;
                  Se === "right" ? Qe = Pe : Se === "center" && (Qe = Math.floor(Pe / 2));
                  let xe = Pe - Qe;
                  return "".concat(" ".repeat(Qe)).concat(We).concat(" ".repeat(xe));
                });
                return "| ".concat(J.join(" | "), " |");
              }
            }
            function X(ce, pe, de) {
              let ae = [], ve = null, { children: K } = ce.getValue();
              for (let [he, ye] of K.entries())
                switch (ie(ye)) {
                  case "start":
                    ve === null && (ve = { index: he, offset: ye.position.end.offset });
                    break;
                  case "end":
                    ve !== null && (ae.push({ start: ve, end: { index: he, offset: ye.position.start.offset } }), ve = null);
                    break;
                  default:
                    break;
                }
              return ue(ce, pe, de, { processor: (he, ye) => {
                if (ae.length > 0) {
                  let Ce = ae[0];
                  if (ye === Ce.start.index)
                    return [K[Ce.start.index].value, pe.originalText.slice(Ce.start.offset, Ce.end.offset), K[Ce.end.index].value];
                  if (Ce.start.index < ye && ye < Ce.end.index)
                    return false;
                  if (ye === Ce.end.index)
                    return ae.shift(), false;
                }
                return de();
              } });
            }
            function ue(ce, pe, de) {
              let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: ve } = ae, K = ae.processor || (() => de()), he = ce.getValue(), ye = [], Ce;
              return ce.each((Ie, Fe) => {
                let me = Ie.getValue(), _ = K(Ie, Fe);
                if (_ !== false) {
                  let J = { parts: ye, prevNode: Ce, parentNode: he, options: pe };
                  G(me, J) && (ye.push(d), Ce && j.has(Ce.type) || (z(me, J) || U(me, J)) && ye.push(d), U(me, J) && ye.push(d)), ye.push(_), Ce = me;
                }
              }, "children"), ve ? ve(ye) : ye;
            }
            function De(ce) {
              let pe = ce;
              for (; u(pe.children); )
                pe = t(pe.children);
              return pe;
            }
            function ie(ce) {
              let pe;
              if (ce.type === "html")
                pe = ce.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
              else {
                let de;
                ce.type === "esComment" ? de = ce : ce.type === "paragraph" && ce.children.length === 1 && ce.children[0].type === "esComment" && (de = ce.children[0]), de && (pe = de.value.match(/^prettier-ignore(?:-(start|end))?$/));
              }
              return pe ? pe[1] || "next" : false;
            }
            function G(ce, pe) {
              let de = pe.parts.length === 0, ae = b.includes(ce.type), ve = ce.type === "html" && L.includes(pe.parentNode.type);
              return !de && !ae && !ve;
            }
            function z(ce, pe) {
              var de, ae, ve;
              let he = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type), ye = pe.parentNode.type === "listItem" && !pe.parentNode.loose, Ce = ((de = pe.prevNode) === null || de === void 0 ? void 0 : de.type) === "listItem" && pe.prevNode.loose, Ie = ie(pe.prevNode) === "next", Fe = ce.type === "html" && ((ae = pe.prevNode) === null || ae === void 0 ? void 0 : ae.type) === "html" && pe.prevNode.position.end.line + 1 === ce.position.start.line, me = ce.type === "html" && pe.parentNode.type === "listItem" && ((ve = pe.prevNode) === null || ve === void 0 ? void 0 : ve.type) === "paragraph" && pe.prevNode.position.end.line + 1 === ce.position.start.line;
              return Ce || !(he || ye || Ie || Fe || me);
            }
            function U(ce, pe) {
              let de = pe.prevNode && pe.prevNode.type === "list", ae = ce.type === "code" && ce.isIndented;
              return de && ae;
            }
            function le(ce) {
              let pe = te(ce, ["linkReference", "imageReference"]);
              return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
            }
            function ge(ce) {
              let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], de = [" ", ...Array.isArray(pe) ? pe : [pe]];
              return new RegExp(de.map((ae) => "\\".concat(ae)).join("|")).test(ce) ? "<".concat(ce, ">") : ce;
            }
            function Ae(ce, pe) {
              let de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!ce)
                return "";
              if (de)
                return " " + Ae(ce, pe, false);
              if (ce = ce.replace(/\\(["')])/g, "$1"), ce.includes('"') && ce.includes("'") && !ce.includes(")"))
                return "(".concat(ce, ")");
              let ae = ce.split("'").length - 1, ve = ce.split('"').length - 1, K = ae > ve ? '"' : ve > ae || pe.singleQuote ? "'" : '"';
              return ce = ce.replace(/\\/, "\\\\"), ce = ce.replace(new RegExp("(".concat(K, ")"), "g"), "\\$1"), "".concat(K).concat(ce).concat(K);
            }
            function Ne(ce, pe, de) {
              return ce < pe ? pe : ce > de ? de : ce;
            }
            function ke(ce) {
              let pe = Number(ce.getName());
              if (pe === 0)
                return false;
              let de = ce.getParentNode().children[pe - 1];
              return ie(de) === "next";
            }
            n.exports = { preprocess: F, print: q, embed: P, massageAstNode: l, hasPrettierIgnore: ke, insertPragma: C };
          } }), Gd = Z({ "src/language-markdown/options.js"(e, n) {
            "use strict";
            re();
            var t = Ot();
            n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
          } }), Jd = Z({ "src/language-markdown/parsers.js"() {
            re();
          } }), da = Z({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
            n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
          } }), Ud = Z({ "src/language-markdown/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = Hd(), a = Gd(), r = Jd(), u = [t(da(), (o) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...o.filenames, "README"], extensions: o.extensions.filter((c) => c !== ".mdx") })), t(da(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
            n.exports = { languages: u, options: a, printers: i, parsers: r };
          } }), zd = Z({ "src/language-html/clean.js"(e, n) {
            "use strict";
            re();
            var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
            function a(r, u) {
              if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
                return null;
              r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
            }
            a.ignoredProperties = s, n.exports = a;
          } }), Xd = Z({ "src/language-html/constants.evaluate.js"(e, n) {
            n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
          } }), Kd = Z({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            n.exports = t;
          } }), qt = Z({ "src/language-html/utils/index.js"(e, n) {
            "use strict";
            re();
            var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: r, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: o } } = Oe(), { CSS_DISPLAY_TAGS: c, CSS_DISPLAY_DEFAULT: v, CSS_WHITE_SPACE_TAGS: m, CSS_WHITE_SPACE_DEFAULT: d } = Xd(), p = Kd(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), h = (_) => _.replace(/^[\t\n\f\r ]+/, ""), w = (_) => _.replace(/[\t\n\f\r ]+$/, ""), T = (_) => h(w(_)), A = (_) => _.replace(/^[\t\f\r ]*\n/g, ""), S = (_) => A(w(_)), B = (_) => _.split(/[\t\n\f\r ]+/), I = (_) => _.match(/^[\t\n\f\r ]*/)[0], k = (_) => {
              let [, J, ne, Ee] = _.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
              return { leadingWhitespace: J, trailingWhitespace: Ee, text: ne };
            }, P = (_) => /[\t\n\f\r ]/.test(_);
            function C(_, J) {
              return !!(_.type === "ieConditionalComment" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === "ieConditionalComment" && !_.complete || le(_) && _.children.some((ne) => ne.type !== "text" && ne.type !== "interpolation") || ye(_, J) && !l(_) && _.type !== "interpolation");
            }
            function D(_) {
              return _.type === "attribute" || !_.parent || !_.prev ? false : g(_.prev);
            }
            function g(_) {
              return _.type === "comment" && _.value.trim() === "prettier-ignore";
            }
            function F(_) {
              return _.type === "text" || _.type === "comment";
            }
            function l(_) {
              return _.type === "element" && (_.fullName === "script" || _.fullName === "style" || _.fullName === "svg:style" || p(_) && (_.name === "script" || _.name === "style"));
            }
            function E(_) {
              return _.children && !l(_);
            }
            function y(_) {
              return l(_) || _.type === "interpolation" || N(_);
            }
            function N(_) {
              return ke(_).startsWith("pre");
            }
            function x(_, J) {
              let ne = Ee();
              if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf)
                return _.type === "interpolation";
              return ne;
              function Ee() {
                return s(_) ? false : (_.type === "text" || _.type === "interpolation") && _.prev && (_.prev.type === "text" || _.prev.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le(_.parent) ? true : !(!_.prev && (_.parent.type === "root" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !De(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));
              }
            }
            function b(_, J) {
              return s(_) ? false : (_.type === "text" || _.type === "interpolation") && _.next && (_.next.type === "text" || _.next.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le(_.parent) ? true : !(!_.next && (_.parent.type === "root" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));
            }
            function L(_) {
              return U(_.cssDisplay) && !l(_);
            }
            function M(_) {
              return s(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;
            }
            function j(_) {
              return $(_) || _.type === "element" && _.children.length > 0 && (["body", "script", "style"].includes(_.name) || _.children.some((J) => te(J))) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== "text" && H(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));
            }
            function $(_) {
              return _.type === "element" && _.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(_.name) || _.cssDisplay.startsWith("table") && _.cssDisplay !== "table-cell");
            }
            function V(_) {
              return Q(_) || _.prev && q(_.prev) || Y(_);
            }
            function q(_) {
              return Q(_) || _.type === "element" && _.fullName === "br" || Y(_);
            }
            function Y(_) {
              return H(_) && R(_);
            }
            function H(_) {
              return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === "root" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);
            }
            function R(_) {
              return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === "root" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);
            }
            function Q(_) {
              switch (_.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive":
                  return true;
                case "element":
                  return ["script", "select"].includes(_.name);
              }
              return false;
            }
            function ee(_) {
              return _.lastChild ? ee(_.lastChild) : _;
            }
            function te(_) {
              return _.children && _.children.some((J) => J.type !== "text");
            }
            function oe(_) {
              let { type: J, lang: ne } = _.attrMap;
              if (J === "module" || J === "text/javascript" || J === "text/babel" || J === "application/javascript" || ne === "jsx")
                return "babel";
              if (J === "application/x-typescript" || ne === "ts" || ne === "tsx")
                return "typescript";
              if (J === "text/markdown")
                return "markdown";
              if (J === "text/html")
                return "html";
              if (J && (J.endsWith("json") || J.endsWith("importmap")) || J === "speculationrules")
                return "json";
              if (J === "text/x-handlebars-template")
                return "glimmer";
            }
            function W(_, J) {
              let { lang: ne } = _.attrMap;
              if (!ne || ne === "postcss" || ne === "css")
                return "css";
              if (ne === "scss")
                return "scss";
              if (ne === "less")
                return "less";
              if (ne === "stylus")
                return t("stylus", J);
            }
            function X(_, J) {
              if (_.name === "script" && !_.attrMap.src)
                return !_.attrMap.lang && !_.attrMap.type ? "babel" : oe(_);
              if (_.name === "style")
                return W(_, J);
              if (J && ye(_, J))
                return oe(_) || !("src" in _.attrMap) && t(_.attrMap.lang, J);
            }
            function ue(_) {
              return _ === "block" || _ === "list-item" || _.startsWith("table");
            }
            function De(_) {
              return !ue(_) && _ !== "inline-block";
            }
            function ie(_) {
              return !ue(_) && _ !== "inline-block";
            }
            function G(_) {
              return !ue(_);
            }
            function z(_) {
              return !ue(_);
            }
            function U(_) {
              return !ue(_) && _ !== "inline-block";
            }
            function le(_) {
              return ke(_).startsWith("pre");
            }
            function ge(_, J) {
              let ne = 0;
              for (let Ee = _.stack.length - 1; Ee >= 0; Ee--) {
                let We = _.stack[Ee];
                We && typeof We == "object" && !Array.isArray(We) && J(We) && ne++;
              }
              return ne;
            }
            function Ae(_, J) {
              let ne = _;
              for (; ne; ) {
                if (J(ne))
                  return true;
                ne = ne.parent;
              }
              return false;
            }
            function Ne(_, J) {
              if (_.prev && _.prev.type === "comment") {
                let Ee = _.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (Ee)
                  return Ee[1];
              }
              let ne = false;
              if (_.type === "element" && _.namespace === "svg")
                if (Ae(_, (Ee) => Ee.fullName === "svg:foreignObject"))
                  ne = true;
                else
                  return _.name === "svg" ? "inline-block" : "block";
              switch (J.htmlWhitespaceSensitivity) {
                case "strict":
                  return "inline";
                case "ignore":
                  return "block";
                default:
                  return J.parser === "vue" && _.parent && _.parent.type === "root" ? "block" : _.type === "element" && (!_.namespace || ne || p(_)) && c[_.name] || v;
              }
            }
            function ke(_) {
              return _.type === "element" && (!_.namespace || p(_)) && m[_.name] || d;
            }
            function ce(_) {
              let J = Number.POSITIVE_INFINITY;
              for (let ne of _.split(`
`)) {
                if (ne.length === 0)
                  continue;
                if (!f.has(ne[0]))
                  return 0;
                let Ee = I(ne).length;
                ne.length !== Ee && Ee < J && (J = Ee);
              }
              return J === Number.POSITIVE_INFINITY ? 0 : J;
            }
            function pe(_) {
              let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);
              return J === 0 ? _ : _.split(`
`).map((ne) => ne.slice(J)).join(`
`);
            }
            function de(_, J) {
              let ne = 0;
              for (let Ee = 0; Ee < _.length; Ee++)
                _[Ee] === J && ne++;
              return ne;
            }
            function ae(_) {
              return _.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            }
            var ve = /* @__PURE__ */ new Set(["template", "style", "script"]);
            function K(_, J) {
              return he(_, J) && !ve.has(_.fullName);
            }
            function he(_, J) {
              return J.parser === "vue" && _.type === "element" && _.parent.type === "root" && _.fullName.toLowerCase() !== "html";
            }
            function ye(_, J) {
              return he(_, J) && (K(_, J) || _.attrMap.lang && _.attrMap.lang !== "html");
            }
            function Ce(_) {
              let J = _.fullName;
              return J.charAt(0) === "#" || J === "slot-scope" || J === "v-slot" || J.startsWith("v-slot:");
            }
            function Ie(_, J) {
              let ne = _.parent;
              if (!he(ne, J))
                return false;
              let Ee = ne.fullName, We = _.fullName;
              return Ee === "script" && We === "setup" || Ee === "style" && We === "vars";
            }
            function Fe(_) {
              let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;
              return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J) : o(pe(S(J)), r) : i(u(a, B(J)));
            }
            function me(_, J) {
              return he(_, J) && _.name === "script";
            }
            n.exports = { htmlTrim: T, htmlTrimPreserveIndentation: S, hasHtmlWhitespace: P, getLeadingAndTrailingHtmlWhitespace: k, canHaveInterpolation: E, countChars: de, countParents: ge, dedentString: pe, forceBreakChildren: $, forceBreakContent: j, forceNextEmptyLine: M, getLastDescendant: ee, getNodeCssStyleDisplay: Ne, getNodeCssStyleWhiteSpace: ke, hasPrettierIgnore: D, inferScriptParser: X, isVueCustomBlock: K, isVueNonHtmlBlock: ye, isVueScriptTag: me, isVueSlotAttribute: Ce, isVueSfcBindingsAttribute: Ie, isVueSfcBlock: he, isDanglingSpaceSensitiveNode: L, isIndentationSensitiveNode: N, isLeadingSpaceSensitiveNode: x, isPreLikeNode: le, isScriptLikeTag: l, isTextLikeNode: F, isTrailingSpaceSensitiveNode: b, isWhitespaceSensitiveNode: y, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: V, preferHardlineAsTrailingSpaces: q, shouldPreserveContent: C, unescapeQuoteEntities: ae, getTextValueParts: Fe };
          } }), Yd = Z({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function n(i) {
              return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
            }
            e.isWhitespace = n;
            function t(i) {
              return e.$0 <= i && i <= e.$9;
            }
            e.isDigit = t;
            function s(i) {
              return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
            }
            e.isAsciiLetter = s;
            function a(i) {
              return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
            }
            e.isAsciiHexDigit = a;
            function r(i) {
              return i === e.$LF || i === e.$CR;
            }
            e.isNewLine = r;
            function u(i) {
              return e.$0 <= i && i <= e.$7;
            }
            e.isOctalDigit = u;
          } }), Qd = Z({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = class {
              constructor(s, a, r) {
                this.filePath = s, this.name = a, this.members = r;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
              }
            };
            e.StaticSymbol = n;
            var t = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, a, r) {
                r = r || [];
                let u = r.length ? ".".concat(r.join(".")) : "", i = '"'.concat(s, '".').concat(a).concat(u), o = this.cache.get(i);
                return o || (o = new n(s, a, r), this.cache.set(i, o)), o;
              }
            };
            e.StaticSymbolCache = t;
          } }), Zd = Z({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = /-+([a-z0-9])/g;
            function t(l) {
              return l.replace(n, function() {
                for (var E = arguments.length, y = new Array(E), N = 0; N < E; N++)
                  y[N] = arguments[N];
                return y[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = t;
            function s(l, E) {
              return r(l, ":", E);
            }
            e.splitAtColon = s;
            function a(l, E) {
              return r(l, ".", E);
            }
            e.splitAtPeriod = a;
            function r(l, E, y) {
              let N = l.indexOf(E);
              return N == -1 ? y : [l.slice(0, N).trim(), l.slice(N + 1).trim()];
            }
            function u(l, E, y) {
              return Array.isArray(l) ? E.visitArray(l, y) : A(l) ? E.visitStringMap(l, y) : l == null || typeof l == "string" || typeof l == "number" || typeof l == "boolean" ? E.visitPrimitive(l, y) : E.visitOther(l, y);
            }
            e.visitValue = u;
            function i(l) {
              return l != null;
            }
            e.isDefined = i;
            function o(l) {
              return l === void 0 ? null : l;
            }
            e.noUndefined = o;
            var c = class {
              visitArray(l, E) {
                return l.map((y) => u(y, this, E));
              }
              visitStringMap(l, E) {
                let y = {};
                return Object.keys(l).forEach((N) => {
                  y[N] = u(l[N], this, E);
                }), y;
              }
              visitPrimitive(l, E) {
                return l;
              }
              visitOther(l, E) {
                return l;
              }
            };
            e.ValueTransformer = c, e.SyncAsync = { assertSync: (l) => {
              if (k(l))
                throw new Error("Illegal state: value cannot be a promise");
              return l;
            }, then: (l, E) => k(l) ? l.then(E) : E(l), all: (l) => l.some(k) ? Promise.all(l) : l };
            function v(l) {
              throw new Error("Internal Error: ".concat(l));
            }
            e.error = v;
            function m(l, E) {
              let y = Error(l);
              return y[d] = true, E && (y[p] = E), y;
            }
            e.syntaxError = m;
            var d = "ngSyntaxError", p = "ngParseErrors";
            function f(l) {
              return l[d];
            }
            e.isSyntaxError = f;
            function h(l) {
              return l[p] || [];
            }
            e.getParseErrors = h;
            function w(l) {
              return l.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = w;
            var T = Object.getPrototypeOf({});
            function A(l) {
              return typeof l == "object" && l !== null && Object.getPrototypeOf(l) === T;
            }
            function S(l) {
              let E = "";
              for (let y = 0; y < l.length; y++) {
                let N = l.charCodeAt(y);
                if (N >= 55296 && N <= 56319 && l.length > y + 1) {
                  let x = l.charCodeAt(y + 1);
                  x >= 56320 && x <= 57343 && (y++, N = (N - 55296 << 10) + x - 56320 + 65536);
                }
                N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));
              }
              return E;
            }
            e.utf8Encode = S;
            function B(l) {
              if (typeof l == "string")
                return l;
              if (l instanceof Array)
                return "[" + l.map(B).join(", ") + "]";
              if (l == null)
                return "" + l;
              if (l.overriddenName)
                return "".concat(l.overriddenName);
              if (l.name)
                return "".concat(l.name);
              if (!l.toString)
                return "object";
              let E = l.toString();
              if (E == null)
                return "" + E;
              let y = E.indexOf(`
`);
              return y === -1 ? E : E.substring(0, y);
            }
            e.stringify = B;
            function I(l) {
              return typeof l == "function" && l.hasOwnProperty("__forward_ref__") ? l() : l;
            }
            e.resolveForwardRef = I;
            function k(l) {
              return !!l && typeof l.then == "function";
            }
            e.isPromise = k;
            var P = class {
              constructor(l) {
                this.full = l;
                let E = l.split(".");
                this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
              }
            };
            e.Version = P;
            var C = typeof window < "u" && window, D = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, g = typeof globalThis < "u" && globalThis, F = g || C || D;
            e.global = F;
          } }), eg = Z({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Qd(), t = Zd(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function a(y) {
              return y.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = a;
            var r = 0;
            function u(y) {
              if (!y || !y.reference)
                return null;
              let N = y.reference;
              if (N instanceof n.StaticSymbol)
                return N.name;
              if (N.__anonymousType)
                return N.__anonymousType;
              let x = t.stringify(N);
              return x.indexOf("(") >= 0 ? (x = "anonymous_".concat(r++), N.__anonymousType = x) : x = a(x), x;
            }
            e.identifierName = u;
            function i(y) {
              let N = y.reference;
              return N instanceof n.StaticSymbol ? N.filePath : "./".concat(t.stringify(N));
            }
            e.identifierModuleUrl = i;
            function o(y, N) {
              return "View_".concat(u({ reference: y }), "_").concat(N);
            }
            e.viewClassName = o;
            function c(y) {
              return "RenderType_".concat(u({ reference: y }));
            }
            e.rendererTypeName = c;
            function v(y) {
              return "HostView_".concat(u({ reference: y }));
            }
            e.hostViewClassName = v;
            function m(y) {
              return "".concat(u({ reference: y }), "NgFactory");
            }
            e.componentFactoryName = m;
            var d;
            (function(y) {
              y[y.Pipe = 0] = "Pipe", y[y.Directive = 1] = "Directive", y[y.NgModule = 2] = "NgModule", y[y.Injectable = 3] = "Injectable";
            })(d = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function p(y) {
              return y.value != null ? a(y.value) : u(y.identifier);
            }
            e.tokenName = p;
            function f(y) {
              return y.identifier != null ? y.identifier.reference : y.value;
            }
            e.tokenReference = f;
            var h = class {
              constructor() {
                let { moduleUrl: y, styles: N, styleUrls: x } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = y || null, this.styles = k(N), this.styleUrls = k(x);
              }
            };
            e.CompileStylesheetMetadata = h;
            var w = class {
              constructor(y) {
                let { encapsulation: N, template: x, templateUrl: b, htmlAst: L, styles: M, styleUrls: j, externalStylesheets: $, animations: V, ngContentSelectors: q, interpolation: Y, isInline: H, preserveWhitespaces: R } = y;
                if (this.encapsulation = N, this.template = x, this.templateUrl = b, this.htmlAst = L, this.styles = k(M), this.styleUrls = k(j), this.externalStylesheets = k($), this.animations = V ? C(V) : [], this.ngContentSelectors = q || [], Y && Y.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = Y, this.isInline = H, this.preserveWhitespaces = R;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = w;
            var T = class {
              static create(y) {
                let { isHost: N, type: x, isComponent: b, selector: L, exportAs: M, changeDetection: j, inputs: $, outputs: V, host: q, providers: Y, viewProviders: H, queries: R, guards: Q, viewQueries: ee, entryComponents: te, template: oe, componentViewType: W, rendererType: X, componentFactory: ue } = y, De = {}, ie = {}, G = {};
                q != null && Object.keys(q).forEach((le) => {
                  let ge = q[le], Ae = le.match(s);
                  Ae === null ? G[le] = ge : Ae[1] != null ? ie[Ae[1]] = ge : Ae[2] != null && (De[Ae[2]] = ge);
                });
                let z = {};
                $ != null && $.forEach((le) => {
                  let ge = t.splitAtColon(le, [le, le]);
                  z[ge[0]] = ge[1];
                });
                let U = {};
                return V != null && V.forEach((le) => {
                  let ge = t.splitAtColon(le, [le, le]);
                  U[ge[0]] = ge[1];
                }), new T({ isHost: N, type: x, isComponent: !!b, selector: L, exportAs: M, changeDetection: j, inputs: z, outputs: U, hostListeners: De, hostProperties: ie, hostAttributes: G, providers: Y, viewProviders: H, queries: R, guards: Q, viewQueries: ee, entryComponents: te, template: oe, componentViewType: W, rendererType: X, componentFactory: ue });
              }
              constructor(y) {
                let { isHost: N, type: x, isComponent: b, selector: L, exportAs: M, changeDetection: j, inputs: $, outputs: V, hostListeners: q, hostProperties: Y, hostAttributes: H, providers: R, viewProviders: Q, queries: ee, guards: te, viewQueries: oe, entryComponents: W, template: X, componentViewType: ue, rendererType: De, componentFactory: ie } = y;
                this.isHost = !!N, this.type = x, this.isComponent = b, this.selector = L, this.exportAs = M, this.changeDetection = j, this.inputs = $, this.outputs = V, this.hostListeners = q, this.hostProperties = Y, this.hostAttributes = H, this.providers = k(R), this.viewProviders = k(Q), this.queries = k(ee), this.guards = te, this.viewQueries = k(oe), this.entryComponents = k(W), this.template = X, this.componentViewType = ue, this.rendererType = De, this.componentFactory = ie;
              }
              toSummary() {
                return { summaryKind: d.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = T;
            var A = class {
              constructor(y) {
                let { type: N, name: x, pure: b } = y;
                this.type = N, this.name = x, this.pure = !!b;
              }
              toSummary() {
                return { summaryKind: d.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = A;
            var S = class {
            };
            e.CompileShallowModuleMetadata = S;
            var B = class {
              constructor(y) {
                let { type: N, providers: x, declaredDirectives: b, exportedDirectives: L, declaredPipes: M, exportedPipes: j, entryComponents: $, bootstrapComponents: V, importedModules: q, exportedModules: Y, schemas: H, transitiveModule: R, id: Q } = y;
                this.type = N || null, this.declaredDirectives = k(b), this.exportedDirectives = k(L), this.declaredPipes = k(M), this.exportedPipes = k(j), this.providers = k(x), this.entryComponents = k($), this.bootstrapComponents = k(V), this.importedModules = k(q), this.exportedModules = k(Y), this.schemas = k(H), this.id = Q || null, this.transitiveModule = R || null;
              }
              toSummary() {
                let y = this.transitiveModule;
                return { summaryKind: d.NgModule, type: this.type, entryComponents: y.entryComponents, providers: y.providers, modules: y.modules, exportedDirectives: y.exportedDirectives, exportedPipes: y.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = B;
            var I = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(y, N) {
                this.providers.push({ provider: y, module: N });
              }
              addDirective(y) {
                this.directivesSet.has(y.reference) || (this.directivesSet.add(y.reference), this.directives.push(y));
              }
              addExportedDirective(y) {
                this.exportedDirectivesSet.has(y.reference) || (this.exportedDirectivesSet.add(y.reference), this.exportedDirectives.push(y));
              }
              addPipe(y) {
                this.pipesSet.has(y.reference) || (this.pipesSet.add(y.reference), this.pipes.push(y));
              }
              addExportedPipe(y) {
                this.exportedPipesSet.has(y.reference) || (this.exportedPipesSet.add(y.reference), this.exportedPipes.push(y));
              }
              addModule(y) {
                this.modulesSet.has(y.reference) || (this.modulesSet.add(y.reference), this.modules.push(y));
              }
              addEntryComponent(y) {
                this.entryComponentsSet.has(y.componentType) || (this.entryComponentsSet.add(y.componentType), this.entryComponents.push(y));
              }
            };
            e.TransitiveCompileNgModuleMetadata = I;
            function k(y) {
              return y || [];
            }
            var P = class {
              constructor(y, N) {
                let { useClass: x, useValue: b, useExisting: L, useFactory: M, deps: j, multi: $ } = N;
                this.token = y, this.useClass = x || null, this.useValue = b, this.useExisting = L, this.useFactory = M || null, this.dependencies = j || null, this.multi = !!$;
              }
            };
            e.ProviderMeta = P;
            function C(y) {
              return y.reduce((N, x) => {
                let b = Array.isArray(x) ? C(x) : x;
                return N.concat(b);
              }, []);
            }
            e.flatten = C;
            function D(y) {
              return y.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function g(y, N, x) {
              let b;
              return x.isInline ? N.type.reference instanceof n.StaticSymbol ? b = "".concat(N.type.reference.filePath, ".").concat(N.type.reference.name, ".html") : b = "".concat(u(y), "/").concat(u(N.type), ".html") : b = x.templateUrl, N.type.reference instanceof n.StaticSymbol ? b : D(b);
            }
            e.templateSourceUrl = g;
            function F(y, N) {
              let x = y.moduleUrl.split(/\/\\/g), b = x[x.length - 1];
              return D("css/".concat(N).concat(b, ".ngstyle.js"));
            }
            e.sharedStylesheetJitUrl = F;
            function l(y) {
              return D("".concat(u(y.type), "/module.ngfactory.js"));
            }
            e.ngModuleJitUrl = l;
            function E(y, N) {
              return D("".concat(u(y), "/").concat(u(N.type), ".ngfactory.js"));
            }
            e.templateJitUrl = E;
          } }), tg = Z({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Yd(), t = eg(), s = class {
              constructor(v, m, d, p) {
                this.file = v, this.offset = m, this.line = d, this.col = p;
              }
              toString() {
                return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
              }
              moveBy(v) {
                let m = this.file.content, d = m.length, p = this.offset, f = this.line, h = this.col;
                for (; p > 0 && v < 0; )
                  if (p--, v++, m.charCodeAt(p) == n.$LF) {
                    f--;
                    let T = m.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                    h = T > 0 ? p - T : p;
                  } else
                    h--;
                for (; p < d && v > 0; ) {
                  let w = m.charCodeAt(p);
                  p++, v--, w == n.$LF ? (f++, h = 0) : h++;
                }
                return new s(this.file, p, f, h);
              }
              getContext(v, m) {
                let d = this.file.content, p = this.offset;
                if (p != null) {
                  p > d.length - 1 && (p = d.length - 1);
                  let f = p, h = 0, w = 0;
                  for (; h < v && p > 0 && (p--, h++, !(d[p] == `
` && ++w == m)); )
                    ;
                  for (h = 0, w = 0; h < v && f < d.length - 1 && (f++, h++, !(d[f] == `
` && ++w == m)); )
                    ;
                  return { before: d.substring(p, this.offset), after: d.substring(this.offset, f + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var a = class {
              constructor(v, m) {
                this.content = v, this.url = m;
              }
            };
            e.ParseSourceFile = a;
            var r = class {
              constructor(v, m) {
                let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = v, this.end = m, this.details = d;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var u;
            (function(v) {
              v[v.WARNING = 0] = "WARNING", v[v.ERROR = 1] = "ERROR";
            })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var i = class {
              constructor(v, m) {
                let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                this.span = v, this.msg = m, this.level = d;
              }
              contextualMessage() {
                let v = this.span.start.getContext(100, 3);
                return v ? "".concat(this.msg, ' ("').concat(v.before, "[").concat(u[this.level], " ->]").concat(v.after, '")') : this.msg;
              }
              toString() {
                let v = this.span.details ? ", ".concat(this.span.details) : "";
                return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(v);
              }
            };
            e.ParseError = i;
            function o(v, m) {
              let d = t.identifierModuleUrl(m), p = d != null ? "in ".concat(v, " ").concat(t.identifierName(m), " in ").concat(d) : "in ".concat(v, " ").concat(t.identifierName(m)), f = new a("", p);
              return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.typeSourceSpan = o;
            function c(v, m, d) {
              let p = "in ".concat(v, " ").concat(m, " in ").concat(d), f = new a("", p);
              return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = c;
          } }), rg = Z({ "src/language-html/print-preprocess.js"(e, n) {
            "use strict";
            re();
            var { ParseSourceSpan: t } = tg(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: o, isIndentationSensitiveNode: c, isLeadingSpaceSensitiveNode: v, isTrailingSpaceSensitiveNode: m, isWhitespaceSensitiveNode: d, isVueScriptTag: p } = qt(), f = [w, T, S, I, k, D, P, C, g, B, F];
            function h(l, E) {
              for (let y of f)
                y(l, E);
              return l;
            }
            function w(l) {
              l.walk((E) => {
                if (E.type === "element" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === "text" && E.children[0].value[0] === `
`) {
                  let y = E.children[0];
                  y.value.length === 1 ? E.removeChild(y) : y.value = y.value.slice(1);
                }
              });
            }
            function T(l) {
              let E = (y) => y.type === "element" && y.prev && y.prev.type === "ieConditionalStartComment" && y.prev.sourceSpan.end.offset === y.startSourceSpan.start.offset && y.firstChild && y.firstChild.type === "ieConditionalEndComment" && y.firstChild.sourceSpan.start.offset === y.startSourceSpan.end.offset;
              l.walk((y) => {
                if (y.children)
                  for (let N = 0; N < y.children.length; N++) {
                    let x = y.children[N];
                    if (!E(x))
                      continue;
                    let b = x.prev, L = x.firstChild;
                    y.removeChild(b), N--;
                    let M = new t(b.sourceSpan.start, L.sourceSpan.end), j = new t(M.start, x.sourceSpan.end);
                    x.condition = b.condition, x.sourceSpan = j, x.startSourceSpan = M, x.removeChild(L);
                  }
              });
            }
            function A(l, E, y) {
              l.walk((N) => {
                if (N.children)
                  for (let x = 0; x < N.children.length; x++) {
                    let b = N.children[x];
                    if (b.type !== "text" && !E(b))
                      continue;
                    b.type !== "text" && (b.type = "text", b.value = y(b));
                    let L = b.prev;
                    !L || L.type !== "text" || (L.value += b.value, L.sourceSpan = new t(L.sourceSpan.start, b.sourceSpan.end), N.removeChild(b), x--);
                  }
              });
            }
            function S(l) {
              return A(l, (E) => E.type === "cdata", (E) => "<![CDATA[".concat(E.value, "]]>"));
            }
            function B(l) {
              let E = (y) => y.type === "element" && y.attrs.length === 0 && y.children.length === 1 && y.firstChild.type === "text" && !r(y.children[0].value) && !y.firstChild.hasLeadingSpaces && !y.firstChild.hasTrailingSpaces && y.isLeadingSpaceSensitive && !y.hasLeadingSpaces && y.isTrailingSpaceSensitive && !y.hasTrailingSpaces && y.prev && y.prev.type === "text" && y.next && y.next.type === "text";
              l.walk((y) => {
                if (y.children)
                  for (let N = 0; N < y.children.length; N++) {
                    let x = y.children[N];
                    if (!E(x))
                      continue;
                    let b = x.prev, L = x.next;
                    b.value += "<".concat(x.rawName, ">") + x.firstChild.value + "</".concat(x.rawName, ">") + L.value, b.sourceSpan = new t(b.sourceSpan.start, L.sourceSpan.end), b.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b.hasTrailingSpaces = L.hasTrailingSpaces, y.removeChild(x), N--, y.removeChild(L);
                  }
              });
            }
            function I(l, E) {
              if (E.parser === "html")
                return;
              let y = /{{(.+?)}}/s;
              l.walk((N) => {
                if (!!u(N))
                  for (let x of N.children) {
                    if (x.type !== "text")
                      continue;
                    let b = x.sourceSpan.start, L = null, M = x.value.split(y);
                    for (let j = 0; j < M.length; j++, b = L) {
                      let $ = M[j];
                      if (j % 2 === 0) {
                        L = b.moveBy($.length), $.length > 0 && N.insertChildBefore(x, { type: "text", value: $, sourceSpan: new t(b, L) });
                        continue;
                      }
                      L = b.moveBy($.length + 4), N.insertChildBefore(x, { type: "interpolation", sourceSpan: new t(b, L), children: $.length === 0 ? [] : [{ type: "text", value: $, sourceSpan: new t(b.moveBy(2), L.moveBy(-2)) }] });
                    }
                    N.removeChild(x);
                  }
              });
            }
            function k(l) {
              l.walk((E) => {
                if (!E.children)
                  return;
                if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === "text" && s(E.children[0].value).length === 0) {
                  E.hasDanglingSpaces = E.children.length > 0, E.children = [];
                  return;
                }
                let y = d(E), N = c(E);
                if (!y)
                  for (let x = 0; x < E.children.length; x++) {
                    let b = E.children[x];
                    if (b.type !== "text")
                      continue;
                    let { leadingWhitespace: L, text: M, trailingWhitespace: j } = a(b.value), $ = b.prev, V = b.next;
                    M ? (b.value = M, b.sourceSpan = new t(b.sourceSpan.start.moveBy(L.length), b.sourceSpan.end.moveBy(-j.length)), L && ($ && ($.hasTrailingSpaces = true), b.hasLeadingSpaces = true), j && (b.hasTrailingSpaces = true, V && (V.hasLeadingSpaces = true))) : (E.removeChild(b), x--, (L || j) && ($ && ($.hasTrailingSpaces = true), V && (V.hasLeadingSpaces = true)));
                  }
                E.isWhitespaceSensitive = y, E.isIndentationSensitive = N;
              });
            }
            function P(l) {
              l.walk((E) => {
                E.isSelfClosing = !E.children || E.type === "element" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);
              });
            }
            function C(l, E) {
              l.walk((y) => {
                y.type === "element" && (y.hasHtmComponentClosingTag = y.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset, y.endSourceSpan.end.offset)));
              });
            }
            function D(l, E) {
              l.walk((y) => {
                y.cssDisplay = i(y, E);
              });
            }
            function g(l, E) {
              l.walk((y) => {
                let { children: N } = y;
                if (!!N) {
                  if (N.length === 0) {
                    y.isDanglingSpaceSensitive = o(y);
                    return;
                  }
                  for (let x of N)
                    x.isLeadingSpaceSensitive = v(x, E), x.isTrailingSpaceSensitive = m(x, E);
                  for (let x = 0; x < N.length; x++) {
                    let b = N[x];
                    b.isLeadingSpaceSensitive = (x === 0 || b.prev.isTrailingSpaceSensitive) && b.isLeadingSpaceSensitive, b.isTrailingSpaceSensitive = (x === N.length - 1 || b.next.isLeadingSpaceSensitive) && b.isTrailingSpaceSensitive;
                  }
                }
              });
            }
            function F(l, E) {
              if (E.parser === "vue") {
                let y = l.children.find((x) => p(x, E));
                if (!y)
                  return;
                let { lang: N } = y.attrMap;
                (N === "ts" || N === "typescript") && (E.__should_parse_vue_template_with_ts = true);
              }
            }
            n.exports = h;
          } }), ng = Z({ "src/language-html/pragma.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
            }
            function s(a) {
              return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
            }
            n.exports = { hasPragma: t, insertPragma: s };
          } }), Yn = Z({ "src/language-html/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.sourceSpan.start.offset;
            }
            function s(a) {
              return a.sourceSpan.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), er = Z({ "src/language-html/print/tag.js"(e, n) {
            "use strict";
            re();
            var t = Xt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: r, line: u, softline: i, hardline: o }, utils: { replaceTextEndOfLine: c } } = Oe(), { locStart: v, locEnd: m } = Yn(), { isTextLikeNode: d, getLastDescendant: p, isPreLikeNode: f, hasPrettierIgnore: h, shouldPreserveContent: w, isVueSfcBlock: T } = qt();
            function A(q, Y) {
              return [q.isSelfClosing ? "" : S(q, Y), B(q, Y)];
            }
            function S(q, Y) {
              return q.lastChild && l(q.lastChild) ? "" : [I(q, Y), P(q, Y)];
            }
            function B(q, Y) {
              return (q.next ? g(q.next) : F(q.parent)) ? "" : [C(q, Y), k(q, Y)];
            }
            function I(q, Y) {
              return F(q) ? C(q.lastChild, Y) : "";
            }
            function k(q, Y) {
              return l(q) ? P(q.parent, Y) : E(q) ? $(q.next) : "";
            }
            function P(q, Y) {
              if (t(!q.isSelfClosing), D(q, Y))
                return "";
              switch (q.type) {
                case "ieConditionalComment":
                  return "<!";
                case "element":
                  if (q.hasHtmComponentClosingTag)
                    return "<//";
                default:
                  return "</".concat(q.rawName);
              }
            }
            function C(q, Y) {
              if (D(q, Y))
                return "";
              switch (q.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment":
                  return "[endif]-->";
                case "ieConditionalStartComment":
                  return "]><!-->";
                case "interpolation":
                  return "}}";
                case "element":
                  if (q.isSelfClosing)
                    return "/>";
                default:
                  return ">";
              }
            }
            function D(q, Y) {
              return !q.isSelfClosing && !q.endSourceSpan && (h(q) || w(q.parent, Y));
            }
            function g(q) {
              return q.prev && q.prev.type !== "docType" && !d(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
            }
            function F(q) {
              return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d(p(q.lastChild)) && !f(q);
            }
            function l(q) {
              return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d(p(q));
            }
            function E(q) {
              return q.next && !d(q.next) && d(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;
            }
            function y(q) {
              let Y = q.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
              return Y ? Y[1] ? Y[1].split(/\s+/) : true : false;
            }
            function N(q) {
              return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
            }
            function x(q, Y, H) {
              let R = q.getValue();
              if (!s(R.attrs))
                return R.isSelfClosing ? " " : "";
              let Q = R.prev && R.prev.type === "comment" && y(R.prev.value), ee = typeof Q == "boolean" ? () => Q : Array.isArray(Q) ? (De) => Q.includes(De.rawName) : () => false, te = q.map((De) => {
                let ie = De.getValue();
                return ee(ie) ? c(Y.originalText.slice(v(ie), m(ie))) : H();
              }, "attrs"), oe = R.type === "element" && R.fullName === "script" && R.attrs.length === 1 && R.attrs[0].fullName === "src" && R.children.length === 0, X = Y.singleAttributePerLine && R.attrs.length > 1 && !T(R, Y) ? o : u, ue = [a([oe ? " " : u, r(X, te)])];
              return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe ? ue.push(R.isSelfClosing ? " " : "") : ue.push(Y.bracketSameLine ? R.isSelfClosing ? " " : "" : R.isSelfClosing ? u : i), ue;
            }
            function b(q) {
              return q.firstChild && N(q.firstChild) ? "" : V(q);
            }
            function L(q, Y, H) {
              let R = q.getValue();
              return [M(R, Y), x(q, Y, H), R.isSelfClosing ? "" : b(R)];
            }
            function M(q, Y) {
              return q.prev && E(q.prev) ? "" : [j(q, Y), $(q)];
            }
            function j(q, Y) {
              return N(q) ? V(q.parent) : g(q) ? C(q.prev, Y) : "";
            }
            function $(q) {
              switch (q.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment":
                  return "<!--[if ".concat(q.condition);
                case "ieConditionalEndComment":
                  return "<!--<!";
                case "interpolation":
                  return "{{";
                case "docType":
                  return "<!DOCTYPE";
                case "element":
                  if (q.condition)
                    return "<!--[if ".concat(q.condition, "]><!--><").concat(q.rawName);
                default:
                  return "<".concat(q.rawName);
              }
            }
            function V(q) {
              switch (t(!q.isSelfClosing), q.type) {
                case "ieConditionalComment":
                  return "]>";
                case "element":
                  if (q.condition)
                    return "><!--<![endif]-->";
                default:
                  return ">";
              }
            }
            n.exports = { printClosingTag: A, printClosingTagStart: S, printClosingTagStartMarker: P, printClosingTagEndMarker: C, printClosingTagSuffix: k, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: F, needsToBorrowParentClosingTagStartMarker: l, needsToBorrowPrevClosingTagEndMarker: g, printOpeningTag: L, printOpeningTagStart: M, printOpeningTagPrefix: j, printOpeningTagStartMarker: $, printOpeningTagEndMarker: V, needsToBorrowNextOpeningTagStartMarker: E, needsToBorrowParentOpeningTagEndMarker: N };
          } }), ug = Z({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
            re(), function(t, s) {
              typeof define == "function" && define.amd ? define([], s) : typeof n == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
            }(e, function() {
              return function(t, s) {
                var a = s && s.logger || console;
                function r(P) {
                  return P === " " || P === "	" || P === `
` || P === "\f" || P === "\r";
                }
                function u(P) {
                  var C, D = P.exec(t.substring(S));
                  if (D)
                    return C = D[0], S += C.length, C;
                }
                for (var i = t.length, o = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, v = /^[^ \t\n\r\u000c]+/, m = /[,]+$/, d = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h, w, T, A, S = 0, B = []; ; ) {
                  if (u(c), S >= i)
                    return B;
                  f = u(v), h = [], f.slice(-1) === "," ? (f = f.replace(m, ""), k()) : I();
                }
                function I() {
                  for (u(o), w = "", T = "in descriptor"; ; ) {
                    if (A = t.charAt(S), T === "in descriptor")
                      if (r(A))
                        w && (h.push(w), w = "", T = "after descriptor");
                      else if (A === ",") {
                        S += 1, w && h.push(w), k();
                        return;
                      } else if (A === "(")
                        w = w + A, T = "in parens";
                      else if (A === "") {
                        w && h.push(w), k();
                        return;
                      } else
                        w = w + A;
                    else if (T === "in parens")
                      if (A === ")")
                        w = w + A, T = "in descriptor";
                      else if (A === "") {
                        h.push(w), k();
                        return;
                      } else
                        w = w + A;
                    else if (T === "after descriptor" && !r(A))
                      if (A === "") {
                        k();
                        return;
                      } else
                        T = "in descriptor", S -= 1;
                    S += 1;
                  }
                }
                function k() {
                  var P = false, C, D, g, F, l = {}, E, y, N, x, b;
                  for (F = 0; F < h.length; F++)
                    E = h[F], y = E[E.length - 1], N = E.substring(0, E.length - 1), x = parseInt(N, 10), b = parseFloat(N), d.test(N) && y === "w" ? ((C || D) && (P = true), x === 0 ? P = true : C = x) : p.test(N) && y === "x" ? ((C || D || g) && (P = true), b < 0 ? P = true : D = b) : d.test(N) && y === "h" ? ((g || D) && (P = true), x === 0 ? P = true : g = x) : P = true;
                  P ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + E + "'.") : (l.url = f, C && (l.w = C), D && (l.d = D), g && (l.h = g), B.push(l));
                }
              };
            });
          } }), sg = Z({ "src/language-html/syntax-attribute.js"(e, n) {
            "use strict";
            re();
            var t = ug(), { builders: { ifBreak: s, join: a, line: r } } = Oe();
            function u(o) {
              let c = t(o, { logger: { error(I) {
                throw new Error(I);
              } } }), v = c.some((I) => {
                let { w: k } = I;
                return k;
              }), m = c.some((I) => {
                let { h: k } = I;
                return k;
              }), d = c.some((I) => {
                let { d: k } = I;
                return k;
              });
              if (v + m + d > 1)
                throw new Error("Mixed descriptor in srcset is not supported");
              let p = v ? "w" : m ? "h" : "d", f = v ? "w" : m ? "h" : "x", h = (I) => Math.max(...I), w = c.map((I) => I.url), T = h(w.map((I) => I.length)), A = c.map((I) => I[p]).map((I) => I ? I.toString() : ""), S = A.map((I) => {
                let k = I.indexOf(".");
                return k === -1 ? I.length : k;
              }), B = h(S);
              return a([",", r], w.map((I, k) => {
                let P = [I], C = A[k];
                if (C) {
                  let D = T - I.length + 1, g = B - S[k], F = " ".repeat(D + g);
                  P.push(s(F, " "), C + f);
                }
                return P;
              }));
            }
            function i(o) {
              return o.trim().split(/\s+/).join(" ");
            }
            n.exports = { printImgSrcset: u, printClassNames: i };
          } }), ig = Z({ "src/language-html/syntax-vue.js"(e, n) {
            "use strict";
            re();
            var { builders: { group: t } } = Oe();
            function s(i, o) {
              let { left: c, operator: v, right: m } = a(i);
              return [t(o("function _(".concat(c, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", v, " ", o(m, { parser: "__js_expression" }, { stripTrailingHardline: true })];
            }
            function a(i) {
              let o = /(.*?)\s+(in|of)\s+(.*)/s, c = /,([^,\]}]*)(?:,([^,\]}]*))?$/, v = /^\(|\)$/g, m = i.match(o);
              if (!m)
                return;
              let d = {};
              if (d.for = m[3].trim(), !d.for)
                return;
              let p = m[1].trim().replace(v, ""), f = p.match(c);
              f ? (d.alias = p.replace(c, ""), d.iterator1 = f[1].trim(), f[2] && (d.iterator2 = f[2].trim())) : d.alias = p;
              let h = [d.alias, d.iterator1, d.iterator2];
              if (!h.some((w, T) => !w && (T === 0 || h.slice(T + 1).some(Boolean))))
                return { left: h.filter(Boolean).join(","), operator: m[2], right: d.for };
            }
            function r(i, o) {
              return o("function _(".concat(i, ") {}"), { parser: "babel", __isVueBindings: true });
            }
            function u(i) {
              let o = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, v = i.trim();
              return o.test(v) || c.test(v);
            }
            n.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: r };
          } }), ho = Z({ "src/language-html/get-node-content.js"(e, n) {
            "use strict";
            re();
            var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = er();
            function o(c, v) {
              let m = c.startSourceSpan.end.offset;
              c.firstChild && u(c.firstChild) && (m -= i(c).length);
              let d = c.endSourceSpan.start.offset;
              return c.lastChild && t(c.lastChild) ? d += s(c, v).length : a(c) && (d -= r(c.lastChild, v).length), v.originalText.slice(m, d);
            }
            n.exports = o;
          } }), ag = Z({ "src/language-html/embed.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, group: s, hardline: a, indent: r, line: u, fill: i, softline: o }, utils: { mapDoc: c, replaceTextEndOfLine: v } } = Oe(), m = Xn(), { printClosingTag: d, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: h, printOpeningTag: w } = er(), { printImgSrcset: T, printClassNames: A } = sg(), { printVueFor: S, printVueBindings: B, isVueEventBindingExpression: I } = ig(), { isScriptLikeTag: k, isVueNonHtmlBlock: P, inferScriptParser: C, htmlTrimPreserveIndentation: D, dedentString: g, unescapeQuoteEntities: F, isVueSlotAttribute: l, isVueSfcBindingsAttribute: E, getTextValueParts: y } = qt(), N = ho();
            function x(L, M, j) {
              let $ = (te) => new RegExp(te.join("|")).test(L.fullName), V = () => F(L.value), q = false, Y = (te, oe) => {
                let W = te.type === "NGRoot" ? te.node.type === "NGMicrosyntax" && te.node.body.length === 1 && te.node.body[0].type === "NGMicrosyntaxExpression" ? te.node.body[0].expression : te.node : te.type === "JsExpressionRoot" ? te.node : te;
                W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || oe.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (q = true);
              }, H = (te) => s(te), R = function(te) {
                let oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return s([r([o, te]), oe ? o : ""]);
              }, Q = (te) => q ? H(te) : R(te), ee = (te, oe) => M(te, Object.assign({ __onHtmlBindingRoot: Y, __embeddedInHtml: true }, oe));
              if (L.fullName === "srcset" && (L.parent.fullName === "img" || L.parent.fullName === "source"))
                return R(T(V()));
              if (L.fullName === "class" && !j.parentParser) {
                let te = V();
                if (!te.includes("{{"))
                  return A(te);
              }
              if (L.fullName === "style" && !j.parentParser) {
                let te = V();
                if (!te.includes("{{"))
                  return R(ee(te, { parser: "css", __isHTMLStyleAttribute: true }));
              }
              if (j.parser === "vue") {
                if (L.fullName === "v-for")
                  return S(V(), ee);
                if (l(L) || E(L, j))
                  return B(V(), ee);
                let te = ["^@", "^v-on:"], oe = ["^:", "^v-bind:"], W = ["^v-"];
                if ($(te)) {
                  let X = V(), ue = I(X) ? "__js_expression" : j.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                  return Q(ee(X, { parser: ue }));
                }
                if ($(oe))
                  return Q(ee(V(), { parser: "__vue_expression" }));
                if ($(W))
                  return Q(ee(V(), { parser: "__js_expression" }));
              }
              if (j.parser === "angular") {
                let te = (G, z) => ee(G, Object.assign(Object.assign({}, z), {}, { trailingComma: "none" })), oe = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], X = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], ue = ["^i18n(-.+)?$"];
                if ($(W))
                  return Q(te(V(), { parser: "__ng_action" }));
                if ($(X))
                  return Q(te(V(), { parser: "__ng_binding" }));
                if ($(ue)) {
                  let G = V().trim();
                  return R(i(y(L, G)), !G.includes("@@"));
                }
                if ($(oe))
                  return Q(te(V(), { parser: "__ng_directive" }));
                let De = /{{(.+?)}}/s, ie = V();
                if (De.test(ie)) {
                  let G = [];
                  for (let [z, U] of ie.split(De).entries())
                    if (z % 2 === 0)
                      G.push(v(U));
                    else
                      try {
                        G.push(s(["{{", r([u, te(U, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                      } catch {
                        G.push("{{", v(U), "}}");
                      }
                  return s(G);
                }
              }
              return null;
            }
            function b(L, M, j, $) {
              let V = L.getValue();
              switch (V.type) {
                case "element": {
                  if (k(V) || V.type === "interpolation")
                    return;
                  if (!V.isSelfClosing && P(V, $)) {
                    let q = C(V, $);
                    if (!q)
                      return;
                    let Y = N(V, $), H = /^\s*$/.test(Y), R = "";
                    return H || (R = j(D(Y), { parser: q, __embeddedInHtml: true }, { stripTrailingHardline: true }), H = R === ""), [h(V, $), s(w(L, $, M)), H ? "" : a, R, H ? "" : a, d(V, $), p(V, $)];
                  }
                  break;
                }
                case "text": {
                  if (k(V.parent)) {
                    let q = C(V.parent, $);
                    if (q) {
                      let Y = q === "markdown" ? g(V.value.replace(/^[^\S\n]*\n/, "")) : V.value, H = { parser: q, __embeddedInHtml: true };
                      if ($.parser === "html" && q === "babel") {
                        let R = "script", { attrMap: Q } = V.parent;
                        Q && (Q.type === "module" || Q.type === "text/babel" && Q["data-type"] === "module") && (R = "module"), H.__babelSourceType = R;
                      }
                      return [t, h(V, $), j(Y, H, { stripTrailingHardline: true }), p(V, $)];
                    }
                  } else if (V.parent.type === "interpolation") {
                    let q = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                    return $.parser === "angular" ? (q.parser = "__ng_interpolation", q.trailingComma = "none") : $.parser === "vue" ? q.parser = $.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : q.parser = "__js_expression", [r([u, j(V.value, q, { stripTrailingHardline: true })]), V.parent.next && f(V.parent.next) ? " " : u];
                  }
                  break;
                }
                case "attribute": {
                  if (!V.value)
                    break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
                    return [V.rawName, "=", V.value];
                  if ($.parser === "lwc" && /^{.*}$/s.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
                    return [V.rawName, "=", V.value];
                  let q = x(V, (Y, H) => j(Y, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, H), { stripTrailingHardline: true }), $);
                  if (q)
                    return [V.rawName, '="', s(c(q, (Y) => typeof Y == "string" ? Y.replace(/"/g, "&quot;") : Y)), '"'];
                  break;
                }
                case "front-matter":
                  return m(V, j);
              }
            }
            n.exports = b;
          } }), vo = Z({ "src/language-html/print/children.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, group: s, ifBreak: a, line: r, softline: u, hardline: i }, utils: { replaceTextEndOfLine: o } } = Oe(), { locStart: c, locEnd: v } = Yn(), { forceBreakChildren: m, forceNextEmptyLine: d, isTextLikeNode: p, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: h } = qt(), { printOpeningTagPrefix: w, needsToBorrowNextOpeningTagStartMarker: T, printOpeningTagStartMarker: A, needsToBorrowPrevClosingTagEndMarker: S, printClosingTagEndMarker: B, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: k } = er();
            function P(g, F, l) {
              let E = g.getValue();
              return f(E) ? [w(E, F), ...o(F.originalText.slice(c(E) + (E.prev && T(E.prev) ? A(E).length : 0), v(E) - (E.next && S(E.next) ? B(E, F).length : 0))), I(E, F)] : l();
            }
            function C(g, F) {
              return p(g) && p(F) ? g.isTrailingSpaceSensitive ? g.hasTrailingSpaces ? h(F) ? i : r : "" : h(F) ? i : u : T(g) && (f(F) || F.firstChild || F.isSelfClosing || F.type === "element" && F.attrs.length > 0) || g.type === "element" && g.isSelfClosing && S(F) ? "" : !F.isLeadingSpaceSensitive || h(F) || S(F) && g.lastChild && k(g.lastChild) && g.lastChild.lastChild && k(g.lastChild.lastChild) ? i : F.hasLeadingSpaces ? r : u;
            }
            function D(g, F, l) {
              let E = g.getValue();
              if (m(E))
                return [t, ...g.map((N) => {
                  let x = N.getValue(), b = x.prev ? C(x.prev, x) : "";
                  return [b ? [b, d(x.prev) ? i : ""] : "", P(N, F, l)];
                }, "children")];
              let y = E.children.map(() => Symbol(""));
              return g.map((N, x) => {
                let b = N.getValue();
                if (p(b)) {
                  if (b.prev && p(b.prev)) {
                    let Y = C(b.prev, b);
                    if (Y)
                      return d(b.prev) ? [i, i, P(N, F, l)] : [Y, P(N, F, l)];
                  }
                  return P(N, F, l);
                }
                let L = [], M = [], j = [], $ = [], V = b.prev ? C(b.prev, b) : "", q = b.next ? C(b, b.next) : "";
                return V && (d(b.prev) ? L.push(i, i) : V === i ? L.push(i) : p(b.prev) ? M.push(V) : M.push(a("", u, { groupId: y[x - 1] }))), q && (d(b) ? p(b.next) && $.push(i, i) : q === i ? p(b.next) && $.push(i) : j.push(q)), [...L, s([...M, s([P(N, F, l), ...j], { id: y[x] })]), ...$];
              }, "children");
            }
            n.exports = { printChildren: D };
          } }), og = Z({ "src/language-html/print/element.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: r, indentIfBreak: u, indent: i, line: o, softline: c }, utils: { replaceTextEndOfLine: v } } = Oe(), m = ho(), { shouldPreserveContent: d, isScriptLikeTag: p, isVueCustomBlock: f, countParents: h, forceBreakContent: w } = qt(), { printOpeningTagPrefix: T, printOpeningTag: A, printClosingTagSuffix: S, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: k } = er(), { printChildren: P } = vo();
            function C(D, g, F) {
              let l = D.getValue();
              if (d(l, g))
                return [T(l, g), a(A(D, g, F)), ...v(m(l, g)), ...B(l, g), S(l, g)];
              let E = l.children.length === 1 && l.firstChild.type === "interpolation" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces, y = Symbol("element-attr-group-id"), N = (M) => a([a(A(D, g, F), { id: y }), M, B(l, g)]), x = (M) => E ? u(M, { groupId: y }) : (p(l) || f(l, g)) && l.parent.type === "root" && g.parser === "vue" && !g.vueIndentScriptAndStyle ? M : i(M), b = () => E ? r(c, "", { groupId: y }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s(c) : c, L = () => (l.next ? I(l.next) : k(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? " " : "" : E ? r(c, "", { groupId: y }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === "comment" || l.lastChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(g.tabWidth * h(D, (j) => j.parent && j.parent.type !== "root"), "}$")).test(l.lastChild.value) ? "" : c;
              return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : "") : N([w(l) ? t : "", x([b(), P(D, g, F)]), L()]);
            }
            n.exports = { printElement: C };
          } }), lg = Z({ "src/language-html/printer-html.js"(e, n) {
            "use strict";
            re();
            var { builders: { fill: t, group: s, hardline: a, literalline: r }, utils: { cleanDoc: u, getDocParts: i, isConcat: o, replaceTextEndOfLine: c } } = Oe(), v = zd(), { countChars: m, unescapeQuoteEntities: d, getTextValueParts: p } = qt(), f = rg(), { insertPragma: h } = ng(), { locStart: w, locEnd: T } = Yn(), A = ag(), { printClosingTagSuffix: S, printClosingTagEnd: B, printOpeningTagPrefix: I, printOpeningTagStart: k } = er(), { printElement: P } = og(), { printChildren: C } = vo();
            function D(g, F, l) {
              let E = g.getValue();
              switch (E.type) {
                case "front-matter":
                  return c(E.raw);
                case "root":
                  return F.__onHtmlRoot && F.__onHtmlRoot(E), [s(C(g, F, l)), a];
                case "element":
                case "ieConditionalComment":
                  return P(g, F, l);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                  return [k(E), B(E)];
                case "interpolation":
                  return [k(E, F), ...g.map(l, "children"), B(E, F)];
                case "text": {
                  if (E.parent.type === "interpolation") {
                    let N = /\n[^\S\n]*$/, x = N.test(E.value), b = x ? E.value.replace(N, "") : E.value;
                    return [...c(b), x ? a : ""];
                  }
                  let y = u([I(E, F), ...p(E), S(E, F)]);
                  return o(y) || y.type === "fill" ? t(i(y)) : y;
                }
                case "docType":
                  return [s([k(E, F), " ", E.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(E, F)];
                case "comment":
                  return [I(E, F), ...c(F.originalText.slice(w(E), T(E)), r), S(E, F)];
                case "attribute": {
                  if (E.value === null)
                    return E.rawName;
                  let y = d(E.value), N = m(y, "'"), x = m(y, '"'), b = N < x ? "'" : '"';
                  return [E.rawName, "=", b, ...c(b === '"' ? y.replace(/"/g, "&quot;") : y.replace(/'/g, "&apos;")), b];
                }
                default:
                  throw new Error("Unexpected node type ".concat(E.type));
              }
            }
            n.exports = { preprocess: f, print: D, insertPragma: h, massageAstNode: v, embed: A };
          } }), cg = Z({ "src/language-html/options.js"(e, n) {
            "use strict";
            re();
            var t = Ot(), s = "HTML";
            n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
          } }), pg = Z({ "src/language-html/parsers.js"() {
            re();
          } }), xn = Z({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
            n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
          } }), fg = Z({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
            n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
          } }), Dg = Z({ "src/language-html/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = lg(), a = cg(), r = pg(), u = [t(xn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(xn(), (o) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...o.extensions, ".mjml"] })), t(xn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(fg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
            n.exports = { languages: u, printers: i, options: a, parsers: r };
          } }), mg = Z({ "src/language-yaml/pragma.js"(e, n) {
            "use strict";
            re();
            function t(r) {
              return /^\s*@(?:prettier|format)\s*$/.test(r);
            }
            function s(r) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
            }
            function a(r) {
              return `# @format

`.concat(r);
            }
            n.exports = { isPragma: t, hasPragma: s, insertPragma: a };
          } }), dg = Z({ "src/language-yaml/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), gg = Z({ "src/language-yaml/embed.js"(e, n) {
            "use strict";
            re();
            function t(s, a, r, u) {
              if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath))
                return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
            }
            n.exports = t;
          } }), Mt = Z({ "src/language-yaml/utils.js"(e, n) {
            "use strict";
            re();
            var { getLast: t, isNonEmptyArray: s } = Ue();
            function a(C, D) {
              let g = 0, F = C.stack.length - 1;
              for (let l = 0; l < F; l++) {
                let E = C.stack[l];
                r(E) && D(E) && g++;
              }
              return g;
            }
            function r(C, D) {
              return C && typeof C.type == "string" && (!D || D.includes(C.type));
            }
            function u(C, D, g) {
              return D("children" in C ? Object.assign(Object.assign({}, C), {}, { children: C.children.map((F) => u(F, D, C)) }) : C, g);
            }
            function i(C, D, g) {
              Object.defineProperty(C, D, { get: g, enumerable: false });
            }
            function o(C, D) {
              let g = 0, F = D.length;
              for (let l = C.position.end.offset - 1; l < F; l++) {
                let E = D[l];
                if (E === `
` && g++, g === 1 && /\S/.test(E))
                  return false;
                if (g === 2)
                  return true;
              }
              return false;
            }
            function c(C) {
              switch (C.getValue().type) {
                case "tag":
                case "anchor":
                case "comment":
                  return false;
              }
              let g = C.stack.length;
              for (let F = 1; F < g; F++) {
                let l = C.stack[F], E = C.stack[F - 1];
                if (Array.isArray(E) && typeof l == "number" && l !== E.length - 1)
                  return false;
              }
              return true;
            }
            function v(C) {
              return s(C.children) ? v(t(C.children)) : C;
            }
            function m(C) {
              return C.value.trim() === "prettier-ignore";
            }
            function d(C) {
              let D = C.getValue();
              if (D.type === "documentBody") {
                let g = C.getParentNode();
                return S(g.head) && m(t(g.head.endComments));
              }
              return h(D) && m(t(D.leadingComments));
            }
            function p(C) {
              return !s(C.children) && !f(C);
            }
            function f(C) {
              return h(C) || w(C) || T(C) || A(C) || S(C);
            }
            function h(C) {
              return s(C == null ? void 0 : C.leadingComments);
            }
            function w(C) {
              return s(C == null ? void 0 : C.middleComments);
            }
            function T(C) {
              return C == null ? void 0 : C.indicatorComment;
            }
            function A(C) {
              return C == null ? void 0 : C.trailingComment;
            }
            function S(C) {
              return s(C == null ? void 0 : C.endComments);
            }
            function B(C) {
              let D = [], g;
              for (let F of C.split(/( +)/))
                F !== " " ? g === " " ? D.push(F) : D.push((D.pop() || "") + F) : g === void 0 && D.unshift(""), g = F;
              return g === " " && D.push((D.pop() || "") + " "), D[0] === "" && (D.shift(), D.unshift(" " + (D.shift() || ""))), D;
            }
            function I(C, D, g) {
              let F = D.split(`
`).map((l, E, y) => E === 0 && E === y.length - 1 ? l : E !== 0 && E !== y.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart());
              return g.proseWrap === "preserve" ? F.map((l) => l.length === 0 ? [] : [l]) : F.map((l) => l.length === 0 ? [] : B(l)).reduce((l, E, y) => y !== 0 && F[y - 1].length > 0 && E.length > 0 && !(C === "quoteDouble" && t(t(l)).endsWith("\\")) ? [...l.slice(0, -1), [...t(l), ...E]] : [...l, E], []).map((l) => g.proseWrap === "never" ? [l.join(" ")] : l);
            }
            function k(C, D) {
              let { parentIndent: g, isLastDescendant: F, options: l } = D, E = C.position.start.line === C.position.end.line ? "" : l.originalText.slice(C.position.start.offset, C.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], y;
              if (C.indent === null) {
                let b = E.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                y = b ? b.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
              } else
                y = C.indent - 1 + g;
              let N = E.split(`
`).map((b) => b.slice(y));
              if (l.proseWrap === "preserve" || C.type === "blockLiteral")
                return x(N.map((b) => b.length === 0 ? [] : [b]));
              return x(N.map((b) => b.length === 0 ? [] : B(b)).reduce((b, L, M) => M !== 0 && N[M - 1].length > 0 && L.length > 0 && !/^\s/.test(L[0]) && !/^\s|\s$/.test(t(b)) ? [...b.slice(0, -1), [...t(b), ...L]] : [...b, L], []).map((b) => b.reduce((L, M) => L.length > 0 && /\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + " " + M] : [...L, M], [])).map((b) => l.proseWrap === "never" ? [b.join(" ")] : b));
              function x(b) {
                if (C.chomping === "keep")
                  return t(b).length === 0 ? b.slice(0, -1) : b;
                let L = 0;
                for (let M = b.length - 1; M >= 0 && b[M].length === 0; M--)
                  L++;
                return L === 0 ? b : L >= 2 && !F ? b.slice(0, -(L - 1)) : b.slice(0, -L);
              }
            }
            function P(C) {
              if (!C)
                return true;
              switch (C.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = { getLast: t, getAncestorCount: a, isNode: r, isEmptyNode: p, isInlineNode: P, mapNode: u, defineShortcut: i, isNextLineEmpty: o, isLastDescendantNode: c, getBlockValueLineContents: k, getFlowScalarLineContents: I, getLastDescendantNode: v, hasPrettierIgnore: d, hasLeadingComments: h, hasMiddleComments: w, hasIndicatorComment: T, hasTrailingComment: A, hasEndComments: S };
          } }), yg = Z({ "src/language-yaml/print-preprocess.js"(e, n) {
            "use strict";
            re();
            var { defineShortcut: t, mapNode: s } = Mt();
            function a(u) {
              return s(u, r);
            }
            function r(u) {
              switch (u.type) {
                case "document":
                  t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                  break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                  t(u, "content", () => u.children[0]);
                  break;
                case "mappingItem":
                case "flowMappingItem":
                  t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                  break;
              }
              return u;
            }
            n.exports = a;
          } }), jr = Z({ "src/language-yaml/print/misc.js"(e, n) {
            "use strict";
            re();
            var { builders: { softline: t, align: s } } = Oe(), { hasEndComments: a, isNextLineEmpty: r, isNode: u } = Mt(), i = /* @__PURE__ */ new WeakMap();
            function o(m, d) {
              let p = m.getValue(), f = m.stack[0], h;
              return i.has(f) ? h = i.get(f) : (h = /* @__PURE__ */ new Set(), i.set(f, h)), !h.has(p.position.end.line) && (h.add(p.position.end.line), r(p, d) && !c(m.getParentNode())) ? t : "";
            }
            function c(m) {
              return a(m) && !u(m, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
            }
            function v(m, d) {
              return s(" ".repeat(m), d);
            }
            n.exports = { alignWithSpaces: v, shouldPrintEndComments: c, printNextEmptyLine: o };
          } }), hg = Z({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
            "use strict";
            re();
            var { builders: { ifBreak: t, line: s, softline: a, hardline: r, join: u } } = Oe(), { isEmptyNode: i, getLast: o, hasEndComments: c } = Mt(), { printNextEmptyLine: v, alignWithSpaces: m } = jr();
            function d(f, h, w) {
              let T = f.getValue(), A = T.type === "flowMapping", S = A ? "{" : "[", B = A ? "}" : "]", I = a;
              A && T.children.length > 0 && w.bracketSpacing && (I = s);
              let k = o(T.children), P = k && k.type === "flowMappingItem" && i(k.key) && i(k.value);
              return [S, m(w.tabWidth, [I, p(f, h, w), w.trailingComma === "none" ? "" : t(","), c(T) ? [r, u(r, f.map(h, "endComments"))] : ""]), P ? "" : I, B];
            }
            function p(f, h, w) {
              let T = f.getValue();
              return f.map((S, B) => [h(), B === T.children.length - 1 ? "" : [",", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? v(S, w.originalText) : ""]], "children");
            }
            n.exports = { printFlowMapping: d, printFlowSequence: d };
          } }), vg = Z({ "src/language-yaml/print/mapping-item.js"(e, n) {
            "use strict";
            re();
            var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: r, join: u, line: i } } = Oe(), { hasLeadingComments: o, hasMiddleComments: c, hasTrailingComment: v, hasEndComments: m, isNode: d, isEmptyNode: p, isInlineNode: f } = Mt(), { alignWithSpaces: h } = jr();
            function w(B, I, k, P, C) {
              let { key: D, value: g } = B, F = p(D), l = p(g);
              if (F && l)
                return ": ";
              let E = P("key"), y = A(B) ? " " : "";
              if (l)
                return B.type === "flowMappingItem" && I.type === "flowMapping" ? E : B.type === "mappingItem" && T(D.content, C) && !v(D.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [E, y, ":"] : ["? ", h(2, E)];
              let N = P("value");
              if (F)
                return [": ", h(2, N)];
              if (o(g) || !f(D.content))
                return ["? ", h(2, E), a, u("", k.map(P, "value", "leadingComments").map(($) => [$, a])), ": ", h(2, N)];
              if (S(D.content) && !o(D.content) && !c(D.content) && !v(D.content) && !m(D) && !o(g.content) && !c(g.content) && !m(g) && T(g.content, C))
                return [E, y, ": ", N];
              let x = Symbol("mappingKey"), b = s([r("? "), s(h(2, E), { id: x })]), L = [a, ": ", h(2, N)], M = [y, ":"];
              o(g.content) || m(g) && g.content && !d(g.content, ["mapping", "sequence"]) || I.type === "mapping" && v(D.content) && f(g.content) || d(g.content, ["mapping", "sequence"]) && g.content.tag === null && g.content.anchor === null ? M.push(a) : g.content && M.push(i), M.push(N);
              let j = h(C.tabWidth, M);
              return T(D.content, C) && !o(D.content) && !c(D.content) && !m(D) ? t([[E, j]]) : t([[b, r(L, j, { groupId: x })]]);
            }
            function T(B, I) {
              if (!B)
                return true;
              switch (B.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble":
                  break;
                case "alias":
                  return true;
                default:
                  return false;
              }
              if (I.proseWrap === "preserve")
                return B.position.start.line === B.position.end.line;
              if (/\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset)))
                return false;
              switch (I.proseWrap) {
                case "never":
                  return !B.value.includes(`
`);
                case "always":
                  return !/[\n ]/.test(B.value);
                default:
                  return false;
              }
            }
            function A(B) {
              return B.key.content && B.key.content.type === "alias";
            }
            function S(B) {
              if (!B)
                return true;
              switch (B.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return B.position.start.line === B.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = w;
          } }), Cg = Z({ "src/language-yaml/print/block.js"(e, n) {
            "use strict";
            re();
            var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: r, join: u, line: i, literalline: o, markAsRoot: c }, utils: { getDocParts: v } } = Oe(), { getAncestorCount: m, getBlockValueLineContents: d, hasIndicatorComment: p, isLastDescendantNode: f, isNode: h } = Mt(), { alignWithSpaces: w } = jr();
            function T(A, S, B) {
              let I = A.getValue(), k = m(A, (F) => h(F, ["sequence", "mapping"])), P = f(A), C = [I.type === "blockFolded" ? ">" : "|"];
              I.indent !== null && C.push(I.indent.toString()), I.chomping !== "clip" && C.push(I.chomping === "keep" ? "+" : "-"), p(I) && C.push(" ", S("indicatorComment"));
              let D = d(I, { parentIndent: k, isLastDescendant: P, options: B }), g = [];
              for (let [F, l] of D.entries())
                F === 0 && g.push(r), g.push(a(v(u(i, l)))), F !== D.length - 1 ? g.push(l.length === 0 ? r : c(o)) : I.chomping === "keep" && P && g.push(s(l.length === 0 ? r : o));
              return I.indent === null ? C.push(t(w(B.tabWidth, g))) : C.push(s(w(I.indent - 1 + k, g))), C;
            }
            n.exports = T;
          } }), Eg = Z({ "src/language-yaml/printer-yaml.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, fill: s, group: a, hardline: r, join: u, line: i, lineSuffix: o, literalline: c }, utils: { getDocParts: v, replaceTextEndOfLine: m } } = Oe(), { isPreviousLineEmpty: d } = Ue(), { insertPragma: p, isPragma: f } = mg(), { locStart: h } = dg(), w = gg(), { getFlowScalarLineContents: T, getLastDescendantNode: A, hasLeadingComments: S, hasMiddleComments: B, hasTrailingComment: I, hasEndComments: k, hasPrettierIgnore: P, isLastDescendantNode: C, isNode: D, isInlineNode: g } = Mt(), F = yg(), { alignWithSpaces: l, printNextEmptyLine: E, shouldPrintEndComments: y } = jr(), { printFlowMapping: N, printFlowSequence: x } = hg(), b = vg(), L = Cg();
            function M(R, Q, ee) {
              let te = R.getValue(), oe = [];
              te.type !== "mappingValue" && S(te) && oe.push([u(r, R.map(ee, "leadingComments")), r]);
              let { tag: W, anchor: X } = te;
              W && oe.push(ee("tag")), W && X && oe.push(" "), X && oe.push(ee("anchor"));
              let ue = "";
              D(te, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !C(R) && (ue = E(R, Q.originalText)), (W || X) && (D(te, ["sequence", "mapping"]) && !B(te) ? oe.push(r) : oe.push(" ")), B(te) && oe.push([te.middleComments.length === 1 ? "" : r, u(r, R.map(ee, "middleComments")), r]);
              let De = R.getParentNode();
              return P(R) ? oe.push(m(Q.originalText.slice(te.position.start.offset, te.position.end.offset).trimEnd(), c)) : oe.push(a(j(te, De, R, Q, ee))), I(te) && !D(te, ["document", "documentHead"]) && oe.push(o([te.type === "mappingValue" && !te.content ? "" : " ", De.type === "mappingKey" && R.getParentNode(2).type === "mapping" && g(te) ? "" : t, ee("trailingComment")])), y(te) && oe.push(l(te.type === "sequenceItem" ? 2 : 0, [r, u(r, R.map((ie) => [d(Q.originalText, ie.getValue(), h) ? r : "", ee()], "endComments"))])), oe.push(ue), oe;
            }
            function j(R, Q, ee, te, oe) {
              switch (R.type) {
                case "root": {
                  let { children: W } = R, X = [];
                  ee.each((De, ie) => {
                    let G = W[ie], z = W[ie + 1];
                    ie !== 0 && X.push(r), X.push(oe()), V(G, z) ? (X.push(r, "..."), I(G) && X.push(" ", oe("trailingComment"))) : z && !I(z.head) && X.push(r, "---");
                  }, "children");
                  let ue = A(R);
                  return (!D(ue, ["blockLiteral", "blockFolded"]) || ue.chomping !== "keep") && X.push(r), X;
                }
                case "document": {
                  let W = Q.children[ee.getName() + 1], X = [];
                  return q(R, W, Q, te) === "head" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && X.push(oe("head")), I(R.head) ? X.push(["---", " ", oe(["head", "trailingComment"])]) : X.push("---")), $(R) && X.push(oe("body")), u(r, X);
                }
                case "documentHead":
                  return u(r, [...ee.map(oe, "children"), ...ee.map(oe, "endComments")]);
                case "documentBody": {
                  let { children: W, endComments: X } = R, ue = "";
                  if (W.length > 0 && X.length > 0) {
                    let De = A(R);
                    D(De, ["blockFolded", "blockLiteral"]) ? De.chomping !== "keep" && (ue = [r, r]) : ue = r;
                  }
                  return [u(r, ee.map(oe, "children")), ue, u(r, ee.map(oe, "endComments"))];
                }
                case "directive":
                  return ["%", u(" ", [R.name, ...R.parameters])];
                case "comment":
                  return ["#", R.value];
                case "alias":
                  return ["*", R.value];
                case "tag":
                  return te.originalText.slice(R.position.start.offset, R.position.end.offset);
                case "anchor":
                  return ["&", R.value];
                case "plain":
                  return Y(R.type, te.originalText.slice(R.position.start.offset, R.position.end.offset), te);
                case "quoteDouble":
                case "quoteSingle": {
                  let W = "'", X = '"', ue = te.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);
                  if (R.type === "quoteSingle" && ue.includes("\\") || R.type === "quoteDouble" && /\\[^"]/.test(ue)) {
                    let ie = R.type === "quoteDouble" ? X : W;
                    return [ie, Y(R.type, ue, te), ie];
                  }
                  if (ue.includes(X))
                    return [W, Y(R.type, R.type === "quoteDouble" ? ue.replace(/\\"/g, X).replace(/'/g, W.repeat(2)) : ue, te), W];
                  if (ue.includes(W))
                    return [X, Y(R.type, R.type === "quoteSingle" ? ue.replace(/''/g, W) : ue, te), X];
                  let De = te.singleQuote ? W : X;
                  return [De, Y(R.type, ue, te), De];
                }
                case "blockFolded":
                case "blockLiteral":
                  return L(ee, oe, te);
                case "mapping":
                case "sequence":
                  return u(r, ee.map(oe, "children"));
                case "sequenceItem":
                  return ["- ", l(2, R.content ? oe("content") : "")];
                case "mappingKey":
                case "mappingValue":
                  return R.content ? oe("content") : "";
                case "mappingItem":
                case "flowMappingItem":
                  return b(R, Q, ee, oe, te);
                case "flowMapping":
                  return N(ee, oe, te);
                case "flowSequence":
                  return x(ee, oe, te);
                case "flowSequenceItem":
                  return oe("content");
                default:
                  throw new Error("Unexpected node type ".concat(R.type));
              }
            }
            function $(R) {
              return R.body.children.length > 0 || k(R.body);
            }
            function V(R, Q) {
              return I(R) || Q && (Q.head.children.length > 0 || k(Q.head));
            }
            function q(R, Q, ee, te) {
              return ee.children[0] === R && /---(?:\s|$)/.test(te.originalText.slice(h(R), h(R) + 4)) || R.head.children.length > 0 || k(R.head) || I(R.head) ? "head" : V(R, Q) ? false : Q ? "root" : false;
            }
            function Y(R, Q, ee) {
              let te = T(R, Q, ee);
              return u(r, te.map((oe) => s(v(u(i, oe)))));
            }
            function H(R, Q) {
              if (D(Q))
                switch (delete Q.position, Q.type) {
                  case "comment":
                    if (f(Q.value))
                      return null;
                    break;
                  case "quoteDouble":
                  case "quoteSingle":
                    Q.type = "quote";
                    break;
                }
            }
            n.exports = { preprocess: F, embed: w, print: M, massageAstNode: H, insertPragma: p };
          } }), Fg = Z({ "src/language-yaml/options.js"(e, n) {
            "use strict";
            re();
            var t = Ot();
            n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
          } }), Ag = Z({ "src/language-yaml/parsers.js"() {
            re();
          } }), Sg = Z({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
            n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
          } }), xg = Z({ "src/language-yaml/index.js"(e, n) {
            "use strict";
            re();
            var t = Bt(), s = Eg(), a = Fg(), r = Ag(), u = [t(Sg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((o) => o !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
            n.exports = { languages: u, printers: { yaml: s }, options: a, parsers: r };
          } }), bg = Z({ "src/languages.js"(e, n) {
            "use strict";
            re(), n.exports = [id(), Sd(), Pd(), Md(), Ud(), Dg(), xg()];
          } });
          re();
          var { version: Tg } = ya(), kt = Sm(), { getSupportInfo: Bg } = Mn(), Ng = xm(), wg = bg(), _g = Oe();
          function bt(e) {
            let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
              for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++)
                s[a] = arguments[a];
              let r = s[n] || {}, u = r.plugins || [];
              return s[n] = Object.assign(Object.assign({}, r), {}, { plugins: [...wg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
            };
          }
          var bn = bt(kt.formatWithCursor);
          Co.exports = { formatWithCursor: bn, format(e, n) {
            return bn(e, n).formatted;
          }, check(e, n) {
            let { formatted: t } = bn(e, n);
            return t === e;
          }, doc: _g, getSupportInfo: bt(Bg, 0), version: Tg, util: Ng, __debug: { parse: bt(kt.parse), formatAST: bt(kt.formatAST), formatDoc: bt(kt.formatDoc), printToDoc: bt(kt.printToDoc), printDocToString: bt(kt.printDocToString) } };
        });
        return Pg();
      });
    }
  });

  // ../../node_modules/.pnpm/prettier@2.7.1/node_modules/prettier/parser-graphql.js
  var require_parser_graphql = __commonJS({
    "../../node_modules/.pnpm/prettier@2.7.1/node_modules/prettier/parser-graphql.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.graphql = e();
        }
      })(function() {
        "use strict";
        var oe = (a, d) => () => (d || a((d = { exports: {} }).exports, d), d.exports);
        var be = oe((Ce, ae) => {
          var H = Object.getOwnPropertyNames, se = (a, d) => function() {
            return a && (d = (0, a[H(a)[0]])(a = 0)), d;
          }, L = (a, d) => function() {
            return d || (0, a[H(a)[0]])((d = { exports: {} }).exports, d), d.exports;
          }, K = se({ "<define:process>"() {
          } }), ce = L({ "src/common/parser-create-error.js"(a, d) {
            "use strict";
            K();
            function i(c, r) {
              let _ = new SyntaxError(c + " (" + r.start.line + ":" + r.start.column + ")");
              return _.loc = r, _;
            }
            d.exports = i;
          } }), ue = L({ "src/utils/try-combinations.js"(a, d) {
            "use strict";
            K();
            function i() {
              let c;
              for (var r = arguments.length, _ = new Array(r), E = 0; E < r; E++)
                _[E] = arguments[E];
              for (let [k, O] of _.entries())
                try {
                  return { result: O() };
                } catch (A) {
                  k === 0 && (c = A);
                }
              return { error: c };
            }
            d.exports = i;
          } }), le = L({ "src/language-graphql/pragma.js"(a, d) {
            "use strict";
            K();
            function i(r) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(r);
            }
            function c(r) {
              return `# @format

` + r;
            }
            d.exports = { hasPragma: i, insertPragma: c };
          } }), pe = L({ "src/language-graphql/loc.js"(a, d) {
            "use strict";
            K();
            function i(r) {
              return typeof r.start == "number" ? r.start : r.loc && r.loc.start;
            }
            function c(r) {
              return typeof r.end == "number" ? r.end : r.loc && r.loc.end;
            }
            d.exports = { locStart: i, locEnd: c };
          } }), fe = L({ "node_modules/graphql/jsutils/isObjectLike.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = i;
            function d(c) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(_) {
                return typeof _;
              } : d = function(_) {
                return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
              }, d(c);
            }
            function i(c) {
              return d(c) == "object" && c !== null;
            }
          } }), z = L({ "node_modules/graphql/polyfills/symbols.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.SYMBOL_TO_STRING_TAG = a.SYMBOL_ASYNC_ITERATOR = a.SYMBOL_ITERATOR = void 0;
            var d = typeof Symbol == "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
            a.SYMBOL_ITERATOR = d;
            var i = typeof Symbol == "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
            a.SYMBOL_ASYNC_ITERATOR = i;
            var c = typeof Symbol == "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
            a.SYMBOL_TO_STRING_TAG = c;
          } }), $ = L({ "node_modules/graphql/language/location.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.getLocation = d;
            function d(i, c) {
              for (var r = /\r\n|[\n\r]/g, _ = 1, E = c + 1, k; (k = r.exec(i.body)) && k.index < c; )
                _ += 1, E = c + 1 - (k.index + k[0].length);
              return { line: _, column: E };
            }
          } }), de = L({ "node_modules/graphql/language/printLocation.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.printLocation = i, a.printSourceLocation = c;
            var d = $();
            function i(k) {
              return c(k.source, (0, d.getLocation)(k.source, k.start));
            }
            function c(k, O) {
              var A = k.locationOffset.column - 1, N = _(A) + k.body, g = O.line - 1, D = k.locationOffset.line - 1, v = O.line + D, I = O.line === 1 ? A : 0, s = O.column + I, p = "".concat(k.name, ":").concat(v, ":").concat(s, `
`), e = N.split(/\r\n|[\n\r]/g), n = e[g];
              if (n.length > 120) {
                for (var t = Math.floor(s / 80), u = s % 80, y = [], f = 0; f < n.length; f += 80)
                  y.push(n.slice(f, f + 80));
                return p + r([["".concat(v), y[0]]].concat(y.slice(1, t + 1).map(function(m) {
                  return ["", m];
                }), [[" ", _(u - 1) + "^"], ["", y[t + 1]]]));
              }
              return p + r([["".concat(v - 1), e[g - 1]], ["".concat(v), n], ["", _(s - 1) + "^"], ["".concat(v + 1), e[g + 1]]]);
            }
            function r(k) {
              var O = k.filter(function(N) {
                var g = N[0], D = N[1];
                return D !== void 0;
              }), A = Math.max.apply(Math, O.map(function(N) {
                var g = N[0];
                return g.length;
              }));
              return O.map(function(N) {
                var g = N[0], D = N[1];
                return E(A, g) + (D ? " | " + D : " |");
              }).join(`
`);
            }
            function _(k) {
              return Array(k + 1).join(" ");
            }
            function E(k, O) {
              return _(k - O.length) + O;
            }
          } }), W = L({ "node_modules/graphql/error/GraphQLError.js"(a) {
            "use strict";
            K();
            function d(f) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(o) {
                return typeof o;
              } : d = function(o) {
                return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
              }, d(f);
            }
            Object.defineProperty(a, "__esModule", { value: true }), a.printError = y, a.GraphQLError = void 0;
            var i = E(fe()), c = z(), r = $(), _ = de();
            function E(f) {
              return f && f.__esModule ? f : { default: f };
            }
            function k(f, m) {
              if (!(f instanceof m))
                throw new TypeError("Cannot call a class as a function");
            }
            function O(f, m) {
              for (var o = 0; o < m.length; o++) {
                var h = m[o];
                h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(f, h.key, h);
              }
            }
            function A(f, m, o) {
              return m && O(f.prototype, m), o && O(f, o), f;
            }
            function N(f, m) {
              if (typeof m != "function" && m !== null)
                throw new TypeError("Super expression must either be null or a function");
              f.prototype = Object.create(m && m.prototype, { constructor: { value: f, writable: true, configurable: true } }), m && n(f, m);
            }
            function g(f) {
              var m = p();
              return function() {
                var h = t(f), l;
                if (m) {
                  var T = t(this).constructor;
                  l = Reflect.construct(h, arguments, T);
                } else
                  l = h.apply(this, arguments);
                return D(this, l);
              };
            }
            function D(f, m) {
              return m && (d(m) === "object" || typeof m == "function") ? m : v(f);
            }
            function v(f) {
              if (f === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return f;
            }
            function I(f) {
              var m = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
              return I = function(h) {
                if (h === null || !e(h))
                  return h;
                if (typeof h != "function")
                  throw new TypeError("Super expression must either be null or a function");
                if (typeof m < "u") {
                  if (m.has(h))
                    return m.get(h);
                  m.set(h, l);
                }
                function l() {
                  return s(h, arguments, t(this).constructor);
                }
                return l.prototype = Object.create(h.prototype, { constructor: { value: l, enumerable: false, writable: true, configurable: true } }), n(l, h);
              }, I(f);
            }
            function s(f, m, o) {
              return p() ? s = Reflect.construct : s = function(l, T, S) {
                var x = [null];
                x.push.apply(x, T);
                var b = Function.bind.apply(l, x), M = new b();
                return S && n(M, S.prototype), M;
              }, s.apply(null, arguments);
            }
            function p() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch {
                return false;
              }
            }
            function e(f) {
              return Function.toString.call(f).indexOf("[native code]") !== -1;
            }
            function n(f, m) {
              return n = Object.setPrototypeOf || function(h, l) {
                return h.__proto__ = l, h;
              }, n(f, m);
            }
            function t(f) {
              return t = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
              }, t(f);
            }
            var u = function(f) {
              N(o, f);
              var m = g(o);
              function o(h, l, T, S, x, b, M) {
                var U, V, q, G, C;
                k(this, o), C = m.call(this, h);
                var R = Array.isArray(l) ? l.length !== 0 ? l : void 0 : l ? [l] : void 0, Y = T;
                if (!Y && R) {
                  var J;
                  Y = (J = R[0].loc) === null || J === void 0 ? void 0 : J.source;
                }
                var F = S;
                !F && R && (F = R.reduce(function(w, P) {
                  return P.loc && w.push(P.loc.start), w;
                }, [])), F && F.length === 0 && (F = void 0);
                var B;
                S && T ? B = S.map(function(w) {
                  return (0, r.getLocation)(T, w);
                }) : R && (B = R.reduce(function(w, P) {
                  return P.loc && w.push((0, r.getLocation)(P.loc.source, P.loc.start)), w;
                }, []));
                var j = M;
                if (j == null && b != null) {
                  var Q = b.extensions;
                  (0, i.default)(Q) && (j = Q);
                }
                return Object.defineProperties(v(C), { name: { value: "GraphQLError" }, message: { value: h, enumerable: true, writable: true }, locations: { value: (U = B) !== null && U !== void 0 ? U : void 0, enumerable: B != null }, path: { value: x != null ? x : void 0, enumerable: x != null }, nodes: { value: R != null ? R : void 0 }, source: { value: (V = Y) !== null && V !== void 0 ? V : void 0 }, positions: { value: (q = F) !== null && q !== void 0 ? q : void 0 }, originalError: { value: b }, extensions: { value: (G = j) !== null && G !== void 0 ? G : void 0, enumerable: j != null } }), b != null && b.stack ? (Object.defineProperty(v(C), "stack", { value: b.stack, writable: true, configurable: true }), D(C)) : (Error.captureStackTrace ? Error.captureStackTrace(v(C), o) : Object.defineProperty(v(C), "stack", { value: Error().stack, writable: true, configurable: true }), C);
              }
              return A(o, [{ key: "toString", value: function() {
                return y(this);
              } }, { key: c.SYMBOL_TO_STRING_TAG, get: function() {
                return "Object";
              } }]), o;
            }(I(Error));
            a.GraphQLError = u;
            function y(f) {
              var m = f.message;
              if (f.nodes)
                for (var o = 0, h = f.nodes; o < h.length; o++) {
                  var l = h[o];
                  l.loc && (m += `

` + (0, _.printLocation)(l.loc));
                }
              else if (f.source && f.locations)
                for (var T = 0, S = f.locations; T < S.length; T++) {
                  var x = S[T];
                  m += `

` + (0, _.printSourceLocation)(f.source, x);
                }
              return m;
            }
          } }), Z = L({ "node_modules/graphql/error/syntaxError.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.syntaxError = i;
            var d = W();
            function i(c, r, _) {
              return new d.GraphQLError("Syntax Error: ".concat(_), void 0, c, [r]);
            }
          } }), he = L({ "node_modules/graphql/language/kinds.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.Kind = void 0;
            var d = Object.freeze({ NAME: "Name", DOCUMENT: "Document", OPERATION_DEFINITION: "OperationDefinition", VARIABLE_DEFINITION: "VariableDefinition", SELECTION_SET: "SelectionSet", FIELD: "Field", ARGUMENT: "Argument", FRAGMENT_SPREAD: "FragmentSpread", INLINE_FRAGMENT: "InlineFragment", FRAGMENT_DEFINITION: "FragmentDefinition", VARIABLE: "Variable", INT: "IntValue", FLOAT: "FloatValue", STRING: "StringValue", BOOLEAN: "BooleanValue", NULL: "NullValue", ENUM: "EnumValue", LIST: "ListValue", OBJECT: "ObjectValue", OBJECT_FIELD: "ObjectField", DIRECTIVE: "Directive", NAMED_TYPE: "NamedType", LIST_TYPE: "ListType", NON_NULL_TYPE: "NonNullType", SCHEMA_DEFINITION: "SchemaDefinition", OPERATION_TYPE_DEFINITION: "OperationTypeDefinition", SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition", OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition", FIELD_DEFINITION: "FieldDefinition", INPUT_VALUE_DEFINITION: "InputValueDefinition", INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition", UNION_TYPE_DEFINITION: "UnionTypeDefinition", ENUM_TYPE_DEFINITION: "EnumTypeDefinition", ENUM_VALUE_DEFINITION: "EnumValueDefinition", INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition", DIRECTIVE_DEFINITION: "DirectiveDefinition", SCHEMA_EXTENSION: "SchemaExtension", SCALAR_TYPE_EXTENSION: "ScalarTypeExtension", OBJECT_TYPE_EXTENSION: "ObjectTypeExtension", INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension", UNION_TYPE_EXTENSION: "UnionTypeExtension", ENUM_TYPE_EXTENSION: "EnumTypeExtension", INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension" });
            a.Kind = d;
          } }), ve = L({ "node_modules/graphql/jsutils/invariant.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = d;
            function d(i, c) {
              var r = Boolean(i);
              if (!r)
                throw new Error(c != null ? c : "Unexpected invariant triggered.");
            }
          } }), ee = L({ "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = void 0;
            var d = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0, i = d;
            a.default = i;
          } }), Te = L({ "node_modules/graphql/jsutils/defineInspect.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = r;
            var d = c(ve()), i = c(ee());
            function c(_) {
              return _ && _.__esModule ? _ : { default: _ };
            }
            function r(_) {
              var E = _.prototype.toJSON;
              typeof E == "function" || (0, d.default)(0), _.prototype.inspect = E, i.default && (_.prototype[i.default] = E);
            }
          } }), te = L({ "node_modules/graphql/language/ast.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isNode = _, a.Token = a.Location = void 0;
            var d = i(Te());
            function i(E) {
              return E && E.__esModule ? E : { default: E };
            }
            var c = function() {
              function E(O, A, N) {
                this.start = O.start, this.end = A.end, this.startToken = O, this.endToken = A, this.source = N;
              }
              var k = E.prototype;
              return k.toJSON = function() {
                return { start: this.start, end: this.end };
              }, E;
            }();
            a.Location = c, (0, d.default)(c);
            var r = function() {
              function E(O, A, N, g, D, v, I) {
                this.kind = O, this.start = A, this.end = N, this.line = g, this.column = D, this.value = I, this.prev = v, this.next = null;
              }
              var k = E.prototype;
              return k.toJSON = function() {
                return { kind: this.kind, value: this.value, line: this.line, column: this.column };
              }, E;
            }();
            a.Token = r, (0, d.default)(r);
            function _(E) {
              return E != null && typeof E.kind == "string";
            }
          } }), ne = L({ "node_modules/graphql/language/tokenKind.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.TokenKind = void 0;
            var d = Object.freeze({ SOF: "<SOF>", EOF: "<EOF>", BANG: "!", DOLLAR: "$", AMP: "&", PAREN_L: "(", PAREN_R: ")", SPREAD: "...", COLON: ":", EQUALS: "=", AT: "@", BRACKET_L: "[", BRACKET_R: "]", BRACE_L: "{", PIPE: "|", BRACE_R: "}", NAME: "Name", INT: "Int", FLOAT: "Float", STRING: "String", BLOCK_STRING: "BlockString", COMMENT: "Comment" });
            a.TokenKind = d;
          } }), re = L({ "node_modules/graphql/jsutils/inspect.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = E;
            var d = i(ee());
            function i(v) {
              return v && v.__esModule ? v : { default: v };
            }
            function c(v) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(s) {
                return typeof s;
              } : c = function(s) {
                return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
              }, c(v);
            }
            var r = 10, _ = 2;
            function E(v) {
              return k(v, []);
            }
            function k(v, I) {
              switch (c(v)) {
                case "string":
                  return JSON.stringify(v);
                case "function":
                  return v.name ? "[function ".concat(v.name, "]") : "[function]";
                case "object":
                  return v === null ? "null" : O(v, I);
                default:
                  return String(v);
              }
            }
            function O(v, I) {
              if (I.indexOf(v) !== -1)
                return "[Circular]";
              var s = [].concat(I, [v]), p = g(v);
              if (p !== void 0) {
                var e = p.call(v);
                if (e !== v)
                  return typeof e == "string" ? e : k(e, s);
              } else if (Array.isArray(v))
                return N(v, s);
              return A(v, s);
            }
            function A(v, I) {
              var s = Object.keys(v);
              if (s.length === 0)
                return "{}";
              if (I.length > _)
                return "[" + D(v) + "]";
              var p = s.map(function(e) {
                var n = k(v[e], I);
                return e + ": " + n;
              });
              return "{ " + p.join(", ") + " }";
            }
            function N(v, I) {
              if (v.length === 0)
                return "[]";
              if (I.length > _)
                return "[Array]";
              for (var s = Math.min(r, v.length), p = v.length - s, e = [], n = 0; n < s; ++n)
                e.push(k(v[n], I));
              return p === 1 ? e.push("... 1 more item") : p > 1 && e.push("... ".concat(p, " more items")), "[" + e.join(", ") + "]";
            }
            function g(v) {
              var I = v[String(d.default)];
              if (typeof I == "function")
                return I;
              if (typeof v.inspect == "function")
                return v.inspect;
            }
            function D(v) {
              var I = Object.prototype.toString.call(v).replace(/^\[object /, "").replace(/]$/, "");
              if (I === "Object" && typeof v.constructor == "function") {
                var s = v.constructor.name;
                if (typeof s == "string" && s !== "")
                  return s;
              }
              return I;
            }
          } }), _e = L({ "node_modules/graphql/jsutils/devAssert.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = d;
            function d(i, c) {
              var r = Boolean(i);
              if (!r)
                throw new Error(c);
            }
          } }), Ee = L({ "node_modules/graphql/jsutils/instanceOf.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = void 0;
            var d = i(re());
            function i(r) {
              return r && r.__esModule ? r : { default: r };
            }
            var c = function(_, E) {
              return _ instanceof E;
            };
            a.default = c;
          } }), me = L({ "node_modules/graphql/language/source.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isSource = A, a.Source = void 0;
            var d = z(), i = _(re()), c = _(_e()), r = _(Ee());
            function _(N) {
              return N && N.__esModule ? N : { default: N };
            }
            function E(N, g) {
              for (var D = 0; D < g.length; D++) {
                var v = g[D];
                v.enumerable = v.enumerable || false, v.configurable = true, "value" in v && (v.writable = true), Object.defineProperty(N, v.key, v);
              }
            }
            function k(N, g, D) {
              return g && E(N.prototype, g), D && E(N, D), N;
            }
            var O = function() {
              function N(g) {
                var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request", v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { line: 1, column: 1 };
                typeof g == "string" || (0, c.default)(0, "Body must be a string. Received: ".concat((0, i.default)(g), ".")), this.body = g, this.name = D, this.locationOffset = v, this.locationOffset.line > 0 || (0, c.default)(0, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || (0, c.default)(0, "column in locationOffset is 1-indexed and must be positive.");
              }
              return k(N, [{ key: d.SYMBOL_TO_STRING_TAG, get: function() {
                return "Source";
              } }]), N;
            }();
            a.Source = O;
            function A(N) {
              return (0, r.default)(N, O);
            }
          } }), ye = L({ "node_modules/graphql/language/directiveLocation.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.DirectiveLocation = void 0;
            var d = Object.freeze({ QUERY: "QUERY", MUTATION: "MUTATION", SUBSCRIPTION: "SUBSCRIPTION", FIELD: "FIELD", FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION", FRAGMENT_SPREAD: "FRAGMENT_SPREAD", INLINE_FRAGMENT: "INLINE_FRAGMENT", VARIABLE_DEFINITION: "VARIABLE_DEFINITION", SCHEMA: "SCHEMA", SCALAR: "SCALAR", OBJECT: "OBJECT", FIELD_DEFINITION: "FIELD_DEFINITION", ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION", INTERFACE: "INTERFACE", UNION: "UNION", ENUM: "ENUM", ENUM_VALUE: "ENUM_VALUE", INPUT_OBJECT: "INPUT_OBJECT", INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION" });
            a.DirectiveLocation = d;
          } }), ke = L({ "node_modules/graphql/language/blockString.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.dedentBlockStringValue = d, a.getBlockStringIndentation = c, a.printBlockString = r;
            function d(_) {
              var E = _.split(/\r\n|[\n\r]/g), k = c(_);
              if (k !== 0)
                for (var O = 1; O < E.length; O++)
                  E[O] = E[O].slice(k);
              for (var A = 0; A < E.length && i(E[A]); )
                ++A;
              for (var N = E.length; N > A && i(E[N - 1]); )
                --N;
              return E.slice(A, N).join(`
`);
            }
            function i(_) {
              for (var E = 0; E < _.length; ++E)
                if (_[E] !== " " && _[E] !== "	")
                  return false;
              return true;
            }
            function c(_) {
              for (var E, k = true, O = true, A = 0, N = null, g = 0; g < _.length; ++g)
                switch (_.charCodeAt(g)) {
                  case 13:
                    _.charCodeAt(g + 1) === 10 && ++g;
                  case 10:
                    k = false, O = true, A = 0;
                    break;
                  case 9:
                  case 32:
                    ++A;
                    break;
                  default:
                    O && !k && (N === null || A < N) && (N = A), O = false;
                }
              return (E = N) !== null && E !== void 0 ? E : 0;
            }
            function r(_) {
              var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", k = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, O = _.indexOf(`
`) === -1, A = _[0] === " " || _[0] === "	", N = _[_.length - 1] === '"', g = _[_.length - 1] === "\\", D = !O || N || g || k, v = "";
              return D && !(O && A) && (v += `
` + E), v += E ? _.replace(/\n/g, `
` + E) : _, D && (v += `
`), '"""' + v.replace(/"""/g, '\\"""') + '"""';
            }
          } }), Ne = L({ "node_modules/graphql/language/lexer.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isPunctuatorTokenKind = E, a.Lexer = void 0;
            var d = Z(), i = te(), c = ne(), r = ke(), _ = function() {
              function t(y) {
                var f = new i.Token(c.TokenKind.SOF, 0, 0, 0, 0, null);
                this.source = y, this.lastToken = f, this.token = f, this.line = 1, this.lineStart = 0;
              }
              var u = t.prototype;
              return u.advance = function() {
                this.lastToken = this.token;
                var f = this.token = this.lookahead();
                return f;
              }, u.lookahead = function() {
                var f = this.token;
                if (f.kind !== c.TokenKind.EOF)
                  do {
                    var m;
                    f = (m = f.next) !== null && m !== void 0 ? m : f.next = O(this, f);
                  } while (f.kind === c.TokenKind.COMMENT);
                return f;
              }, t;
            }();
            a.Lexer = _;
            function E(t) {
              return t === c.TokenKind.BANG || t === c.TokenKind.DOLLAR || t === c.TokenKind.AMP || t === c.TokenKind.PAREN_L || t === c.TokenKind.PAREN_R || t === c.TokenKind.SPREAD || t === c.TokenKind.COLON || t === c.TokenKind.EQUALS || t === c.TokenKind.AT || t === c.TokenKind.BRACKET_L || t === c.TokenKind.BRACKET_R || t === c.TokenKind.BRACE_L || t === c.TokenKind.PIPE || t === c.TokenKind.BRACE_R;
            }
            function k(t) {
              return isNaN(t) ? c.TokenKind.EOF : t < 127 ? JSON.stringify(String.fromCharCode(t)) : '"\\u'.concat(("00" + t.toString(16).toUpperCase()).slice(-4), '"');
            }
            function O(t, u) {
              for (var y = t.source, f = y.body, m = f.length, o = u.end; o < m; ) {
                var h = f.charCodeAt(o), l = t.line, T = 1 + o - t.lineStart;
                switch (h) {
                  case 65279:
                  case 9:
                  case 32:
                  case 44:
                    ++o;
                    continue;
                  case 10:
                    ++o, ++t.line, t.lineStart = o;
                    continue;
                  case 13:
                    f.charCodeAt(o + 1) === 10 ? o += 2 : ++o, ++t.line, t.lineStart = o;
                    continue;
                  case 33:
                    return new i.Token(c.TokenKind.BANG, o, o + 1, l, T, u);
                  case 35:
                    return N(y, o, l, T, u);
                  case 36:
                    return new i.Token(c.TokenKind.DOLLAR, o, o + 1, l, T, u);
                  case 38:
                    return new i.Token(c.TokenKind.AMP, o, o + 1, l, T, u);
                  case 40:
                    return new i.Token(c.TokenKind.PAREN_L, o, o + 1, l, T, u);
                  case 41:
                    return new i.Token(c.TokenKind.PAREN_R, o, o + 1, l, T, u);
                  case 46:
                    if (f.charCodeAt(o + 1) === 46 && f.charCodeAt(o + 2) === 46)
                      return new i.Token(c.TokenKind.SPREAD, o, o + 3, l, T, u);
                    break;
                  case 58:
                    return new i.Token(c.TokenKind.COLON, o, o + 1, l, T, u);
                  case 61:
                    return new i.Token(c.TokenKind.EQUALS, o, o + 1, l, T, u);
                  case 64:
                    return new i.Token(c.TokenKind.AT, o, o + 1, l, T, u);
                  case 91:
                    return new i.Token(c.TokenKind.BRACKET_L, o, o + 1, l, T, u);
                  case 93:
                    return new i.Token(c.TokenKind.BRACKET_R, o, o + 1, l, T, u);
                  case 123:
                    return new i.Token(c.TokenKind.BRACE_L, o, o + 1, l, T, u);
                  case 124:
                    return new i.Token(c.TokenKind.PIPE, o, o + 1, l, T, u);
                  case 125:
                    return new i.Token(c.TokenKind.BRACE_R, o, o + 1, l, T, u);
                  case 34:
                    return f.charCodeAt(o + 1) === 34 && f.charCodeAt(o + 2) === 34 ? I(y, o, l, T, u, t) : v(y, o, l, T, u);
                  case 45:
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return g(y, o, h, l, T, u);
                  case 65:
                  case 66:
                  case 67:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                  case 78:
                  case 79:
                  case 80:
                  case 81:
                  case 82:
                  case 83:
                  case 84:
                  case 85:
                  case 86:
                  case 87:
                  case 88:
                  case 89:
                  case 90:
                  case 95:
                  case 97:
                  case 98:
                  case 99:
                  case 100:
                  case 101:
                  case 102:
                  case 103:
                  case 104:
                  case 105:
                  case 106:
                  case 107:
                  case 108:
                  case 109:
                  case 110:
                  case 111:
                  case 112:
                  case 113:
                  case 114:
                  case 115:
                  case 116:
                  case 117:
                  case 118:
                  case 119:
                  case 120:
                  case 121:
                  case 122:
                    return e(y, o, l, T, u);
                }
                throw (0, d.syntaxError)(y, o, A(h));
              }
              var S = t.line, x = 1 + o - t.lineStart;
              return new i.Token(c.TokenKind.EOF, m, m, S, x, u);
            }
            function A(t) {
              return t < 32 && t !== 9 && t !== 10 && t !== 13 ? "Cannot contain the invalid character ".concat(k(t), ".") : t === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : "Cannot parse the unexpected character ".concat(k(t), ".");
            }
            function N(t, u, y, f, m) {
              var o = t.body, h, l = u;
              do
                h = o.charCodeAt(++l);
              while (!isNaN(h) && (h > 31 || h === 9));
              return new i.Token(c.TokenKind.COMMENT, u, l, y, f, m, o.slice(u + 1, l));
            }
            function g(t, u, y, f, m, o) {
              var h = t.body, l = y, T = u, S = false;
              if (l === 45 && (l = h.charCodeAt(++T)), l === 48) {
                if (l = h.charCodeAt(++T), l >= 48 && l <= 57)
                  throw (0, d.syntaxError)(t, T, "Invalid number, unexpected digit after 0: ".concat(k(l), "."));
              } else
                T = D(t, T, l), l = h.charCodeAt(T);
              if (l === 46 && (S = true, l = h.charCodeAt(++T), T = D(t, T, l), l = h.charCodeAt(T)), (l === 69 || l === 101) && (S = true, l = h.charCodeAt(++T), (l === 43 || l === 45) && (l = h.charCodeAt(++T)), T = D(t, T, l), l = h.charCodeAt(T)), l === 46 || n(l))
                throw (0, d.syntaxError)(t, T, "Invalid number, expected digit but got: ".concat(k(l), "."));
              return new i.Token(S ? c.TokenKind.FLOAT : c.TokenKind.INT, u, T, f, m, o, h.slice(u, T));
            }
            function D(t, u, y) {
              var f = t.body, m = u, o = y;
              if (o >= 48 && o <= 57) {
                do
                  o = f.charCodeAt(++m);
                while (o >= 48 && o <= 57);
                return m;
              }
              throw (0, d.syntaxError)(t, m, "Invalid number, expected digit but got: ".concat(k(o), "."));
            }
            function v(t, u, y, f, m) {
              for (var o = t.body, h = u + 1, l = h, T = 0, S = ""; h < o.length && !isNaN(T = o.charCodeAt(h)) && T !== 10 && T !== 13; ) {
                if (T === 34)
                  return S += o.slice(l, h), new i.Token(c.TokenKind.STRING, u, h + 1, y, f, m, S);
                if (T < 32 && T !== 9)
                  throw (0, d.syntaxError)(t, h, "Invalid character within String: ".concat(k(T), "."));
                if (++h, T === 92) {
                  switch (S += o.slice(l, h - 1), T = o.charCodeAt(h), T) {
                    case 34:
                      S += '"';
                      break;
                    case 47:
                      S += "/";
                      break;
                    case 92:
                      S += "\\";
                      break;
                    case 98:
                      S += "\b";
                      break;
                    case 102:
                      S += "\f";
                      break;
                    case 110:
                      S += `
`;
                      break;
                    case 114:
                      S += "\r";
                      break;
                    case 116:
                      S += "	";
                      break;
                    case 117: {
                      var x = s(o.charCodeAt(h + 1), o.charCodeAt(h + 2), o.charCodeAt(h + 3), o.charCodeAt(h + 4));
                      if (x < 0) {
                        var b = o.slice(h + 1, h + 5);
                        throw (0, d.syntaxError)(t, h, "Invalid character escape sequence: \\u".concat(b, "."));
                      }
                      S += String.fromCharCode(x), h += 4;
                      break;
                    }
                    default:
                      throw (0, d.syntaxError)(t, h, "Invalid character escape sequence: \\".concat(String.fromCharCode(T), "."));
                  }
                  ++h, l = h;
                }
              }
              throw (0, d.syntaxError)(t, h, "Unterminated string.");
            }
            function I(t, u, y, f, m, o) {
              for (var h = t.body, l = u + 3, T = l, S = 0, x = ""; l < h.length && !isNaN(S = h.charCodeAt(l)); ) {
                if (S === 34 && h.charCodeAt(l + 1) === 34 && h.charCodeAt(l + 2) === 34)
                  return x += h.slice(T, l), new i.Token(c.TokenKind.BLOCK_STRING, u, l + 3, y, f, m, (0, r.dedentBlockStringValue)(x));
                if (S < 32 && S !== 9 && S !== 10 && S !== 13)
                  throw (0, d.syntaxError)(t, l, "Invalid character within String: ".concat(k(S), "."));
                S === 10 ? (++l, ++o.line, o.lineStart = l) : S === 13 ? (h.charCodeAt(l + 1) === 10 ? l += 2 : ++l, ++o.line, o.lineStart = l) : S === 92 && h.charCodeAt(l + 1) === 34 && h.charCodeAt(l + 2) === 34 && h.charCodeAt(l + 3) === 34 ? (x += h.slice(T, l) + '"""', l += 4, T = l) : ++l;
              }
              throw (0, d.syntaxError)(t, l, "Unterminated string.");
            }
            function s(t, u, y, f) {
              return p(t) << 12 | p(u) << 8 | p(y) << 4 | p(f);
            }
            function p(t) {
              return t >= 48 && t <= 57 ? t - 48 : t >= 65 && t <= 70 ? t - 55 : t >= 97 && t <= 102 ? t - 87 : -1;
            }
            function e(t, u, y, f, m) {
              for (var o = t.body, h = o.length, l = u + 1, T = 0; l !== h && !isNaN(T = o.charCodeAt(l)) && (T === 95 || T >= 48 && T <= 57 || T >= 65 && T <= 90 || T >= 97 && T <= 122); )
                ++l;
              return new i.Token(c.TokenKind.NAME, u, l, y, f, m, o.slice(u, l));
            }
            function n(t) {
              return t === 95 || t >= 65 && t <= 90 || t >= 97 && t <= 122;
            }
          } }), Oe = L({ "node_modules/graphql/language/parser.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.parse = O, a.parseValue = A, a.parseType = N, a.Parser = void 0;
            var d = Z(), i = he(), c = te(), r = ne(), _ = me(), E = ye(), k = Ne();
            function O(I, s) {
              var p = new g(I, s);
              return p.parseDocument();
            }
            function A(I, s) {
              var p = new g(I, s);
              p.expectToken(r.TokenKind.SOF);
              var e = p.parseValueLiteral(false);
              return p.expectToken(r.TokenKind.EOF), e;
            }
            function N(I, s) {
              var p = new g(I, s);
              p.expectToken(r.TokenKind.SOF);
              var e = p.parseTypeReference();
              return p.expectToken(r.TokenKind.EOF), e;
            }
            var g = function() {
              function I(p, e) {
                var n = (0, _.isSource)(p) ? p : new _.Source(p);
                this._lexer = new k.Lexer(n), this._options = e;
              }
              var s = I.prototype;
              return s.parseName = function() {
                var e = this.expectToken(r.TokenKind.NAME);
                return { kind: i.Kind.NAME, value: e.value, loc: this.loc(e) };
              }, s.parseDocument = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.DOCUMENT, definitions: this.many(r.TokenKind.SOF, this.parseDefinition, r.TokenKind.EOF), loc: this.loc(e) };
              }, s.parseDefinition = function() {
                if (this.peek(r.TokenKind.NAME))
                  switch (this._lexer.token.value) {
                    case "query":
                    case "mutation":
                    case "subscription":
                      return this.parseOperationDefinition();
                    case "fragment":
                      return this.parseFragmentDefinition();
                    case "schema":
                    case "scalar":
                    case "type":
                    case "interface":
                    case "union":
                    case "enum":
                    case "input":
                    case "directive":
                      return this.parseTypeSystemDefinition();
                    case "extend":
                      return this.parseTypeSystemExtension();
                  }
                else {
                  if (this.peek(r.TokenKind.BRACE_L))
                    return this.parseOperationDefinition();
                  if (this.peekDescription())
                    return this.parseTypeSystemDefinition();
                }
                throw this.unexpected();
              }, s.parseOperationDefinition = function() {
                var e = this._lexer.token;
                if (this.peek(r.TokenKind.BRACE_L))
                  return { kind: i.Kind.OPERATION_DEFINITION, operation: "query", name: void 0, variableDefinitions: [], directives: [], selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
                var n = this.parseOperationType(), t;
                return this.peek(r.TokenKind.NAME) && (t = this.parseName()), { kind: i.Kind.OPERATION_DEFINITION, operation: n, name: t, variableDefinitions: this.parseVariableDefinitions(), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
              }, s.parseOperationType = function() {
                var e = this.expectToken(r.TokenKind.NAME);
                switch (e.value) {
                  case "query":
                    return "query";
                  case "mutation":
                    return "mutation";
                  case "subscription":
                    return "subscription";
                }
                throw this.unexpected(e);
              }, s.parseVariableDefinitions = function() {
                return this.optionalMany(r.TokenKind.PAREN_L, this.parseVariableDefinition, r.TokenKind.PAREN_R);
              }, s.parseVariableDefinition = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.VARIABLE_DEFINITION, variable: this.parseVariable(), type: (this.expectToken(r.TokenKind.COLON), this.parseTypeReference()), defaultValue: this.expectOptionalToken(r.TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0, directives: this.parseDirectives(true), loc: this.loc(e) };
              }, s.parseVariable = function() {
                var e = this._lexer.token;
                return this.expectToken(r.TokenKind.DOLLAR), { kind: i.Kind.VARIABLE, name: this.parseName(), loc: this.loc(e) };
              }, s.parseSelectionSet = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.SELECTION_SET, selections: this.many(r.TokenKind.BRACE_L, this.parseSelection, r.TokenKind.BRACE_R), loc: this.loc(e) };
              }, s.parseSelection = function() {
                return this.peek(r.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
              }, s.parseField = function() {
                var e = this._lexer.token, n = this.parseName(), t, u;
                return this.expectOptionalToken(r.TokenKind.COLON) ? (t = n, u = this.parseName()) : u = n, { kind: i.Kind.FIELD, alias: t, name: u, arguments: this.parseArguments(false), directives: this.parseDirectives(false), selectionSet: this.peek(r.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0, loc: this.loc(e) };
              }, s.parseArguments = function(e) {
                var n = e ? this.parseConstArgument : this.parseArgument;
                return this.optionalMany(r.TokenKind.PAREN_L, n, r.TokenKind.PAREN_R);
              }, s.parseArgument = function() {
                var e = this._lexer.token, n = this.parseName();
                return this.expectToken(r.TokenKind.COLON), { kind: i.Kind.ARGUMENT, name: n, value: this.parseValueLiteral(false), loc: this.loc(e) };
              }, s.parseConstArgument = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.ARGUMENT, name: this.parseName(), value: (this.expectToken(r.TokenKind.COLON), this.parseValueLiteral(true)), loc: this.loc(e) };
              }, s.parseFragment = function() {
                var e = this._lexer.token;
                this.expectToken(r.TokenKind.SPREAD);
                var n = this.expectOptionalKeyword("on");
                return !n && this.peek(r.TokenKind.NAME) ? { kind: i.Kind.FRAGMENT_SPREAD, name: this.parseFragmentName(), directives: this.parseDirectives(false), loc: this.loc(e) } : { kind: i.Kind.INLINE_FRAGMENT, typeCondition: n ? this.parseNamedType() : void 0, directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
              }, s.parseFragmentDefinition = function() {
                var e, n = this._lexer.token;
                return this.expectKeyword("fragment"), ((e = this._options) === null || e === void 0 ? void 0 : e.experimentalFragmentVariables) === true ? { kind: i.Kind.FRAGMENT_DEFINITION, name: this.parseFragmentName(), variableDefinitions: this.parseVariableDefinitions(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(n) } : { kind: i.Kind.FRAGMENT_DEFINITION, name: this.parseFragmentName(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(n) };
              }, s.parseFragmentName = function() {
                if (this._lexer.token.value === "on")
                  throw this.unexpected();
                return this.parseName();
              }, s.parseValueLiteral = function(e) {
                var n = this._lexer.token;
                switch (n.kind) {
                  case r.TokenKind.BRACKET_L:
                    return this.parseList(e);
                  case r.TokenKind.BRACE_L:
                    return this.parseObject(e);
                  case r.TokenKind.INT:
                    return this._lexer.advance(), { kind: i.Kind.INT, value: n.value, loc: this.loc(n) };
                  case r.TokenKind.FLOAT:
                    return this._lexer.advance(), { kind: i.Kind.FLOAT, value: n.value, loc: this.loc(n) };
                  case r.TokenKind.STRING:
                  case r.TokenKind.BLOCK_STRING:
                    return this.parseStringLiteral();
                  case r.TokenKind.NAME:
                    switch (this._lexer.advance(), n.value) {
                      case "true":
                        return { kind: i.Kind.BOOLEAN, value: true, loc: this.loc(n) };
                      case "false":
                        return { kind: i.Kind.BOOLEAN, value: false, loc: this.loc(n) };
                      case "null":
                        return { kind: i.Kind.NULL, loc: this.loc(n) };
                      default:
                        return { kind: i.Kind.ENUM, value: n.value, loc: this.loc(n) };
                    }
                  case r.TokenKind.DOLLAR:
                    if (!e)
                      return this.parseVariable();
                    break;
                }
                throw this.unexpected();
              }, s.parseStringLiteral = function() {
                var e = this._lexer.token;
                return this._lexer.advance(), { kind: i.Kind.STRING, value: e.value, block: e.kind === r.TokenKind.BLOCK_STRING, loc: this.loc(e) };
              }, s.parseList = function(e) {
                var n = this, t = this._lexer.token, u = function() {
                  return n.parseValueLiteral(e);
                };
                return { kind: i.Kind.LIST, values: this.any(r.TokenKind.BRACKET_L, u, r.TokenKind.BRACKET_R), loc: this.loc(t) };
              }, s.parseObject = function(e) {
                var n = this, t = this._lexer.token, u = function() {
                  return n.parseObjectField(e);
                };
                return { kind: i.Kind.OBJECT, fields: this.any(r.TokenKind.BRACE_L, u, r.TokenKind.BRACE_R), loc: this.loc(t) };
              }, s.parseObjectField = function(e) {
                var n = this._lexer.token, t = this.parseName();
                return this.expectToken(r.TokenKind.COLON), { kind: i.Kind.OBJECT_FIELD, name: t, value: this.parseValueLiteral(e), loc: this.loc(n) };
              }, s.parseDirectives = function(e) {
                for (var n = []; this.peek(r.TokenKind.AT); )
                  n.push(this.parseDirective(e));
                return n;
              }, s.parseDirective = function(e) {
                var n = this._lexer.token;
                return this.expectToken(r.TokenKind.AT), { kind: i.Kind.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(e), loc: this.loc(n) };
              }, s.parseTypeReference = function() {
                var e = this._lexer.token, n;
                return this.expectOptionalToken(r.TokenKind.BRACKET_L) ? (n = this.parseTypeReference(), this.expectToken(r.TokenKind.BRACKET_R), n = { kind: i.Kind.LIST_TYPE, type: n, loc: this.loc(e) }) : n = this.parseNamedType(), this.expectOptionalToken(r.TokenKind.BANG) ? { kind: i.Kind.NON_NULL_TYPE, type: n, loc: this.loc(e) } : n;
              }, s.parseNamedType = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.NAMED_TYPE, name: this.parseName(), loc: this.loc(e) };
              }, s.parseTypeSystemDefinition = function() {
                var e = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
                if (e.kind === r.TokenKind.NAME)
                  switch (e.value) {
                    case "schema":
                      return this.parseSchemaDefinition();
                    case "scalar":
                      return this.parseScalarTypeDefinition();
                    case "type":
                      return this.parseObjectTypeDefinition();
                    case "interface":
                      return this.parseInterfaceTypeDefinition();
                    case "union":
                      return this.parseUnionTypeDefinition();
                    case "enum":
                      return this.parseEnumTypeDefinition();
                    case "input":
                      return this.parseInputObjectTypeDefinition();
                    case "directive":
                      return this.parseDirectiveDefinition();
                  }
                throw this.unexpected(e);
              }, s.peekDescription = function() {
                return this.peek(r.TokenKind.STRING) || this.peek(r.TokenKind.BLOCK_STRING);
              }, s.parseDescription = function() {
                if (this.peekDescription())
                  return this.parseStringLiteral();
              }, s.parseSchemaDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("schema");
                var t = this.parseDirectives(true), u = this.many(r.TokenKind.BRACE_L, this.parseOperationTypeDefinition, r.TokenKind.BRACE_R);
                return { kind: i.Kind.SCHEMA_DEFINITION, description: n, directives: t, operationTypes: u, loc: this.loc(e) };
              }, s.parseOperationTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseOperationType();
                this.expectToken(r.TokenKind.COLON);
                var t = this.parseNamedType();
                return { kind: i.Kind.OPERATION_TYPE_DEFINITION, operation: n, type: t, loc: this.loc(e) };
              }, s.parseScalarTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("scalar");
                var t = this.parseName(), u = this.parseDirectives(true);
                return { kind: i.Kind.SCALAR_TYPE_DEFINITION, description: n, name: t, directives: u, loc: this.loc(e) };
              }, s.parseObjectTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("type");
                var t = this.parseName(), u = this.parseImplementsInterfaces(), y = this.parseDirectives(true), f = this.parseFieldsDefinition();
                return { kind: i.Kind.OBJECT_TYPE_DEFINITION, description: n, name: t, interfaces: u, directives: y, fields: f, loc: this.loc(e) };
              }, s.parseImplementsInterfaces = function() {
                var e;
                if (!this.expectOptionalKeyword("implements"))
                  return [];
                if (((e = this._options) === null || e === void 0 ? void 0 : e.allowLegacySDLImplementsInterfaces) === true) {
                  var n = [];
                  this.expectOptionalToken(r.TokenKind.AMP);
                  do
                    n.push(this.parseNamedType());
                  while (this.expectOptionalToken(r.TokenKind.AMP) || this.peek(r.TokenKind.NAME));
                  return n;
                }
                return this.delimitedMany(r.TokenKind.AMP, this.parseNamedType);
              }, s.parseFieldsDefinition = function() {
                var e;
                return ((e = this._options) === null || e === void 0 ? void 0 : e.allowLegacySDLEmptyFields) === true && this.peek(r.TokenKind.BRACE_L) && this._lexer.lookahead().kind === r.TokenKind.BRACE_R ? (this._lexer.advance(), this._lexer.advance(), []) : this.optionalMany(r.TokenKind.BRACE_L, this.parseFieldDefinition, r.TokenKind.BRACE_R);
              }, s.parseFieldDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName(), u = this.parseArgumentDefs();
                this.expectToken(r.TokenKind.COLON);
                var y = this.parseTypeReference(), f = this.parseDirectives(true);
                return { kind: i.Kind.FIELD_DEFINITION, description: n, name: t, arguments: u, type: y, directives: f, loc: this.loc(e) };
              }, s.parseArgumentDefs = function() {
                return this.optionalMany(r.TokenKind.PAREN_L, this.parseInputValueDef, r.TokenKind.PAREN_R);
              }, s.parseInputValueDef = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName();
                this.expectToken(r.TokenKind.COLON);
                var u = this.parseTypeReference(), y;
                this.expectOptionalToken(r.TokenKind.EQUALS) && (y = this.parseValueLiteral(true));
                var f = this.parseDirectives(true);
                return { kind: i.Kind.INPUT_VALUE_DEFINITION, description: n, name: t, type: u, defaultValue: y, directives: f, loc: this.loc(e) };
              }, s.parseInterfaceTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("interface");
                var t = this.parseName(), u = this.parseImplementsInterfaces(), y = this.parseDirectives(true), f = this.parseFieldsDefinition();
                return { kind: i.Kind.INTERFACE_TYPE_DEFINITION, description: n, name: t, interfaces: u, directives: y, fields: f, loc: this.loc(e) };
              }, s.parseUnionTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("union");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseUnionMemberTypes();
                return { kind: i.Kind.UNION_TYPE_DEFINITION, description: n, name: t, directives: u, types: y, loc: this.loc(e) };
              }, s.parseUnionMemberTypes = function() {
                return this.expectOptionalToken(r.TokenKind.EQUALS) ? this.delimitedMany(r.TokenKind.PIPE, this.parseNamedType) : [];
              }, s.parseEnumTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("enum");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseEnumValuesDefinition();
                return { kind: i.Kind.ENUM_TYPE_DEFINITION, description: n, name: t, directives: u, values: y, loc: this.loc(e) };
              }, s.parseEnumValuesDefinition = function() {
                return this.optionalMany(r.TokenKind.BRACE_L, this.parseEnumValueDefinition, r.TokenKind.BRACE_R);
              }, s.parseEnumValueDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName(), u = this.parseDirectives(true);
                return { kind: i.Kind.ENUM_VALUE_DEFINITION, description: n, name: t, directives: u, loc: this.loc(e) };
              }, s.parseInputObjectTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("input");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseInputFieldsDefinition();
                return { kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION, description: n, name: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseInputFieldsDefinition = function() {
                return this.optionalMany(r.TokenKind.BRACE_L, this.parseInputValueDef, r.TokenKind.BRACE_R);
              }, s.parseTypeSystemExtension = function() {
                var e = this._lexer.lookahead();
                if (e.kind === r.TokenKind.NAME)
                  switch (e.value) {
                    case "schema":
                      return this.parseSchemaExtension();
                    case "scalar":
                      return this.parseScalarTypeExtension();
                    case "type":
                      return this.parseObjectTypeExtension();
                    case "interface":
                      return this.parseInterfaceTypeExtension();
                    case "union":
                      return this.parseUnionTypeExtension();
                    case "enum":
                      return this.parseEnumTypeExtension();
                    case "input":
                      return this.parseInputObjectTypeExtension();
                  }
                throw this.unexpected(e);
              }, s.parseSchemaExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("schema");
                var n = this.parseDirectives(true), t = this.optionalMany(r.TokenKind.BRACE_L, this.parseOperationTypeDefinition, r.TokenKind.BRACE_R);
                if (n.length === 0 && t.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.SCHEMA_EXTENSION, directives: n, operationTypes: t, loc: this.loc(e) };
              }, s.parseScalarTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("scalar");
                var n = this.parseName(), t = this.parseDirectives(true);
                if (t.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.SCALAR_TYPE_EXTENSION, name: n, directives: t, loc: this.loc(e) };
              }, s.parseObjectTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("type");
                var n = this.parseName(), t = this.parseImplementsInterfaces(), u = this.parseDirectives(true), y = this.parseFieldsDefinition();
                if (t.length === 0 && u.length === 0 && y.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.OBJECT_TYPE_EXTENSION, name: n, interfaces: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseInterfaceTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("interface");
                var n = this.parseName(), t = this.parseImplementsInterfaces(), u = this.parseDirectives(true), y = this.parseFieldsDefinition();
                if (t.length === 0 && u.length === 0 && y.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.INTERFACE_TYPE_EXTENSION, name: n, interfaces: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseUnionTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("union");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseUnionMemberTypes();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.UNION_TYPE_EXTENSION, name: n, directives: t, types: u, loc: this.loc(e) };
              }, s.parseEnumTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("enum");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseEnumValuesDefinition();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.ENUM_TYPE_EXTENSION, name: n, directives: t, values: u, loc: this.loc(e) };
              }, s.parseInputObjectTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("input");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseInputFieldsDefinition();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION, name: n, directives: t, fields: u, loc: this.loc(e) };
              }, s.parseDirectiveDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("directive"), this.expectToken(r.TokenKind.AT);
                var t = this.parseName(), u = this.parseArgumentDefs(), y = this.expectOptionalKeyword("repeatable");
                this.expectKeyword("on");
                var f = this.parseDirectiveLocations();
                return { kind: i.Kind.DIRECTIVE_DEFINITION, description: n, name: t, arguments: u, repeatable: y, locations: f, loc: this.loc(e) };
              }, s.parseDirectiveLocations = function() {
                return this.delimitedMany(r.TokenKind.PIPE, this.parseDirectiveLocation);
              }, s.parseDirectiveLocation = function() {
                var e = this._lexer.token, n = this.parseName();
                if (E.DirectiveLocation[n.value] !== void 0)
                  return n;
                throw this.unexpected(e);
              }, s.loc = function(e) {
                var n;
                if (((n = this._options) === null || n === void 0 ? void 0 : n.noLocation) !== true)
                  return new c.Location(e, this._lexer.lastToken, this._lexer.source);
              }, s.peek = function(e) {
                return this._lexer.token.kind === e;
              }, s.expectToken = function(e) {
                var n = this._lexer.token;
                if (n.kind === e)
                  return this._lexer.advance(), n;
                throw (0, d.syntaxError)(this._lexer.source, n.start, "Expected ".concat(v(e), ", found ").concat(D(n), "."));
              }, s.expectOptionalToken = function(e) {
                var n = this._lexer.token;
                if (n.kind === e)
                  return this._lexer.advance(), n;
              }, s.expectKeyword = function(e) {
                var n = this._lexer.token;
                if (n.kind === r.TokenKind.NAME && n.value === e)
                  this._lexer.advance();
                else
                  throw (0, d.syntaxError)(this._lexer.source, n.start, 'Expected "'.concat(e, '", found ').concat(D(n), "."));
              }, s.expectOptionalKeyword = function(e) {
                var n = this._lexer.token;
                return n.kind === r.TokenKind.NAME && n.value === e ? (this._lexer.advance(), true) : false;
              }, s.unexpected = function(e) {
                var n = e != null ? e : this._lexer.token;
                return (0, d.syntaxError)(this._lexer.source, n.start, "Unexpected ".concat(D(n), "."));
              }, s.any = function(e, n, t) {
                this.expectToken(e);
                for (var u = []; !this.expectOptionalToken(t); )
                  u.push(n.call(this));
                return u;
              }, s.optionalMany = function(e, n, t) {
                if (this.expectOptionalToken(e)) {
                  var u = [];
                  do
                    u.push(n.call(this));
                  while (!this.expectOptionalToken(t));
                  return u;
                }
                return [];
              }, s.many = function(e, n, t) {
                this.expectToken(e);
                var u = [];
                do
                  u.push(n.call(this));
                while (!this.expectOptionalToken(t));
                return u;
              }, s.delimitedMany = function(e, n) {
                this.expectOptionalToken(e);
                var t = [];
                do
                  t.push(n.call(this));
                while (this.expectOptionalToken(e));
                return t;
              }, I;
            }();
            a.Parser = g;
            function D(I) {
              var s = I.value;
              return v(I.kind) + (s != null ? ' "'.concat(s, '"') : "");
            }
            function v(I) {
              return (0, k.isPunctuatorTokenKind)(I) ? '"'.concat(I, '"') : I;
            }
          } });
          K();
          var Ie = ce(), ge = ue(), { hasPragma: Se } = le(), { locStart: Ae, locEnd: De } = pe();
          function Ke(a) {
            let d = [], { startToken: i } = a.loc, { next: c } = i;
            for (; c.kind !== "<EOF>"; )
              c.kind === "Comment" && (Object.assign(c, { column: c.column - 1 }), d.push(c)), c = c.next;
            return d;
          }
          function ie(a) {
            if (a && typeof a == "object") {
              delete a.startToken, delete a.endToken, delete a.prev, delete a.next;
              for (let d in a)
                ie(a[d]);
            }
            return a;
          }
          var X = { allowLegacySDLImplementsInterfaces: false, experimentalFragmentVariables: true };
          function Le(a) {
            let { GraphQLError: d } = W();
            if (a instanceof d) {
              let { message: i, locations: [c] } = a;
              return Ie(i, { start: c });
            }
            return a;
          }
          function xe(a) {
            let { parse: d } = Oe(), { result: i, error: c } = ge(() => d(a, Object.assign({}, X)), () => d(a, Object.assign(Object.assign({}, X), {}, { allowLegacySDLImplementsInterfaces: true })));
            if (!i)
              throw Le(c);
            return i.comments = Ke(i), ie(i), i;
          }
          ae.exports = { parsers: { graphql: { parse: xe, astFormat: "graphql", hasPragma: Se, locStart: Ae, locEnd: De } } };
        });
        return be();
      });
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/GraphQLWorker.js
  var require_GraphQLWorker = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/GraphQLWorker.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.create = exports.GraphQLWorker = void 0;
      var graphql_language_service_1 = require_dist();
      var LanguageService_1 = require_LanguageService();
      var utils_1 = require_utils3();
      var GraphQLWorker = function() {
        function GraphQLWorker2(ctx, createData) {
          this._ctx = ctx;
          this._languageService = new LanguageService_1.LanguageService(createData.languageConfig);
          this._formattingOptions = createData.formattingOptions;
        }
        GraphQLWorker2.prototype.doValidation = function(uri) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_1, graphqlDiagnostics;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_1 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_1) {
                  return [2, []];
                }
                graphqlDiagnostics = this._languageService.getDiagnostics(uri, document_1);
                return [2, graphqlDiagnostics.map(utils_1.toMarkerData)];
              } catch (err) {
                console.error(err);
                return [2, []];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doComplete = function(uri, position) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_2, graphQLPosition, suggestions;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_2 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_2) {
                  return [2, []];
                }
                graphQLPosition = (0, utils_1.toGraphQLPosition)(position);
                suggestions = this._languageService.getCompletion(uri, document_2, graphQLPosition);
                return [2, suggestions.map(function(suggestion) {
                  return (0, utils_1.toCompletion)(suggestion);
                })];
              } catch (err) {
                console.error(err);
                return [2, []];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doHover = function(uri, position) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_3, graphQLPosition, hover;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_3 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_3) {
                  return [2, null];
                }
                graphQLPosition = (0, utils_1.toGraphQLPosition)(position);
                hover = this._languageService.getHover(uri, document_3, graphQLPosition);
                return [2, {
                  content: hover,
                  range: (0, utils_1.toMonacoRange)((0, graphql_language_service_1.getRange)({
                    column: graphQLPosition.character,
                    line: graphQLPosition.line
                  }, document_3))
                }];
              } catch (err) {
                console.error(err);
                return [2, null];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doGetVariablesJSONSchema = function(uri) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document, jsonSchema;
            return __generator(this, function(_a3) {
              documentModel = this._getTextModel(uri);
              document = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
              if (!documentModel || !document) {
                return [2, null];
              }
              jsonSchema = this._languageService.getVariablesJSONSchema(uri, document, { useMarkdownDescription: true });
              if (jsonSchema) {
                jsonSchema.$id = "monaco://variables-schema.json";
                jsonSchema.title = "GraphQL Variables";
                return [2, jsonSchema];
              }
              return [2, null];
            });
          });
        };
        GraphQLWorker2.prototype.doFormat = function(uri) {
          var _a3;
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document, prettierStandalone, prettierGraphqlParser;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  documentModel = this._getTextModel(uri);
                  document = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                  if (!documentModel || !document) {
                    return [2, null];
                  }
                  return [4, Promise.resolve().then(function() {
                    return __importStar(require_standalone());
                  })];
                case 1:
                  prettierStandalone = _b.sent();
                  return [4, Promise.resolve().then(function() {
                    return __importStar(require_parser_graphql());
                  })];
                case 2:
                  prettierGraphqlParser = _b.sent();
                  return [2, prettierStandalone.format(document, __assign({ parser: "graphql", plugins: [prettierGraphqlParser] }, (_a3 = this._formattingOptions) === null || _a3 === void 0 ? void 0 : _a3.prettierConfig))];
              }
            });
          });
        };
        GraphQLWorker2.prototype._getTextModel = function(uri) {
          var e_1, _a3;
          var models = this._ctx.getMirrorModels();
          try {
            for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
              var model = models_1_1.value;
              if (model.uri.toString() === uri) {
                return model;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (models_1_1 && !models_1_1.done && (_a3 = models_1.return))
                _a3.call(models_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return null;
        };
        GraphQLWorker2.prototype.doUpdateSchema = function(schema) {
          return this._languageService.updateSchema(schema);
        };
        GraphQLWorker2.prototype.doUpdateSchemas = function(schemas) {
          return this._languageService.updateSchemas(schemas);
        };
        return GraphQLWorker2;
      }();
      exports.GraphQLWorker = GraphQLWorker;
      exports.default = {
        GraphQLWorker
      };
      function create(ctx, createData) {
        return new GraphQLWorker(ctx, createData);
      }
      exports.create = create;
    }
  });

  // ../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/graphql.worker.js
  var require_graphql_worker = __commonJS({
    "../../node_modules/.pnpm/monaco-graphql@1.1.2_hcy3mshtuqano6ettx6nar7lwm/node_modules/monaco-graphql/dist/graphql.worker.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      var editor_worker_1 = (init_editor_worker(), __toCommonJS(editor_worker_exports));
      var GraphQLWorker_1 = require_GraphQLWorker();
      self.onmessage = function() {
        (0, editor_worker_1.initialize)(function(ctx, createData) {
          return new GraphQLWorker_1.GraphQLWorker(ctx, createData);
        });
      };
    }
  });
  require_graphql_worker();
})();
